<!doctype html>
<html lang="zh-cn">
  <head>
    <title>Socket function // Vcvc Blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.90.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Vcvc" />
    
    <meta name="description" content="Vcvc Blog | 前沿技术-投资:30%价值投资/70%成长投资，目前关注AR(Augmented reality)并看多VR" />
    <meta name="keywords" content="Vcvc,Vcvc Blog,Open Source,前沿技术,成长投资,价值投资" />
    <link rel="stylesheet" href="https://6923403.github.io/css/main.min.c2052924716d810662c2cc67f9223190e814e1923e41ea4b9647c5c71b6ce3b6.css" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://6923403.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Vcvc" /></a>
      <h1>Vcvc Blog</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p>关注AR(Augmented reality)</p>
      <div class="app-header-social">
        
          <a href="https://github.com/6923403" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/vcvckw" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
          <a href="mailto:vcvckw@gmail.com" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail">
  <title>mail</title>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>
</svg>
          </a>
        
        
        <a href="/vcvc/index.html" target="_blank">
          <img  border="0" src="/vcvc/arrow.png" alt="Home" width="26" height="26"></a>
<div class="searchBox">
       <form method="get" target = "_blank" action="http://www.google.com/search">
           <input type="text" name="query" class="searchField" placeholder = "Search-goolge" />
           <input type="hidden" name="sitesearch" value="6923403.github.io">
       </form>
</div>
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Socket function</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 26, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          6 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://6923403.github.io/tags/linux/">Linux</a>
              <a class="tag" href="https://6923403.github.io/tags/cpp/">CPP</a>
              <a class="tag" href="https://6923403.github.io/tags/socket/">Socket</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p><strong>setsockopt</strong></p>
<pre tabindex="0"><code>获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时，

选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选

项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。
</code></pre><p><img src="/img/socket/1.png" alt="option"></p>
<p><strong>SO_LINGER选项</strong></p>
<pre tabindex="0"><code>struct linger
{
    int l_onoff;
    int l_linger;
};
</code></pre><ul>
<li>l_onoff = 0, 数据保持发送完成后立即返回</li>
<li>l_onoff = 1, l_linger = 0, 立即放回 放弃发送, 发送rst 自身立即复位</li>
<li>l_onoff = 1, l_linger = 1, 阻塞到超时或数据发送完成, 保持尝试发送,超时后立即结束</li>
</ul>
<p><strong>SO_REUSEADDR选项</strong></p>
<p><strong>改变了通配绑定时处理源地址冲突的处理方式, 让端口释放后立即就可以被再次使用</strong></p>
<ul>
<li>允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在</li>
<li>允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可</li>
<li>允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。一般不用于tco服务器</li>
<li>允许完全重复的捆绑</li>
</ul>
<p>Re:</p>
<p><a href="https://www.cnblogs.com/my_life/articles/5174585.html">https://www.cnblogs.com/my_life/articles/5174585.html</a></p>
<p><a href="https://www.jianshu.com/p/141aa1c41f15">https://www.jianshu.com/p/141aa1c41f15</a></p>
<p><a href="https://blog.csdn.net/u010144805/article/details/78579528">https://blog.csdn.net/u010144805/article/details/78579528</a></p>
<hr>
<pre tabindex="0"><code>int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock *lock);
</code></pre><p><strong>fcntl函数有5种功能：</strong></p>
<ul>
<li>1.复制一个现有的描述符（cmd=F_DUPFD）.</li>
<li>2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).</li>
<li>3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).</li>
<li>4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).</li>
<li>5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).</li>
</ul>
<p>Re: <a href="https://www.cnblogs.com/xuyh/p/3273082.html">https://www.cnblogs.com/xuyh/p/3273082.html</a></p>
<hr>
<p><strong>非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。</strong></p>
<p><strong>对于一个给定的描述符两种方法对其指定非阻塞I/O:</strong></p>
<ul>
<li>1.调用open获得描述符，并指定O_NONBLOCK标志</li>
<li>2.对已经打开的文件描述符，调用fcntl，打开O_NONBLOCK文件状态标志。</li>
</ul>
<pre tabindex="0"><code>flags = fcntl( s, F_GETFL, 0 ) )
fcntl( s, F_SETFL, flags | O_NONBLOCK )
</code></pre><p>Re:
<a href="https://blog.csdn.net/zhulinfeiba/article/details/5011573">https://blog.csdn.net/zhulinfeiba/article/details/5011573</a></p>
<hr>
<ul>
<li>htonl()&ndash;&ldquo;Host to Network Long int&rdquo;     32Bytes</li>
</ul>
<p><strong>将主机的无符号长整形数转换成网络字节顺序。//将无符号长整型网络字节序转换为主机字节序</strong></p>
<ul>
<li>ntohl()&ndash;&ldquo;Network to Host Long int&rdquo;     32Bytes</li>
</ul>
<p><strong>将一个无符号长整形数从网络字节顺序转换为主机字节顺序。</strong></p>
<ul>
<li>htons()&ndash;&ldquo;Host to Network Short int&rdquo;   16Bytes</li>
</ul>
<p><strong>将主机的无符号短整形数转换成网络字节顺序。//将无符号短整型主机字节序转换为网络字节序</strong></p>
<ul>
<li>ntohs()&ndash;&ldquo;Network to Host Short int&rdquo;   16Bytes</li>
</ul>
<p><strong>将一个无符号短整形数从网络字节顺序转换为主机字节顺序。</strong></p>
<ul>
<li>inet_addr()</li>
</ul>
<p><strong>将一个点间隔地址转换成一个in_addr</strong></p>
<ul>
<li>inet_ntoa()</li>
</ul>
<p><strong>是编程语言，功能是将网络地址转换成“.”点隔的字符串格式。</strong></p>
<ul>
<li>inet_aton()</li>
</ul>
<p><strong>与inet_ntoa()作用相反。本函数将点分十进制转换为整数</strong></p>
<ul>
<li>atoi()</li>
</ul>
<p><strong>array to integer将字符串转换为整形数</strong></p>
<hr>
<p><strong>新型网路地址转化函数inet_pton和inet_ntop</strong>
这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。</p>
<pre tabindex="0"><code>#include &lt;arpe/inet.h&gt;
int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1

const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
        返回值：若成功则为指向结构的指针，若出错则为NULL
</code></pre><ul>
<li>
<p>1.这两个函数的family参数既可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.</p>
</li>
<li>
<p>2.第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.</p>
</li>
<li>
<p>3.inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达式（strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。</p>
</li>
</ul>
<pre tabindex="0"><code>inet_pton(AF_INET, ip, &amp;foo.sin_addr);   //  代替 foo.sin_addr.addr=inet_addr(ip);

char str[INET_ADDRSTRLEN];
char *ptr = inet_ntop(AF_INET,&amp;foo.sin_addr, str, sizeof(str));      // 代替 ptr = inet_ntoa(foo.sin_addr)
</code></pre><p><strong>示例代码</strong></p>
<pre tabindex="0"><code>int main()
{
    char IPdotdec[20]; // 存放点分十进制IP地址
    struct in_addr s;  // IPv4地址结构体
    // 输入IP地址
    printf(&quot;Please input IP address: &quot;);
    scanf(&quot;%s&quot;, &amp;IPdotdec);
    // 转换
    inet_pton(AF_INET, IPdotdec, (void *)&amp;s);
    printf(&quot;inet_pton: 0x%x\n&quot;, s.s_addr); // 注意得到的字节序
    // 反转换
    inet_ntop(AF_INET, (void *)&amp;s, IPdotdec, 16);
    printf(&quot;inet_ntop: %s\n&quot;, IPdotdec);
}

Run:
Please input IP address: 127.0.0.1
inet_pton: 0x100007f
inet_ntop: 127.0.0.1
</code></pre><p>Re: <a href="https://blog.csdn.net/zyy617532750/article/details/58595700">https://blog.csdn.net/zyy617532750/article/details/58595700</a></p>
<p><a href="https://www.cnblogs.com/wuyuxuan/p/10772779.html">https://www.cnblogs.com/wuyuxuan/p/10772779.html</a></p>
<hr>
<p><code>int send( SOCKET s,char *buf,int len,int flags )</code></p>
<p><strong>功能：不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。</strong></p>
<ul>
<li>
<p>参数一：指定发送端套接字描述符；</p>
</li>
<li>
<p>参数二：存放应用程序要发送数据的缓冲区；</p>
</li>
<li>
<p>参数三：实际要发送的数据的字节数；</p>
</li>
<li>
<p>参数四：一般置为0。</p>
</li>
</ul>
<p><code>int recv( SOCKET s, char *buf, int  len, int flags)</code></p>
<p><strong>功能：不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。</strong></p>
<ul>
<li>
<p>参数一：指定接收端套接字描述符；</p>
</li>
<li>
<p>参数二：指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p>
</li>
<li>
<p>参数三：指明buf的长度；</p>
</li>
<li>
<p>参数四 ：一般置为0。</p>
</li>
</ul>
<p>Re: <a href="https://blog.csdn.net/lanzhihui_10086/article/details/40681617">https://blog.csdn.net/lanzhihui_10086/article/details/40681617</a></p>
<hr>
<p><code>read(sock, buf, sizeof(buf) -1)</code></p>
<p><strong>read从套接字文件中读取数据, fd为要读取的文件的描述符，buf为要接收数据的缓冲区地址，nbytes为要读取的数据的字节数。</strong></p>
<hr>
<pre tabindex="0"><code>    /*
     * 本函数向服务ip发起请求 服务器ip port 保存在sockaddr_in中
     * int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen);  //Linux
     * int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen);  //Windows
     * sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。
     */
    connect(sock, (struct sockaddr*) &amp;serv_addr, sizeof(serv_addr));
</code></pre><hr>
<p><strong>linux mutex block</strong></p>
<p><code>pthread_mutexattr_t mattr</code></p>
<p><code>int pthread_mutexattr_init(pthread_mutexattr_t *mattr)</code></p>
<p><strong>pthread_mutex_init() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。</strong></p>
<ul>
<li>Success: return 0</li>
</ul>
<p><strong>POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁</strong></p>
<pre tabindex="0"><code>pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;
</code></pre><p><strong>动态方式是采用pthread_mutex_init()函数来初始化互斥锁</strong></p>
<pre tabindex="0"><code>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)
</code></pre><p><strong>其中mutexattr用于指定互斥锁属性（见下），如果为NULL则使用缺省属性, <code>pthread_mutex_destroy()</code>用于注销一个互斥锁</strong></p>
<pre tabindex="0"><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)
</code></pre><p><strong>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 <code>pthread_mutex_destroy()</code>除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。</strong></p>
<p><strong>2.属性 3. 锁操作</strong></p>
<p>Re:
<a href="https://www.cnblogs.com/lidabo/p/4566693.html">https://www.cnblogs.com/lidabo/p/4566693.html</a></p>
<hr>
<p><strong>互斥锁的类型：有以下几个取值空间:</strong></p>
<ul>
<li>
<p>PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。</p>
</li>
<li>
<p>PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</p>
</li>
<li>
<p>PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</p>
</li>
<li>
<p>PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。
*<em>pthread_mutexattr_settype(pthread_mutexattr_t <em>attr , int type)</em></em>
**pthread_mutexattr_gettype(pthread_mutexattr_t <em>attr , int <em>type)</em></em></p>
</li>
</ul>
<p>Re:
<a href="https://blog.csdn.net/happylzs2008/article/details/89067028">https://blog.csdn.net/happylzs2008/article/details/89067028</a></p>
<hr>
<p><strong>销毁互斥锁属性对象</strong></p>
<ul>
<li><code>pthread_mutexattr_destroy(3C)</code> 可用来取消分配用于维护 <code>pthread_mutexattr_init()</code> 所创建的属性对象的存储空间。</li>
</ul>
<p><strong>对于互斥锁属性对象，必须首先通过调用<code>pthread_mutexattr_destroy(3C)</code>将其销毁，才能重新初始化该对象。pthread_mutexattr_init() 调用会导致分配类型为 opaque 的对象。如果未销毁该对象，则会导致内存泄漏</strong></p>
<p>Re:
<a href="https://blog.csdn.net/jasmineal/article/details/8807744">https://blog.csdn.net/jasmineal/article/details/8807744</a></p>
<hr>
<p><strong>对锁的操作主要包括加锁 pthread_mutex_lock()、解锁pthread_mutex_unlock()和测试加锁 pthread_mutex_trylock()三个。</strong></p>
<ul>
<li>int pthread_mutex_lock(pthread_mutex_t *mutex)</li>
<li>int pthread_mutex_unlock(pthread_mutex_t *mutex)</li>
<li>int pthread_mutex_trylock(pthread_mutex_t *mutex)</li>
</ul>
<p><strong>pthread_mutex_trylock()语义与pthread_mutex_lock()类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待</strong></p>
<p><strong><code>pthread_mutex_lock</code> 用于解决由于竞争产生的优先级反转问题。没锁更新所有权,锁住</strong></p>
<p>Re:
<a href="https://blog.csdn.net/jasmineal/article/details/8807744">https://blog.csdn.net/jasmineal/article/details/8807744</a></p>
<p><a href="https://blog.csdn.net/oqqYuJi12345678/article/details/100585669">https://blog.csdn.net/oqqYuJi12345678/article/details/100585669</a></p>
<hr>
<pre tabindex="0"><code>backtrace
backtrace_symbols
backtrace_symbols_fd
</code></pre><p>To: <a href="https://6923403.github.io/post/backtrace/">https://6923403.github.io/post/backtrace/</a></p>
<hr>
<p><strong><code>pthread_cond_broadcast(&amp;cond1)</code>的作用是唤醒所有正在<code>pthread_cond_wait(&amp;cond1,&amp;mutex1)</code>的线程。</strong></p>
<pre tabindex="0"><code>while(lock_status_[lid] == LOCKED) 
{
    pthread_cond_wait(&amp;c_, &amp;m_);
}
    pthread_cond_broadcast(&amp;c_);
</code></pre><p><strong>一旦某个锁被释放，所有的阻塞线程都会被唤醒，但唯有阻塞在这个锁的线程才能真正被唤醒。</strong></p>
<p><strong><code>pthread_cond_signal(&amp;cond1)</code>的的作用是唤醒所有正在 <code>pthread_cond_wait(&amp;cond1,&amp;mutex1)</code>的至少一个线程。（虽然我还没碰到过多于一个线程的情况，但是man帮组手册上说的是至少一个）</strong></p>
<p>Re:</p>
<p><a href="https://www.cnblogs.com/XiaoXiaoShuai-/p/11855408.html">https://www.cnblogs.com/XiaoXiaoShuai-/p/11855408.html</a></p>
<p><a href="https://www.cnblogs.com/zhouzhuo/p/3781511.html">https://www.cnblogs.com/zhouzhuo/p/3781511.html</a></p>
<hr>
<pre tabindex="0"><code>struct hostent{
    char *h_name;  //official name
    char **h_aliases;  //alias list
    int  h_addrtype;  //host address type
    int  h_length;  //address lenght
    char **h_addr_list;  //address list
}
</code></pre><ul>
<li>h_name：官方域名（Official domain name）。官方域名代表某一主页，但实际上一些著名公司的域名并未用官方域名注册。</li>
<li>h_aliases：别名，可以通过多个域名访问同一主机。同一 IP 地址可以绑定多个域名，因此除了当前域名还可以指定其他域名。</li>
<li>h_addrtype：gethostbyname() 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取IP地址的地址族（地址类型）信息，IPv4 对应 AF_INET，IPv6 对应 AF_INET6。</li>
<li>h_length：保存IP地址长度。IPv4 的长度为 4 个字节，IPv6 的长度为 16 个字节。</li>
<li>h_addr_list：这是最重要的成员。通过该成员以整数形式保存域名对应的 IP 地址。对于用户较多的服务器，可能会分配多个 IP 地址给同一域名，利用多个服务器进行均衡负载。</li>
</ul>
<p><strong>gethostbyname</strong></p>
<p><code>struct hostent *gethostbyname(const char *hostname);</code></p>
<p><strong>gethostbyaddr 根据ip地址获取主机的完整信息</strong></p>
<p><code>struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);</code></p>
<p>Re:</p>
<p><a href="http://c.biancheng.net/view/2357.html">http://c.biancheng.net/view/2357.html</a></p>
<hr>
<p><strong>getservbyname 根据名称获取某个服务的完整信息</strong></p>
<p><code>struct servent *getservbyname(const char *name, const char *proto)</code></p>
<p><strong>getservbyport 根据端口号获取某个服务的完整信息</strong></p>
<p><code>struct servent *getservbyport(int port, const char *proto)</code></p>
<p><strong>getaddrinfo 通过主机名获得IP地址也能通过服务名获得端口号</strong></p>
<p><code>int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);</code></p>
<p><strong>之后用freeaddrinfo 释放getaddrinfo所分配的内存</strong></p>
<p><code>void freeaddrinfo(struct addrinfo *res);</code></p>
<p><strong>getnameinfo 通过socket地址同时获得字符串表示的主机名和服务名</strong></p>
<p><code>int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags); </code></p>
<hr>
<p><strong>readv 将数据从文件描述符读到分散的内存块中</strong></p>
<p><code>ssize_t readv(int fd, const struct iovec *iov, int iovcnt);</code></p>
<p><strong>writev 将多块分散的数据一并写入文件描述符中</strong></p>
<p><code>ssize_t writev(int fd, const struct iovec *iov, int iovcnt);</code></p>
<p><strong>sendfile 在两个文件描述符之间传递数据 避免内核缓冲区和用户之间的数据拷贝-零拷贝</strong></p>
<p><code>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></p>
<hr>
<p><strong>mmap 申请一段内存空间 将这段内存作为进程间通信的共享内存,可以将文件直接映射到其中</strong></p>
<p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>
<img src="/img/socket/mmap_port.png" alt="mmap_port">
<img src="/img/socket/mmap_flags.png" alt="mmap_flags"></p>
<p><strong>munmap 释放mmap创建的内存空间</strong></p>
<p><code>int munmap(void *addr, size_t length);</code></p>
<p><strong>splice 用于在两个文件描述符之间移动数据-零拷贝</strong></p>
<p><code>ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);</code></p>
<p><img src="/img/socket/splice_flags.png" alt="splice_flags">
<img src="/img/socket/splice_errno.png" alt="splice_errno"></p>
<hr>
<p><strong>syslog和rsyslogd 守护进程通信</strong></p>
<p><code>void syslog(int priority, const char *format, ...);</code>
<img src="/img/socket/syslog.png" alt="syslog"></p>
<p><strong>openlog改变syslog默认输出方式 进一步结构化日志内容</strong></p>
<p><code>void openlog(const char *ident, int option, int facility);</code>
<img src="/img/socket/openlog.png" alt="openlog"></p>
<p><strong>setlogmask 设置日志掩码</strong></p>
<p><code>int setlogmask(int mask);</code></p>
<p><strong>closelog关闭日志功能</strong></p>
<p><code>void closelog();</code></p>
<hr>
<p><strong>get_uid获取和设置当前进程真实用户</strong></p>
<pre tabindex="0"><code>uid_t getuid(void); //真实用户ID
uid_t geteuid(void); //有效用户ID
gid_t getgid(void); //真实组ID
gid_t getegid(void); //有效组ID
int setuid(uid_t uid); //设置真实用户ID
int seteuid(uid_t euid); //设置有效用户ID
int setgid(gid_t gid); //设置真实组ID
int setegid(gid_t egid); //设置有效组ID
</code></pre><p><strong>getpgid 获取进程组ID</strong></p>
<p><code>pid_t getpgid(pid_t pid);</code></p>
<p><strong>setpgid 设置用户组ID</strong>
<code>int setpgid(pid_t pid, pid_t pgid);</code></p>
<p><strong>setsid 创建一个会话</strong></p>
<p><code>pid_t setsid(void);</code></p>
<p><strong>getsid 读取sid</strong></p>
<p><code>pid_t getsid(pid_t pid);</code></p>
<p><strong>rlimit 系统资源读取\设置</strong></p>
<p><code>int getrlimit(int resource, struct rlimit *rlim);</code></p>
<p><code>int setrlimit(int resource, const struct rlimit *rlim);</code></p>
<pre tabindex="0"><code>struct rlimit
{
    rlim_t rlim_cur;
    rlim_t rlim_max;
}
</code></pre><p><img src="/img/socket/rlimit.png" alt="rlimit"></p>
<p><strong>cwd 获取进程当前工作目录和改变进程工作目录</strong></p>
<p><code>char *getcwd(char *buf, size_t size);</code></p>
<p><code>int chdir(const char *path);</code></p>
<p><strong>chroot 改变进程根目录</strong></p>
<p><code>int chroot(const char * path);</code></p>
<p><strong>daemon 守护进程</strong></p>
<p><code>int daemon(int nochdir, int noclose);</code></p>
<hr>
<p><strong>基本框架</strong></p>
<p><img src="/img/socket/server_framework.png" alt="server_framework"></p>
<p><strong>reactor 要求主线程只负责监听文件描述上是否有事情发生 有的话立即将该事件通知工作线程</strong></p>
<p><img src="/img/socket/reactor.png" alt="reactor"></p>
<p><strong>proactor 将所有I/0操作都交给主线程和内核来处理 工作线程仅仅负责业务逻辑</strong></p>
<p><img src="/img/socket/proactor.png" alt="proactor"></p>
<p><strong>同步模拟的Procator</strong></p>
<p><img src="/img/socket/%E5%90%8C%E6%AD%A5io.png" alt="同步io"></p>
<p><strong>并发模式</strong></p>
<p><img src="/img/socket/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%88%86%E6%9E%90.png" alt="同步异步分析"></p>
<p><strong>半同步/半异步模式</strong></p>
<p><img src="/img/socket/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5.png" alt="半同步半异步">
<img src="/img/socket/%E5%8F%8D%E5%BA%94%E5%A0%86.png" alt="反应堆"></p>
<p><strong>存在的缺点</strong></p>
<p><img src="/img/socket/%E7%BC%BA%E7%82%B9.png" alt="缺点"></p>
<p><strong>高效模式</strong></p>
<p><img src="/img/socket/%E9%AB%98%E6%95%88%E6%A8%A1%E5%BC%8F.png" alt="高效模式"></p>
<hr>
<p><strong>领导者/追随者模式 是多个工作线程轮流获得事件源集合, 轮流监听、分发并处理事件的一种模式</strong></p>
<p><img src="/img/socket/leader.png" alt="leader"></p>
<p><strong>1. 句柄集 句柄表示I/O资源 在linux下通常是一个文件描述符 句柄集管理众多句柄</strong></p>
<p><strong>2. 线程集 负责各线程之间的同步 以及新领导者线程的推选. 线程集里的线程在任何时间都必须处于一下三种状态之一</strong></p>
<p><img src="/img/socket/thread_1.png" alt="thread1">
<img src="/img/socket/thread_2.png" alt="thread2">
<img src="/img/socket/%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png" alt="转换关系"></p>
<p><strong>领导者/追随者 工作流程图</strong></p>
<p><img src="/img/socket/%E9%A2%86%E5%AF%BC%E8%BF%BD%E9%9A%8F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="领导追随者模式"></p>
<hr>
<p><strong>select 在一段指定时间内 监听用户感兴趣的文件描述符上的可读、可写、异常等事件, readfds\writefds\exceptfds分别指向可读、可写、异常</strong></p>
<p><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p>
<p><strong>poll 指定时间内轮询一定数量的文件描述符 测试其中是否有就绪者</strong></p>
<p><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code>
<img src="/img/socket/poll1.png" alt="poll1">
<img src="/img/socket/poll2.png" alt="poll2"></p>
<p><strong>epoll 把用户关心的文件描述符上的事件放在内核里的一个事件表中, 从而无需每次调用都要重复传入文件描述符集或事件集, 但epoll需要额外的文件描述符, 来唯一标识内核中的事件表</strong></p>
<p><strong>epoll_create 创建文件描述符</strong></p>
<p><code>int epoll_create(int size);</code></p>
<p><strong>操作epoll的内核事件表</strong></p>
<p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></p>
<p><img src="/img/socket/optype.png" alt="op"></p>
<p><strong>epoll_wait 在一段超时时间内等待一组文件描述符上的事件</strong></p>
<p><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></p>
<p><strong>LT 水平触发是默认工作模式、ET边缘触发</strong></p>
<p><strong>select\poll\epoll 区别比较</strong></p>
<p><img src="/img/socket/poll_compare.png" alt="poll_compare"></p>
<hr>
<p><strong>kill 一个进程给其他进程发送信号</strong></p>
<p><code>int kill(pid_t pid, int sig);</code></p>
<p><img src="/img/socket/kill.png" alt="kill"></p>
<p><strong>kill出错的情况</strong></p>
<p><img src="/img/socket/kill_error.png" alt="kill_error"></p>
<p><strong>信号处理函数SIG_DFL使用信号的默认处理方式、SIG_IGN表示忽略目标信号</strong></p>
<pre tabindex="0"><code>//原型: typedef void (* __sighandler_t) (int);
#define SIG_DFL((__sighandler_t) 0)
#define SIG_IGN((__sighandler_t) 1) 
</code></pre><p><strong>signal信号设置处理函数</strong></p>
<p><code>sighandler_t signal(int signum, sighandler_t handler);</code></p>
<p><strong>signal更健壮的接口</strong></p>
<p><code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p>
<p><img src="/img/socket/sa_flags.png" alt="sa_flags"></p>
<p><strong>信号集</strong></p>
<pre tabindex="0"><code>int sigemptyset(sigset_t * _set) //清空信号集
int sigfillset(sigset_t * _set) //在信号集中设置所有信号
int sigaddset(sigset_t * _set, int _signo) //将信号 _signo添加至信号集中
int sigdelset(sigset_t * _set, int _signo) //将信号 _signo从信号集中删除
int sigismember(const sigset_t * _set, int _signo) //测试 _signo是否在信号集中
</code></pre><p><strong>设置或查看进程信号掩码</strong></p>
<p><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></p>
<p><img src="/img/socket/sigprocmask.png" alt="sigprocmask"></p>
<p><strong>sigpending 获得进程当前被挂起的信号集 成功返回0 失败-1</strong></p>
<p><code>int sigpending(sigset_t *set);</code></p>
<hr>
<p><strong>SO_RCVTIMEO接收数据超时时间 SO_SNDTIMEO发送数据超时时间</strong></p>
<p><img src="/img/socket/timeo.png" alt="timeo"></p>
<p><strong>高性能定时器 时间轮</strong></p>
<p><img src="/img/socket/%E6%97%B6%E9%97%B4%E8%BD%AE.png" alt="时间轮"></p>
<hr>
<p><strong>fork 复制当前进程, 在内核进程表中创建一个新的进程表项</strong></p>
<p><code>pid_t fork(void);</code></p>
<p><strong>exec 在子进程中执行其他程序, 即替换当前进程映像</strong></p>
<pre tabindex="0"><code>int execl(const char* path, const char * arg, ...);
int execlp(const char* file, const char* arg, ...);
int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
</code></pre><p><strong>wait 在父进程中调用, 等待子进程的结束, 并获取子进程的返回信息,避免了僵尸进程的产生或使子进程的僵尸态立即结束, wait函数将阻塞进程,直到进程的某个子进程结束运行为止</strong></p>
<pre tabindex="0"><code>pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);
</code></pre><p><img src="/img/socket/%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF.png" alt="子进程状态信息"></p>
<p><strong>semget 系统调用创建一个新的信号量集, 或者获取一个已经存在的信号量集</strong></p>
<p><code>int semget(key_t key, int nsems, int semflg);</code></p>
<p><strong>semop 对信号量的操作是对这些内核变量的操作</strong></p>
<p><code>int semop(int semid, struct sembuf *sops, size_t nsops);</code></p>
<p><strong>semctl 系统调用允许调用者对信号量进行直接控制</strong></p>
<p><code>int semctl(int semid, int semnum, int cmd, ...);</code></p>
<p><strong>shmget 系统调用创建一段新的共享内存,或者获取一段已存在的共享内存</strong></p>
<p><code>int shmget(key_t key, size_t size, int shmflg);</code></p>
<p><strong>shmat shmdt 共享内存被创建\获取后,不能立即访问,而是需要先将它关联到进程的地址空间中,使用完共享内存之后,也需要将它从进程地址空间中分离</strong></p>
<pre tabindex="0"><code>void *shmat(int shmid, const void *shmaddr, int shmflg);
int shmdt(const void *shmaddr);
</code></pre><p><strong>shmctl系统调用控制内存的某些属性</strong></p>
<p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></p>
<p><img src="/img/socket/shmctl.png" alt="shmctl"></p>
<p><strong>shm_open 创建或打开POSIX共享内存对象. Linux提供了一种利用mmap在无关进程之间共享内存的方式,这种方式无须任何文件支持,但它需要先使用shm_open 创建\打开一个POSIX共享内存对象</strong></p>
<pre tabindex="0"><code>//编译时需要指定链接: -lrt
int shm_open(const char *name, int oflag, mode_t mode);
</code></pre><p><img src="/img/socket/shm_open_oflag.png" alt="shm_open_oflag"></p>
<p><strong>shm_unlink 删除创建的共享内存对象</strong></p>
<p><code>int shm_unlink(const char *name);</code></p>
<hr>
<p><strong>socketpair()函数用于创建一对无名的、相互连接的套接子。</strong></p>
<p><a href="https://blog.csdn.net/weixin_40039738/article/details/81095013">https://blog.csdn.net/weixin_40039738/article/details/81095013</a></p>
<pre tabindex="0"><code>int socketpair(int d, int type, int protocol, int sv[2])；
</code></pre><p>如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中。</p>
<p><strong>基本用法：</strong></p>
<ul>
<li>
<ol>
<li>这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读； </li>
</ol>
</li>
<li>
<ol start="2">
<li>如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功； </li>
</ol>
</li>
<li>
<ol start="3">
<li>读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程。如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写。因为文件描述副sv[0]和sv[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。 </li>
</ol>
</li>
</ul>
<p><strong>s</strong>endmsg、recvmsg、send函数的使用**</p>
<pre tabindex="0"><code>#sendmsg()用来将数据由指定的socket传给对方主机. 失败返回-1
int sendmsg(int s, const strcut msghdr *msg, unsigned int flags);

#函数说明：recvmsg()用来接收远程主机经指定的socket 传来的数据.  失败返回-1
int recvmsg(int s, struct msghdr *msg, unsigned int flags);

#send()用来将数据由指定的socket 传给对方主机.  失败返回-1
int send(int s, const void * msg, int len, unsigned int falgs);
</code></pre><p><strong>函数send参数flags 一般设0, 其他数值定义如下：</strong></p>
<ul>
<li>MSG_OOB 传送的数据以out-of-band 送出.</li>
<li>MSG_DONTROUTE 取消路由表查询</li>
<li>MSG_DONTWAIT 设置为不可阻断运作</li>
<li>MSG_NOSIGNAL 此动作不愿被SIGPIPE 信号中断.</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>
<br />
<hr width = "450" color="#eeeeee" align="left">
  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/vcvc/license.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
<br />
<br />
<hr width = "450" color="#eeeeee" align="left">

<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '04113d0f85a50a1085fb',
        clientSecret: '3c6f0b9285b24893ac2ff9956d547aefd21a7eec',
        repo: '6923403.github.io',
        owner: '6923403',
        admin: ['6923403'],
        id: location.pathname, 
        distractionFreeMode: false 
    });
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
            return;
        }
        gitalk.render('gitalk-container');
    })();
</script>


    </main>
  </body>
</html>
