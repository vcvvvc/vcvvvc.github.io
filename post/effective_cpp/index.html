<!doctype html>
<html lang="en-us">
  <head>
    <title>Effective C&#43;&#43; 总结 // Vcvc Blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Vcvc" />
    <meta name="description" content="" />
    <meta name="keywords" content="VcVc,VcVc Blog,Cplusplus, CPP,Open Source,Rust,Python,Linux" />
    <link rel="stylesheet" href="https://6923403.github.io/css/main.min.c2052924716d810662c2cc67f9223190e814e1923e41ea4b9647c5c71b6ce3b6.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Effective C&#43;&#43; 总结"/>
<meta name="twitter:description" content="条款01: 将C&#43;&#43;视为一个语言联邦 C&#43;&#43;已经是个多重范型编程语言 (multiparadigm programming language）
同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。
 条款02：尽量以 const，enum，inline替换#define 也可以说是 宁可以编译器替换预处理器
#define 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间
第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：
class Gameplayer { private: static const int NumTurns = 5; //常量声明式  int scores[NumTurns]; ... }; 第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的&quot;the enum hack&quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”
enum hack的行为某方面说比较像#define而不像const
class Gameplayer { private: enum {NumTurns = 5}; int scores[NumTurns]; ... }; 本文要点
  对于单纯常量,最好以const对象或enums替换#defines.
  对于形似函数的宏(macros) ,最好改用inline函数替换#defines.
   条款03: 尽可能使用const 如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。
作用
 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。  char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量  // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int&amp; Var); // 引用参数在函数内为常量  // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:你曾经承诺不改动的那个对象被改动了。这就是为什么&quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。"/>

    <meta property="og:title" content="Effective C&#43;&#43; 总结" />
<meta property="og:description" content="条款01: 将C&#43;&#43;视为一个语言联邦 C&#43;&#43;已经是个多重范型编程语言 (multiparadigm programming language）
同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。
 条款02：尽量以 const，enum，inline替换#define 也可以说是 宁可以编译器替换预处理器
#define 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间
第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：
class Gameplayer { private: static const int NumTurns = 5; //常量声明式  int scores[NumTurns]; ... }; 第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的&quot;the enum hack&quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”
enum hack的行为某方面说比较像#define而不像const
class Gameplayer { private: enum {NumTurns = 5}; int scores[NumTurns]; ... }; 本文要点
  对于单纯常量,最好以const对象或enums替换#defines.
  对于形似函数的宏(macros) ,最好改用inline函数替换#defines.
   条款03: 尽可能使用const 如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。
作用
 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。  char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量  // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int&amp; Var); // 引用参数在函数内为常量  // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:你曾经承诺不改动的那个对象被改动了。这就是为什么&quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://6923403.github.io/post/effective_cpp/" />
<meta property="article:published_time" content="2021-04-11T14:44:22+08:00" />
<meta property="article:modified_time" content="2021-04-11T14:44:22+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://6923403.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Vcvc" /></a>
      <h1>Vcvc Blog</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p> Amateur Financer.</p>
      <div class="app-header-social">
        
          <a href="https://github.com/6923403" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/vcvckw" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
          <a href="mailto:vcvckw@gmail.com" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail">
  <title>mail</title>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>
</svg>
          </a>
        
        
<div class="searchBox">
       <form method="get" target = "_blank" action="http://www.google.com/search">
           <input type="text" name="query" class="searchField" placeholder = "Search-goolge" />
           <input type="hidden" name="sitesearch" value="6923403.github.io">
       </form>
</div>
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Effective C&#43;&#43; 总结</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 11, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          6 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://6923403.github.io/tags/cpp/">CPP</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="条款01-将c视为一个语言联邦">条款01: 将C++视为一个语言联邦</h3>
<p><strong>C++已经是个多重范型编程语言 (multiparadigm programming language）</strong></p>
<p><strong>同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。</strong></p>
<hr>
<h3 id="条款02尽量以-constenuminline替换define">条款02：尽量以 const，enum，inline替换#define</h3>
<p><strong>也可以说是 宁可以编译器替换预处理器</strong></p>
<p><strong><code>#define</code> 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间</strong></p>
<p><strong>第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Gameplayer</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> NumTurns <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">//常量声明式
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> scores[NumTurns];
    ...
};
</code></pre></div><p><strong>第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的&quot;the enum hack&quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”</strong></p>
<p><strong>enum hack的行为某方面说比较像#define而不像const</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Gameplayer</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">enum</span> {NumTurns <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>};
    <span style="color:#66d9ef">int</span> scores[NumTurns];
    ...
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>
<p><strong>对于单纯常量,最好以const对象或enums替换#defines.</strong></p>
</li>
<li>
<p><strong>对于形似函数的宏(macros) ,最好改用inline函数替换#defines.</strong></p>
</li>
</ul>
<hr>
<h3 id="条款03-尽可能使用const">条款03: 尽可能使用const</h3>
<p><strong>如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。</strong></p>
<p><strong>作用</strong></p>
<ul>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> greeting;                <span style="color:#75715e">// 指针变量，指向字符数组变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p3 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p4 <span style="color:#f92672">=</span> greeting;    <span style="color:#75715e">// 自身是常量的指针，指向字符数组常量
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function1</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Var);           <span style="color:#75715e">// 传递过来的参数在函数内不可变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> Var);         <span style="color:#75715e">// 参数指针所指内容为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function3</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> Var);         <span style="color:#75715e">// 参数指针为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function4</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> Var);          <span style="color:#75715e">// 引用参数在函数内为常量
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 函数返回值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">function5</span>();      <span style="color:#75715e">// 返回一个常数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">function6</span>();     <span style="color:#75715e">// 返回一个指向常量的指针变量，使用：const int *p = function6();
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">function7</span>();     <span style="color:#75715e">// 返回一个指向变量的常指针，使用：int* const p = function7();
</span></code></pre></div><p><strong>const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:<code>你曾经承诺不改动的那个对象被改动了。</code>这就是为什么&quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。</strong></p>
<p><strong>non-const成员函数本来就可以对其对象做任何动作,所以在其中调用一个const成员函数并不会带来风险。这就是为什么本例以static_cast作用于*this的原因: 这里并不存在const相关危险。</strong></p>
<p><strong>观点</strong></p>
<ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施bitwise constness,但你编写程序时应该使用“概念上的常量性” (conceptual constness)</li>
<li>当const和non-const成员函数有着实质等价的实现时,令non-const版本调用const版本可避免代码重复。</li>
</ul>
<hr>
<h3 id="条款04-确定对象被使用前已先被初始化">条款04: 确定对象被使用前已先被初始化</h3>
<p><strong>第一、 读取未初始化的值会导致不明确的行为。</strong></p>
<p><strong>第二、使用构造函数初始化列表进行初始化为佳</strong></p>
<p><strong><code>#2</code>这个构造函数和<code>#1</code>的最终结果相同,但通常效率较高。基于赋值的那个版 本(本例第一版本)首先调用default构造函数为theName, theAddress和thePhones设初值,然后立刻再对它们赋予新值。 default构造函数的一切作为因此浪费了。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ABEntry</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ABEntry();
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> a;
    <span style="color:#66d9ef">int</span> b;
    <span style="color:#66d9ef">int</span> c;
};

<span style="color:#75715e"># 1 
</span><span style="color:#75715e"></span>ABEntry<span style="color:#f92672">::</span>ABEntry()
{
    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">#2
</span><span style="color:#75715e"></span>ABEntry<span style="color:#f92672">::</span>ABEntry() <span style="color:#f92672">:</span> a(<span style="color:#ae81ff">0</span>), b(<span style="color:#ae81ff">0</span>), c(<span style="color:#ae81ff">0</span>)
{}
</code></pre></div><p><strong>有些情况下即使面对的成员变量属于内置类型(那么其初始化与赋值的成本相同) ,也一定得使用初值列。是的,如果成员变量是const或references,它们就一定需要初值,不能被赋值。</strong></p>
<p><strong>第三、 防止初始化次序问题 合理运用单例模式</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Filesystem</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ...
    <span style="color:#66d9ef">static</span> Filesystem<span style="color:#f92672">*</span> fts();
};

Filesystem<span style="color:#f92672">*</span> Filesystem<span style="color:#f92672">::</span>GetInstance()
{
	<span style="color:#66d9ef">static</span> connection_pool connPool;
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>connPool;
}

<span style="color:#75715e">#2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Filesystem</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> Filesystem<span style="color:#f92672">*</span> fts;
    Filesystem(){};
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> Filesystem<span style="color:#f92672">*</span> getInstance()
    {
        <span style="color:#66d9ef">if</span> (fts <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        {
            fts <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Filesystem();
        }
        <span style="color:#66d9ef">return</span> fts;
    }
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>为内置型对象进行手工初始化,因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列(member initialization list) ,而不要在构造函数</li>
<li>本体内使用赋值操作(assignment) 。初值列列出的成员变量,其排列次序应该和它们在class中的声明次序相同。</li>
<li>为免除“跨编译单元之初始化次序”问题,请以local static对象替换non-local static对象。</li>
</ul>
<hr>
<h3 id="条款05-了解c默默编写并调用哪些函数">条款05: 了解C++默默编写并调用哪些函数</h3>
<p><strong>编译器可以暗自为class创建默认构造函数、拷贝构造函数、拷贝赋值操作符、以及析构函数。记住，这些函数不是类一创建出来就有的，惟有当这些函数被需要（调用），它们才会被编译器创建出来。</strong></p>
<p><strong>当然，如果你在创建类时，自己声明了那些函数，编译器就不会再创建了。</strong></p>
<hr>
<h3 id="条款06-若不想使用编译器自动生成的函数就该明确拒绝">条款06: 若不想使用编译器自动生成的函数，就该明确拒绝</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HomeForSale</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ...
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    HomeForSale(<span style="color:#66d9ef">const</span> HomeForSale<span style="color:#f92672">&amp;</span>);
    HomeForSale<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> HomeForSale<span style="color:#f92672">&amp;</span>);
    ...
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>为驳回编译器自动(暗自)提供的机能,可将相应的成员函数声明为private并且 不予实现。使用像Uncopyable这样的base class也是一种做法。</li>
</ul>
<hr>
<h3 id="条款07-为多态基类声明virtual析构函数">条款07: 为多态基类声明virtual析构函数</h3>
<p><strong>如果base class没有<code>virtual</code> 会直接调用base class析构函数, derived class成员未释放。造成资源泄漏、内存浪费。</strong></p>
<p><strong>无端地将所有classes的析构函数声明为virtual,就像从未声明它们为virtual一样,都是错误的。许多人的心得是:只有当class内含至少一个virtual函数,才为它声明virtual析构函数。</strong></p>
<p><strong>欲实现出virtual函数,对象必须携带某些信息,主要用来在运行期决定哪一个 virtual函数该被调用。这份信息通常是由一个所谓<code>vptr (virtual table pointer)</code>指针指 出。vptr指向一个由函数指针构成的数组,称为<code>vtbl(virtual table);</code>每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数,实际被调用的函数取决于该对象的vptr所指的那个vtbl-编译器在其中寻找适当的函数指针。</strong></p>
<p><strong>第二、 关于虚函数、纯虚函数</strong></p>
<ul>
<li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func()</li>
<li>纯虚函数，在虚函数后加“=0”，如 virtual void func()=0</li>
<li>对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。</li>
<li>对于纯虚函数，子类必须提供纯虚函数的个性化实现。</li>
<li>一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。</li>
<li>只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。</li>
<li>构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</li>
</ul>
<p><strong>如何选用</strong></p>
<ul>
<li>当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。</li>
<li>当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>polymorphic (带多态性质的) base classes应该声明一个virtual析构函数。如果 class带有任何virtual函数,它就应该拥有一个virtual析构函数。</li>
<li>Classes的设计目的如果不是作为base classes使用,或不是为了具备多态性 (polymorphically) ,就不该声明virtual析构函数。</li>
</ul>
<hr>
<h3 id="条款08-别让异常逃离析构函数">条款08: 别让异常逃离析构函数</h3>
<p><strong>当vector v被销毁,它有责任销毁其内含的所有widgets。假设v内含十个Widgets,而在析构第一个元素期间,有个异常被抛出。其他九个widgets还是应该被销毁(否则它们保存的任何资源都会发生泄漏) ,因此v应该调用它们各个析构函数。但假设在那些调用期间,第二个widget析构函数又抛出异常。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#f92672">~</span>widget() {
        ... <span style="color:#75715e">//假设可能抛出异常
</span><span style="color:#75715e"></span>    };
};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dosomething</span>()
{
    std:;vector<span style="color:#f92672">&lt;</span>widget<span style="color:#f92672">&gt;</span> v;
    ...
}
</code></pre></div><p><strong>但如果你的析构函数必须执行一个动作，如果该调用导致异常, DBConn析构函数会传播该异常,也就是允许它离开这个析构函数。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DBConnection</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> DBconnection create();
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">close</span>();
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    DBConnection db;
};
</code></pre></div><p><strong>有两个方法 但是作用不大</strong></p>
<p><strong>1. 调用abort</strong></p>
<p><strong>如果程序遭遇一个“于析构期间发生的错误”后无法继续执行, “强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数传播出去(那会导致不明确的行为)。也就是说调用abort可以抢先制“不明确行为”于死地。</strong></p>
<p><strong>2. 吞下因调用close而发生的异常</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DBconn<span style="color:#f92672">::~</span>DBconn()
{
    <span style="color:#66d9ef">try</span>{
        db.close();
    }
    <span style="color:#66d9ef">catch</span>(...)
    {
        std<span style="color:#f92672">::</span>abort();
    }
}
</code></pre></div><p><strong>一个较佳策略是重新设计DBConn接口,使其客户有机会对可能出现的问题作出反应。</strong></p>
<p><strong>如果某个操作可能在失败时抛出异常,而又存在某种需要必须处理该异常,那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险,总会带来“过早结束程序”或“发生不明确行为”的风险。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DBConn</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
...
	<span style="color:#66d9ef">void</span> close()                 <span style="color:#75715e">//供客户使用的新函数
</span><span style="color:#75715e"></span>	{
		db.close();
		closed <span style="color:#f92672">=</span> true;
	}
	<span style="color:#f92672">~</span>DBConn()
	{
		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>closed){
			<span style="color:#66d9ef">try</span>{                  <span style="color:#75715e">//关闭连接（如果客户不那么做的话）
</span><span style="color:#75715e"></span>				db.close();
			}
			<span style="color:#66d9ef">catch</span>(...){           <span style="color:#75715e">//如果关闭动作失败，记录下并结束程序或吞下异常
</span><span style="color:#75715e"></span>				                  <span style="color:#75715e">//制作运转记录，记下对close的调用失败；
</span><span style="color:#75715e"></span>			...
			}
		}
	}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	DBConnection db;
	<span style="color:#66d9ef">bool</span> closed;
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么class应该提供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
<hr>
<h3 id="条款09-绝不在构造和析构过程中调用virtual函数">条款09: 绝不在构造和析构过程中调用virtual函数</h3>
<p><strong><code>BuyTransaction b;</code>这时候被调用的logTransaction是 Transaction内的版本,不是Buyrransaction内的版本-即使目前即将建立的对象类型是BuyTransaction。base class构造期间virtual函数绝不会下降到derived classes阶层。</strong></p>
<p><strong>非正式的说法或许比较传神: 在base class构造期间, virtual函数不是virtual函数。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Transaction</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Transaction( );
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">logrransaction</span>() <span style="color:#66d9ef">const</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    ...
};
Transaction<span style="color:#f92672">::</span> Transaction ()
{
    ...
    logTransaction();
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BuyTransaction</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Transaction { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> logrransaction() <span style="color:#66d9ef">const</span>;
    ...
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SellTransaction</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Transaction {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> logTransaction() <span style="color:#66d9ef">const</span>;
    ...
};
</code></pre></div><p><strong>其他方案可以解决这个问题。一种做法是在class Transaction内将 1ogTransaction函数改为non-virtual,然后要求derived class构造函数传递必要信 息给Transaction构造函数,而后那个构造函数便可安全地调用non-virtual logTransaction。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BuyTransaction</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Transaction {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Buyrransaction ( parameters) <span style="color:#f92672">:</span> Transaction (createLogstring ( parameters ))  {...}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string createLogstring( parameters );
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>在构造和析构期间不要调用virtual函数,因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)。</li>
</ul>
<hr>
<h3 id="条款10-令operator返回一个reference-to-this">条款10: 令operator=返回一个<code>reference to *this</code></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Widget<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> rhs)  <span style="color:#75715e">//返回类型是个reference，指向当前对象
</span><span style="color:#75715e"></span>{
	...
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;                     <span style="color:#75715e">//返回左侧对象
</span><span style="color:#75715e"></span>}

<span style="color:#75715e"># 实现连锁赋值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> x, y, z;
x <span style="color:#f92672">=</span> y <span style="color:#f92672">=</span> z <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>;                       <span style="color:#75715e">//赋值连锁形式
</span></code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>令赋值(assignment)操作符返回一个reference to *this</li>
</ul>
<hr>
<h3 id="条款11-在operator中处理自我赋值">条款11: 在operator=中处理“自我赋值”</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bitmap</span> {...};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span> {
    ...
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    Bitmap<span style="color:#f92672">*</span> pb;
};

<span style="color:#75715e"># 直接赋值不具备自我赋值安全、异常安全性
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># 传统不安全做法
</span><span style="color:#75715e"># 不具备异常安全性
</span><span style="color:#75715e"></span>Widget<span style="color:#f92672">&amp;</span> Widget<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> Widqet<span style="color:#f92672">&amp;</span> rhs) {
    <span style="color:#66d9ef">delete</span> pb;
    pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bitmap(<span style="color:#f92672">*</span>rhs.pb); 
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}

<span style="color:#75715e"># 保证异常安全性做法
</span><span style="color:#75715e"></span>Widget<span style="color:#f92672">&amp;</span> Widget<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> rhs) {
    Bitmap<span style="color:#f92672">*</span> pOring <span style="color:#f92672">=</span> pb;
    pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bitmap(<span style="color:#f92672">*</span>rhs.pb);
    <span style="color:#66d9ef">delete</span> pOring;
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}

<span style="color:#75715e"># copy-and-swap v1
</span><span style="color:#75715e"></span>Widget<span style="color:#f92672">&amp;</span> Widget<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> rhs) {
     Widget <span style="color:#a6e22e">temp</span> (rhs); 
     swap (temp);
     <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}

<span style="color:#75715e"># copy-and-swap v2
</span><span style="color:#75715e"></span>Widget<span style="color:#f92672">&amp;</span> Widget<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Widget rhs) {
     Widget <span style="color:#a6e22e">temp</span> (rhs); 
     swap (temp);
     <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>确保当对象自我赋值时operator-有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap.</li>
<li>确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为仍然正确。</li>
</ul>
<hr>
<h3 id="条款12-复制对象时勿忘其每一个成分">条款12: 复制对象时勿忘其每一个成分</h3>
<p><strong>如果你声明自己的copying函数,意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的,会以一种奇怪的方式回敬: 当你的实现代码几乎必然出错时却不告诉你。</strong></p>
<p><strong>当类含有其他类的成员、类发生继承</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Date</span> { ... };
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ...
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    std<span style="color:#f92672">::</span>string name; 
    Date lastTransaction;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PriorityCustomer</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Customer { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
     PrioriuyCustomer(<span style="color:#66d9ef">const</span> PriorityCustomer<span style="color:#f92672">&amp;</span> rhs);
     PriorityCustomer<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> PriorityCustomer<span style="color:#f92672">&amp;</span> rhs);
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
     <span style="color:#66d9ef">int</span> priority;
};

Prioritycustomer<span style="color:#f92672">::</span>PriorityCustomer(<span style="color:#66d9ef">const</span> PriorityCustomer<span style="color:#f92672">&amp;</span> rhs) <span style="color:#f92672">:</span> priority(rhs.priority)
{
    logCall(<span style="color:#e6db74">&#34;PriorityCustomer copy constructor&#34;</span>);
}

PriorityCustomer<span style="color:#f92672">&amp;</span> PriorityCustomer<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> PriorityCustomer<span style="color:#f92672">&amp;</span> rhs) {
    logCall(<span style="color:#e6db74">&#34;PriorityCustomer copy assignment operator&#34;</span>); 
    priority<span style="color:#f92672">=</span>rhs.priority;
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p><strong>它们复制了Prioritycustomer声明的成员变量, 但每个PriorityCustomer还内含它所继承的Customer成员变量复件(副本) ,而那些成员变量却未被复制。</strong></p>
<p><strong>应该让derived class的copying函数调用相应的base class函数</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">PriorityCustomer<span style="color:#f92672">::</span>PriorityCustomer(<span style="color:#66d9ef">const</span> Prioritycustomer<span style="color:#f92672">&amp;</span> rhs) <span style="color:#f92672">:</span> customer(rhs), priority(rhs.priority)
{
    logCall (<span style="color:#e6db74">&#34;PriorityCustomer copy constructor&#34;</span>);
}
PriorityCustomer<span style="color:#f92672">&amp;</span> PriorityCustomer<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Prioritycustomer<span style="color:#f92672">&amp;</span> rhs) {
    logCall (<span style="color:#e6db74">&#34;PriorityCustomer copy assignment operator&#34;</span>);
    Customer: <span style="color:#f92672">:</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span> (rhs);
    priority<span style="color:#f92672">=</span>rhs.priority;
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p><strong>copy assignment操作符调用copy构造函数是不合理的,因为这就像试图构造一个已经存在的对象。</strong></p>
<p><strong>反方向&ndash;令copy构造函数调用copy assignment操作符-同样无意义。构造函数用来初始化新对象,而assignment操作符只施行于已初始化对象身上。</strong></p>
<p><strong>本文要点</strong></p>
<ul>
<li>
<p>本条款题目所说的“复制每一个成分”现在应该很清楚了。当你编写一个copying函数,请确保:</p>
<ul>
<li>复制所有local成员变量</li>
<li>调用所有base classes内的适当的 copying函数。</li>
</ul>
</li>
<li>
<p>Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”</p>
</li>
<li>
<p>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中,并由两个coping函数共同调用。</p>
</li>
</ul>
<hr>
<h3 id="条款13-以对象管理资源">条款13: 以对象管理资源</h3>
<p>所谓资源就是,一旦用了它,将来必须还给系统。C++程序中最常使用的资源就是动态分配内存(如果你分配内存却从来不曾归还它,会导致内存泄漏) ,但内存只是你必须管理的众多资源之一。</p>
<p>程序中过早的return、continus、goto等 略过delete， 泄漏的不只是内含投资对象的那块内存,还包括那些投资对象所保存的任何资源。</p>
<p><strong>使用智能指针</strong></p>
<p><code>auto_ptr</code>在C++11已被弃用</p>
<p><strong>代替方案为 “引用计数型智慧指针&quot;(reference-counting smart pointer;RCSP)</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
    std<span style="color:#f92672">::</span>tr1<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Investment<span style="color:#f92672">&gt;</span> pInv(createInvestment());
    ...
}
</code></pre></div><ul>
<li>获得资源后立刻放进管理对象( managing object)内。</li>
<li>管理对象(managing object)运用析构函数确保资源被释放。</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>为防止资源泄漏,请使用RAI1对象,它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的RAlI classes分别是tr1::shared-ptr和autoptr,前者通常是较佳选择,因为其copy行为比较直观。若选择auto-ptr,复制动作会使它(被复制物)指向null</li>
</ul>
<hr>
<h3 id="条款14-在资源管理类中小心coping行为">条款14: 在资源管理类中小心coping行为</h3>
<pre><code>Lock ml1 (&amp;m); //锁定m
Lock ml2 (ml1); //将ml1复制到m12身上。这会发生什么事?
</code></pre><p><strong>当一个RAI1对象被复制 该怎么办:</strong></p>
<ul>
<li>禁止复制</li>
<li>对底层资源采用“引用计数法”(智能指针)</li>
<li>复制底部资源。(深度拷贝)</li>
<li>转移底部资源的拥有权。</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>复制RAl1对象必须一并复制它所管理的资源,所以资源的copying行为决定 RAII对象的copying行为。</li>
<li>普遍而常见的RAll class copying行为是:抑制copying、施行引用计数法 (reference counting) 。不过其他行为也都可能被实现。</li>
</ul>
<hr>
<h3 id="条款15-在资源管理类中提供对原始资源的访问">条款15: 在资源管理类中提供对原始资源的访问</h3>
<p><strong>最佳设计很可能是坚持条款18的忠告: “让接口容易被正确使用,不易被误用”。</strong></p>
<p><strong>本文要点</strong></p>
<ul>
<li>APIs往往要求访问原始资源(raw resources) ,所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。</li>
</ul>
<hr>
<h3 id="条款16-成对使用new和delete时要采取相同形式">条款16: 成对使用new和delete时要采取相同形式</h3>
<p><strong>本文要点</strong></p>
<ul>
<li>如果你在new表达式中使用1],必须在相应的delete表达式中也使用1]。如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[]</li>
</ul>
<hr>
<h3 id="条款17-以独立语句将newed对象置入智能指针">条款17: 以独立语句将newed对象置入智能指针</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processwidget</span>(std<span style="color:#f92672">::</span>tr1<span style="color:#f92672">::</span>shared ptr<span style="color:#f92672">&lt;</span>widget<span style="color:#f92672">&gt;</span> pw, priority());
</code></pre></div><p>虽然我们在此使用“对象管理式资源” (object-managingresources) ,上述调用却可能泄漏资源。</p>
<p>在调用processWidget之前,编译器必须创建代码,做以下三件事:</p>
<ul>
<li>调用priority</li>
<li>执行&quot;new widget&quot;</li>
<li>调用trl::sharedptr构造函数</li>
</ul>
<p><strong>c++并不是特定次序完成函数参数的核算、弹性大。如果<code>priority</code>出现异常 <code>new widget</code>返回的指针将会遗失</strong></p>
<p><strong>本文要点</strong></p>
<ul>
<li>以独立语句将newed对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。</li>
</ul>
<hr>
<h3 id="条款18-让接口容易被正确使用不易被误用">条款18: 让接口容易被正确使用,不易被误用</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>tr1<span style="color:#f92672">::</span>shared ptr<span style="color:#f92672">&lt;</span>Investment<span style="color:#f92672">&gt;</span> pInv( <span style="color:#66d9ef">static</span> cast<span style="color:#f92672">&lt;</span>Investment<span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">0</span>), getRidofInvestment);
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>好的接口很容易被正确使用,不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促进正确使用”的办法包括接口的一致性,以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作,束缚对象值,以及消除客户的资源管理责任。</li>
<li>tr1::sharedptr支持定制型删除器(custom deleter) 。这可防范DLL问题,可被用来自动解除互斥锁(mutexes,见条款14)等等。</li>
</ul>
<hr>
<h3 id="条款19设计class犹如设计type">条款19:设计class犹如设计type</h3>
<p>在设计class时,要考虑一系列的问题, 包括：</p>
<ul>
<li>新type的对象应该如何被创建和销毁（构造和析构）</li>
<li>对象的初始化和对象的赋值该有什么样的差别，这个答案决定你的构造函数和赋值操作符的行为，以及其间的差异。</li>
<li>新的type的对象如果被pass by value，意味着什么？记住，拷贝构造函数用来定义一个type的pass-by-value该如何实现。</li>
<li>什么是新type的“合法值”？（约束条件）成员函数必须进行错误检查工作。</li>
<li>你的新type需要配合某个继承图系吗？（注意虚函数）</li>
<li>你的新type需要什么样的转换？（显示转换、类型转换操作符）</li>
<li>什么样的操作符和函数对此新type而言是合理的？这决定你为你的class声明哪些函数，哪些是成员函数，哪些不是。</li>
<li>什么样的标准函数应该驳回？那些正是必须声明为private者（条款6）。</li>
<li>什么是新type的“未声明接口”</li>
<li>你的新type有多么一般化？（class template）</li>
<li>成员函数和成员变量的可见范围（public/protected/private）</li>
<li>是否真的需要一个新type</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>Class的设计就是type的设计。在定义一个新type之前,请确定你已经考虑过本条款覆盖的所有讨论主题。</li>
</ul>
<hr>
<h3 id="条款20宁以pass-by-reference-to-const替换pass-by-value">条款20:宁以pass-by-reference-to-const替换pass-by-value</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">validatestudent</span>(<span style="color:#66d9ef">const</span> student<span style="color:#f92672">&amp;</span> s);
</code></pre></div><p><strong>这种传递方式的效率高得多:没有任何构造函数或析构函数被调用,因为没有任何新对象被创建。修订后的这个参数声明中的const是重要的。以by reference方式传递参数也可以避免对象切割问题</strong></p>
<p><strong>本文要点</strong></p>
<ul>
<li>尽量以pass-by-reference-to-const替换pass-by-value,前者通常比较高效,并可避免</li>
<li>切割问题(slicing problem) 。
以上规则并不适用于内置类型,以及STL的迭代器和函数对象。对它们而言, pass-by-value往往比较适当。</li>
</ul>
<hr>
<h3 id="条款21-必须返回对象时别妄想返回其reference">条款21: 必须返回对象时,别妄想返回其reference</h3>
<p>任何时候看到一个引用声明式，你都应该立刻问自己，它的另一个名称是什么？</p>
<p><strong>虽然函数参数最好用引用值，但函数返回值却不要随便去用引用，这回造成很多问题，比如引用的对象在函数结束后即被销毁，或是需要付出很多成本和代码来保证其不被销毁且不重复，这大概率没有必要，就返回一个值/对象就好了。</strong></p>
<p><strong>本文要点</strong></p>
<ul>
<li>绝不要返回pointer或reference指向一个local stack对象,或返回reference指向一 个heap-allocated对象,或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference指向一个local static对象”提供了一份设计实例。</li>
</ul>
<hr>
<h3 id="条款22将成员变量声明为private">条款22:将成员变量声明为private</h3>
<p><strong>封装重要性,可以确保class的约束条件总是会获得维护,因为只有成员函数可以影响它们。</strong></p>
<p><strong>protected并不比public更加具有封装性，因为protected修饰的成员变量一旦修改，也会造成子类的大量修改。</strong></p>
<p>从封装的角度观之,其实只有两种访问权限: private (提供封装)和其他(不提供封装)</p>
<p><strong>本文要点</strong></p>
<ul>
<li>切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证,并提供class作者以充分的实现弹性。</li>
<li>protected并不比public更具封装性。</li>
</ul>
<hr>
<h3 id="条款23-宁以non-member-non-friend替换member函数">条款23: 宁以non-member, non-friend替换member函数</h3>
<p><strong>提供non-member函数可允许对webBrowser相关机能有较大的包裹弹性 (packaging flexibility) ,而那最终导致较低的编译相依度,增加webBrowser的可延伸性。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clearBrowser</span>(WebBrowser<span style="color:#f92672">&amp;</span> wb) {
    wb.clearCache();
    wb.clearHistory();
    wb.removeCookies();
}
</code></pre></div><p>愈少代码可以看到数据(也就是访问它) ,愈多的数据可被封装,而我们也就愈能自由地改变对象数据</p>
<p>在C++,比较自然的做法是让clearBrowser成为一个non-member函数并且位于 WebBrowser所在的同一个namespace (命名空间)内:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> WebBrowserStuff{
    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WebBrowser</span>{... };
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clearBrowser</span>(WebBrowser<span style="color:#f92672">&amp;</span> wb);
}
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包 裹弹性(packaging flexibility)和机能扩充性。</li>
</ul>
<hr>
<h3 id="条款24-若所有参数皆需类型转换请为此采用non-member函数">条款24: 若所有参数皆需类型转换,请为此采用non-member函数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> Rational <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>;
}<span style="color:#960050;background-color:#1e0010">；</span>

<span style="color:#75715e">#没问题
</span><span style="color:#75715e"></span>Rational oneEighth(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>);
Rational <span style="color:#a6e22e">oneHalf</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
Rational result <span style="color:#f92672">=</span> oneHalf <span style="color:#f92672">*</span> oneEighth;
result <span style="color:#f92672">=</span> result <span style="color:#f92672">*</span> oneEighth;
result <span style="color:#f92672">=</span> oneHalf <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// result = oneHalf.operator*(2);
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#错误
</span><span style="color:#75715e"></span>result <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> oneHalf; <span style="color:#75715e">//出错  result = 2.operator*(oneHalf);
</span></code></pre></div><p>编译器知道你正在传递一个int,而函数需要的是Rational;但它也知道只要调用Rational构造函数并赋予你所提供的int,就可以变出一个适当的Rational来。</p>
<p><strong>结论是,只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”&ndash;即this对象-的那个隐喻参数,绝不是隐式转换的合格参与者。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span>{
    ...
};

<span style="color:#66d9ef">const</span> Rational <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span> (<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>hs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&amp;</span> rhs) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rational</span> (<span style="color:#ae81ff">1</span>hs.numerator() <span style="color:#f92672">*</span> rhs.numerator( ), 
                    <span style="color:#ae81ff">1</span>hs.denominator() <span style="color:#f92672">*</span> rhs.denominator());
}

<span style="color:#75715e">#编译通过
</span><span style="color:#75715e"></span>Rational <span style="color:#a6e22e">oneFourth</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>);
Rational result; result <span style="color:#f92672">=</span> oneFourth <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
result <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> oneFourth;
</code></pre></div><p><strong><code>operator*</code> 无需设置为friend 因为<code>operator*</code> 可以完全藉由Rational的public接口完成任务</strong></p>
<p><strong>结论是,只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”&ndash;即this对象-的那个隐喻参数,绝不是隐式转换的合格参与者。</strong></p>
<p><strong>本文要点</strong></p>
<ul>
<li>如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换,那么这个函数必须是个non-member.</li>
</ul>
<hr>
<h3 id="条款25-考虑写出一个不抛异常的swap函数">条款25: 考虑写出一个不抛异常的swap函数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> WidgetStuff {
    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">widget</span> {
    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
        <span style="color:#66d9ef">void</span> swap (Widget<span style="color:#f92672">&amp;</span> other)
        {
            <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>swap;
            swap (pImpl, other.pImpl);
        }
    };

    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">void</span> swap(widget<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> a, widget<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> b) {
        a.swap(b);
    }
}

<span style="color:#75715e">#调用T专属版本,并在该版本不存在的情况下调用std内的一般化版本。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> 
<span style="color:#66d9ef">void</span> dosomething(T<span style="color:#f92672">&amp;</span> a, T<span style="color:#f92672">&amp;</span> b) {
        <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>swap;
        ...
        swap(a, b);
    }
}
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>成员函数swap版本绝不可抛出异常</li>
<li>当std::swap对你的类型效率不高时,提供一个swap成员函数,并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap,也该提供一个non-member swap用来调用前者。对 于classes (而非templates) ,也请特化std::swapo</li>
<li>调用swap时应针对std: :swap使用using声明式,然后调用swap并且不带任何“命名空间资格修饰”</li>
<li>为“用户定义类型”进行std templates全特化是好的,但千万不要尝试在std内加入某些对std而言全新的东西。</li>
</ul>
<hr>
<h3 id="条款26-尽可能延后变量定义式的出现时间">条款26: 尽可能延后变量定义式的出现时间</h3>

    </div>
    <div class="post-footer">
      
    </div>
  </article>
<br />
<hr width = "450" color="#eeeeee" align="left">
  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
<a rel="index" href="https://6923403.github.io/"></a>

    </main>
  </body>
</html>
