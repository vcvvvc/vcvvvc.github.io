<!doctype html>
<html lang="zh-cn">
  <head>
    <title>Effective C&#43;&#43; 下 // Vcvc Blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.83.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Vcvc" />
    
    <meta name="description" content="用文字记录经验。" />
    <meta name="keywords" content="Vcvc,Vcvc Blog,CPP,Open Source,Python,Linux" />
    <link rel="stylesheet" href="https://6923403.github.io/css/main.min.c2052924716d810662c2cc67f9223190e814e1923e41ea4b9647c5c71b6ce3b6.css" />
    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Effective C&#43;&#43; 下"/>
<meta name="twitter:description" content="条款41:了解隐式接口和编译期多态 template&lt;typename T&gt; void doProcessing (T&amp; w) { if (w.size() &gt; 10 &amp;&amp; w != someNastywidget) { T temp(w); temp.normalize(); temp.swap(w); } }  w必须支持哪一种接口,系由template中执行于w身上的操作来决定。 凡涉及w的任何函数调用,例如operator&gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates&quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。  显式接口和隐式接口的差异
显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。
 其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。  隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。
template&lt;typename T&gt; void doProcessing( T&amp; w) { if (w.size() &gt; 10 &amp;&amp; w != someNastywidget) { ... } }  它必须提供一个名为size的成员函数,该函数返回一个整数值。 它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T  本文要点
 classes和templates都支持接口(interfaces)和多态(polymorphism) 。 对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。 对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。   条款42: 了解typename的双重意义 template&lt;class T&gt; class widget; //使用&#34;class&#34; template&lt;typename T&gt; class Widget; //使用&#34;typename&#34;  C&#43;&#43;并不总是把class和typename视为等价。有时候你一定得使用 typename。  template&lt;typename C&gt; void print2nd(const C&amp; container) { if (container."/>

    <meta property="og:title" content="Effective C&#43;&#43; 下" />
<meta property="og:description" content="条款41:了解隐式接口和编译期多态 template&lt;typename T&gt; void doProcessing (T&amp; w) { if (w.size() &gt; 10 &amp;&amp; w != someNastywidget) { T temp(w); temp.normalize(); temp.swap(w); } }  w必须支持哪一种接口,系由template中执行于w身上的操作来决定。 凡涉及w的任何函数调用,例如operator&gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates&quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。  显式接口和隐式接口的差异
显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。
 其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。  隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。
template&lt;typename T&gt; void doProcessing( T&amp; w) { if (w.size() &gt; 10 &amp;&amp; w != someNastywidget) { ... } }  它必须提供一个名为size的成员函数,该函数返回一个整数值。 它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T  本文要点
 classes和templates都支持接口(interfaces)和多态(polymorphism) 。 对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。 对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。   条款42: 了解typename的双重意义 template&lt;class T&gt; class widget; //使用&#34;class&#34; template&lt;typename T&gt; class Widget; //使用&#34;typename&#34;  C&#43;&#43;并不总是把class和typename视为等价。有时候你一定得使用 typename。  template&lt;typename C&gt; void print2nd(const C&amp; container) { if (container." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://6923403.github.io/post/effective_cpp_2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-04-24T20:40:36&#43;08:00" />
<meta property="article:modified_time" content="2021-04-24T20:40:36&#43;08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://6923403.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Vcvc" /></a>
      <h1>Vcvc Blog</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p> Amateur Financer.</p>
      <div class="app-header-social">
        
          <a href="https://github.com/6923403" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/vcvckw" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
          <a href="mailto:vcvckw@gmail.com" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail">
  <title>mail</title>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>
</svg>
          </a>
        
        
        <a href="/vcvc/index.html" target="_blank">
          <img  border="0" src="/vcvc/arrow.png" alt="Home" width="24" height="24"></a>






        <script src="https://unpkg.com/lunr/lunr.js"></script>
        var documents = [{
        "name": "Lunr",
        "text": "Like Solr, but much smaller, and not as bright."
        }, {
        "name": "React",
        "text": "A JavaScript library for building user interfaces."
        }, {
        "name": "Lodash",
        "text": "A modern JavaScript utility library delivering modularity, performance & extras."
        }]
      </div>-->
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Effective C&#43;&#43; 下</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 24, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          11 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://6923403.github.io/tags/cpp/">CPP</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="条款41了解隐式接口和编译期多态">条款41:了解隐式接口和编译期多态</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> doProcessing (T<span style="color:#f92672">&amp;</span> w) {
    <span style="color:#66d9ef">if</span> (w.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">&amp;&amp;</span> w <span style="color:#f92672">!=</span> someNastywidget) {
        T <span style="color:#a6e22e">temp</span>(w);
        temp.normalize();
        temp.swap(w);
    }
}
</code></pre></div><ul>
<li>w必须支持哪一种接口,系由template中执行于w身上的操作来决定。</li>
<li>凡涉及w的任何函数调用,例如operator&gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates&quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。</li>
</ul>
<p><strong>显式接口和隐式接口的差异</strong></p>
<p><strong>显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。</strong></p>
<ul>
<li>其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。</li>
</ul>
<p><strong>隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> doProcessing( T<span style="color:#f92672">&amp;</span> w)
{
    <span style="color:#66d9ef">if</span> (w.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">&amp;&amp;</span> w <span style="color:#f92672">!=</span> someNastywidget) {
        ...
    }
}
</code></pre></div><ul>
<li>它必须提供一个名为size的成员函数,该函数返回一个整数值。</li>
<li>它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>classes和templates都支持接口(interfaces)和多态(polymorphism) 。</li>
<li>对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。</li>
<li>对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。</li>
</ul>
<hr>
<h3 id="条款42-了解typename的双重意义">条款42: 了解typename的双重意义</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">widget</span>; <span style="color:#75715e">//使用&#34;class&#34;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>; <span style="color:#75715e">//使用&#34;typename&#34;
</span></code></pre></div><ul>
<li>C++并不总是把class和typename视为等价。有时候你一定得使用 typename。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> C<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> print2nd(<span style="color:#66d9ef">const</span> C<span style="color:#f92672">&amp;</span> container) {
<span style="color:#66d9ef">if</span> (container.size() <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>) {
        C<span style="color:#f92672">::</span><span style="color:#66d9ef">const</span> iterator iter(container.begin());
        <span style="color:#f92672">++</span>iter;
        <span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>iter;
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> value;
    }
}
</code></pre></div><p><strong>template内出现的名 称如果相依于某个template参数, 称之为从属名称(dependent names)。如果从属 名称在class内呈嵌套状,我们称它为嵌套从属名称(nested dependent name) 。int是一个不依赖任何template参数的名称，为非从属名称(non-dependent names)。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> C<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> print2nd(<span style="color:#66d9ef">const</span> C<span style="color:#f92672">&amp;</span> container) {
    <span style="color:#66d9ef">if</span>(container.size() <span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">2</span>)
        C<span style="color:#f92672">::</span>const_iterator iter(container.begin()); <span style="color:#75715e">//假设为非类型
</span><span style="color:#75715e"></span>}
</code></pre></div><p>如果解析器在template中遭遇一个嵌套从属名称,它便假设这名称不是个类型,除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#正确版本
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> C<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> print2nd(<span style="color:#66d9ef">const</span> C<span style="color:#f92672">&amp;</span> container) {
<span style="color:#75715e">//这是合法的CH+代码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (container.size() <span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">2</span>) {
        <span style="color:#66d9ef">typename</span> C<span style="color:#f92672">::</span>const_iterator iter(container.begin());
    }
}
</code></pre></div><p><strong>一般性规则很简单:任何时候当你想要在template中指涉一个嵌套从属类型名称,就必须在紧临它的前一个位置放上关键字typename</strong></p>
<p>&ldquo;typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是, typename不可以出现在base classes list内的嵌套从属类型名称之前,也不可在 member initialization list (成员初值列)中作为base class修饰符。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Nested { <span style="color:#75715e">//不允许
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">explicit</span> Derived(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> Base<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Nested(x) <span style="color:#75715e">//不允许
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">typename</span> Base<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Nested temp; <span style="color:#75715e">//允许
</span><span style="color:#75715e"></span>        ...
    }
    ...
};
</code></pre></div><p>由于std::iterator-traits<!-- raw HTML omitted -->: :value-type是个嵌套从属类型名 称(value-type被嵌套于iterator-traits<!-- raw HTML omitted -->之内而IterT是个template参数) ,所以我们必须在它之前放置typename</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> workwithiterator(IterT iter)
<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator traits<span style="color:#f92672">&lt;</span>IterT<span style="color:#f92672">&gt;::</span>value type temp (<span style="color:#f92672">*</span>iter);
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>声明template参数时,前缀关键字class和typename可互换。</li>
<li>请使用关键字typename标识嵌套从属类型名称;但不得在base class lists (基类 列)或member initialization list (成员初值列)内以它作为base class修饰符。</li>
</ul>
<hr>
<h3 id="条款43-学习处理模板化基类内的名称">条款43: 学习处理模板化基类内的名称</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MsgInfo</span> { ... };
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Company<span style="color:#f92672">&gt;</span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MsgSender</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> sendClear(<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info) {
        std<span style="color:#f92672">::</span>string msg;
        <span style="color:#960050;background-color:#1e0010">这儿</span>,<span style="color:#960050;background-color:#1e0010">根据</span>info产生信息;
        Company c;
        c.sendcleartext (msg);
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sendSecret</span> (<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info) { 
        ... 
    }
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>typenane Company<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoggingMsgSender</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MsgSender<span style="color:#f92672">&lt;</span>Company<span style="color:#f92672">&gt;</span> { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> sendClearMsg (<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info) {
        <span style="color:#75715e">//将“传送前”的信息写至log;
</span><span style="color:#75715e"></span>        sendClear (info); <span style="color:#75715e">//调用base class函数;这段码无法通过编译。
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//将“传送后”的信息写至1og;
</span><span style="color:#75715e"></span>    }
    ...
};
</code></pre></div><p>上面问题在于,当编译器遭遇class template LoggingMsgSender定义式时,并不知 道它继承什么样的class。当然它继承的是MsgSender<!-- raw HTML omitted -->,但其中的Company 是个template参数,不到后来(当LoggingMsgSender被具现化)无法确切知道它 是什么。而如果不知道Company是什么,就无法知道class MsgSender<!-- raw HTML omitted -->看起来像什么&ndash;更明确地说是没办法知道它是否有个sendClear函数。</p>
<p><strong>解决办法</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MsgSender</span><span style="color:#f92672">&lt;</span>Companyz<span style="color:#f92672">&gt;</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ...
    <span style="color:#75715e">//删除了sendclear
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> sendSecret(<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info) { 
        ...
    }
}<span style="color:#960050;background-color:#1e0010">；</span>
</code></pre></div><p>注意class定义式最前头的&quot;template&lt;&ldquo;语法象征这既不是template也不是 标准class,而是个特化版的MsgSender template,在template实参是Companyz时被使用。这是所谓的模板全特化(total template specialization)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Company<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoggingMsgSender</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MsqSender<span style="color:#f92672">&lt;</span>Company<span style="color:#f92672">&gt;</span> { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> sendClearMsg (<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info)
    {
        <span style="color:#75715e">//将“传送前”的信息写至log;
</span><span style="color:#75715e"></span>        sendClear(info); <span style="color:#75715e">//如果company == Companyz,这个函数不存在。将“传送后”的信息写至log;
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//将“传送后”的信息写至log;
</span><span style="color:#75715e"></span>    }
    ...
};
</code></pre></div><p>它知道base class templates有可能被特化,而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在templatized base classes (模板化基类, 本例的MsgSenderkCompany&gt;)内寻找继承而来的名称(本例的SendClear) 。</p>
<p>为了重头来过,我们必须有某种办法令C++“不进入templatized base classes观察”的行为失效。
有三个办法,第一是在base class函数调用动作之前加上<code>this-&gt;</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Company<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoggingMsgSender</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MsqSender<span style="color:#f92672">&lt;</span>Company<span style="color:#f92672">&gt;</span> { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> sendClearMsq (<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info) {
        <span style="color:#75715e">//将“传送前”的信息写至log;,
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>sendClear(info);
        <span style="color:#75715e">//将“传送后”的信息写至log;
</span><span style="color:#75715e"></span>    }
    ...
};
</code></pre></div><p><strong>第二是使用using声明式。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Company<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoggingMsgSender</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MsgSender<span style="color:#f92672">&lt;</span>Company<span style="color:#f92672">&gt;</span> { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> MsgSender<span style="color:#f92672">&lt;</span>Company<span style="color:#f92672">&gt;::</span>sendClear;
    ...
    <span style="color:#66d9ef">void</span> sendClearMsg (<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info)
    {
        ...
        sendClear (info);
        ...
    }
    ...
};
</code></pre></div><p><strong>第三个做法是,明白指出被调用的函数位于base class内:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Company<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoggingMsgSender</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MsgSender<span style="color:#f92672">&lt;</span>Company<span style="color:#f92672">&gt;</span> { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> sendClearMsg (<span style="color:#66d9ef">const</span> MsgInfo<span style="color:#f92672">&amp;</span> info) {
        ...
        MsgSender<span style="color:#f92672">&lt;</span>Company<span style="color:#f92672">&gt;::</span>sendClear(info);
        ...
    }
    ...
};
</code></pre></div><p>但这往往是最不让人满意的一个解法,因为如果被调用的是virtual函数,上述的明确资格修饰(explicit qualification)会关闭&quot;virtual绑定行为”。</p>
<p><strong>从名称可视点(visibility point)的角度出发,上述每一个解法做的事情都相同:对编译器承诺&quot;base class template的任何特化版本都将支持其一般(泛化)版本所提供的接口”。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LoggingMsgSender<span style="color:#f92672">&lt;</span>Companyz<span style="color:#f92672">&gt;</span> zMsgSender; 
MsgInfo msgData;
...
zMsgSender.sendClearMsg(msgData); <span style="color:#75715e">//错误
</span></code></pre></div><p>因为在那个点上,编译器知道base class是个template特化版本Msgsender<!-- raw HTML omitted -->,而且它们知道那个 class不提供sendClear函数,而后者却是sendClearMsg尝试调用的函数。</p>
<p><strong>本文要点</strong></p>
<ul>
<li>可在derived class templates内通过&quot;this-&gt;&ldquo;指涉base class templates内的成员名称,或藉由一个明白写出的&quot;base class资格修饰符”完成。</li>
</ul>
<hr>
<h3 id="条款44-将与参数无关的代码抽离templates">条款44: 将与参数无关的代码抽离templates</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t n<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SquareMatrix</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ...
    <span style="color:#66d9ef">void</span> invert(); <span style="color:#75715e">// 求逆矩阵
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">SquareMatrix<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>,<span style="color:#ae81ff">5</span><span style="color:#f92672">&gt;</span> sml;
...
sm1.invert(); <span style="color:#75715e">//调用SquareMatrix&lt;double,5&gt;::invert
</span><span style="color:#75715e"></span>SquareMatrix<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>,<span style="color:#ae81ff">10</span><span style="color:#f92672">&gt;</span> sm2;
...
sm2.invert();
</code></pre></div><p>这会具现两份invert。这些函数并非完全相同，但除了常量5和10，其他部分都相同，这是template引出代码膨胀的一个典型例子。</p>
<p>下面是第一次修改</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>                <span style="color:#75715e">//与尺寸无关的base class
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SquareMatrixBase</span>{
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> invert(std<span style="color:#f92672">::</span>size_t matrixSize);    <span style="color:#75715e">//以给定的尺寸求逆矩阵
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t n<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SquareMatrix</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">private</span> SquareMatrixBase<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> SquareMatrixBase<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>invert;<span style="color:#75715e">//避免遮掩base版的invert
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> invert() {<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>invert(n);}    <span style="color:#75715e">//制造一个inline调用，用this-&gt;为了不被derived classes的函数名称掩盖
</span><span style="color:#75715e"></span>};
</code></pre></div><p>带参数的invert位于base class中。和SquareMatrix一样，也是个template，不同的是他只对“矩阵元素对象的类型”参数化，不对矩阵的尺寸参数化。因此对于给定的元素对象类型，所有矩阵共享同一个(也是唯一一个）SquareMatrixBase class。也将因此而共享这唯一一个class内的invert。</p>
<p>另一个办法是令SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存。而只要它存储了那些东西，也就可能存储矩阵尺寸：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SquareMatrixBase</span>{
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    SquareMatrixBase(std<span style="color:#f92672">::</span>size_t n, T<span style="color:#f92672">*</span> pMem)
        <span style="color:#f92672">:</span>size(n), pData(pMem){}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setDataPtr</span>(T<span style="color:#f92672">*</span> ptr){pData <span style="color:#f92672">=</span> ptr;}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    std<span style="color:#f92672">::</span>size_t size;
    T<span style="color:#f92672">*</span> pData;
};
</code></pre></div><p>这允许derived classes决定内存分配方式。某些实现版本也许会将矩阵数据存储在SquareMatrix对象内部：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t n<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SquareMatrix</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">private</span> SquareMatrixBase<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    SquareMatrix()<span style="color:#f92672">:</span> SquareMatrixBase<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(n, data) {}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    T data[n<span style="color:#f92672">*</span>n];
}
</code></pre></div><p>另一种做法是把每个矩阵的数据放进heap：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t n<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SquareMatrix</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">private</span> SquareMatrixBase<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    SquareMatrix()
        <span style="color:#f92672">:</span>SquareMatrixBase<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(n, <span style="color:#ae81ff">0</span>),<span style="color:#75715e">//base class的数据指针设为null
</span><span style="color:#75715e"></span>        pData(<span style="color:#66d9ef">new</span> T[n<span style="color:#f92672">*</span>n])<span style="color:#75715e">//为内容分配内存，将指向该内存的指针存储起来
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>setDataPtr(pData.get());<span style="color:#75715e">//将pData的一个副本交给base class
</span><span style="color:#75715e"></span>    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    boost<span style="color:#f92672">::</span>scoped_array<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> pData;
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>Templates生成多个classes和多个函数,所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</li>
<li>因非类型模板参数(non-type template parameters)而造成的代码膨胀,往往可消除,做法是以函数参数或class成员变量替换template参数。</li>
<li>因类型参数(type parameters)而造成的代码膨胀,往往可降低,做法是让带有 完全相同二进制表述(binary representations)的具现类型(instantiation types)共享实现码。</li>
</ul>
<hr>
<h3 id="条款45-运用成员函数模板接受所有兼容类型">条款45: 运用成员函数模板接受所有兼容类型</h3>
<p><strong>Templates和泛型编程(Generic Programming)</strong></p>
<p>构造模版, 这样的模板(templates)是所谓member function templates (常简称为member templates) ,其作用是为class生成函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SmartPtr</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> U<span style="color:#f92672">&gt;</span>
    SmartPtr (<span style="color:#66d9ef">const</span> SmartPtr<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;&amp;</span> other);
};
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SmartPtr</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> U<span style="color:#f92672">&gt;</span>
    SmartPtr(<span style="color:#66d9ef">const</span> SmartPtr<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;&amp;</span> other) <span style="color:#f92672">:</span> heldPtr (other.get ()) {..} 
    T<span style="color:#f92672">*</span> <span style="color:#a6e22e">get</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> heldPtr; }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    T<span style="color:#f92672">*</span> heldptr;
};
</code></pre></div><p>使用成员初值列(member initialization list)来初始化SmartPtr<!-- raw HTML omitted -->之内类型为T*的成员变量,并以类型为U*的指针(由SmartEtrU&gt;持有)作为初值。这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译,</p>
<p><strong>成员函数模版也支持赋值操作</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">shared_ptr</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">explicit</span> shared_ptr(Y<span style="color:#f92672">*</span> p);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    shared_ptr(shared_ptr<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> r);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">explicit</span> shared_ptr(weak_ptr<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> r);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">explicit</span> shared_ptr(auto_ptr<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;&amp;</span> r);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    shared_ptr<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(shared_ptr<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> r); 
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    shared_ptr<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">-</span>(auto_ptr<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;&amp;</span> r);
};
</code></pre></div><p>上述所有构造函数都是explicit,惟有“泛化copy构造函数&quot;除外。那意味从某个sharedptr类型隐式转换至另一个sharedptr类型是被允许的,但从某个内置指针或从其他智能指针类型进行隐式转换则不被认可(如果是显式转换如cast强制转型动作倒是可以)。</p>
<p>member templates并不改变语言规则,而语言规则说,如果程序需要一个copy构造函数,你却没有声明它,编译器会为你暗自生成一个。在class内声明泛化copy构造函数(是个member template)并不会阻止编译器生成它们自己的copy构造函数(一个non-template)</p>
<p><strong>所以如果你想要控制copy构造的方方面面,你必须同时声明泛化copy构造函数和“正常的” copy构造函数。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">shared</span> ptr {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    shared_ptr(shared_ptr <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> r);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    shared_ptr(shared_ptr<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> r);
    shared_ptr<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(shared_ptr <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> r);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span><span style="color:#f92672">&gt;</span>
    shared_ptr<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span> (shared_ptr<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> r);
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>请使用member function templates (成员函数模板)生成“可接受所有兼容类型”的函数。</li>
<li>如果你声明member templates用于“泛化copy构造&quot;或“泛化assignment操作&rdquo;,你还是需要声明正常的copy构造函数和copy assignment操作符。</li>
</ul>
<hr>
<h3 id="条款46需要类型转换时请为模板定义非成员函数">条款46:需要类型转换时请为模板定义非成员函数</h3>
<p>条款24的模版化</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> <span style="color:#960050;background-color:#1e0010">т</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Rational (<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> numerator <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> denominator <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">const</span> T <span style="color:#a6e22e">numerator</span>() <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">const</span> T <span style="color:#a6e22e">denominator</span>() <span style="color:#66d9ef">const</span>;
    ...
};
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>hs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> rhs)
{ ... }
</code></pre></div><p><code>Rational&lt;int&gt; oneHalf(1, 2);</code></p>
<p><code>Rational&lt;int&gt; result = oneHalf * 2;</code></p>
<ul>
<li>在template实参推导过程中从不将隐式类型转换函数纳入考虑。</li>
</ul>
<p>方法一: template class内的friend声明式可以指涉某个特定函数。那意味class Rational<!-- raw HTML omitted -->可以声明operator*是它的一个friend函数。令Rational<!-- raw HTML omitted --> class声明适当的operator*为其friend函数,可简化整个问题</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span> { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ...
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">const</span> Rational <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span> (<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>hs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&amp;</span> rhs);
};
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span> (<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> lhs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> rhs)
{ ... }
</code></pre></div><p>当对象oneHalf被声 明为一个Rational<!-- raw HTML omitted -->, class Rational<!-- raw HTML omitted -->于是被具现化出来,而作为过程的 一部分, friend函数operator*(接受Rational<!-- raw HTML omitted -->参数)也就被自动声明出来。后者身为一个函数而非函数模板(function template) ,因此编译器可在调用它时使用隐式转换函数(例如Rational的non-explicit构造函数)</p>
<p><strong>混合式代码通过了编译,因为编译器知道我们要调用哪个函数(就是接受一个Rationalkint&gt;以及又一个Rationalkint&gt;的那个operator * ) ,但那个函数只被声明于Rational内,并没有被定义出来。</strong></p>
<p><strong>方法二: 将operator * 函数本体合并至其声明式内:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ...
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">const</span> Rational <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>hs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&amp;</span> rhs) {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rational</span>(lhs.numerator() <span style="color:#f92672">*</span> rhs.numerator(), 
                lhs.denominator() <span style="color:#f92672">*</span> rhs.denominator())
    }
};
</code></pre></div><p>&ldquo;Rational是个template&quot;这一事实意味上述的辅助函数通常也是个template, 所以定义了Rational的头文件代码,很典型地长这个样子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span>; <span style="color:#75715e">//声明Rational template
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> doMultiply(<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> <span style="color:#ae81ff">1</span>hs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> rhs);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>typenane T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span> (
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> lhs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> rhs) { 
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">doMultiply</span>(lhs, rhs); 
    }
}<span style="color:#960050;background-color:#1e0010">；</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> doMultiply (<span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> lhs, <span style="color:#66d9ef">const</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> rhs) {
     <span style="color:#66d9ef">return</span> Rational<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> (lhs.numerator() <span style="color:#f92672">*</span> rhs.numerator(), 
                    lhs.denominator() <span style="color:#f92672">*</span> rhs.denominator());
}
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>当我们编写一个class template,而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时,请将那些函数定义为&quot;class template内部 的friend函数”</li>
</ul>
<hr>
<h3 id="条款47-请使用traits-classes表现类型信息">条款47: 请使用traits classes表现类型信息</h3>
<p><strong>STL迭代器分类(categories)</strong></p>
<ul>
<li>
<p>input选代器
只能向前移动,一次一步,客户只可读取(不能涂写)它们所指的东西,而且只能读取一次。</p>
</li>
<li>
<p>Output迭代器
一切只为输出:它们只向前移动,一次一步,客户只可涂写它们所指的东西,而且只能涂写一次。</p>
</li>
<li>
<p>forward迭代器。
这种迭代器可以做前述两种分类所能做的每一件事,而且可以读或写其所指物一次以上。这使得它们可施行于多次性操作算法(multi-pass algorithms) 。</p>
</li>
<li>
<p>Bidirectional迭代器
比上一个分类威力更大: 它除了可以向前移动,还可以向后移动。</p>
</li>
<li>
<p>random access选代器
这种迭代器比上一个分类威力更大的地方在于它可以执行“迭代器算术”,也就是它可以在常量时间内向前或向后跳跃任意距离。</p>
</li>
</ul>
<p><strong>针对这五种分类,C++标准库分别提供专属的&quot;卷标结构&rdquo;(tag struct)加以区分:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">input_iterator_tag</span>{};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">output_iterator_tag</span>{};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">forward_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> input_iterator_tag{};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">bidirectional_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> forward_iterator_tag{};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">random_access_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> bidirectional_iterator_tag{};
</code></pre></div><p><strong>traits允许我们在编译期得到类型的信息。traits并非一个关键字，而是一个编程惯例。</strong></p>
<p>traits的另一个需求在于advance对与基本数据类型也能正常工作，比如char*。所以traits不能借助类来实现， 于是我们把traits放到模板中。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT<span style="color:#f92672">&gt;</span>          <span style="color:#75715e">// template for information about
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iterator_traits</span>;           <span style="color:#75715e">// iterator types
</span></code></pre></div><p>terator_traits&lt; IterT&gt;将会标识IterT的迭代器类别。iterator_traits的实现包括两部分：</p>
<ul>
<li>用户定义类型的迭代器</li>
<li>基本数据类型的指针</li>
</ul>
<p><strong>用户类型的迭代器</strong></p>
<p>在用户定义的类型中，typedef该类型支持迭代器的Tag</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> ... <span style="color:#f92672">&gt;</span> <span style="color:#75715e">// template params elided
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">deque</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">iterator</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">typedef</span> random_access_iterator_tag iterator_category;
  }<span style="color:#f92672">:</span>
};
</code></pre></div><p>在全局的iterator_traits模板中typedef那个用户类型中的Tag，以提供全局和统一的类型识别。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iterator_traits</span> {
  <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">typename</span> IterT<span style="color:#f92672">::</span>iterator_category iterator_category;
};
</code></pre></div><p><strong>基本数据类型的指针</strong></p>
<p>为了支持指针迭代器, iterator-traits特别针对指针类型提供一个偏特化版本(partial template specialization) 。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iterator</span> traits<span style="color:#f92672">&lt;</span>IterT<span style="color:#f92672">*&gt;</span>
{
    <span style="color:#66d9ef">typedef</span> random access iterator tag iterator category;
    ...
};
</code></pre></div><p><strong>如何设计并实现一个traits class</strong></p>
<ul>
<li>确认若干你希望将来可取得的类型相关信息。例如对迭代器而言,我们希望将 来可取得其分类(category) 。</li>
<li>为该信息选择一个名称(例如iterator_category) 。</li>
<li>提供一个template和一组特化版本(例如稍早说的iterator-traits) ,内含你希望支持的类型相关信息。</li>
</ul>
<p><strong>advance的实现</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT, <span style="color:#66d9ef">typename</span> DistT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> advance(IterT<span style="color:#f92672">&amp;</span> iter, DistT d) {
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeid</span>(<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator_traits<span style="color:#f92672">&lt;</span>IterT<span style="color:#f92672">&gt;::</span>iterator_category) <span style="color:#f92672">==</span>
        <span style="color:#66d9ef">typeid</span>(std<span style="color:#f92672">::</span>random_access_iterator_tag))
  ...
}
</code></pre></div><p>上述实现其实并不完美，至少if语句中的条件在编译时就已经决定，它的判断却推迟到了运行时（显然是低效的）。 在编译时作此判断，需要为不同的iterator提供不同的方法，然后在advance里调用它们。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT, <span style="color:#66d9ef">typename</span> DistT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> advance(IterT<span style="color:#f92672">&amp;</span> iter, DistT d) {
  doAdvance(                                              <span style="color:#75715e">// call the version
</span><span style="color:#75715e"></span>    iter, d,                                              <span style="color:#75715e">// of doAdvance
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator_traits<span style="color:#f92672">&lt;</span>IterT<span style="color:#f92672">&gt;::</span>iterator_category()
  );
}

<span style="color:#75715e">// 随机访问迭代器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT, <span style="color:#66d9ef">typename</span> DistT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> doAdvance(IterT<span style="color:#f92672">&amp;</span> iter, DistT d, std<span style="color:#f92672">::</span>random_access_iterator_tag) {
  iter <span style="color:#f92672">+=</span> d;
}

<span style="color:#75715e">// 双向迭代器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT, <span style="color:#66d9ef">typename</span> DistT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> doAdvance(IterT<span style="color:#f92672">&amp;</span> iter, DistT d, std<span style="color:#f92672">::</span>bidirectional_iterator_tag) {
  <span style="color:#66d9ef">if</span> (d <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) { <span style="color:#66d9ef">while</span> (d<span style="color:#f92672">--</span>) <span style="color:#f92672">++</span>iter; }
  <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">while</span> (d<span style="color:#f92672">++</span>) <span style="color:#f92672">--</span>iter; }
}

<span style="color:#75715e">// 输入迭代器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT, <span style="color:#66d9ef">typename</span> DistT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> doAdvance(IterT<span style="color:#f92672">&amp;</span> iter, DistT d, std<span style="color:#f92672">::</span>input_iterator_tag) {
  <span style="color:#66d9ef">if</span> (d <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> ) {
     <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>out_of_range(<span style="color:#e6db74">&#34;Negative distance&#34;</span>);    <span style="color:#75715e">// see below
</span><span style="color:#75715e"></span>  }
  <span style="color:#66d9ef">while</span> (d<span style="color:#f92672">--</span>) <span style="color:#f92672">++</span>iter;
}
</code></pre></div><p><strong>总结如何使用一个traits class</strong></p>
<ul>
<li>建立一组重载函数(身份像劳工)或函数模板(例如doAdvance) ,彼此间的差异只在于各自的traits参数。令每个函数实现码与其接受之traits信息相应和。</li>
<li>建立一个控制函数(身份像工头)或函数模板(例如advance) ,它调用上述那些“劳工函数”并传递traits class所提供的信息。</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和&quot;templates特化”完成实现。</li>
<li>整合重载技术(overloading)后, traits classes有可能在编译期对类型执行 if.else测试。</li>
</ul>
<hr>
<h3 id="条款48-认识template元编程">条款48: 认识template元编程</h3>
<p><strong>Template metaprogramming (TMP,模板元编程)是编写template-based C++程序并执行于编译期的过程。</strong></p>
<p>**使用TMP有两个好处: **</p>
<ul>
<li>第一,它让某些事情更容易。如果没有它,那些事情 将是困难的,甚至不可能的。</li>
<li>第二,由于template metaprograms执行于C++编译期,因此可将工作从运行期转移到编译期。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> IterT, <span style="color:#66d9ef">typename</span> DistT<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> advance(IterT<span style="color:#f92672">&amp;</span> iter, DistT d) {
  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeid</span>(<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator_traits<span style="color:#f92672">&lt;</span>IterT<span style="color:#f92672">&gt;::</span>iterator_category) <span style="color:#f92672">==</span>
    <span style="color:#66d9ef">typeid</span>(std<span style="color:#f92672">::</span>random_access_iterator_tag)){
        iter <span style="color:#f92672">+=</span> d;
  }
  ...
}

list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it;
advance(it, <span style="color:#ae81ff">10</span>);
</code></pre></div><p>其实上述代码是不能编译的，设想以下advance&lt;list<!-- raw HTML omitted -->::iterator, int&gt;中的这条语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">iter <span style="color:#f92672">+=</span> d;
</code></pre></div><p><code>list&lt;int&gt;::iterator</code>是双向迭代器，不支持+=运算。虽然上述语句不会执行，但编译器不知道这一点。 编译时这条语句仍然会抛出类型错误。</p>
<p><strong>TMP已被证明是个“图灵完全”(Turing-complete)机器</strong></p>
<p>TMP主要是个“函数式语言” (functional language), TMP的递归甚至不是正常种类,因为TMP循环并不涉及递归函数调用,而是涉及“递归模板具现化”(recursive template instantiation) 。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> n<span style="color:#f92672">&gt;</span> 
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Factorial</span> {
    <span style="color:#66d9ef">enum</span> { value <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> Factorial<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;::</span>value };
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Factorial</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span> { <span style="color:#75715e">//Factorial&lt;0&gt; 值为1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">enum</span>{ value<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> };
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> Factorial<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span><span style="color:#f92672">&gt;::</span>value; <span style="color:#75715e">//印出120
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> Factorial<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span><span style="color:#f92672">&gt;::</span>value; <span style="color:#75715e">//印出3628800
</span><span style="color:#75715e"></span>}
</code></pre></div><p>为了更好地理解TMP的重要性，我们来看看TMP能干什么：</p>
<ul>
<li>确保量纲正确。在科学计算中，量纲的结合要始终保持正确。比如一定要单位为”m”的变量和单位为”s”的变量相除才能得到一个速度变量（其单位为”m/s”）。 使用TMP时，编译器可以保证这一点。因为不同的量纲在TMP中会被映射为不同的类型。</li>
<li>优化矩阵运算。比如矩阵连乘问题，TMP中有一项表达式模板（expression template）的技术，可以在编译期去除临时变量和合并循环。 可以做到更好的运行时效率。</li>
<li>自定义设计模式的实现。设计模式往往有多种实现方式，而一项叫基于策略设计（policy-based design）的TMP技术可以帮你创建独立的设计策略（design choices），而这些设计策略可以以任意方式组合。生成无数的设计模式实现方式。</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>Template metaprogramming (TMP,模板元编程)可将工作由运行期移往编译期,因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP可被用来生成“基于政策选择组合&rdquo; (based on combinations of policychoices)的客户定制代码,也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
<hr>
<p>了解C++内存管理例程的行为。这场游戏的两个主角是分配例程和归还例程(allocation and deallocation routines,也就是operator new和operator delete), 配角是new-handler, 这是当operator new无法满足客户的内存需求时所调用的函数。</p>
<p>operator new和operator delete只适合用来分配单一对 象。Arrays所用的内存由operator new1]分配出来,并由operator delete[]归还(注意两个函数名称中的[])</p>
<h3 id="条款49-了解new-handler的行为">条款49: 了解new-handler的行为</h3>
<p><strong><a href="https://github.com/6923403/CPP_Demo/blob/master/test/new_handler.cpp">new_handler函数运行代码</a></strong></p>
<p>当operator new抛出异常以反映一个未获满足的内存需求之前,它会先调用个客户指定的错误处理函数,一个所谓的new-handler。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> std {
    <span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">new</span> handler) (); 
    new_handler <span style="color:#a6e22e">set_new_handler</span>(new_handler p) <span style="color:#66d9ef">throw</span>();
}
</code></pre></div><p>//以下是当operator new无法分配足够内存时, 该被调用的函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outOfMem</span>(){
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Unable to alloc memory&#34;</span>;
    std<span style="color:#f92672">::</span>abort();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    std<span style="color:#f92672">::</span>set_new_handler(outOfMem);
    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">100000000L</span>];
}
</code></pre></div><p><strong>当operator new无法满足内存申请时,它会不断调用new-handler函数,直到找到足够内存。</strong></p>
<p>一个设计良好的new-handler函数必须做以下事情:</p>
<ul>
<li>使更多内存可用；</li>
<li>安装一个新的”new-handler”；</li>
<li>卸载当前”new-handler”，传递null给set_new_handler即可；</li>
<li>抛出bad_alloc（或它的子类）异常；</li>
<li>不返回，可以abort或者exit。</li>
</ul>
<p>std::set_new_handler设置的是全局的bad_alloc的错误处理函数，C++并未提供类型相关的bad_alloc异常处理机制。 但我们可以重载类的operator new，当创建对象时暂时设置全局的错误处理函数，结束后再恢复全局的错误处理函数。</p>
<p>比如Widget类，首先需要声明自己的set_new_handler和operator new：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>new_handler set_new_handler(std<span style="color:#f92672">::</span>new_handler p) <span style="color:#66d9ef">throw</span>();
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc);
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>new_handler current;
};

<span style="color:#75715e">// 静态成员需要定义在类的外面
</span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>new_handler Widget<span style="color:#f92672">::</span>current <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
std<span style="color:#f92672">::</span>new_handler Widget<span style="color:#f92672">::</span>set_new_handler(std<span style="color:#f92672">::</span>new_handler p) <span style="color:#66d9ef">throw</span>(){
    std<span style="color:#f92672">::</span>new_handler old <span style="color:#f92672">=</span> current;
    current <span style="color:#f92672">=</span> p;
    <span style="color:#66d9ef">return</span> old;
}
</code></pre></div><p>关于abort, exit, terminate的区别：abort会设置程序非正常退出，exit会设置程序正常退出，当存在未处理异常时C++会调用terminate， 它会回调由std::set_terminate设置的处理函数，默认会调用abort。</p>
<p>最后来实现operator new，该函数的工作分为三个步骤：</p>
<ul>
<li>调用std::set_new_handler，把Widget::current设置为全局的错误处理函数；</li>
<li>调用全局的operator new来分配真正的内存；</li>
<li>如果分配内存失败，Widget::current将会抛出异常；</li>
<li>不管成功与否，都卸载Widget::current，并安装调用Widget::operator new之前的全局错误处理函数。</li>
</ul>
<p>我们通过RAII类来保证原有的全局错误处理函数能够恢复，让异常继续传播。关于RAII可以参见Item 13。 先来编写一个保持错误处理函数的RAII类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewHandlerHolder</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">explicit</span> NewHandlerHolder(std<span style="color:#f92672">::</span>new_handler nh)<span style="color:#f92672">:</span> handler(nh){}
    <span style="color:#f92672">~</span>NewHandlerHolder(){ std<span style="color:#f92672">::</span>set_new_handler(handler); }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    std<span style="color:#f92672">::</span>new_handler handler;
    NewHandlerHolder(<span style="color:#66d9ef">const</span> HandlerHolder<span style="color:#f92672">&amp;</span>);     <span style="color:#75715e">// 禁用拷贝构造函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> NewHandlerHolder<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> NewHandlerHolder<span style="color:#f92672">&amp;</span>); <span style="color:#75715e">// 禁用赋值运算符
</span><span style="color:#75715e"></span>};
</code></pre></div><p>Widget::operator new的实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> Widget<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc){
    NewHandlerHolder <span style="color:#a6e22e">h</span>(std<span style="color:#f92672">::</span>set_new_handler(current));
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size);    <span style="color:#75715e">// 调用全局的new，抛出异常或者成功
</span><span style="color:#75715e"></span>}   <span style="color:#75715e">// 函数调用结束，原有错误处理函数恢复
</span></code></pre></div><p><strong>客户使用Widget的方式也符合基本数据类型的惯例：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outOfMem</span>();
Widget<span style="color:#f92672">::</span>set_new_handler(outOfMem);

Widget <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Widget;    <span style="color:#75715e">// 如果失败，将会调用outOfMem
</span><span style="color:#75715e"></span>string <span style="color:#f92672">*</span>ps <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> string;    <span style="color:#75715e">// 如果失败，将会调用全局的 new-handling function，当然如果没有的话就没有了
</span><span style="color:#75715e"></span>Widget<span style="color:#f92672">::</span>set_new_handler(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 把Widget的异常处理函数设为空
</span><span style="color:#75715e"></span>Widget <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Widget;    <span style="color:#75715e">// 如果失败，立即抛出异常
</span></code></pre></div><p>仔细观察上面的代码，很容易发现自定义”new-handler”的逻辑其实和Widget是无关的。我们可以把这些逻辑抽取出来作为一个模板基类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewHandlerSupport</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>new_handler set_new_handler(std<span style="color:#f92672">::</span>new_handler p) <span style="color:#66d9ef">throw</span>();
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc);
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>new_handler current;
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
std<span style="color:#f92672">::</span>new_handler NewHandlerSupport<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>current <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
std<span style="color:#f92672">::</span>new_handler NewHandlerSupport<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>set_new_handler(std<span style="color:#f92672">::</span>new_handler p) <span style="color:#66d9ef">throw</span>(){
    std<span style="color:#f92672">::</span>new_handler old <span style="color:#f92672">=</span> current;
    current <span style="color:#f92672">=</span> p;
    <span style="color:#66d9ef">return</span> old;
}

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> NewHandlerSupport<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc){
    NewHandlerHolder <span style="color:#a6e22e">h</span>(std<span style="color:#f92672">::</span>set_new_handler(current));
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size);
}
</code></pre></div><p>有了这个class template,为widget添加set-new-handler支持能力就轻而易举了:</p>
<p>只要令widget继承自<code>NewHandlerSupport&lt;widget&gt;</code>就好</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> NewHandlerSupport<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span> { 
    ... 
    <span style="color:#75715e">//和先前一样但不必声明set_new_handler或operator new
</span><span style="color:#75715e"></span>};
</code></pre></div><p><strong>operator new则应该抛出bad alloc异常</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">widget</span>{ ....};
widget<span style="color:#f92672">*</span> pw1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> widget; <span style="color:#75715e">//分配失败 抛出bad_alloc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (pw1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) ... <span style="color:#75715e">//一定失败
</span><span style="color:#75715e"></span>widget<span style="color:#f92672">*</span> pw2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> (std<span style="color:#f92672">::</span>nothrow) widget; <span style="color:#75715e">//分配失败返回0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (pw2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) ... <span style="color:#75715e">//可能成功
</span></code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>set-new_handler允许客户指定一个函数,在内存分配无法获得满足时被调用。</li>
<li>Nothrow new是一个颇为局限的工具,因为它只适用于内存分配;后继的构造函数调用还是可能抛出异常。</li>
</ul>
<hr>
<h3 id="条款50-了解new和delete的合理替换时机">条款50: 了解new和delete的合理替换时机</h3>
<p><strong>替换编译器提供的operator new或operator delete理由:</strong></p>
<ul>
<li>检测使用错误。new得到的内存如果没有delete会导致内存泄露，而多次delete又会引发未定义行为。如果自定义operator new来保存动态内存的地址列表，在delete中判断内存是否完整，便可以识别使用错误，避免程序崩溃的同时还可以记录这些错误使用的日志。</li>
<li>提高效率。全局的new和delete被设计为通用目的（general purpose）的使用方式，通过提供自定义的new，我们可以手动维护更适合应用场景的存储策略。</li>
<li>收集使用信息。在继续自定义new之前，你可能需要先自定义一个new来收集地址分配信息，比如动态内存块大小是怎样分布的？分配和回收是先进先出FIFO还是后进先出LIFO？</li>
<li>实现非常规的行为。比如考虑到安全，operator new把新申请的内存全部初始化为0.</li>
<li>其他原因，比如抵消平台相关的字节对齐，将相关的对象放在一起等等。</li>
</ul>
<p><strong>定制型operator new</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> signature <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xDEADBEEF</span>;    <span style="color:#75715e">// 边界符
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> Byte;

<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc) {
    <span style="color:#75715e">// 多申请一些内存来存放占位符
</span><span style="color:#75715e"></span>    size_t realSize <span style="color:#f92672">=</span> size <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);

    <span style="color:#75715e">// 申请内存
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pMem <span style="color:#f92672">=</span> malloc(realSize);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pMem) <span style="color:#66d9ef">throw</span> bad_alloc();

    <span style="color:#75715e">// 写入边界符
</span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Byte<span style="color:#f92672">*&gt;</span>(pMem)<span style="color:#f92672">+</span>realSize<span style="color:#f92672">-</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)))
        <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span>(pMem)) <span style="color:#f92672">=</span> signature;

    <span style="color:#75715e">// 返回真正的内存区域
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Byte<span style="color:#f92672">*&gt;</span>(pMem) <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);
}
</code></pre></div><p>这个operator new的缺点主要在于它疏忽了身为这个特殊函数所应该具备的“坚持C++规矩”的态度。</p>
<p><strong>所有operator news都应该内含一个循环,反复调用某个new-handling函数。</strong></p>
<p><strong>齐位(alignment)意义重大,因为C++要求所有operator news返回的指针都有适当的对齐(取决于数据类型)。</strong></p>
<p><strong>本条款的主题是,了解何时可在“全局性的”或&quot;class专属的”基础上合理替换缺省的new和delete:</strong></p>
<ul>
<li>为了检测运用错误</li>
<li>为了收集动态分配内存之使用统计信息</li>
<li>为了增加分配和归还的速度。</li>
<li>为了降低缺省内存管理器带来的空间额外开销。</li>
<li>为了弥补缺省分配器中的非最佳齐位(suboptimal alignment)。</li>
<li>为了将相关对象成簇集中。</li>
<li>为了获得非传统的行为。</li>
</ul>
<p><strong>本文要点</strong></p>
<ul>
<li>有许多理由需要写个自定的new和delete,包括改善效能、对heap运用错误进行调试、收集heap使用信息。</li>
</ul>
<hr>
<h3 id="条款51-编写new和delete时需固守常规">条款51: 编写new和delete时需固守常规</h3>
<p>实现一致性operator new必得返回正确的值,内存不足时必得调用new-handling函数 ,必须有对付零内存需求的准备,还需避免不慎掩盖正常形式的new。</p>
<p>operator new的返回值十分单纯。如果它有能力供应客户申请的内存,就返回一个指针指向那块内存。如果没有那个能力,就遵循条款49描述的规则,并抛出一个badalloc异常。然而其实也不是非常单纯,因为operatornew实际上不只一次尝试分配内存,并在每次失败后调用new-handling函数。</p>
<p>奇怪的是C++规定,即使客户要求0bytes, operator new也得返回一个合法指针。</p>
<p><strong>non-member operator new</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc) {
    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std; <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) {
    size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">while</span> (true) { 
        <span style="color:#960050;background-color:#1e0010">尝试分配</span>size bytes;
        <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">分配成功</span>)
        <span style="color:#66d9ef">return</span> (<span style="color:#960050;background-color:#1e0010">一个指针</span>,<span style="color:#960050;background-color:#1e0010">指向分配得来的内存</span>);
        <span style="color:#75715e">//分配失败;找出目前的new-handling函数(见下)
</span><span style="color:#75715e"></span>        new_handler globalHandler <span style="color:#f92672">=</span> set_new_handler(<span style="color:#ae81ff">0</span>);
        set_new_handler(globalHandler);
        <span style="color:#66d9ef">if</span> (globalHandler) 
            (<span style="color:#f92672">*</span>globalHandler)();
        <span style="color:#66d9ef">else</span> 
            <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>bad_alloc();
    }
}
</code></pre></div><ul>
<li>size == 0时申请大小为1看起来不太合适，但它非常简单而且能正常工作。况且你不会经常申请大小为0的空间吧？</li>
<li>两次set_new_handler调用先把全局”new handler”设置为空再设置回来，这是因为无法直接获取”new handler”，多线程环境下这里一定需要锁。</li>
<li>while(true)意味着这可能是一个死循环。所以Item 49提到，”new handler”要么释放更多内存、要么安装一个新的”new handler”，如果你实现了一个无用的”new handler”这里就是死循环了。</li>
</ul>
<p>谈到operator new内含一个无穷循环,而上述伪码明白表明出这个循环: &ldquo;while (true)&ldquo;就是那个无穷循环。</p>
<p>退出此循环的唯一办法是:内存被成功分配或new-handling函数做了一件描述于条款49的事情:让更多内存可用、安装 另一个new-hander、卸除new-handler、抛出badalloc异常(或其派生物) ,或是承认失败而直接return。</p>
<p>重载operator new为成员函数通常是为了对某个特定的类进行动态内存管理的优化，而不是用来给它的子类用的。 因为在实现Base::operator new()时，是基于对象大小为sizeof(Base)来进行内存管理优化的。</p>
<p>当然，有些情况你写的Base::operator new是通用于整个class及其子类的，这时这一条规则不适用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc);
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base{...};
Derived <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived; <span style="color:#75715e">//调用了Base::operator new
</span></code></pre></div><p>子类继承Base::operator new()之后，因为当前对象不再是假设的大小，该方法不再适合管理当前对象的内存了。
处理此情势的最佳做法是将“内存申请量错误”的调用行为改采标准operator new</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>Base<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc){
    <span style="color:#66d9ef">if</span>(size <span style="color:#f92672">!=</span> <span style="color:#66d9ef">sizeof</span>(Base)) <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size);
    ...
}
</code></pre></div><p>上面的代码没有检查size == 0！这是C++神奇的地方，大小为0的独立对象会被插入一个char（见Item 39）。 所以sizeof(Base)永远不会是0，所以size == 0的情况交给::operator new(size)去处理了。</p>
<p>这里提一下operator new[]，它和operator new具有同样的参数和返回值， 要注意的是你不要假设其中有几个对象，以及每个对象的大小是多少，所以不要操作这些还不存在的对象。因为：</p>
<ul>
<li>你不知道对象大小是什么。上面也提到了当继承发生时size不一定等于sizeof(Base)。</li>
<li>size实参的值可能大于这些对象的大小之和。因为Item 16中提到，数组的大小可能也需要存储。</li>
</ul>
<p><strong>operatore delete</strong></p>
<p><strong>C++保证“删除null指针永远安全”</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>rawMem) <span style="color:#66d9ef">throw</span>(){
    <span style="color:#66d9ef">if</span>(rawMem <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;
    <span style="color:#75715e">// 释放内存
</span><span style="color:#75715e"></span>}
</code></pre></div><p>万一你的class专属的operator new将大小有误的分配行为转交::operator new执行,你也必须将大小有误的删除行为转交::operator delete执行:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc);
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>rawMem, std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>();
};
<span style="color:#66d9ef">void</span> Base<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>rawMem, std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(){
    <span style="color:#66d9ef">if</span>(rawMem <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;     <span style="color:#75715e">// 检查空指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(size <span style="color:#f92672">!=</span> <span style="color:#66d9ef">sizeof</span>(Base)){
        <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(rawMem);
    }
    <span style="color:#75715e">// 释放内存
</span><span style="color:#75715e"></span>}
</code></pre></div><p>如果即将被删除的对象派生自某个base class而后者欠缺virtual析 构函数,那么C++传给operatordelete的sizet数值可能不正确。</p>
<p><strong>本文要点</strong></p>
<ul>
<li>operator new应该内含一个无穷循环,并在其中尝试分配内存,如果它无法满足内存需求,就该调用new_handler,它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。</li>
<li>operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。</li>
</ul>
<hr>
<h3 id="条款52-写了placement-new也要写placement-delete">条款52: 写了placement new也要写placement delete</h3>
<p>“placement new”通常是专指指定了位置的new(std::size_t size, void *mem)，用于vector申请capacity剩余的可用内存。 但广义的”placement new”指的是拥有额外参数的operator new。</p>
<p>new和delete是要成对的，因为当构造函数抛出异常时用户无法得到对象指针，因而delete的责任在于C++运行时。 运行时需要找到匹配的delete并进行调用。因此当我们编写了”placement new”时，也应当编写对应的”placement delete”， 否则会引起内存泄露。在编写自定义new和delete时，还要避免不小心隐藏它们的正常版本。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">widget</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">//非正常形式的new
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size t size, std: <span style="color:#f92672">:</span>ostream<span style="color:#f92672">&amp;</span> logStream) <span style="color:#66d9ef">throw</span> (std<span style="color:#f92672">::</span>bad alloc);

    <span style="color:#75715e">//正常的class专属delete
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pMemory std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>();
};
</code></pre></div><p>如果operatornew接受的参数除了一定会有的那个sizet之外还有其他,这 便是个所谓的placement new。因此,上述的operator new是个placement版本。众多placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pMemory) <span style="color:#66d9ef">throw</span>();
</code></pre></div><p><strong>那个class将引起微妙的内存泄漏</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">widget<span style="color:#f92672">*</span> pw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> (std<span style="color:#f92672">::</span>cerr)widget;
</code></pre></div><p>如果内存分配成功,而widget构造函数抛出异常,运行期系统有责任取消operator new的分配并恢复旧观。然而运行期系统无法知道真正被调用的那个operator new如何运作,因此它无法取消分配并恢复旧观,所以上述做法行不通。</p>
<p><strong>运行期系统寻找“参数个数和类型都与operator new相同”的某个operator delete。如果找到,那就是它的调用对象。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">throw</span>();
</code></pre></div><p>如果一个带额外参数的operator new没有“带相同额外参数”的对应版operator delete,那么当new的内存分配动作需要取消并恢复旧观时就没有任何operator delete会被调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">widget</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size t size, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> logstream) <span style="color:#66d9ef">throw</span> (std<span style="color:#f92672">::</span>bad alloc);
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pMemory) <span style="color:#66d9ef">throw</span>();
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pMemory, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> logstream) <span style="color:#66d9ef">throw</span>();
};
</code></pre></div><p>placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针(例如上述的pw)施行delete绝不会导致调用 placement delete, 这意味着避免内存泄漏我们需要一个正常的operatordelete(用于构造期间无任何异常被抛出)和一个placement版本(用于构造期间有异常被抛出)。后者的额外参数必须和operator new一样。</p>
<p>由于成员函数的名称会掩盖其外围作用域中的相同名称(见条款33),你必须小心避免让class专属的news掩盖客户期望的其他news (包括正常版 本) 。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size t size, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> logStream) 
        <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad alloc);
};

Base<span style="color:#f92672">*</span> pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Base; <span style="color:#75715e">//错误!因为正常形式的operator new被掩盖.
</span><span style="color:#75715e"></span>Base<span style="color:#f92672">*</span> pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> (std<span style="color:#f92672">::</span>cerr) Base; <span style="color:#75715e">//正确,调用Base的placement new.
</span></code></pre></div><p>为了避免全局的”new”被隐藏，先来了解一下C++提供的三种全局”new”：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc); <span style="color:#75715e">//normal new
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) <span style="color:#66d9ef">throw</span>(); <span style="color:#75715e">//placement new
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>nothrow_t<span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">throw</span>(); <span style="color:#75715e">//见Item 49
</span></code></pre></div><p>对于每一个可用的operator new也请确定提供对应的operator delete。如果你希望这些函数有着平常的行为,只要令你的class专属版本调用global版本即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StandardNewDeleteForms</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#75715e">// normal new/delete
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(std<span style="color:#f92672">::</span>size_t size) <span style="color:#66d9ef">throw</span>(std<span style="color:#f92672">::</span>bad_alloc) { <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size); }
  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pMemory) <span style="color:#66d9ef">throw</span>() { <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(pMemory); }

  <span style="color:#75715e">// placement new/delete
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t size, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr) <span style="color:#66d9ef">throw</span>() { <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size, ptr); }
  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pMemory, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr) <span style="color:#66d9ef">throw</span>() { <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(pMemory, ptr); }

  <span style="color:#75715e">// nothrow new/delete
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t size, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>nothrow_t<span style="color:#f92672">&amp;</span> nt) <span style="color:#66d9ef">throw</span>() { <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size, nt); }
  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pMemory, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>nothrow_t<span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">throw</span>() { <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(pMemory); }
};
</code></pre></div><p>凡是想以自定形式扩充标准形式的客户,可利用继承机制及using声明式, 取得标准形式:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">widget</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> StandardNewDeleteForms { 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> StandardNewDeleteForms<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>; 
    <span style="color:#66d9ef">using</span> standardNewDeleteForms<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>;
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size t size std: <span style="color:#f92672">:</span>ostrean<span style="color:#f92672">&amp;</span> logSt.ream) <span style="color:#66d9ef">throw</span> (std<span style="color:#f92672">::</span>bad alloc);
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pMemory, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> logstream) <span style="color:#66d9ef">throw</span>();
    ...
};
</code></pre></div><p><strong>本文要点</strong></p>
<ul>
<li>当你写一个placement operator new,请确定也写出了对应的placementoperator delete。如果没有这样做,你的程序可能会发生隐微而时断时续的内存泄漏。</li>
<li>当你声明placement new和placement delete,请确定不要无意识(非故意)地遮掩了它们的正常版本。</li>
</ul>
<hr>
<h3 id="条款53-不要轻忽编译器的警告">条款53: 不要轻忽编译器的警告</h3>
<p>编译警告在C++中很重要，因为它可能是个错误啊！ 不要随便忽略那些警告，因为编译器的作者比你更清楚那些代码在干什么。 所以，</p>
<ul>
<li>请严肃对待所有warning，要追求最高warning级别的warning-free代码；</li>
<li>但不要依赖于warning，可能换个编译器有些warning就不在了。</li>
</ul>
<p><strong>一个常见错误</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> f() <span style="color:#66d9ef">const</span>;
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> B{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> f();
};
</code></pre></div><p>这里希望以D::f重新定义virtual函数B::,但其中有个错误: B中的f是个const成员函数,而在D中它未被声明为const。我手上的一个编译器于是这样说
话了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">warning: D<span style="color:#f92672">::</span>f() hides <span style="color:#66d9ef">virtual</span> B<span style="color:#f92672">::</span>f()
</code></pre></div><p>这个编译器试图告诉你声明于B中的f并未在D中被重新声明, 而是被整个遮掩了。</p>
<p><strong>本文要点</strong></p>
<ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高(最严苛)警告级别下争取“无任何警告”的荣誉。</li>
<li>不要过度倚赖编译器的报警能力,因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上,你原本倚赖的警告信息有可能消失。</li>
</ul>
<hr>
<h3 id="条款54-让自己熟悉包括tr1在内的标准程序库">条款54: 让自己熟悉包括TR1在内的标准程序库</h3>
<p><strong>本文要点</strong></p>
<ul>
<li>C++标准程序库的主要机能由STL, iostreams、 locales组成。并包含C99标准程序库。</li>
<li>TR1添加了智能指针(例如trl::shared ptr)、一般化函数指针(tr1:: function) 、 hash-based容器、正则表达式(regular expressions)以及另外10个组件的支持。</li>
<li>TR1自身只是一份规范。为获得TR1提供的好处,你需要一份实物。一个好的 实物来源是Boost</li>
</ul>
<hr>
<h3 id="条款55-让自己熟悉boost">条款55: 让自己熟悉Boost</h3>
<p><strong>本文要点</strong></p>
<ul>
<li>Boost是一个社群,也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在CH+标准化过程中扮演深具影响力的角色。</li>
<li>Boost提供许多TR1组件实现品,以及其他许多程序库。</li>
</ul>
<hr>
<p>Re:</p>
<p><a href="https://blog.csdn.net/qq_36915078/article/details/104751688">https://blog.csdn.net/qq_36915078/article/details/104751688</a></p>
<p><a href="https://harttle.land/tags.html#Effective-C++">https://harttle.land/tags.html#Effective-C++</a></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>
<br />
<hr width = "450" color="#eeeeee" align="left">
  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/vcvc/license.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
<br />
<br />
<hr width = "450" color="#eeeeee" align="left">
</div>
  
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '21b0d923081673c4c523',
        clientSecret: 'f3b067b311054eeea1dc23fed945221e8585372f',
        repo: '6923403.github.io',
        owner: '6923403',
        admin: ['6923403'],
        id: location.pathname, 
        distractionFreeMode: false 
    });
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
            return;
        }
        gitalk.render('gitalk-container');
    })();
</script>

  <div>

    </main>
  </body>
</html>
