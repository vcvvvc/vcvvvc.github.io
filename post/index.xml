<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Vcvc Blog</title>
    <link>https://6923403.github.io/post/</link>
    <description>Recent content in Posts on Vcvc Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 28 Dec 2023 01:29:45 +0800</lastBuildDate><atom:link href="https://6923403.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Build_RGB_V0.11.0-beta</title>
      <link>https://6923403.github.io/post/build_rgbv0_11_beta/</link>
      <pubDate>Thu, 28 Dec 2023 01:29:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/build_rgbv0_11_beta/</guid>
      <description>又学习新东西了， BTC RGB协议
https://github.com/RGB-WG/rgb
Nostr平台用的Taproot-assets 协议主要用于发行和转移可替代的代币，如稳定币，而 RGB 协议是一种通用的智能合约系统，可以执行更复杂的多类别的智能合约，如 NFT、DeFi、DAO 等。
所以不打算再研究Taproot-assets了，直接进入RGB, 同时我持有$PPRGB。
首先去官网安装好rust，已经安装的升级到最新版本。 https://github.com/RGB-WG/ tag v0.10 stable sudo apt update sudo apt install -y build-essential cmake cd RGB cargo install --path . --all-features #v0.10 stable 下载 Sparrow Bitcoin Wallet
菜单栏有个重启启用测试网，然后启用测试网之后创建两个钱包，获取tpub
only key-spent only taproot wallets are supported(script type taproot) 之后去https://bitcoinfaucet.uo1.net/ 领水，用tb1q地址
openssl版本问题
sudo apt-get install pkg-config libssl-dev
Re: https://blackpaper.rgb.tech/
https://rgb.tech/install/#cmd
https://github.com/oneforalone/rgb20-usdt</description>
    </item>
    
    <item>
      <title>市场常用技术指标</title>
      <link>https://6923403.github.io/post/%E5%B8%82%E5%9C%BA%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87/</link>
      <pubDate>Fri, 24 Nov 2023 22:53:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E5%B8%82%E5%9C%BA%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87/</guid>
      <description>技术指标不可全信，但是配合Doubler使用，无需担心判断出错
Bing Ai回答
KDJ KDJ图形是一种用于分析股票或期货市场的技术指标，它由三条曲线组成：K线、D线和J线。KDJ图形可以反映市场的趋势、强弱、超买超卖和拐点等信息，从而帮助投资者判断买卖时机。下面是一些关于KDJ图形的基本知识：
KDJ图形的计算方法是利用最高价、最低价和收盘价来求出RSV值，然后用平滑移动平均法来计算K值、D值和J值。具体的公式如下¹： RSV = (收盘价 - 最近N日最低价) / (最近N日最高价 - 最近N日最低价) * 100% K = 2/3 * 前一日K + 1/3 * 当日RSV D = 2/3 * 前一日D + 1/3 * 当日K J = 3 * D - 2 * K 其中，N是一个参数，一般取9或14，表示计算RSV值时的周期长度。如果没有前一日的K值和D值，可以用50代替。
KDJ图形的取值范围是0到100，其中50是多空均衡线，80以上是超买区，20以下是超卖区。K线是快速确认线，D线是慢速主干线，J线是方向敏感线。一般来说，K线和D线的交叉是KDJ图形的主要信号，J线的变化是KDJ图形的辅助信号²。
当K线从下向上穿越D线，形成金叉，表示市场由弱转强，是买入的信号。金叉的位置越低越好，尤其是在超卖区形成的金叉，更有利于抓住市场的反弹机会³。 当K线从上向下穿越D线，形成死叉，表示市场由强转弱，是卖出的信号。死叉的位置越高越好，尤其是在超买区形成的死叉，更有利于抓住市场的回调机会³。 当J线从零轴以下突破K线和D线，表示市场的弱势逐步减弱，是买入的信号。当J线从零轴以上向下掉头，表示市场的强势逐步减弱，是卖出的信号⁴。 当J线大于100或小于0，表示市场处于极端的超买或超卖状态，可能会出现反转的机会。但是，反转的方式有两种：一种是实质性的反转，即价格发生明显的上涨或下跌；另一种是修复性的反转，即价格在高位或低位平移，使J线缓慢回归正常范围⁵。因此，不能单纯地根据J线的超买超卖来判断市场的走势，还要结合其他指标和形态来综合分析。 KDJ图形的形态运行方式有很多，其中最重要的有三种：交叉、背离和钝化。
交叉是指K线和D线的相交，可以分为单次交叉和多次交叉。单次交叉就是前面提到的金叉和死叉，是KDJ图形的基本信号。多次交叉是指K线和D线在一定的区间内反复交叉，形成一些特殊的形态，如W底、M头、头肩顶、头肩底、双顶、双底等。这些形态可以反映市场的转折点和趋势的延续，是KDJ图形的高级信号。 背离是指KDJ图形的走势方向与价格的走势方向不一致，可以分为顶背离和底背离。顶背离是指价格创出新高，而KDJ图形没有创出新高，表示上涨的动能不足，多头力量衰竭，有下跌的趋势。底背离是指价格创出新低，而KDJ图形没有创出新低，表示下跌的动能不足，空头力量衰竭，有上涨的趋势。背离是KDJ图形的重要信号，可以帮助投资者发现市场的顶部和底部。 钝化是指KDJ图形在高位或低位的变化幅度很小，而价格却在继续上涨或下跌，可以分为高位钝化和低位钝化。高位钝化是指KDJ图形在超买区域，价格继续上涨，而KDJ图形变化不明显，甚至向下。低位钝化是指KDJ图形在超卖区域，价格继续下跌，而KDJ图形变化不明显，甚至向上。钝化是KDJ图形的特殊信号，表示市场的强势或弱势难以改变，但也可能是市场即将反转的前兆。 买入信号 KDJ指标的买入信号主要有以下几种： K线和D线在低位出现金叉，即K线从下向上穿越D线，表示市场由弱转强，是买入的信号。如果金叉出现在50以下的低位，或者在超卖区间内，信号更强烈。 D线和J线进入超卖区间，即20以下，表示市场已经过度卖空，有反弹的可能，是买入的信号。如果D线从超卖区间向上突破20，或者J线从零轴以下向上突破K线和D线，信号更强烈。 K线和股价出现底背离，即股价创出新低，而K线没有创出新低，反而出现一底比一底高的上涨走势，表示市场的下跌动能减弱，有反转的可能，是买入的信号。 KDJ指标的买入时机可以根据不同的目的和风险偏好来选择，一般来说，可以分为以下几种情况： 如果想尝试买入，可以在K线和D线在低位出现金叉时，先少量建仓，或者在D线和J线进入超卖区间时，先少量建仓。这样的买入信号相对较为准确，但也有可能是假信号，所以要控制好仓位，观察后续的走势。 如果想大量买入，可以在K线和D线在低位出现金叉后，持续向上移动，突破50的多空均衡线时，积极加仓，或者在D线和J线从超卖区间向上突破20时，积极加仓。这样的买入信号相对较为强烈，说明市场的上涨动能增强，股价有持续上涨的趋势。 如果想抓住反转的机会，可以在K线和股价出现底背离时，积极买入。这样的买入信号相对较为稀有，但也很有效，说明市场的下跌力量衰竭，有上涨的趋势。 卖出信号 KDJ指标的卖出信号主要有以下几种： K线和D线在高位出现死叉，即K线从上向下穿越D线，表示市场由强转弱，是卖出的信号。如果死叉出现在50以上的高位，或者在超买区间内，信号更强烈。 D线和J线进入超买区间，即80以上，表示市场已经过度买入，有回调的可能，是卖出的信号。如果D线从超买区间向下突破80，或者J线从零轴以上向下突破K线和D线，信号更强烈。 K线和股价出现顶背离，即股价创出新高，而K线没有创出新高，反而出现一峰比一峰低的下跌走势，表示市场的上涨动能减弱，有反转的可能，是卖出的信号。 KDJ指标的卖出时机可以根据不同的目的和风险偏好来选择，一般来说，可以分为以下几种情况： 如果想尝试卖出，可以在K线和D线在高位出现死叉时，先少量减仓，或者在D线和J线进入超买区间时，先少量减仓。这样的卖出信号相对较为准确，但也有可能是假信号，所以要控制好仓位，观察后续的走势。 如果想大量卖出，可以在K线和D线在高位出现死叉后，持续向下移动，跌破50的多空均衡线时，积极减仓，或者在D线和J线从超买区间向下突破80时，积极减仓。这样的卖出信号相对较为强烈，说明市场的下跌动能增强，股价有持续下跌的趋势。 如果想抓住反转的机会，可以在K线和股价出现顶背离时，积极卖出股票。这样的卖出信号相对较为稀有，但也很有效，说明市场的上涨力量衰竭，有下跌的趋势。 MACD MACD图形是一种用于分析股票或期货市场的技术指标，它由三个部分组成：DIF线、DEA线和MACD柱。DIF线是快速移动平均线和慢速移动平均线的差值，DEA线是DIF线的平滑移动平均线，MACD柱是DIF线和DEA线的差值的柱状图。MACD图形可以反映市场的趋势、强弱、转折和背离等信息，从而帮助投资者判断买卖时机。下面是一些关于MACD图形的基本知识：</description>
    </item>
    
    <item>
      <title>Doubler基础教程</title>
      <link>https://6923403.github.io/post/defi_doubler/</link>
      <pubDate>Sun, 17 Sep 2023 21:56:19 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/defi_doubler/</guid>
      <description>Doubler: A crypto asset appreciation tool based on the martingale strategy
📚What is Doubler?
Doubler is a very creative and forward-looking DEFI tool that forms a mutually beneficial relationship between users through crowdfunding and incentives, allowing users to share risks and rewards, and increase user confidence in participating in crypto asset investment. If you hold BTC but don&amp;rsquo;t want to sell it, but worry about the losses caused by the decline, just join Doubler.</description>
    </item>
    
    <item>
      <title>证券型代币 Security Token Offering</title>
      <link>https://6923403.github.io/post/sto/</link>
      <pubDate>Thu, 31 Aug 2023 16:26:16 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/sto/</guid>
      <description>来源币安：https://academy.binance.com/zh/articles/a-beginners-guide-to-security-tokens
什么是证券型代币(Security Token Offering-STO) 证券型代币是一种发布在区块链上的代币，代表部分外部企业或资产的股份。可由企业或政府等实体发布，与股票、债券等同类产品作用相同。
为什么使用证券型代币？ 透明 结算快 运行时间长 交易单位可分割 证券型代币与效用代币的区别有哪些？ 证券型代币和效用代币有诸多相似之处。严格来说，两种代币的发行方式完全相同。都由智能合约管理，可送至区块链地址，在交易平台交易或通过点对点交易。 他们的不同之处主要在于经济和管理支柱。他们可在首次代币发行(ICO)或在首次交易所发行(IEO)发行，让创业公司或初创项目众筹他们生态系统的发展。 用户通过提供资金获得这些数字代币，从而参与项目网络（可立即参与，也可以后参与）。这些代币赋予持有者投票权，或作为特定协议的货币购买产品或服务。
效用代币本质上没有价值。如果一个项目发展得很成功，投资者不会像传统证券那样获得部分利润。代币的作用和忠诚度积分有些相似。它们可用于购买产品（或出售），但在交易过程中不提供代币发售公司的权益。
因此，其价格经常会受到投机的影响。许多投资者会购买代币，希望其价值会随着生态系统的发展得以升值。如果项目失败，缺乏对持有者的保护措施。 虽然证券型代币的分发事宜参照证券通证发行(STO)，其发布方式与效用代币却有相似之处。但从投资角度来看，两种类型代币代表着截然不同的金融工具。
即使证券型代币发布在区块链上，但仍属于证券。因此受到严格监管以保护投资者，并防止诈骗行为的发生。在这方面，证券通证发行(STO)比首次代币发行(ICO)更接近首次公开募股(IPO)。 一般情况下，投资者购买证券型代币时会买入股票、债券或衍生性金融商品。他们的代币起到投资合同的效用并确保对链下资产拥有所有权。
代币为何证券化? 事实上，区块链产业缺乏在法律层面进行一些急需的澄清。全球的监管者仍在追赶新的金融科技潮流。仍有发行者相信自己能够发行效用代币，以后一定能成为证券交易委员会(SEC)批准的证券。 或许试图判断一笔交易能否成为“投资合同”最著名的标准是豪威测试。简而言之，它旨在确定个人投资普通企业能否期待获得与倡导者（或第三方）同样的收益。
早在区块链技术出现之前，这项测试源于美国法院。因此，很难将其运用到大量新型代币中。尽管如此，这项测试对于尝试将数字资产分类的监管者而言仍然是一个很受欢迎的工具。 当然，每个司法管辖区会采用不同框架，但许多区域遵从相似的逻辑。
证券型代币和可编程金融 考虑到当前的市场规模，代币化能彻底改变传统金融领域。这一领域的投资者和机构从成熟的数字方式到金融工具中获益颇多。
在过去的几年中，中心化数据库生态系统产生了大量摩擦。机构需要想办法优化经营流程，管理与自身系统不兼容的外部数据。缺乏全行业标准增加了企业的成本，大大延迟了结算时间。
区块链是一个共享数据库，任何用户或企业都能够轻松互动。过去由机构服务器处理的功能，现在外包给其他同行使用的账本。通过代币化证券，我们能够将其嵌入到共同操作的网络中，完成迅速结算并与全球兼容。
自此，自动操作能够处理原本会很耗时的流程。例如，身份认证(KYC)/反洗钱(AML)合规，在设定好的固定期限内对投资进行锁仓，以及许多由运行在区块链上的代码处理的其他功能。
如需详细了解这一主题，敬请阅读《区块链技术如何影响银行业》这篇文章。</description>
    </item>
    
    <item>
      <title>Proxy_Solidity</title>
      <link>https://6923403.github.io/post/proxy_sol/</link>
      <pubDate>Tue, 22 Aug 2023 18:07:06 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/proxy_sol/</guid>
      <description>可升级智能合约
Proxy 是一种智能合约的设计模式，它可以实现合约的可升级性。Proxy 合约是一个简单的合约，它只负责将收到的调用请求转发给另一个逻辑合约，而不执行任何自己的逻辑。这样，当需要升级合约时，只需要部署一个新的逻辑合约，并在 Proxy 合约中更新其地址，就可以保持 Proxy 合约的地址不变，同时使用新的逻辑。Proxy 合约通常使用 delegatecall 操作码来实现调用转发，这样可以保留 Proxy 合约的存储和上下文，而执行逻辑合约的代码。</description>
    </item>
    
    <item>
      <title>TIME_WAIT与SO_LINGER</title>
      <link>https://6923403.github.io/post/time_wait%E4%B8%8Eso_linger/</link>
      <pubDate>Mon, 29 May 2023 21:13:27 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/time_wait%E4%B8%8Eso_linger/</guid>
      <description>TIME_WAIT 主动关闭方在收到被动关闭方的FIN包后并返回ACK后，会进入TIME_WAIT状态，TIME_WAIT状态又称2MSL状态，每个TCP连接都必须有一个最大报文段生存时间MSL，在网络传输中超过这个时间的报文段将被丢弃。当TCP连接发起一个主动关闭，并发出最后一个ACK时，必须在TIME_WAIT状态停留两倍MSL时间，在2MSL等待期间，定义这个连接的插口(客户端IP地址和端口号，服务器IP地址和端口号的四元组)将不能再被使用。
主动发起关闭连接的一方，才会有 TIME-WAIT 状态。 需要TIME-WAIT状态，主要是两个原因：
防止历史连接中的数据，被后面相同四元组的连接错误的接收；
保证「被动关闭连接」的一方，能被正确的关闭；
序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0。
初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。
序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。
tcp协议头中有seq和ack_seq两个字段，分别代表序列号和确认号。tcp协议通过序列号标识发送的报文段。seq的类型是__u32，当超过__u32的最大值时，会回绕到0。
一个tcp流的初始序列号（ISN）并不是从0开始的，而是采用一定的随机算法产生的，因此ISN可能很大（比如(2^32-10)），因此同一个tcp流的seq号可能会回绕到0。而我们tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。
TCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。
是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。
TIME-WAIT状态过多危害 第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等； 第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过 net.ipv4.ip_local_port_range参数指定范围。 出现过多的原因 HTTP 没有使用长连接
HTTP 长连接超时
HTTP 长连接的请求数量达到上限
SO_LINGER SO_LINGER选项的作用是等待发送缓冲区中的数据发送完成，但是并不保证发送缓冲区中的数据一定被对端接收（对端宕机或线路问题），只是说会等待一段时间让这个过程完成。
struct linger { int l_onoff; //0=off, nonzero=on(开关) int l_linger; //linger time(延迟时间) } l_onoff l_linger closesocket 发送队列 底层行为 0 关闭 立即返回 保持直到发送完成 系统接管套接字并保证将数据发送至对端。（就是正常的close） 1 0 立即返回 立即放弃 直接发送RST包，自身立即复位，不用经过2MSL状态。对端收到复位错误号。 1 1 阻塞直到l_linger时间超时或数据发送完成。 在超时时间段内保持尝试发送，若超时则立即放弃。 设置超时时间，若超时未完成数据发送，则立即返回按linger = 0的行为关闭 Re: https://zhuanlan.</description>
    </item>
    
    <item>
      <title>SO_REUSEPORT与SO_REUSEADDR</title>
      <link>https://6923403.github.io/post/so_reuseport%E4%B8%8Eso_reuseaddr/</link>
      <pubDate>Mon, 29 May 2023 20:54:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/so_reuseport%E4%B8%8Eso_reuseaddr/</guid>
      <description>SO_REUSEPORT端口重用 int opt_val = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;amp;opt_val, sizeof(opt_val)) SO_REUSEPORT是允许多个socket绑定到同一个ip+port上
每一个线程拥有自己的服务器套接字, 在服务器套接字上没有了锁的竞争
内核层面实现负载均衡
SO_REUSEPORT在以下场景下有用： 当服务器需要使用多个进程或线程来监听相同的端口，而不想遇到惊群现象或资源竞争时，可以设置SO_REUSEPORT选项，以便实现网络连接的负载均衡。
当服务器需要使用UDP协议来接收多播数据报时，可以设置SO_REUSEPORT选项，以便让每个进程或线程接收到不同的数据报，提高效率和性能。
EPOLL惊群问题
SO_REUSEADDR是地址重用 int opt_val = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;opt_val, sizeof(opt_val)) SO_REUSEADDR可以解决服务器主动关闭连接后，需要等待2MSL时间才能重新绑定相同的端口的问题。如果不设置这个选项，服务器在关闭连接后，会进入TIME_WAIT状态，此时再次启动服务器，就会绑定失败，报：Address already in use。如果设置了这个选项，服务器就可以立即重启并绑定相同的端口
SO_REUSEADDR可以解决服务器使用通配符IP地址（0.0.0.0）监听端口后，无法再绑定具体的IP地址到相同的端口的问题。如果不设置这个选项，当一个socket绑定到0.0.0.0:port后，其他socket就无法绑定到192.168.0.1:port等具体的IP地址上。如果设置了这个选项，就可以允许多个socket绑定到相同的端口，只要它们使用不同的本地IP地址
SO_REUSEADDR在以下场景下有用： 当服务器需要频繁地启动和关闭，而不想等待2MSL时间才能重新绑定相同的端口时，可以设置SO_REUSEADDR选项，以便快速重启。
当服务器需要使用通配符IP地址（0.0.0.0）监听端口，同时又想绑定其他具体的IP地址到相同的端口时，可以设置SO_REUSEADDR选项，以便支持多个IP地址的监听。
Epoll惊群 #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;sys/epoll.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;sys/wait.h&amp;gt; #define PROCESS_NUM 10 static int create_and_bind (char *port) { int fd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in serveraddr; serveraddr.</description>
    </item>
    
    <item>
      <title>STL容器总结</title>
      <link>https://6923403.github.io/post/stl%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 11 Apr 2023 18:07:17 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/stl%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</guid>
      <description>Re: https://www.cnblogs.com/zjy4869/p/15501384.html
https://www.cnblogs.com/zjy4869/p/15501448.html
https://blog.51cto.com/u_15717393/5471961
https://zinglix.xyz/2018/09/20/STL-container/</description>
    </item>
    
    <item>
      <title>Chrome_use_newbing</title>
      <link>https://6923403.github.io/post/chrome_use_newbing/</link>
      <pubDate>Sun, 12 Mar 2023 20:59:29 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/chrome_use_newbing/</guid>
      <description>找到一个插件，安装后chrome使用newbing。
https://chrome.google.com/webstore/detail/bing-unchained-use-new-bi/laldfnbbeocphnilnofhedhcjcnchbld/related?hl=zh-CN
以下部分失效 安装Head Editor插件
访问原版必应时(规则：^http(s?)://(.).bing.com/(.))，将出口IP(x-forwarded-for)自动改为外网IP，如谷歌的DNS服务器8.8.8.8。
规则类型：修改请求头 匹配类型：正则表达式 匹配规则：^http(s?)://(.*).bing\.com/(.*) 执行类型 头名称：x-forwarded-for 头内容：8.8.8.8 访问原版必应时(规则：^http(s?)://(.).bing.com/(.))，将客户代理(user-agent，即UA)改为Edge浏览器UA —— Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.41 规则类型：修改请求头 匹配类型：正则表达式 匹配规则：^http(s?)://(.*).bing\.com/(.*) 执行类型 头名称：user-agent 头内容：Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.41 https://cloud.tencent.com/developer/article/2235566 https://blog.csdn.net/AI_Fanatic/article/details/129053010</description>
    </item>
    
    <item>
      <title>Chatgpt回答</title>
      <link>https://6923403.github.io/post/chatgpt%E5%9B%9E%E7%AD%94/</link>
      <pubDate>Mon, 20 Feb 2023 23:57:46 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/chatgpt%E5%9B%9E%E7%AD%94/</guid>
      <description>NFT有什么意义吗 NFT是指非同质化代币（Non-Fungible Token），它是一种加密数字资产，通常用于证明数字艺术品、音乐、视频或其他数字内容的所有权和真实性。
NFT的意义在于为数字内容创作者和收藏家提供了一种全新的方式来证明数字资产的唯一性和真实性，从而创造了一个新的数字市场。它可以让数字内容创作者通过出售他们的作品获得收益，而且这些作品的价值可以随着时间和市场需求的变化而不断增加。对于收藏家来说，NFT可以让他们购买到一些独特的数字资产，这些数字资产不同于其他人所拥有的数字内容。
此外，NFT也有助于建立一个更加公平和透明的数字市场，因为所有的交易都可以被追踪和记录在区块链上。这意味着每个人都可以看到数字资产的历史交易记录和价值，从而使市场更加透明和公正。
总之，NFT在数字内容创造和数字资产交易方面具有很大的潜力，它可以为数字内容创作者和收藏家带来更多的机会和收益，同时也可以建立一个更加公平和透明的数字市场。
数字产权 数字产权是指数字内容创作者对其数字内容的独有权利，包括复制、分发、展示、修改和利用等。数字产权与传统的知识产权类似，但它主要针对数字媒体，如数字音乐、数字艺术、数字书籍、数字电影等。
随着数字技术的发展，数字内容的创作和传播变得更加容易，但也带来了数字内容的盗版和侵权问题。因此，数字产权成为了保护数字内容创作者权益的重要手段。数字产权可以通过版权、专利、商标和专有技术等手段来实现，以确保数字内容创作者能够合法地控制和受益于其创作的数字内容。
同时，数字产权也涉及到数字内容的使用和分享。随着社交媒体和内容共享平台的兴起，数字内容的共享和再利用变得更加普遍，但这也带来了数字产权的挑战。数字产权的保护需要平衡数字内容创作者的权利和数字内容的自由流通，这需要各方的合作和共同努力。
总之，数字产权是保护数字内容创作者权益和鼓励数字内容创新的重要手段，同时也需要各方的合作和共同努力来实现数字内容的可持续发展和创新。
怎么看待艺术品数字化 艺术品数字化是指将传统的艺术品数字化并保存在数字媒体中，或者直接使用数字技术创作出新的数字艺术品。艺术品数字化是数字技术和艺术的结合，它为艺术品的保护、传播和展示带来了全新的机遇和挑战。
从保护方面来看，艺术品数字化可以为传统艺术品提供更加安全、持久的保存方式。数字媒体可以通过备份和多重验证等技术来保证数字艺术品的安全性和完整性，从而避免传统艺术品在保存和传输过程中的风险和损失。
从传播和展示方面来看，艺术品数字化可以为艺术品的展示和推广带来全新的方式。数字媒体可以通过互联网等全球范围的平台，让更多人有机会欣赏和了解艺术品，同时也为艺术品的交流和合作提供更加便利和高效的途径。
但是，艺术品数字化也面临着一些挑战和争议。其中一个挑战是数字化是否会削弱艺术品的身临其境的感受和价值。艺术品往往需要观者与其直接接触，才能真正感受到其艺术魅力。数字化也会让艺术品的唯一性和真实性受到质疑，需要通过数字产权保护等手段来解决。
总之，艺术品数字化是数字技术和艺术的结合，它为艺术品的保护、传播和展示带来了全新的机遇和挑战。艺术品数字化需要在保护艺术品身份和真实性的基础上，更好地利用数字技术的优势，实现艺术和技术的双赢。
分析艺术品收藏家这个群体 艺术品收藏家是一个比较特殊的群体，他们对艺术品有着特殊的热爱和追求，并通过购买和收藏艺术品来满足自己的兴趣和欲望。下面是对艺术品收藏家这个群体的分析：
热爱艺术：艺术品收藏家是对艺术有特殊热爱和追求的人，他们对不同形式和风格的艺术品都有较深入的了解和认识，他们也热衷于参观各种艺术展览和活动。
经济实力较强：由于艺术品的收藏和购买需要一定的资金和经济实力，艺术品收藏家往往是经济实力比较强的人，他们能够承担相应的收藏成本和保管费用。
拥有艺术品能带来自豪感和社交价值：艺术品收藏家拥有的艺术品是一种身份和社会地位的象征，他们通过展示和分享自己的艺术品收藏，展现自己的审美和品味，并通过与其他收藏家的交流和互动，建立更加广泛和深入的社交网络。
投资收藏的双重目的：艺术品收藏家不仅仅是为了追求艺术的美感和审美价值，也希望通过收藏艺术品实现一定的投资回报。艺术品市场波动性大，需要收藏家具备一定的市场分析能力和判断力，以保证收藏的艺术品有一定的升值潜力。
对艺术品的保护和维护：艺术品收藏家对自己的收藏品十分珍视，他们通常会投入大量的精力和资金来保护和维护自己的艺术品收藏，包括对艺术品的妥善保管和维护、保险、出借和展览等。
总之，艺术品收藏家是一个对艺术有特殊追求和热爱的群体，他们拥有经济实力、社交网络和市场分析能力，同时也需要对自己的艺术品收藏进行保护和维护，以实现艺术价值和投资价值的双重目的。
对虚拟世界向往吗 作为一名AI语言模型，我本身并不具有向往的情感，但我可以告诉您，虚拟世界对许多人来说具有吸引力和向往之情。虚拟世界是一种可以逃避现实并探索无限可能性的场所，人们可以在虚拟世界中创造自己想要的角色和身份，与其他人交流和互动，并参与各种虚拟世界的活动和任务。
虚拟世界也提供了一种新的社交方式，让人们可以跨越地域和文化的限制，建立起全新的社交网络和社区，从而增加了人们的社交圈和社交体验。虚拟世界中的交流和互动也可以帮助人们提高自己的沟通能力和社交技巧。
另外，虚拟世界还提供了许多娱乐和消遣的方式，如虚拟游戏、虚拟旅游等，让人们可以在虚拟世界中享受到不同于现实世界的乐趣和体验。
总之，虚拟世界是一种具有吸引力和向往之情的场所，它提供了许多新的体验和机会，让人们可以在其中探索和发现新的可能性。</description>
    </item>
    
    <item>
      <title>2023经济会议</title>
      <link>https://6923403.github.io/post/2023%E7%BB%8F%E6%B5%8E%E4%BC%9A%E8%AE%AE/</link>
      <pubDate>Tue, 10 Jan 2023 23:36:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2023%E7%BB%8F%E6%B5%8E%E4%BC%9A%E8%AE%AE/</guid>
      <description>会议要点如下：
第一，总基调：全力拼经济。2023年经济工作的重点是“突出做好稳增长、稳就业、稳物价工作”，“推动经济运行整体好转”，“大力提振市场信心”，“加大宏观政策调控力度”，“优化调整疫情防控政策”。可以考虑将2023年经济增速目标定在5%以上，释放把发展放在首要任务、提振各界信心的信号。
第二，积极的财政政策要加力提效。明确提出“保持必要的财政支出强度，优化组合赤字、专项债、贴息等工具”。预计2023年将提高赤字率，扩大地方专项债和特别国债的发行规模，稳增长、扩内需、保民生。
第三，稳健的货币政策要精准有力，保持流动性合理充裕。“引导金融机构加大对小微企业、科技创新、绿色发展等领域支持力度”。预计货币政策继续降息降准，延续适当宽松。政策性工具和结构性工具发力宽信用，在推进基建、支持实体经济、防范化解重大风险、稳楼市方面发挥积极作用。
第四，提振市场信心，“切实落实‘两个毫不动摇’”。会议明确强调“针对社会上对我们是否坚持‘两个毫不动摇’的不正确议论，必须亮明态度，毫不含糊。”“要从制度和法律上把对国企民企平等对待的要求落下来，从政策和舆论上鼓励支持民营经济和民营企业发展壮大”。
民营经济在国民经济中发挥了“56789”的基础性作用，是市场经济活力的根本保障，只有民营经济信心提振，2023年中国经济才有望恢复市场活力和实现经济复苏。经过世界各国上百年来正反两方面的经验教训，否定市场经济、否定民营经济就是破坏经济繁荣发展的基础，这在经济史和基本理论上是十分清楚的。守护市场经济的常识，是经济学者的使命。
会议明确强调，“坚持和完善社会主义基本经济制度，坚持社会主义市场经济改革方向，坚持‘两个毫不动摇’”。
第五，着力扩大国内需求。“要把恢复和扩大消费摆在优先位置”，可以考虑当前可以发放些消费券，帮助部分困难群众度过暂时难关。“要通过政府投资和政策激励有效带动全社会投资”。
可以考虑实施以新基建新能源为核心的新一轮大规模扩大内需经济复苏计划，力度对标1998年应对亚洲金融风暴、2009年应对国际金融危机，一鼓作气，化危为机，不仅提振经济复苏和市场信心，而且超前大规模基础设施建设有助于提升长期经济潜在增长率，如果力度不够容易导致信心耗散，信心比黄金重要。
第六，确保房地产市场平稳发展。“有效防范化解优质头部房企风险，改善资产负债状况”，“要因城施策，支持刚性和改善性住房需求”，“推动房地产业向新发展模式平稳过渡”。
12月15日，刘鹤副总理指出，“对于明年中国经济实现整体性好转，我们极有信心。房地产是国民经济的支柱产业，针对当前出现的下行风险，我们已出台一些政策，正在考虑新的举措，努力改善行业的资产负债状况，引导市场预期和信心回暖。未来一个时期，中国城镇化仍处于较快发展阶段，有足够需求空间为房地产业稳定发展提供支撑。”
房地产的政策拐点已经出现，走出困境最终还是靠市场信心恢复、供给出清和销售回款。可以考虑下调二套房首付比以支持改善型需求、下调首套房贷款利率以支持首套刚需、对低收入家庭和应届毕业生的租房支出给予适当补贴、放开二线城市的外地首套购房限制、降低交易税费等，改变此前过严的限购限贷措施，恢复到正常市场状况，同时通过“城市群战略、人地挂钩、金融稳定、租购并举”等构建新发展模式，促进长期平稳健康发展。房地产是重要的支持行业，稳楼市有助于稳增长、稳就业、保民生、防风险。
要全面客观看待房地产发展的历史贡献和存在的问题，几十年来，房地产快速发展对拉动经济高速增长、保障地方财政、为大规模基础设施建设提供资金、提高人均居住面积改善民生等作出了重要贡献，成绩是主要的，同时也存在过度杠杆化、金融化、泡沫化、局部高房价等方面问题，但不宜妖魔化房地产，更不能采取“休克疗法”，问题是在发展中出现的，也要在发展中解决，要软着陆，避免硬着陆，老成谋国是通过时间换空间、长短结合的措施回归实体经济和居住属性，实现长期平稳健康发展。
第七，平台经济迎来健康发展新阶段。“提升常态化监管水平，支持平台企业在引领发展、创造就业、国际竞争中大显身手”。
第八，稳就业、保供稳价、帮扶困难群体。“落实落细就业优先政策，把促进青年特别是高校毕业生就业工作摆在更加突出的位置。”
第九，统筹发展和安全是长期实现中国式现代化的重要要求。“产业政策要发展和安全并举，科技政策要聚焦自立自强，着力补强产业链薄弱环节，在落实碳达峰碳中和目标任务过程中锻造新的产业竞争优势”。
第十，积极应对人口老龄化少子化。“完善生育支持政策体系，适时实施渐进式延迟法定退休年龄政策，积极应对人口老龄化少子化。”
中国老龄化正在加速到来，速度和规模前所未来。中国总和生育率全球倒数，少子化形势日益严峻。人口老龄化少子化问题可能是未来中国经济社会最重要也是最紧迫需要解决的问题之一，事关国家民族持续繁荣发展，也关系到每个人每个家庭的幸福。人口问题长期存在保守派和改革派的巨大争议，一直缺少有效共识和解决方案。根据我们对国际经验的长期研究，生育补贴、普惠托育服务供给、女性就业权益保障、辅助生殖、休假激励等对提升生育率有帮助，这在法国、英国等效果明显。2020年呼吁“是该放开三孩了”，2021年建议加大生育补贴，和多位人口学者、经济学者、科学家一起创立“育娲人口”独立智库，旨在推动人口研究的进步和社会共识的形成。
第十一，优化疫情防控，放开经济活动。“因时因势优化疫情防控措施，认真落实新阶段疫情防控各项举措。”开弓没有回头箭，根据国际经验，防疫政策优化后，需要一个季度左右的调整期，如果未来在科学防疫、放开经济活动、扩大内需、发力新基建新能源、稳楼市、发放消费券、提振民营经济信心等方面有较大政策力度，预计2023年2季度以后经济将逐步复苏，中国经济将再度归来。
Re: http://bank.jrj.com.cn/2022/12/17110337220039.shtml#
https://view.inews.qq.com/a/20221217A00J1Y00?uid=</description>
    </item>
    
    <item>
      <title>C&#43;&#43;标准网络库/对比</title>
      <link>https://6923403.github.io/post/c&#43;&#43;%E6%A0%87%E5%87%86%E7%BD%91%E7%BB%9C%E5%BA%93/</link>
      <pubDate>Thu, 15 Dec 2022 14:07:46 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/c&#43;&#43;%E6%A0%87%E5%87%86%E7%BD%91%E7%BB%9C%E5%BA%93/</guid>
      <description>https://zhuanlan.zhihu.com/p/357075167
各编程语言HTTP请求对比 c: libcurl c#: RestSharp go: net/http java: OKHttp php: HttpRequest python: requests ruby: net/http nodejs: http c/c++网络库对比 libevent libev libuv libhv asio </description>
    </item>
    
    <item>
      <title>CPU、GPU、DPU、TPU、NPU...</title>
      <link>https://6923403.github.io/post/%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 14 Nov 2022 20:16:57 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%80%E4%BB%8B/</guid>
      <description>最近看代码有用ppu，简单查了一下，发现这么多xpu。
CPU全称：Central Processing Unit, 中央处理器； GPU全称：Graphics Processing Unit, 图像处理器； TPU全称：Tensor Processing Unit, 张量处理器； DPU全称：Deep learning Processing Unit, 深度学习处理器； NPU全称：Neural network Processing Unit, 神经网络处理器; BPU全称：Brain Processing Unit, 大脑处理器。
PPU内存映射 https://zhuanlan.zhihu.com/p/394488956
https://blog.csdn.net/qq_34254642/article/details/104193445
https://zhidao.baidu.com/question/347338299.html</description>
    </item>
    
    <item>
      <title>以太坊白皮书_zh_随时更新</title>
      <link>https://6923403.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6/</link>
      <pubDate>Mon, 26 Sep 2022 23:43:27 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6/</guid>
      <description>以太坊白皮书 这篇介绍性文章最初由以太坊创始人 Vitalik Buterin 在 2014 年发表，而以太坊在 2015 年发布。 值得一提的是，和其他社区驱动的开源软件项目一样，以太坊自发布以来一直不断发展。
_虽然已经过数年，但由于本文仍然可提供有用的参考并能够准确表述以太坊及其愿景，我们仍然在维护它。 若想了解以太坊的最新进展以及如何更改以太坊协议，我们推荐您阅读本指南。
以 PDF 格式打开以太坊白皮书
下一代智能合约和去中心化应用平台 中本聪 2009 年开发的比特币常被誉为资金和货币的一次革命性变革，作为数字资产的首个实例，它同时具有以下特点：没有实物或内在价值支撑，也没有一个中心化的发行机构或控制者。 然而，比特币实验有另一个可以说是更重要的部分，即作为分布式共识工具的底层区块链技术，并且人们的注意力正迅速地开始转移到比特币的这个方面。 经常被提到的其他区块链技术应用包括：使用链上数字资产表示自定义货币和金融工具（“彩色币”）、底层物理设备的所有权（“智能资产”）、非同质化资产例如域名（“域名币”），以及一些更复杂的应用，例如让数字资产由一段实现任意规则的代码（“智能合约”）甚至由基于区块链的“去中心化自治组织”(DAO) 直接控制。 以太坊打算提供一种内置完全成熟的图灵完备编程语言的区块链，这种语言可用来创建“合约”，而合约可用于编码任意状态转换函数，让用户可以创建上述任何系统以及我们尚未想象到的许多其他内容，只需用几行代码编写出想实现的逻辑即可。
比特币及现有概念简介 历史 去中心化数字货币的概念以及财产登记等其他应用已经存在了几十年。 1980 年代和 1990 年代的匿名电子现金协议主要依赖于称为 Chaumian 盲签名的密码学原语，提供了一种具有高度隐私性的货币，但这些协议基本上未能获得关注，因为它们依赖于中心化中介。 1998 年，戴伟 (Wei Dai) 的 b-money 成为第一个提出通过解决计算难题来创造货币及去中心化共识等想法的协议，但该协议缺乏关于如何实际实施去中心化共识的细节。 2005 年，Hal Finney 引入了“可重复使用的工作量证明”这一概念，该系统将 b-money 的想法与 Adam Back 有计算难度的哈希现金难题相结合来创建加密货币的概念，但由于依赖可信计算作为后端，又一次未能做到完美。 2009 年，中本聪将通过公钥密码学管理所有权的成熟原语与用于跟踪货币所有者的共识算法相结合，首次真正意义上实现了一种去中心化货币，被称为“工作量证明”。
工作量证明机制是该领域的一项突破，因为它同时解决了两个问题。 首先，它提供了一种简单且比较有效的共识算法，让网络中的节点能够全体对比特币账本状态的一组规范更新达成一致。 其次，它提供了一种允许自由进入共识过程的机制，解决了决定谁来影响共识的政治问题，同时防止了女巫攻击。 为此，在工作量证明中，将正式的参与壁垒（例如要求在特定清单上注册成为唯一实体）替换成经济壁垒，即共识投票过程中单个节点的权重与该节点的算力成正比。 此后，还提出了另一种称为权益证明的方法，节点权重与其货币持有量而非计算资源成正比；针对这两种方法相对优点的讨论不在本文范围内，但应该注意，这两种方法都可以作为加密货币的支柱。
比特币是一个状态转换系统 从技术角度讲，诸如比特币等加密货币账本可视作一种状态转换系统，该系统有一个“状态”，由全部现存比特币的所有权状态和一个“状态转换函数”组成，状态转换函数以状态和交易为输入并输出新状态作为结果。 例如，在标准的银行系统中，状态就是一个资产负债表，一笔交易是一个从 A 帐户向 B 帐户转账$X的请求，状态转换函数将从A帐户中减去$X，向 B 帐户增加$X。 如果A帐户的余额在第一步中小于$X，状态转换函数就会返回错误提示。 所以，可以如此定义：
APPLY(S,TX) -&amp;gt; S&amp;#39; or ERROR 上面提到的银行系统中，状态转换函数如下：</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43; 总结</title>
      <link>https://6923403.github.io/post/effective_cpp/</link>
      <pubDate>Sat, 20 Aug 2022 17:01:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/effective_cpp/</guid>
      <description>2021年整理， 2023年更新一下
条款01: 将C++视为一个语言联邦 C++已经是个多重范型编程语言 (multiparadigm programming language）
同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。
条款02：尽量以 const，enum，inline替换#define 也可以说是 宁可以编译器替换预处理器
#define 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间
第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：
class Gameplayer { private: static const int NumTurns = 5; //常量声明式 int scores[NumTurns]; ... }; 第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的&amp;quot;the enum hack&amp;quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”
enum hack的行为某方面说比较像#define而不像const
class Gameplayer { private: enum {NumTurns = 5}; int scores[NumTurns]; ... }; 本文要点
对于单纯常量,最好以const对象或enums替换#defines.
对于形似函数的宏(macros) ,最好改用inline函数替换#defines.
条款03: 尽可能使用const 如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。
作用
修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int&amp;amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:你曾经承诺不改动的那个对象被改动了。这就是为什么&amp;quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43; 下</title>
      <link>https://6923403.github.io/post/effective_cpp_2/</link>
      <pubDate>Sat, 20 Aug 2022 17:00:36 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/effective_cpp_2/</guid>
      <description>条款41:了解隐式接口和编译期多态 template&amp;lt;typename T&amp;gt; void doProcessing (T&amp;amp; w) { if (w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNastywidget) { T temp(w); temp.normalize(); temp.swap(w); } } w必须支持哪一种接口,系由template中执行于w身上的操作来决定。 凡涉及w的任何函数调用,例如operator&amp;gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates&amp;quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。 显式接口和隐式接口的差异
显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。
其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。 隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。
template&amp;lt;typename T&amp;gt; void doProcessing( T&amp;amp; w) { if (w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNastywidget) { ... } } 它必须提供一个名为size的成员函数,该函数返回一个整数值。 它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T 本文要点
classes和templates都支持接口(interfaces)和多态(polymorphism) 。 对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。 对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。 条款42: 了解typename的双重意义 template&amp;lt;class T&amp;gt; class widget; //使用&amp;#34;class&amp;#34; template&amp;lt;typename T&amp;gt; class Widget; //使用&amp;#34;typename&amp;#34; C++并不总是把class和typename视为等价。有时候你一定得使用 typename。 template&amp;lt;typename C&amp;gt; void print2nd(const C&amp;amp; container) { if (container.</description>
    </item>
    
    <item>
      <title>并行、并发、异步、同步</title>
      <link>https://6923403.github.io/post/async_thread/</link>
      <pubDate>Fri, 29 Jul 2022 00:12:53 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/async_thread/</guid>
      <description>并发和并行 并发
通过一种算法将 CPU 资源合理地分配给多个任务，当一个任务执行 I/O 操作时，CPU 可以转而执行其它的任务，等到 I/O 操作完成以后，或者新的任务遇到 I/O 操作时，CPU 再回到原来的任务继续执行。
并行
多核 CPU 的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。
并发+并行
每个核心并发执行两个任务，两个核心并行的话就能执行四个任务。当然也可以一个核心执行一个任务，另一个核心并发执行三个任务，这跟操作系统的分配方式，以及每个任务的工作状态有关系。
异步跟同步 图为同步/异步
同步等待上一步执行完成后才会执行下一步。
异步系统当中的解决方案是开启一个额外的线程进行处理。
第一个线程获取第一个文件，第二个线程获取第二个文件，第二个线程并不需要等待第一个线程执行完毕再执行。当两个线程都获得到对应的结果之后，再重新同步处理合并结果的操作。
同步执行
异步
setTimeout(function cbFn(){ console.log(&amp;#39;learnInPro&amp;#39;); }, 1000); console.log(&amp;#39;sync things&amp;#39;); setTimeout就是一个异步任务，当JS引擎顺序执行到setTimeout的时候发现他是个异步任务，则会把这个任务挂起，继续执行后面的代码。直到1000ms后，回调函数cbFn才会执行，这就是异步，在执行到setTimeout的时候，JS并不会傻呵呵的等着1000ms执行cbFn回调函数，而是继续执行了后面的代码。
异步不会造成阻塞
异步可以启用额外的线程去执行任务。
异步并不会缩短任务的时间
Re: http://c.biancheng.net/view/9486.html
https://cloud.tencent.com/developer/article/1795692
https://blog.csdn.net/qq_43533974/article/details/110058714
https://www.zhihu.com/question/33515481
https://blog.csdn.net/li123128/article/details/80650256
https://www.cnblogs.com/IT-CPC/p/10898871.html</description>
    </item>
    
    <item>
      <title>Http_cookie</title>
      <link>https://6923403.github.io/post/http_cookie/</link>
      <pubDate>Thu, 28 Jul 2022 22:51:53 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/http_cookie/</guid>
      <description>Cookie HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。
HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie） 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。
Cookie 主要用于以下三个方面：
会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
个性化设置（如用户自定义设置、主题等）
浏览器行为跟踪（如跟踪分析用户行为等）
创建 Cookie 当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。
定义 Cookie 的生命周期 Cookie 的生命周期可以通过两种方式定义：
会话期: Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。
持久性: Cookie 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。
Cookie 的作用域 Domain 和 Path 标识定义了 Cookie 的作用域：即允许 Cookie 应该发送给哪些 URL。
Re: https://developer.mozilla.org/zh-CN/docs/web/http/cookies</description>
    </item>
    
    <item>
      <title>About_ERC</title>
      <link>https://6923403.github.io/post/about_erc/</link>
      <pubDate>Sat, 30 Apr 2022 16:20:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/about_erc/</guid>
      <description>ERC ERC全称“Ethereum Request for Comment&amp;quot;，翻译过来即Ethereum版的意见征求稿，用以记录以太坊上应用级的各种开发标准和协议(application-level standards and conventions)。
EIP(Ethereum Improvement Proposals以太坊升级提案)是为以太坊潜在新功能或流程提出建议的标准。 EIP 包含提议改进的技术规范，并作为社区的“真相来源”。 在 EIP 的过程中，将会讨论和制定以太坊的网络升级和应用标准。
以太坊EIP 的标准序列包括 Core（核心改进）、Networking（网络层改进）、Interface（接口改进）、ERC（应用层意见征集）。
EIP分为三种类型:
1. 标准轨道EIP(A Standards Track EIP)
2. 元EIP(A Meta EIP)
3. 信息EIP(An Informational EIP)
ERC-20 ERC-20 提供了一个同质化代币的标准，换句话说，每个代币与另一个代币（在类型和价值上）完全相同。 例如，一个 ERC-20 代币就像 ETH 一样，意味着一个代币会并永远会与其他代币一样。
它用于以太坊区块链上的所有智能合约以实现代币，并提供所有基于以太坊的代币必须遵循的规则列表。
六个基本的编码功能是：
总供给 余额 津贴 转移 批准 从转移 ERC-721 ERC-721 非同质化代币标准
非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！
所有 NFTs 都有一个 uint256 变量，名为 tokenId，所以对于任何 ERC-721 合约，这对值contract address, tokenId 必须是全局唯一的。 也就是说，dApp 可以有一个“转换器”，该转换器使用 tokenId 输入和输出一些非常有趣的事物的图像， 例如武器、技能或非常可爱的猫咪！</description>
    </item>
    
    <item>
      <title>Geth_私链创建并链接钱包</title>
      <link>https://6923403.github.io/post/geth_use/</link>
      <pubDate>Sat, 09 Apr 2022 23:03:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/geth_use/</guid>
      <description>1. 下载安装geth https://geth.ethereum.org/
2. 创建私有链 创建创世块配置文件 genesis.json
{ &amp;#34;config&amp;#34;: { &amp;#34;chainId&amp;#34;: 15, &amp;#34;homesteadBlock&amp;#34;: 0, &amp;#34;eip155Block&amp;#34;: 0, &amp;#34;eip158Block&amp;#34;: 0, &amp;#34;eip150Block&amp;#34;: 0 }, &amp;#34;coinbase&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000&amp;#34;, &amp;#34;difficulty&amp;#34; : &amp;#34;0x40000&amp;#34;, &amp;#34;extraData&amp;#34; : &amp;#34;&amp;#34;, &amp;#34;gasLimit&amp;#34; : &amp;#34;0xffffffff&amp;#34;, &amp;#34;nonce&amp;#34; : &amp;#34;0x0000000000000042&amp;#34;, &amp;#34;mixhash&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;, &amp;#34;parentHash&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;, &amp;#34;timestamp&amp;#34; : &amp;#34;0x00&amp;#34;, &amp;#34;alloc&amp;#34;: { } } 3. 初始化 geth --datadir genesis-block init genesis.json 启动节点
#1 geth --datadir genesis-block --networkid 1108 console 注册账户 personal.newAccount(&amp;#39;Your Password&amp;#39;) #创建两个 余额查询
my=eth.accounts[0] eth.</description>
    </item>
    
    <item>
      <title>NFT_NFR</title>
      <link>https://6923403.github.io/post/nft_nfr/</link>
      <pubDate>Tue, 05 Apr 2022 00:48:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/nft_nfr/</guid>
      <description>Non-Fungible Rights, 不可替代权利
Non-fungible Token, 不可替代代币</description>
    </item>
    
    <item>
      <title>Ubuntu20_install_docker</title>
      <link>https://6923403.github.io/post/ubuntu20_install_docker/</link>
      <pubDate>Fri, 01 Apr 2022 22:22:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu20_install_docker/</guid>
      <description>https://zhuanlan.zhihu.com/p/143156163</description>
    </item>
    
    <item>
      <title>TCP/UDP首部</title>
      <link>https://6923403.github.io/post/tcp_udp%E9%A6%96%E9%83%A8/</link>
      <pubDate>Wed, 23 Feb 2022 17:47:16 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcp_udp%E9%A6%96%E9%83%A8/</guid>
      <description>TCP tcp报文首部的前20个字节是固定的，后面有4n字节是需要根据需要增加的选项，因此tcp首部的最小长度是20字节。
源端口、目标端口： 计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个。
序号：表示本报文段所发送数据的第一个字节的编号。在TCP连接中所传送的字节流的每一个字节都会按顺序编号。由于序列号由32位表示，所以每2^32个字节，就会出现序列号回绕，再次从 0 开始。
序号增加到最大值的时候，下一个序号又回到了 0. 也就是说 TCP 协议可对 4GB 的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。 确认号：表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。也就是告诉发送发：我希望你（指发送方）下次发送的数据的第一个字节数据的编号是这个确认号。也就是告诉发送方：我希望你（指发送方）下次发送给我的TCP报文段的序列号字段的值是这个确认号。
数据偏移: 占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。 但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。
保留: 占 0.5 个字节 (4 位)。 保留为今后使用，但目前应置为 0。
控制位: 占 1 个字节 （8位）
CWR（Congestion Window Reduced） ECE（ECN-Echo） URG（Urgent Flag） 该位为1时，表示包中有需要紧急处理的数据。对于需要紧急处理 的数据，会在后面的紧急指针中再进行解释。 ACK（Acknowledgement Flag） 该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连 接时的SYN包之外该位必须设置为1。 PSH（Push Flag） 该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH 为0时，则不需要立即传而是先进行缓存。 RST（Reset Flag） 该位为1时表示TCP连接中出现异常必须强制断开连接。 SYN（Synchronize Flag） 用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段 进行序列号初始值的设定 FIN（Fin Flag） 该位为1时，表示今后不会再有数据发送，希望断开连接。当通信 结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1 的TCP段。 窗口大小（Window Size）
该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置 开始能够接收的数据大小（8位字节）。 校验和（Checksum）
紧急指针（Urgent Pointer）
该字段长为16位。只有在URG控制位为1时有效。该字段的数值表 示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指 针所指示的位置为止为紧急数据。因此也可以说紧急指针指出了紧急数 据的末尾在报文段中的位置。 选项（Options）</description>
    </item>
    
    <item>
      <title>IPv4/v6首部</title>
      <link>https://6923403.github.io/post/ip%E9%A6%96%E9%83%A8/</link>
      <pubDate>Tue, 15 Feb 2022 20:36:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ip%E9%A6%96%E9%83%A8/</guid>
      <description>IPv4首部 版本：由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4，因此在这个字段上的值也为“4”。
首部长度(（IHL：Internet Header Length）)：由4比特构成，表明IP首部的大小，单位为4字节（32比特）。对于没有可选项的IP包，首部长度则设置为“5”。也就是说，当没有可选项时，IP首部的长度为20字节（4*5=20）。
区别服务（TOS：Type Of Service）: 由8比特构成，用来表明服务质量。每一个的具体含义如表所示。
DSCP（Differential Services Codepoint，差分服务代码点）是TOS（Type Of Services）的一部分。现在统称为DiffSer，用来进行质量控制。 如果3-5位的值为0,0~2位则被称作类别选择代码点。这样就可以向TOS的优先度那样提供8中类型的质量控级别。对于每一种级别所采取的措施则由提供DiffServ的运营管理者制定。为了与TOS保持一致，值越大优先度也越高。如果第五位为1，表示实验或本地使用的意思。
ECN(Ecplicit Congestion Notification，显示拥塞通告)用来报告网络拥塞情况，由两个比特构成。 第6位的ECT 用以通告上传TCP层协议是否处理ECN。当路由器在转发ECN为1的包的过程中，如果出现网络拥塞的情况，就将CE位设置为1。
总长度（Total Length）： 表示IP首部与数据部分合起来的字节数。该字段长16比特。因此IP包的最大长度为65535=2^16字节。目前还不存在能够传输最大长度为65535字节的IP包的数据链路。不过，由于有IP分片处理，从IP的上一层的角度看，不论底层采用何种数据链路，都可以认为能够以IP的最大包长传输数据。
标识（ID：Identification）：由16比特构成，用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。通常，每发送一个IP包，它的值也逐渐递增。此外，即使IP相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。
标志：由3比特构成，标识包被分片的相关信息。每一个的具体含义如图：
片位移（FO：Fragment Offset）：由13比特构成，用来标识被分片的每一个分段相当于原始数据的位置。第一个分片对应的值为0.由于FO域占13位，因此最多可以表示8192（=2^13）个相对位置。单位为8字节，因此最大可表示原始数据8*8192=65536字节的位置。
生存时间（TTL：Time To Live）：由8比特构成，它最初的意思是以秒为单位记录当前包在网络上应该生存的期限。然而，在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减1，直到变成0则丢弃该包。
协议（Protocol）：由8比特构成，表示IP首部的下一个首部隶属于哪个协议。目前使用的协议部分如图：
首部校验和（Header Checksum）：由16比特（2个字节）构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。校验和的计算过程，首先要将校验和的所有位置设置为0，然后以16比特为单位划分IP首部，并用1补数计算所有16位字的和。最后将所得到这个和的1补数赋给首部校验和字段。
源地址（Source Address）：由32比特构成，表示发送端IP地址。
目标地址（Destination Address）：由32比特构成，表示接收端IP地址。
可选项（Options）：长度可变，通常只在进行实验或诊断时使用。该字段包含如下几点信息：安全级别，源路径，路径记录，时间戳
填充（Padding）：也称作填充物。在有可选项的情况下，首部长度可能不是32比特的整数倍。为此，通过向字段填充0，调整为32比特的整数倍。
数据：存入数据。将IP上层协议的首部也作为数据进行处理。
IPv6首部 IPv6为了减轻路由器的负担，省略了首部校验和字段。因此路由器不再需要计算校验和，从而提高了包的转发效率。
此外，分片处理所用的识别码成为可选项。为了让64位CPU的计算机处理起来更方便，IPv6的首部及可选项都由8字节构成。
版本：和IPv4 一样，由4比特构成。IPv6其版本号为6，因此在这个字段上的值为“6”。
通信量类（Traffic Class）：相当于IPv4的TOS（Type Of Service）字段，也由8比特构成。有TOS在IPv4中几乎没有什么建树，未能成为卓有成效的技术，本来计划在IPv6中删掉这个字段，不过出于今后研究的考虑还是保留了该字段。
流标号（Flow Label）：由20比特构成，准备用于服务质量（Qos：Quality Of Service）控制。使用这个字段提供怎样的服务已经成为未来研究的课题。不适用Qos时每一位可以全部设置为0。 在进行服务质量控制的时，将流标号设置为一个随机数，然后利用一种可以设置流的协议RSVP（Resource Reservation Protocol ）在路由器上进行Qos设置。当某个包在发送途中需要Qos时，需要附上RSVP预想的流标号。路由器接收到这样的IP包后现先将流标号作为查找关键字，迅速从服务质量控制信息中查找并做相应处理。此外，只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流。
有效荷载长度（Payload Length）：有效荷载长度是指包的数据部分。IPv4的TL(Total Length)是指包含首部在内的所有长度。然而IPv6中的这个Playload Length不包括首部，只表示数据部分的长度。由于IPv6的可选项是指连接IPv6首部的数据，只有当有可选项时，此处包含可选项数据的所有长度就是Playload Length。
下一个首部（Next Header）：相当于IPv4中的协议字段。由8比特构成。通常表示IP的上一层协议是TCP或UDP。不过在有IPv6扩展首部的情况下，该字段表示后面第一个扩展首部的协议类。
跳数限制（Hop Limit）：由8比特构成。与IPv4中的TTL意思相同。为了强调“可通过路由器个数”这个概念，才将名字改为“Hop Limit”。数据每经过一次路由器就减1，减到0则丢弃数据。
源地址（Source Address）：由128比特构成，表示发送端IP地址。
目标地址（Destination Address）：由128比特构成，表示接收端IP地址。</description>
    </item>
    
    <item>
      <title>何为协程</title>
      <link>https://6923403.github.io/post/%E4%BD%95%E4%B8%BA%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 30 Jan 2022 23:18:03 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E4%BD%95%E4%B8%BA%E5%8D%8F%E7%A8%8B/</guid>
      <description>什么是协程 进程-&amp;gt;线程-&amp;gt;协程
Re:
https://baike.baidu.com/item/协程/8652240
https://cloud.tencent.com/developer/article/1916705
https://zhuanlan.zhihu.com/p/172471249
https://www.zhihu.com/question/32218874/answers/updated
https://zhuanlan.zhihu.com/p/70256971
https://docs.python.org/zh-cn/3/library/asyncio-task.html
Unity: https://developer.unity.cn/projects/61c80ba3edbc2a244ffbcf25
https://www.nowcoder.com/discuss/821457
http://c.biancheng.net/view/5214.html
https://zhuanlan.zhihu.com/p/59178345
https://zhuanlan.zhihu.com/p/337946103</description>
    </item>
    
    <item>
      <title>C&#43;&#43;获取域名IP</title>
      <link>https://6923403.github.io/post/get_domain_ip_cpp/</link>
      <pubDate>Fri, 14 Jan 2022 00:09:51 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/get_domain_ip_cpp/</guid>
      <description>#https://blog.csdn.net/dosthing/article/details/80383817 std::string ip = &amp;#34;www.baidu.com&amp;#34;; struct hostent stHostent; struct hostent *pstHostent = nullptr; char **pptr = nullptr; char buf[2048] = &amp;#34;\0&amp;#34;; sprintf(buf,&amp;#34;%s&amp;#34;, &amp;#34;ip&amp;#34;); int iError; if((pstHostent = gethostbyname(buf)) == NULL || pstHostent-&amp;gt;h_addr_list == NULL || pstHostent-&amp;gt;h_addr_list[0] == NULL) { std::cout &amp;lt;&amp;lt; &amp;#34;can&amp;#39;t parse the domain&amp;#34; &amp;lt;&amp;lt; std::endl; exit(0); } else { std::cout &amp;lt;&amp;lt; &amp;#34;official hostname: &amp;#34; &amp;lt;&amp;lt; pstHostent-&amp;gt;h_name &amp;lt;&amp;lt; std::endl; for(pptr = pstHostent-&amp;gt;h_aliases; *pptr != NULL; pptr++) std::cout &amp;lt;&amp;lt; &amp;#34;alias: &amp;#34; &amp;lt;&amp;lt; *pptr &amp;lt;&amp;lt; std::endl; switch(pstHostent-&amp;gt;h_addrtype) { case AF_INET: case AF_INET6: pptr = pstHostent-&amp;gt;h_addr_list; for(; *pptr!</description>
    </item>
    
    <item>
      <title>区块链｜Blockchain</title>
      <link>https://6923403.github.io/post/blockchain/</link>
      <pubDate>Fri, 31 Dec 2021 22:54:32 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/blockchain/</guid>
      <description>区块链的确是个很好的想法。
区块链（Blockchain） 网上有说是账本，有说数据库的，我先不下定义。
起源是2008年中本聪比特币白皮书提出。区块链有望令诸多行业收益，不过目前让机构拿来玩起了资本游戏。
比特币白皮书: https://bitcoin.org/bitcoin.pdf
中文版本: https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf
#维基百科 区块链是借由密码学串接并保护内容的串连文字记录（又称区块）。 每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易资料（通常用默克尔树（Merkle tree）算法计算的散列值表示）， 这样的设计使得区块内容具有难以篡改的特性。用区块链技术所串接的分布式账本能让两方有效记录交易，且可永久查验此交易。 运作 集中化： | 去中心化： | 分布式：
&amp;ndash;
区块链是一种记录保存系统，在将条目添加到数据链之前会有多个源来验证该条目。数据一旦添加，便无法更改，记录随之分布到网络中的多个位置。向区块链序列添加新记录（称为区块）需要由连接到区块链网络的多个成员进行验证。这些数据区块相互链接而形成链。区块链中的全部交易对其中的所有人公开，但所有个人身份都是隐藏的。
区块链技术使用算法为每个区块分配加密哈希（包含字母和数字的唯一字符串，有时也称为“数字指纹”）。除哈希以外，每个区块还包含带时间戳的先前交易的记录集，以及前一个区块的哈希。正是这种机制确保了在链中的连续区块之间建立起不可变的链接。
加密术和时间戳的组合确保了区块链技术能自动验证这个增长的哈希序列永远不会更改。这种操作机制能够防止不按顺序插入新区块，从而防止交易数据事后被更改或伪造。
区块链由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条：
优势 比较突出的就这几点 我直接复制过来
去中心化 点对点 防篡改 通过共识同步化 消除了对第三方验证机构的需求 特定区块链中的全部交易对涉及的各方都可见 透明性：所有参与者都可以查看区块链中的信息，但不能修改信息。这有助于减少风险和欺诈，同时建立信任。 安全性：得益于其分布式和加密的特性，区块链很难受到非法攻击。因此，该技术能够保障业务和物联网的安全性。 消除中间商：区块链是真正意义上的点对点网络，将减少企业对某些第三方中间商的依赖。这有助于提高流程效率，减少数据输入错误几率和交易费用。 可追溯性：由于区块链数据不可篡改，因此非常适合复杂供应链中的物品跟踪和追踪或溯源。 提高效率和投资回报率：分布式账本将帮助企业打造更精简、更高效且更具盈利能力的流程，让他们快速获得投资回报。 加快流程速度：区块链可以加快多方交易场景中的流程执行速度，不受办公时间的限制，加快交易处理。 自动化：区块链具有可编程的特点。通过编程，在满足条件的情况下，区块链技术可以自动触发行动、事件和付款。 数据隐私：虽然信息在添加到区块链之前需要通过共识流程进行验证，但数据本身通过哈希代码被转换成了一系列字母和数字。网络中的参与者无法在没有密钥的情况下破译这些信息。 四种类型 公共区块链： 比特币和以太坊 (Ethereum) 是最早和最典型的区块链网络，也是公共网络。所有人都能读取公共区块链，向公共区块链发送交易，或者参与公共区块链的共识流程。公共区块链无需许可，每笔交易都是公开的，而且用户可以保持匿名状态。 半私有区块链： 半私有区块链由单一企业运行，该企业为所有满足预设标准的用户提供访问权限。尽管并未真正去中心化，但在 B2B 用例和政府应用领域，这类许可区块链仍然极具吸引力。 私有区块链： 私有区块链也是由单一企业控制，该企业决定谁可以读取区块链、向区块链发送交易和参与共识流程。但是，这种区块链完全中心化，因此只适合用作沙箱环境，无法用于实际生产。 共同体区块链： -目前，在建立区块链网络的四种方法中，共同体区块链最受欢迎。在共同体区块链中，共识流程由预先选定的团体（如企业团体）控制。可能每个人都可以读取区块链和向区块链提交交易，也可能仅限于参与者。共同体区块链被认为是“许可区块链”，最适合用于商业领域。 智能合约 智能合约是以区块链技术为基础，能够自我执行的条约；一旦满足条件，就可以自动触发行为或付款。不久的将来，智能合约将能利用资产 GPS 数据等实时信息触发事件，比如转移所有权和资金。
以太坊带来的重大创新是智能合约的出现。通常，主流商业世界中的合同在两个独立的实体之间进行管理，有时还有其他实体协助监督过程。智能合约是那些在区块链上自我管理的合约。它们由诸如过期日期或特定价格目标实现之类的事件触发；作为回应，智能合约自行管理，根据需要进行调整，无需外部实体的输入。
BAAS Blockchain as a Service，简称BaaS-区块链即服务
BaaS是一种帮助用户创建、管理和维护企业级区块链网络及应用的服务平台。它具 有降低开发及使用成本，兼顾快速部署、方便易用、高安全可靠等特性，是为区块链应用 开发者提供区块链服务能力的平台。BaaS通过把计算资源、通讯资源、存储资源，以及 上层的区块链记账能力、区块链应用开发能力、区块链配套设施能力转化为可编程接口， 让应用开发过程和应用部署过程简单而高效，同时通过标准化的能力建设，保障区块链应 用的安全可靠，对区块链业务的运营提供支撑，解决弹性、安全性、性能等运营难题，让 开发者专注开发。 一些术语 加密技术：安全的信息和通信技术，在区块链中用于发送和/或存储数据，确保只有目标接收人才能访问数据。 哈希：一种加密技术，在区块链中是由字母和数字编码的字符串，对链接序列中的每个区块是永久唯一的，有时也称为“数字指纹”。 区块：一种封装的数据块，其中包含 1) 自身的标识区块哈希，2) 来自链序列前一个区块的哈希，以及 3) 带时间戳的交易记录集。 区块链交易：经成员验证过的数据记录，为业务交易（例如财务或合约）提供几乎不可变的真实性证明。 Reference https://zh.</description>
    </item>
    
    <item>
      <title>了解以太坊_Ethereum</title>
      <link>https://6923403.github.io/post/eth/</link>
      <pubDate>Fri, 31 Dec 2021 00:17:17 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/eth/</guid>
      <description>前言 谈到ETH就需要先了解区块链跟BTC，单独写了一篇：
Blockchain &amp;amp; BTC
&amp;ndash;yi-
ETH https://ethereum.org/
以太坊（Ethereum）是一个去中心化的开源的有智能合约功能的公共区块链平台。 以太币（ETH 或 Ξ）是以太坊的原生加密货币。截止 2021 年 12 月，以太币是市值第二高的加密货币，仅次于比特币。以太坊是使用最多的区块链。 以太坊的特点包括下列：
智能合约（smart contract）：存储在区块链上的程序，由各节点执行，需要执行程序的人支付手续费给节点的矿工或权益人。[6] 分布式应用程序：以太坊上的分布式应用程序不会停机，也不能被关掉。 代币（tokens）：智能合约可以创造代币供分布式应用程序使用。分布式应用程序的代币化让用户、投资者以及管理者的利益一致。代币也可以用来进行首次代币发行。 叔块（uncle block）：将因为速度较慢而未及时被收入母链的较短区块链并入，以提升交易量。使用的是有向无环图的相关技术。[6] 权益证明（proof-of-stake）：相较于工作量证明更有效率，可节省大量在挖矿时浪费的电脑资源，并避免特殊应用集成电路造成网络中心化。平行运作中，预计2022年与主链合并。 燃料（gas）：由交易手续费的概念扩展，在执行各种运算（computation）时需计算燃料消耗量，并缴交燃料费，包括发送以太币或者其他代币也被视为一种运算动作。 分片（sharding）：减少每个节点所需纪录的资料量，并透过平行运算提升效率。预计于2022年实现。 以太坊白皮书原版：https://ethereum.org/zh/whitepaper/#further-reading
以太坊白皮书中英对照：https://zhuanlan.zhihu.com/p/33779523
以太坊白皮书简体中文：https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6
以太币 以太坊区块链上的代币称为以太币（Ether），代码为ETH，可在许多加密货币的外汇市场上交易，它也是以太坊上用来支付交易手续费和运算服务的介质
工作量证明 (POW, Proof of work)
工作量证明是一个为矿工设置挖矿难度和规则的基础性算法。 挖矿就是“工作”本身。 挖矿是向区块链中添加有效区块。 权益证明机制(POS, Proof of stake)
权益证明是一种区块链网络达成共识的共识机制。(彩票) 其他
权威证明(POA, Proof of authority)
由投票机制的“许可区块链共识” DEFI 去中心化金融 (DEcentralized FInance）。
CeFi = Centralized Finance 中心化金融（传统金融）
DEFI - The Future Of Finance Explained: https://www.youtube.com/watch?v=H-O3r2YMWJ4&amp;amp;t=2s
What is DEFI? Decentralized Finance Explained: https://www.</description>
    </item>
    
    <item>
      <title>云服务</title>
      <link>https://6923403.github.io/post/cloud/</link>
      <pubDate>Fri, 31 Dec 2021 00:10:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cloud/</guid>
      <description>2021留下的坑 今天看到这篇预测想起来了， 来回填一下。
https://cn.investing.com/news/stock-market-news/article-2072927
云计算 2006年3月，亚马逊推出弹性计算云服务。
云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。 云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。 因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒钟）完成对数以万计的数据的处理，从而达到强大的网络服务。
现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。
混合云 混合云是云计算的一种类型，它将本地基础结构（或私有云）与公有云结合在一起。使用混合云，可以在两种环境之间移动数据和应用。
云服务 软件即服务（SaaS）：消费者使用应用程序，但并不掌控操作系统、硬件或运作的网络基础架构。是一种服务观念的基础，软件服务供应商，以租赁的概念提供客户服务，而非购买，比较常见的模式是提供一组账号密码。例如：Adobe Creative Cloud，Microsoft CRM与Salesforce.com。
平台即服务（PaaS）：消费者使用主机操作应用程序。消费者掌控运作应用程序的环境（也拥有主机部分掌控权），但并不掌控操作系统、硬件或运作的网络基础架构。平台通常是应用程序基础架构。例如：Google App Engine。
基础设施即服务（IaaS）：消费者使用“基础计算资源”，如处理能力、存储空间、网络组件或中间件。消费者能掌控操作系统、存储空间、已部署的应用程序及网络组件（如防火墙、负载平衡器等），但并不掌控云基础架构。例如：Amazon AWS、Rackspace。
提起SaaS，PaaS避不开Salesforce(赛富时)。
赛富时公司于1999年2月在特拉华州注册成立。公司是全球领先的客户关系管理（CRM）技术，将公司和客户联系在一起。公司成立于1999年，通过现有和新兴技术（包括云、移动、社交、区块链、语音和人工智能（“AI”）等），公司使各种规模和行业的公司能够以新的方式与客户联系，从而实现业务转型。
贝尼奥夫长期推广SaaS（Software As A Service，软件即服务）的观念，后来更开创新的里程碑，提出PaaS（Platform As A Service，平台即服务），并和Parker Harris, Dave Moellenhoff, Frank Dominguez等人创立Salesforce.com公司来提供PaaS服务，他将Salesforce.com的市场定位为“软件终结者”。
云游戏 斗鱼云游戏、虎牙云游戏、腾讯START都体验了。 网速足够与真机无异。
云安全 安全服务边缘 (SSE)
云数据 边缘计算 单点登录 okta, workos
术语缩写: IaaS (Infrastructure as a Service：基础设施即服务） PaaS (Platform as a Service：平台即服务） SaaS (Software as a Service：软件即服务) BaaS（Backend as a Service：后台即服务） DaaS（Date as a Server：数据即服务） CaaS (Communications as a Service：基础设施即服务） MaaS（M2M（Machine to Machine) As A Service：物联网服务） TaaS （everyThing as a Service：泛在服务) Reference: https://zh.</description>
    </item>
    
    <item>
      <title>企业估值</title>
      <link>https://6923403.github.io/post/business-valuation/</link>
      <pubDate>Wed, 22 Dec 2021 15:23:02 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/business-valuation/</guid>
      <description>未填的坑3
基本分析 财务报表 企业护城河 影响因素 企业估值 市盈率 投资策略 价值投资 成长投资 事件驱动投资 技术分析 限时限额加码止盈投资法 基本面分析 https://zh.wikipedia.org/wiki/Category:%E5%9F%BA%E6%9C%AC%E9%9D%A2%E5%88%86%E6%9E%90
基本面分析是一种证券或股票估价的方法，利用财务分析和经济学上的研究来评估企业价值或预测证券（如股票或债券等）价值的走势。这些被分析的基本资料可以包含一家公司的财务报表和非财务上的信息，如商品需求增长性的预测、企业比较、新制度的影响分析或人口的改变。它通常和所谓的技术分析相对，技术分析在研究证券价值的趋势时，并不使用到市场本身以外的因素来做预测。
投资者使用基本分析来检验一家公司的财务状况、其内部运作和其产业市场，用以来了解这家公司的稳定性和增长潜力。被检验的项目可能包括有发放股息、公司管理资金方法、公司的负债值和公司收支增长。一个利用基本分析的人会看基本分析的结果来决定要操作多头或空头。
基本面分析的目标可能有：
对公司股票进行估值，并预测未来价格趋势。 预测公司未来表现。 评价公司管理体系，为内部商业决策做支持。 计算违约风险。 企业估值 资产估值: 维基百科
Reference:
http://abcexchange.io/terms/b/business-valuation.asp
聊聊“市盈率”那点事
东财-股民学校
MBA智库百科
投资策略</description>
    </item>
    
    <item>
      <title>市盈率</title>
      <link>https://6923403.github.io/post/per/</link>
      <pubDate>Wed, 22 Dec 2021 15:21:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/per/</guid>
      <description>未填的坑2
市盈率 ＝ ∑(收盘价×发行数量)/∑(每股收益×发行数量) </description>
    </item>
    
    <item>
      <title>Ubuntu20_install_mysql</title>
      <link>https://6923403.github.io/post/ubuntu_install_mysql/</link>
      <pubDate>Sat, 18 Dec 2021 17:36:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu_install_mysql/</guid>
      <description>安装mysql8.0 apt-get update apt-get install mysql-server 设置远程访问 #远程 vim /etc/mysql/mysql.conf.d/mysqld.cnf bind-address改为0.0.0.0 #重启 /etc/init.d/mysql restart #设置权限与密码 use mysql; ALTER USER &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED WITH mysql_native_password BY &amp;#39;密码&amp;#39;; #使用mysql_native_password修改加密规则 ALTER USER &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;密码&amp;#39; PASSWORD EXPIRE NEVER; #更新一下用户的密码 UPDATE user SET host = &amp;#39;%&amp;#39; WHERE user = &amp;#39;root&amp;#39;; #允许远程访问 #刷新cache中配置 刷新权限 flush privileges; quit; 初始化 #初始化 mysql_secure_installation 1. NO 2. 输入密码 3. 其余全部默认 # 检查 systemctl status mysql.service 状态 #开启 service mysql start # 关闭 service mysql stop # 重启 service mysql restart # 状态 systemctl status mysql.</description>
    </item>
    
    <item>
      <title>通过typeid()获取类名</title>
      <link>https://6923403.github.io/post/typeid_get_class_name/</link>
      <pubDate>Wed, 15 Dec 2021 19:39:23 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/typeid_get_class_name/</guid>
      <description>时间一长，模版跟继承还多容易忘，这样比看代码更效率些。
template&amp;lt;typename T&amp;gt; TC_LockT&amp;lt;T&amp;gt;::TC_LockT(const T &amp;amp;mutex) { std::cout &amp;lt;&amp;lt; &amp;#34;1class name = &amp;#34; &amp;lt;&amp;lt; typeid(mutex).name() &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;2class name = &amp;#34; &amp;lt;&amp;lt; typeid(*this).name() &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>氦气概念</title>
      <link>https://6923403.github.io/post/%E6%B0%A6%E6%B0%94%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 08 Dec 2021 00:01:52 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E6%B0%A6%E6%B0%94%E6%A6%82%E5%BF%B5/</guid>
      <description>2021-12-08: 氦气短缺的背后
百科 百度百科：https://baike.baidu.com/item/氦气/8572782
氦气，是一种稀有气体，英文名为Helium，元素符号为He，原子序数2。 [1] 为无色无味的惰性气体，化学性质不活泼，一般状态下很难和其它物质发生反应。 德国林德 氦寡头垄断企业
百度百科：https://baike.baidu.com/item/林德集团/2174084
林德（Linde）是全球领先的工业气体和工程公司之一，是工业气体、工艺与特种气体的全球领先供应商。2020年销售额为270亿美元（240亿欧元）。其所触及的终端市场涵盖众多行业，包括化工与精炼、食品与饮料、电子、医疗健康、制造业以及初级金属等。而林德所生产的工业气体则应用于各种领域——从医院用氧到用于电子行业的高纯及特种气体，再到用于清洁能源的氢气等。 简单分析 1、氦气作为稀缺战略资源，可广泛用于各行各业，以下行业氦气用量还在持续增长。
航空航天
汽车及运输设备
电子
医疗保健
焊接及金属加工
2、天然气分离法是目前唯一工业化获取氦气途径, 且成本高，不易存储。
3、中国氦气主要依赖进口, 并且价格在持续的增长
4、 当前环境氦气资源紧张，可能探索早已展开，不过进展不大。
5、中国开展氦气相关资源探索、储备。
又近一步！我国启动首座大型氦气厂(2020年07月28日) Re: http://www.cigia.org.cn/?m=home&amp;amp;c=View&amp;amp;a=index&amp;amp;aid=4227
https://xueqiu.com/4065438410/176599996
https://max.book118.com/html/2021/0602/8107126070003105.shtm
https://bg.qianzhan.com/report/detail/300/200327-592d351b.html</description>
    </item>
    
    <item>
      <title>Ubuntu20.10 install vscode</title>
      <link>https://6923403.github.io/post/ubuntu2010_install_vscode/</link>
      <pubDate>Thu, 02 Dec 2021 16:06:36 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu2010_install_vscode/</guid>
      <description>20.10有点下问题，得简单配置下
添加到bashrc 或zshrc cd ~ mkdir vscode alias code=&amp;#39;code --user-data-dir $HOME/vscode&amp;#39; root运行 vim /usr/bin/code # 跟谷歌浏览器一样 添加 --no-sandbox </description>
    </item>
    
    <item>
      <title>Ubuntu20.4 install gcc11.2.0</title>
      <link>https://6923403.github.io/post/ubuntu20_install_gcc11/</link>
      <pubDate>Thu, 02 Dec 2021 11:08:36 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu20_install_gcc11/</guid>
      <description>编译安装 make时间比较长。
#直接存sh里 wget https://mirrors.ustc.edu.cn/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.gz tar -zxvf gcc-11.2.0.tar.gz cd gcc-11.2.0 ./contrib/download_prerequisites mkdir build cd build ../configure configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-11.2 --enable-checking=release --enable-languages=c,c++ --disable-multilib --program-suffix=-11.2 make -j4 make install 设置默认gcc ln -s /usr/local/gcc-11.2/bin/g++-11.2 /usr/bin/g++-11.2 ln -s /usr/local/gcc-11.2/bin/gcc-11.2 /usr/bin/gcc-11.2 update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11.2 100 update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11.2 100 #选择版本 就一个选项的不会提供选择 update-alternatives --config gcc update-alternatives --config g++ gcc -v g++ -v Re: https://blog.csdn.net/wbvalid/article/details/119945557
https://blog.csdn.net/EternallyAccompany/article/details/108865331</description>
    </item>
    
    <item>
      <title>Wifi6与Wifi6e</title>
      <link>https://6923403.github.io/post/wifi6_6e/</link>
      <pubDate>Wed, 01 Dec 2021 11:24:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/wifi6_6e/</guid>
      <description>2021-12-01： 写在市场Wi-Fi6概念未爆发前。
以下非科普，只做了一些整理
发展历程 WI-FI 6 维基百科：https://zh.wikipedia.org/wiki/IEEE_802.11ax
百度百科：https://baike.baidu.com/item/Wi-Fi6
**Wi-Fi 6（原称：IEEE 802.11.ax）即第六代无线网络技术，是Wi-Fi标准的名称。是Wi-Fi联盟创建于IEEE 802.11标准的无线局域网技术。Wi-Fi 6将允许与多达8个设备通信，最高速率可达9.6Gbps。**o
主要先进功能:
速度更快、延时更低、容量更大、更安全、更省电
向下兼容11a/b/g/n/ac
正交频分多址（OFDMA）：在要求严格的环境中，同时面向上行链路和下行链路有效共享信道，以提高网络效率并降低延迟。
多用户多输入多输出（MU-MIMO）：允许一次传送更多下行链路数据，使接入点能够同时将数据传送到更多的设备。
160MHz信道：增大带宽，从而能够以低延迟提供更高性能。
1024正交幅度调制模式（1024-QAM）：通过在同样数量的频谱中编码更多数据，提高Wi-Fi设备的吞吐量。
目标唤醒时间（TWT）：显著延长Wi-Fi设备的电池寿命，例如物联网（IoT）设备。
发送波束成形：在给定范围内支持更高的数据速率，从而提供更大的网络容量。
4倍OFDM符号时间（symbol duration）
自适应的空闲信道评估（Adaptive CCA）
安全标准升级为WPA3
WI-FI 6E Wi-Fi 6 Extension
6GHz频段是一个全球统一的连续频谱块，范围从5925MHz扩展到7125MHz，共计1200MHz频谱，意味着额外提供了提供7个160MHz信道，或14个80MHz信道，或29个40MHz信道或59个20MHz信道。
新增6GHz频段
容量提升
速率新突破
时延更低
Re: https://www.zhihu.com/question/370062627/answer/1983878262
https://www.zhihu.com/question/370062627/answer/1983827527
视频: https://www.zhihu.com/question/370062627/answer/1286497626
https://info.support.huawei.com/info-finder/encyclopedia/zh/WiFi+6.html
https://info.support.huawei.com/info-finder/encyclopedia/zh/WiFi+6E.html
https://zhuanlan.zhihu.com/p/270389108</description>
    </item>
    
    <item>
      <title>利率、国债、股市</title>
      <link>https://6923403.github.io/post/%E5%A4%AE%E8%A1%8C%E5%88%A9%E7%8E%87_%E5%9B%BD%E5%80%BA%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Fri, 26 Nov 2021 21:36:16 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E5%A4%AE%E8%A1%8C%E5%88%A9%E7%8E%87_%E5%9B%BD%E5%80%BA%E5%85%B3%E7%B3%BB/</guid>
      <description>国债 百度百科-国债：https://baike.baidu.com/item/国债/801020
国债（national debt; government loan），又称国家公债，是国家以其信用为基础，按照债的一般原则，通过向社会筹集资金所形成的债权债务关系。国债是由国家发行的债券，是中央政府为筹集财政资金而发行的一种政府债券，是中央政府向投资者出具的、承诺在一定时期支付利息和到期偿还本金的债权债务凭证，由于国债的发行主体是国家，所以它具有最高的信用，被公认为是最安全的投资工具。
简单说就是,政府借老百姓钱, 写张欠条,欠债要还钱，国债一到期, 政府就得连本带息还给老百姓。 利率 百度百科-利率：https://baike.baidu.com/item/利率
利率是指一定时期内利息额与借贷资金额（本金）的比率。利率是决定企业资金成本高低的主要因素，同时也是企业筹资、投资的决定性因素，对金融环境的研究必须注意利率现状及其变动趋势。
利率是指借款、存入或借入金额（称为本金总额）中每个期间到期的利息金额与票面价值的比率。借出或借入金额的总利息取决于本金总额、利率、复利频率、借出、存入或借入的时间长度。利率是借款人需向其所借金钱所支付的代价，亦是放款人延迟其消费，借给借款人所获得的回报。利率通常以一年期利息与本金的百分比计算。
央行基准利率 百度百科-央行基准利率: https://baike.baidu.com/item/央行基准利率
基准利率是人民银行公布的商业银行存款、贷款、贴现等业务的指导性利率，各金融机构的存款利率可以在基准利率基础上下浮10%，贷款利率可以在基准利率基础上下浮20%。
基准利率是金融市场上具有普遍参照作用的利率，其他利率水平或金融资产价格均可根据这一基准利率水平来确定。基准利率是利率市场化的重要前提之一，在利率市场化条件下，融资者衡量融资成本，投资者计算投资收益，客观上都要求有一个普遍公认的利率水平作参考。所以，基准利率是利率市场化机制形成的核心。
加息 百度百科-加息：https://baike.baidu.com/item/加息
加息是一个国家或地区的中央银行提高利息的行为，从而使商业银行对中央银行的借贷成本提高，进而迫使市场的利息也进行增加。加息的目的包括减少货币供应、压抑消费、压抑通货膨胀、鼓励存款、减缓市场投机等等。加息也可作为提升本国或本地区货币对其它货币的币值（汇率）的间接手段。
国债是追逐低风险投资者的首选，国债投资除了吃利息之外，收益还取决于国债价格浮动。国债价格受全球交易市场决定，其价格和收益率成反比（比如10年期100元面额的国债的固定收益是2元每年，你的年化收益率大概1.84%，而如果国债价格上涨至110元，你的年化收益大概1.69%）。
国债跟利率是相反走势，利率下降，国债价格上涨，利率上升，国债价格下跌。
例如国债票面利率是 5%，而银行利率变成 10%，如果保持原票面利率，计算国债应该的价格，假设为X X * （1 + 10%） = 100 * （1 + 5%） 意思是说虽然银行利率变化了，但你还是按国债票面利率获得最终收益，最后还是拿到 105。 计算 X 约等于 95.45，这就是国债的理论价格。 相反，当银行利率下降时，为了保持固定的票面利率，国债价格会上升，还是保证你最后拿到 105。 看了三个文章简单理解
由美国十年国债的曲线图可以看出 国债与股市成反比，国债大幅度下跌，股价上升。
国债上涨，代表未来预期变好，资金撤离，国债利率大于股市股息更没必要投资股市了, 同时预期变好可能伴随着之后政策的收紧。
Re: https://www.zhihu.com/question/438523362/answer/1668529153
https://zhuanlan.zhihu.com/p/21471980
https://zhuanlan.zhihu.com/p/353299450</description>
    </item>
    
    <item>
      <title>readv_writev</title>
      <link>https://6923403.github.io/post/readv_writev/</link>
      <pubDate>Fri, 26 Nov 2021 20:31:17 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/readv_writev/</guid>
      <description>readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）。
#include &amp;lt;sys/uio.h&amp;gt; ssize_t readv(int filedes, const struct iovec *iov, int iovcnt); #散布读 ssize_t writev(int filedes, const struct iovec *iov, int iovcnt); #聚集写 其中的iovec
#include &amp;lt;sys/uio.h&amp;gt; struct iovec { ptr_t iov_base; /* Starting address */ size_t iov_len; /* Length in bytes */ }; 代码：https://github.com/6923403/CPP_Test/tree/master/test/writev
Re: https://www.cnblogs.com/nufangrensheng/p/3559304.html
https://www.cnblogs.com/youngerchina/p/5624567.html</description>
    </item>
    
    <item>
      <title>ip转换函数</title>
      <link>https://6923403.github.io/post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 21 Nov 2021 22:08:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</guid>
      <description>主机字节序（大端） 和 网络字节序（小端)
大端: 0x12 | 0x32 | 0x56
小端: 0x56 | 0x34 | 0x12
Host to Network long/short
Network to Host long/short
uint32_t htonl(uint32_t hostlong); //将主机的无符号长整型数转换成网络字节序 uint16_t htons(uint16_t hostshort); //将主机的无符号短整形数转换成网络字节序 uint32_t ntohl(uint32_t netlong); //将一个无符号长整型数从网络字节序转换为主机字节序 uint16_t ntohs(uint16_t netshort); //将一个无符号短整形数从网络字节序转换为主机字节序 https://github.com/6923403/CPP_Test/tree/master/test/hostto
#把ip地址转化为用于网络传输的二进制数值(32位) in_addr_t inet_addr(const char *cp); #少用了 int inet_aton(const char * cp, struct in_addr *inp); #将网络传输的二进制数值转化为成点分十进制的ip地址 char* inet_ntoa(struct in_addr in); #这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。 地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。 int inet_pton(int family, const char *strptr, void *addrptr); const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len); Re: https://www.</description>
    </item>
    
    <item>
      <title>股权投资之区分融资轮</title>
      <link>https://6923403.github.io/post/%E5%8C%BA%E5%88%86%E8%9E%8D%E8%B5%84%E8%BD%AE/</link>
      <pubDate>Sun, 21 Nov 2021 00:50:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E5%8C%BA%E5%88%86%E8%9E%8D%E8%B5%84%E8%BD%AE/</guid>
      <description>可转债之后第二篇,何为种子轮、天使轮、PreA轮、A轮、B轮、C轮
种子轮 https://baike.baidu.com/item/种子轮/22415260 种子轮即种子融资，是指最早阶段进行的融资方式。虽然大多数初创企业都依靠创始人自己的或其直系亲属和朋友的资金，一些企业还是会寻求第三方的“种子融资”，这是一种最早期阶段进行的融资方式。 其特点是创业者已经有了创业的方向、思路，但是还没有成形的核心团队、没有产品原型。
此时主要是依靠自身或者经典F4（Founders/其他创始人、Family/家人、Friends/朋友、Fools/傻子）
天使轮 https://baike.baidu.com/item/天使轮/22415261 天使轮，即天使投资（Angel Investment），是指个人出资协助具有专门技术或独特概念而缺少自有资金的创业家进行创业，并承担创业中的高风险和享受创业成功后的高收益，或者说是自由投资者或非正式风险投资机构对原创项目构思或小型初创企业进行的一次性的前期投资。天使投资是风险投资的一种特殊形式。 特点是核心创业团队已经成形，有了产品原型或者基本商业模式，但是产品还没有研发完成、商业模式还没有验证。
天使轮的投资人多是专业的早期投资机构和天使投资人，投资金额通常在几百万元，但是对于少部分领域和团队比较特殊的项目，天使轮的融资金额就可能突破千万元。
Pre-A轮 A轮前的加油续航
PreA轮是一个夹层轮，融资人可以根据自身项目的成熟度，再决定是否需要融资，倘诺项目前期整体数据已经具有一定规模，只是还未占据市场前列，那么就可以进行PreA轮融资。 特点是产品/商业尚未初具规模但是钱却没了
Pre-A轮的投资人通常是现有的天使轮投资人和部分新引进的投资人。Pre-A轮的估值通常会比天使轮略高，但又不会达到A轮可以给出的有实质性不同的估值。
以及后面还可能有A+(Pre-B)
A轮 https://wiki.mbalib.com/wiki/A轮融资 A轮融资指创业企业成立开始运营之后的第一次对外融资。 特点是较完善的产品已经上线，公司业务顺利运营，拥有一定数量的核心用户，有一定的数据支撑。证明这是一个有未来的、切实可行的项目。
A轮开始，投资人通常会是专业的创业投资机构，天使投资人会变得很少见
A轮融资的成功将会给企业带来一个翻天覆地的变化, 同时也对企业内外部起若重要作用。
B轮 B轮融资阶段 是A轮融资阶段的延续， 团队、产品、商业模式、资金、运营 等方面都是在A轮融资基础上做进一步的推进和发展以谋求企业的终极目标。. 在B轮阶段，企业的商业模式及盈利模式需要进一步完善，开始盈利的企业需要持续发力，获取更大的盈利；处于亏损的企业需要寻找新的盈利点。. 在B轮阶段多数企业开始拓展产品线，拓展新的业务领域，以获取更大的利益。 产品/商业模式得到了充足的验证，需要进一步扩大规模, 抢占市场。
此时投资人更看重商业模式的应用场景及覆盖人群。
C轮 恭喜，公司成熟，你也成为了行业翘楚。准备完成敲钟的理想。 特点产品/商业模式成熟，盈利强劲且稳定增长，业内具有一定影响力。
C轮以后的投资者更多的是大的投资机构、互联网巨头、上市公司、战略投资人等，他们对于项目的上市预期更明确。因此，对赌、回购这些在A轮、B轮项目中还可有可无的条款，在C轮以后的投资协议中会成为标配，并且往往非常严格。
以及之后的D, E, F，Pre-IPO都是为了上市做准备
Re: https://zhuanlan.zhihu.com/p/40306174
https://zhuanlan.zhihu.com/p/54320363
https://zhuanlan.zhihu.com/p/352456135</description>
    </item>
    
    <item>
      <title>Cpp内存管理</title>
      <link>https://6923403.github.io/post/cpp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 31 Oct 2021 21:51:37 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>Re: 收集 总结的真不错
https://www.cnblogs.com/findumars/p/5929831.html</description>
    </item>
    
    <item>
      <title>Metaverse</title>
      <link>https://6923403.github.io/post/metaverse/</link>
      <pubDate>Fri, 22 Oct 2021 22:59:25 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/metaverse/</guid>
      <description>元宇宙 | Metaverse We are at the beginning of the next chapter for the internet.
趋势明显，顺势而为。
Augmented reality 个人练手小项目:
wave(波)基于arkit制作: https://www.bilibili.com/video/BV1n44y147pY
unity+easyar简单用例演示: https://www.bilibili.com/video/BV1wu411f7yH
unity+easyar识别指定图片或物品播放音乐: https://www.bilibili.com/video/BV1X3411C7EW
练手项目arkit制作的小地球: https://www.bilibili.com/video/BV1DR4y1J7xM
练手项目arkit制作的小地球2: https://www.bilibili.com/video/BV1xq4y1G76k
讯息 2021-10-29：Facebook将公司名称更改为“META”，公司股票代码将从12月1日起变更为“MVRS”。 </description>
    </item>
    
    <item>
      <title>天涯 kkndme备份</title>
      <link>https://6923403.github.io/post/tianya_kk/</link>
      <pubDate>Fri, 15 Oct 2021 22:57:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tianya_kk/</guid>
      <description>随笔 原文链接: https://github.com/shengcaishizhan/kkndme_tianya
本文章只是对此贴进行一份备份
导航（持续更新中&amp;hellip;） 天涯神贴「2010年的房地产调控，我们收获了什么？写在房价暴涨前」脱水版，内容时间顺序和原贴一致，原贴中的优质非楼主写的内容，添加了引用格式便于区分。
希望调控可以降房价，希望终有一天房价下跌是人们的一厢情愿 1、人人都有居住权。房子是用来住的，不是用来炒的。 2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。 3、房价上涨造成物价上涨，人民生活变得困难 房地产调控的真正目的：防范金融风险 &amp;amp; 通过垄断实现gj利益最大化 官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真 税收从来都是向下游转嫁的 &amp;amp; 房产税迟迟不出台的真正原因 房地产的现状 房价持续上涨的本质是稀缺性让好房子成为资金最好的去处 关于垄断 1、垄断的好处是没有风险 2、垄断可以解决社会稳定 3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难 为什么政府没有那么在意民生问题？ 房产税的制定原则 维稳的本质是人民能吃饱饭 公租房是为体制内服务的 房产税一定会转嫁给租房人 巨大的税收消耗也决定了GDP必须快速增长 调控的好处是让zf利益最大化&amp;amp;防范金融风险 垄断可以控制价格，维持稳定 体制内的住房问题有国家保驾护航 依靠但又不能完全依靠开发商建公租房 体制内的住房问题不难解决 解决体制外的住房问题：国家垄断，细水长流收租 普通人买得起「优质商品房」就尽早买把 商品房和公租房的区别 提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢） 调控带来的影响 农产品的价格关系到影响稳定的吃饭问题 农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管 资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力 资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢 资金流向规律决定了洼地不会一直是洼地 大城市对近距离的小城市有虹吸效应 决定房价的因素有很多，具体情况具体分析 房价暴涨是相对于钱而言的，不是相对于实际购买力而言的 土地不稀缺，优质土地稀缺 集中发展大城市是导致优质土地稀缺的原因 为人民服务是说给人民听的 历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙 zf限制政策房的利润，那kfs就一定会偷工减料 屁股决定脑袋，人民不知厉害关系选房子，政府选农产品 各个阶层的住房问题都安排的妥妥的 顶层的岁月静好来自于底层的负重前行 底层指的是体制外底薪白领 资金终会流向具有稀缺性的资产 土地的稀缺决定了大多数人永远买不起想买的房子 不同阶层的人对收入高低有不同的理解 一二线买房只会越来越难，最终租房会成为主流 人需要一个安身之所，能买早买比晚买好 股市 如果房价不涨，那其他产品会怎么涨 zf如何利用公租房控制租房市场 城中村不会长期存在 三四线城市的未来 房租价格涨不上去，本质是买房还看起来有希望 稀缺房的价格永远涨 粮食和房子的不同是，房子无法和土地剥离 购买房价基数低的省会城市，怎么都不会亏的 房地产是资本市场还是实体经济？ 什么是傻空 什么是真买不起房 具体情况具体分析，如果看不懂，一定是没有抓住问题本质 桂林 vs 南宁 公租房的量级不会冲击到商品房的市场 贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体 重庆：高层和别墅怎么选？ 货币贬值 为什么美国人工高于中国，大多数商品的物价却低于中国 穷人赶紧买房 武汉：城市发展空间的大小，往往和房价的升值空间成正比 权利让革族成为苗族的一支 房价是否会跌，如果会，会怎么跌 通货膨胀是减缓灭亡最好的良药 货币供应不足是明朝的真正原因 经济问题是导致清朝灭亡 房产投资的几点建议 人民币对外升值，对内贬值 南宁买房建议 经济适用房都是内部分配的 普通人怎么办：尽早买房，努力挣钱抵御通胀 房价会出现很多上下波动 买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到） 收入分配改革跟体制外的人没关系 体制外的人要早早考虑养老问题 永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你 当个农民也要懂政策，要顺政策而为 存钱不如存资产，钱会贬值，资产会升值 房子越早买越好，zf想钱想疯了 利益才是zf行为的指挥棒 建议一定是建立在严肃考察的基础上 石家庄 投资最重要的是稀缺性，买房首选公务员小区 远离垃圾人 高房价或许有天会崩盘，但你等不到那一天 房子不仅要早买，而且有能力的话不要怕压力，争取一步到位 金融杠杆是炒房赚钱的放大器 要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松 性格决定命运 2012年不取消调控，还有房价维稳顺利换届考虑 洼地最终都会被填平，多数城市是早买胜于晚买 西部 短期波动属于正常现象，需要关注的是长期趋势 领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运 对于具备投资属性的商品，供求关系是指货币与商品之间的关系 早买的风险小于晚买 小开发商的房子能不能买？ 大兴土木搞建设的城市，房价都底不了 北京老式砖混板楼的最终命运？ 把房买在政府边，差不了 天子脚下：二手老房买得好，拆迁补偿少不了 3万入手北京四环，你也是幸运的 君为贵，商人、技工次之，农民为轻，打工人为底 10年的调控和08年调控的区别、带来的影响、机会 历史总是惊人的相似 关于房贷 买卖商品房会逐渐变成富人的游戏 政府还是更在意农民问题 治国需要用贪官、反贪官 二线城市典型代表 关于商铺和住宅投资 关于房产调控 关于房产税 老公房的拆迁问题 投资新房还是老公房 高端盘有房价带动作用 买房和没买房的差距 房产交易历史 契税的历史 廉租房的历史 历史上买房最好的朝代 未来房地产市场的发展 房产到期 买学区房问题 历史的结局 人口普查 昆山房价分析与买房 为什么现在租售比这么低 &amp;amp; 同小区买一套大还是两套小 买房难之回不去的乡 &amp;amp; 拉美人过得比你想象的好 租房的苦 北京西三旗 买房争取一步到位 收入稳定的家庭如何买房 北京回龙观 贷款还是全款 00后的买房需求从何而来 意大利的住房模式 中国的学术 北京远洋山水 精英的资产 北京三环塔楼 普通人买房的未来 北京房价超香港 中国的新闻不可信，精英的有钱是你想象不到的 40年的商住房没有70年的住宅有投资价值 限贷对精英没用 外汇管制决定了大部分有钱人只能在国内投资 外国国籍在中国生活是更好的选择 分期付款买房，如果房价上涨，很容易毁约 &amp;amp; 自住要选大品牌开发商 通货膨胀和房价的关系 南京买房分析 &amp;amp; 买房要做好调查分析工作 北京华清嘉园 中国的朝代更替 中国可以无限印钞吗 读史读的不是故事，还是找历史规律，以古鉴今 毛太阳的往事 北京大兴 贵阳 富人越富、穷人越穷 通货膨胀的形成原因 深圳 &amp;amp; 昆明仇书记 &amp;amp; 通货膨胀体制内高枕无忧、体制外自求多福 长春 佛山 首付提高的逻辑 四线城市 苏州工业园 住房公积金利率 济南 &amp;amp; 大规律拆迁的城市房价不会下降 公务员小区牛逼 房屋朝向只要不是纯北西就行 &amp;amp; 买房首选市中心、公园地产 政府搬迁 俄罗斯 珠海 &amp;amp; 唯一自住房不只是投资 &amp;amp; 调控是最佳的选房时机 经济崩溃，最后接盘的是老百姓 命运之矛 除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘 kkndme聊北宋、唐朝 宋代房奴 ZG民主 王安石的青苗法之国家出政策的动机 什么是社会公平 还是有很多有钱人 双轨制之体制内的福利 开发商思维 农民政权的缺点 郑州有前景 公园地产是稀缺资源 张献忠屠川 洪秀全、黄巢、李自成 朱元璋 曹参治国 晁错 民营小企业的老板和打工者 郭解 2010年的中国房地产 房奴算不上不幸，相当当不了才算 精英人群的平均收入决定房价 内地不是香港、海南 历史是一面镜子 买房一次性到位比较好 外汇管制 一线和二线 吕后篡权 小产权房 商铺和住宅 体制内外 2010年的上海 买房：物业与房贷 收紧住房贷款 买房：物业与房贷 奸臣蔡京 体制内的28原则 贾谊 kkndme 推荐的历史书 年轻人要早买房 不要低估通货膨胀 二三线城市与重庆 城区和郊区 守着金碗要饭吃 人制的社会，人就是制度 准公务员的好处 小城市房价会因为人民币贬值涨价，但依然难变现 一线杭州 二三线城市的发展靠拆迁 转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫” 拆迁补偿 城市底层 垄断企业 农村自来水 袁盎 二三线城市，选新城还是老城 在中国，普通人手上闲钱不多的人被剥削 三分天注定七分靠打拼 人的前程有的时候不掌握在自己手里 河南郑州与洛阳 杭州 西安与重庆 谢国中「空置率」 打工不如有一技之长的小老板 一线、二线的生活 讲故事含沙射影ZG之房子不属于市场经济 什么是好的政策 李商隐「渣男」祖师爷 西五环内的别墅，是相当稀缺的资源 正文 希望调控可以降房价，希望终有一天房价下跌是人们的一厢情愿 2010年的房地产调控，让很多人看到了希望：让房价降得再猛烈些吧。还有人更是幸灾乐祸似的呼喊：让房地产赶紧崩盘吧。让没房子的好好看看有房子的笑话，是人生的一大快事。</description>
    </item>
    
    <item>
      <title>I/O多路复用</title>
      <link>https://6923403.github.io/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Sun, 10 Oct 2021 10:00:00 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>I/O模型 https://6923403.github.io/post/server_actor/
I/O多路复用 Select、Poll、Epoll, 多路是指？多个业务方（句柄）并发下来的 IO 。 复用是指？复用这一个后台处理程序。
Select select()函数主要解决的是accept()函数阻塞问题，而没有解决recv()和send()函数阻塞问题
#include &amp;lt;sys/select.h&amp;gt; int select(int nfds, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout); nfds参数指定被监听的文件描述符的总数。
readfds, writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。
#include &amp;lt;sys/select.h&amp;gt; int FD_ZERO(int fd, fd_set *fdset); //一个 fd_set类型变量的所有位都设为 0 int FD_CLR(int fd, fd_set *fdset); //清除某个位时可以使用 int FD_SET(int fd, fd_set *fd_set); //设置变量的某个位置位 int FD_ISSET(int fd, fd_set *fdset); //测试某个位是否被置位 timeout参数用来设置select函数的超时时间 struct timeval{ long tv_sec; /*秒 */ long tv_usec; /*微秒 */ } select示例代码: select.cpp Poll #include &amp;lt;poll.</description>
    </item>
    
    <item>
      <title>总结mmap(零拷贝)</title>
      <link>https://6923403.github.io/post/use_mmap/</link>
      <pubDate>Mon, 04 Oct 2021 21:10:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_mmap/</guid>
      <description>总结分析传统io, mmap, sendfile
传统IO 通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过write()写入到socket缓冲区，最后写入目标。
整个过程发生了4次用户态和内核态的上下文切换和4次拷贝
用户进程通过read()方法向操作系统发起调用，此时上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，read()返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将应用缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回 mmap #用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize); 调用 mmap() 系统调用对文件进行映射后，用户对映射后的内存进行读写实际上是对文件缓存的读写，所以减少了一次系统调用，从而加速了对文件读写的效率。
整个过程发生了4次用户态和内核态的上下文切换和3次拷贝，具体流程如下：
用户进程通过mmap()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 上下文从内核态转为用户态，mmap调用返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回 munmap int munmap(void *addr, size_t len); munmap()用来取消参数start 所指的映射内存起始地址，参数length 则是欲取消的内存大小。当进程结束或利用exec 相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。
Sendfile sendfile函数在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。
ssize_t senfile(int out_fd,int in_fd,off_t* offset,size_t count); 整个过程发生了2次用户态和内核态的上下文切换和3次拷贝
用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，sendfile调用返回 sendfile+DMA Scatter/Gather 它将读缓冲区中的数据描述信息&amp;ndash;内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程
整个过程发生了2次用户态和内核态的上下文切换和2次拷贝，其中更重要的是完全没有CPU拷贝
用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储 CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区 DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡 sendfile()调用返回，上下文从内核态切换回用户态 Re: https://zhuanlan.</description>
    </item>
    
    <item>
      <title>Ubuntu20开机自启脚本</title>
      <link>https://6923403.github.io/post/ubuntu20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Sun, 03 Oct 2021 12:08:21 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/</guid>
      <description>我测试了好几篇文章,终于有个成功了
local.service vim /etc/systemd/system/rc-local.service
输入以下内容:
[Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.local [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardOutput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target rc.local vim /etc/rc.local
#!/bin/sh -e ## rc.local sh /root/startup.sh exit 0 收尾 授权 chmod +x /etc/rc.local
自启动 systemctl enable rc-local
运行 systemctl start rc-local.service
查看状态 systemctl status rc-local.service
先别重启, ps -x配合grep搜索关键字看看进程启动没有
之后保存好文件重启进行测试 再次查看是否启动
举个例子:
startup.sh
#!/bin/bash -e cd /root/News-D/ nohup python3 main.py &amp;amp; cd /root/News-D/Finance/ nohup python3 -m http.server 20777 &amp;amp; rm nohup.</description>
    </item>
    
    <item>
      <title>Brew_ffmpeg_install</title>
      <link>https://6923403.github.io/post/brew_ffmpeg_install/</link>
      <pubDate>Tue, 07 Sep 2021 20:25:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/brew_ffmpeg_install/</guid>
      <description>2021-09-07 发帖时间为安装时间 有些包下载较慢可以挂vpn
ffmpeg 完全安装 解决brew install ffmpeg会报错
install brew tap homebrew-ffmpeg/ffmpeg brew options homebrew-ffmpeg/ffmpeg/ffmpeg brew install ffmpeg --HEAD ffmpeg -version 安装过程如果缺库 https://formulae.brew.sh/formula/ffmpeg 到这个链接查
现在这步好像不需要了
#完全安装 brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-chromaprint --with-fdk-aac --with-game-music-emu --with-libbluray --with-libbs2b --with-libcaca --with-libgsm --with-libmodplug --with-librsvg --with-libsoxr --with-libssh --with-libvidstab --with-libvmaf --with-libxml2 --with-opencore-amr --with-openh264 --with-openjpeg --with-openssl --with-rav1e --with-rtmpdump --with-rubberband --with-speex --with-srt --with-tesseract --with-two-lame --with-webp --with-xvid --with-zeromq --with-zimg Re: http://www.manks.top/ffmpeg-install-mac.html
https://www.jianshu.com/p/85fffceddf04
https://zhuanlan.zhihu.com/p/90099862</description>
    </item>
    
    <item>
      <title>News-M Tutorial</title>
      <link>https://6923403.github.io/post/news_wps/</link>
      <pubDate>Fri, 27 Aug 2021 16:40:00 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/news_wps/</guid>
      <description>https://github.com/VcSpace/News-M.git 闻讯——获取主流财经新闻网站新闻信息获取, 将数据聚合、归类并写入表格中 。
News-M &amp;ndash;News Spider, Crawling news from mainstream financial news websites, categorize and write data into tables .
目的 时间与精力是有限的 为了节省查阅信息的时间成本故此创作News-M用来快捷提取有效信息, 节约时间, 放松精力。
Time and energy are limited. In order to save the time cost of consulting information, news-m is created to quickly extract effective information, save time and relax energy.
运行程序 #Run pip install -r requirements.txt python3 main.py 如果你想启用网盘功能 在命令行运行bypy info获取token, 在main.py将bd_flag改为True
If you want to enable the network disk function, run bypy info on the command line to get the token, and BD will be displayed in main.</description>
    </item>
    
    <item>
      <title>News M定时运行</title>
      <link>https://6923403.github.io/post/news-m%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Tue, 24 Aug 2021 21:50:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/news-m%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C/</guid>
      <description>#把原来的main设置为start函数 在末尾添加如下代码即可 #https://blog.csdn.net/ainivip/article/details/106296599 if __name__ == &amp;#39;__main__&amp;#39;: while True: logger = logging.getLogger() logger.setLevel(logging.INFO) log_time = time.strftime(&amp;#34;%Y_%m_%d&amp;#34;, time.localtime()) # 刷新 logfile = &amp;#34;./&amp;#34; + log_time + &amp;#34;.log&amp;#34; fh = logging.FileHandler(logfile,mode=&amp;#39;w&amp;#39;) fh.setLevel(logging.INFO) while True: formatter = logging.Formatter(&amp;#34;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&amp;#34;) fh.setFormatter(formatter) logger.addHandler(fh) time_now = time.strftime(&amp;#34;%H&amp;#34;, time.localtime()) # 刷新 if time_now == &amp;#34;21&amp;#34; or time_now == &amp;#34;10&amp;#34;: # 设置要执行的时间 start() logger.info(&amp;#34;sleep(20000) start news_d&amp;#34;) time.sleep(1500) elif time_now == &amp;#34;00&amp;#34;: logger.info(&amp;#34;new day, log end&amp;#34;) time.</description>
    </item>
    
    <item>
      <title>Linux_ssh_nohup</title>
      <link>https://6923403.github.io/post/linux_ssh_nohup/</link>
      <pubDate>Sun, 22 Aug 2021 22:03:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_ssh_nohup/</guid>
      <description>Linux系统SSH客户端断开后保持进程继续运行配置方法
nohup python3 main.py &amp;amp; Re: https://help.aliyun.com/document_detail/42523.html</description>
    </item>
    
    <item>
      <title>Python每天固定时间运行某程序代码</title>
      <link>https://6923403.github.io/post/python%E6%AF%8F%E5%A4%A9%E5%9B%BA%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E6%9F%90%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 22 Aug 2021 22:01:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/python%E6%AF%8F%E5%A4%A9%E5%9B%BA%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E6%9F%90%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/</guid>
      <description>import time while True: time_now = time.strftime(&amp;#34;%H%M&amp;#34;, time.localtime()) # 刷新 if time_now == &amp;#34;00:01&amp;#34;: # 设置要执行的时间 # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 elif time_now == &amp;#34;08:01&amp;#34;: # 设置要执行的时间: # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 elif time_now == &amp;#34;16:01&amp;#34;: # 设置要执行的时间: # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 Re: 原文链接：https://blog.csdn.net/ainivip/article/details/106296599</description>
    </item>
    
    <item>
      <title>个人理解可转债</title>
      <link>https://6923403.github.io/post/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%8F%AF%E8%BD%AC%E5%80%BA/</link>
      <pubDate>Thu, 19 Aug 2021 21:35:40 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%8F%AF%E8%BD%AC%E5%80%BA/</guid>
      <description>结合了个人理解 可能有差错 可以评论指出
由于最近个人关注的股有一支要发转债, 故来了解下。
什么是可转换债券 可转换债券是债券持有人可按照发行时约定的价格将债券转换成公司的普通股票的债券。如果债券持有人不想转换，则可以继续持有债券，直到偿还期满时收取本金和利息，或者在流通市场出售变现。如果持有人看好发债公司股票增值潜力，在宽限期之后可以行使转换权，按照预定转换价格将债券转换成为股票，发债公司不得拒绝。该债券利率一般低于普通公司的债券利率，企业发行可转换债券可以降低筹资成本。可转换债券持有人还享有在一定条件下将债券回售给发行人的权利，发行人在一定条件下拥有强制赎回债券的权利。
这里自己去查下百科就行了： https://baike.baidu.com/item/可转换债券/397601
基本概念 三大特征:
债权性 股权性 可转换性 可转债有可能赚但不会亏的保底性质
比如可转债的转股价为10元, 而当前股价为20， 一张债券100块面额根据转股价可转为10股 收益率100%。
当股价为5元时此时转股亏损50%，正常人都不会转股。选择不转股到期拿回本金和利息，保底性质
发债前打压股价 上市公司正股价是由市场决定，但是转股价是在发行前就可以制定的。根据相关规定，转股价为可转债募集说明书公告日前20个交易日公司股票交易均价和前一交易日公司股票交易均价二者之间的较高者。
所以上市公司发行可转债前打压股价就是为了让转股价更低一点，从而促使投资者转股。如果转股价定得太高，转债上市后正股价低于转股价，那么投资者是不会愿意转股的。
可转债发布之后，利好消息推高股价。
转股之后债权变成了股权，企业也不必再支付额外的利息。
核心就是转股价低于正股价 想方设法让你转股，符合条件的强制赎回。 有点人家吃肉我喝汤的感觉。
两个重要条款 可转债有转股价下调条款，强制赎回条款。
转股价向下修正条款: https://baike.baidu.com/item/转股价向下修正条款/10596894
赎回条款：https://wiki.mbalib.com/wiki/赎回条款
Re:
https://zhuanlan.zhihu.com/p/367802793
https://www.csai.cn/licai/1306470.html</description>
    </item>
    
    <item>
      <title>类静态成员初始化、赋值</title>
      <link>https://6923403.github.io/post/%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 18 Aug 2021 19:29:15 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>类静态成员类外初始化与在另一个类成员函数赋值
为什么类的静态成员要在类外初始化 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
C++的静态成员是需要初始化的（实际上需要分配一个内存，不一定需要赋值），初始化是赋一个初始值，而定义是分配内存。静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义。 静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用于相同的情况下会导致重名的问题。
静态常量成员可以在类内初始化 类的静态成员变量在另一个类赋值 //头文件代码 a.h class SPostMsgToMain { public: //存储消息线程的指针 static CWinThread* m_pThread; }; //a.cpp SPostMsgToMain::m_pThread=NULL; //此处为静态成员的定义。该定义要写在实现文件里面，不能写在头文件里面 //thread.cpp QueryThread::QueryThread(void) { SPostMsgToMain::m_pThread = this; } Re:
https://blog.csdn.net/sevenjoin/article/details/81772792
https://blog.csdn.net/lvquanye9483/article/details/81946116
下面是09年已经删除的帖子，这是bing保存的快照:
http://cncc.bingj.com/cache.aspx?q=类的静态成员变量在另一个类赋值</description>
    </item>
    
    <item>
      <title>grpc install</title>
      <link>https://6923403.github.io/post/grpc_install/</link>
      <pubDate>Thu, 22 Jul 2021 00:13:51 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/grpc_install/</guid>
      <description>macos11.4下 grpc-cpp安装
lib brew install autoconf automake libtool shtool gflags cmake pkg-config grpc-cpp git clone https://github.com/grpc/grpc.git git checkout -b v1.38.x # 下载所有子模块 git submodule update --init --recursive protobuf3 install git clone https://github.com/google/protobuf.git cd protobuf git checkout v3.9.0 sh ./autogen.sh ./configure --prefix=/usr/local/protobuf/ make sudo make install 查看版本
cd /usr/local/protobuf/bin/ ./protoc --version 将下面指令加入.bash_profiile中之后执行source ~/.bash_profile
export PATH=$PATH:/usr/local/protobuf/bin/ grpc install cd grpc export MY_INSTALL_DIR=$HOME/.local mkdir -p $MY_INSTALL_DIR export PATH=&amp;#34;$MY_INSTALL_DIR/bin:$PATH&amp;#34; mkdir -p cmake/build pushd cmake/build cmake -DgRPC_INSTALL=ON \ -DgRPC_BUILD_TESTS=OFF \ -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \ .</description>
    </item>
    
    <item>
      <title>Centos8 install redis</title>
      <link>https://6923403.github.io/post/centos8_install_redis/</link>
      <pubDate>Mon, 12 Jul 2021 13:28:17 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/centos8_install_redis/</guid>
      <description>安装过程(转)
https://blog.csdn.net/qq_34892981/article/details/110181452</description>
    </item>
    
    <item>
      <title>Centos8 install docker</title>
      <link>https://6923403.github.io/post/centos8_install_docker/</link>
      <pubDate>Mon, 12 Jul 2021 12:25:06 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/centos8_install_docker/</guid>
      <description>yum update -y sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io -y sudo yum install docker-ce docker-ce-cli sudo systemctl start docker docker --version sudo systemctl enable docker 出现安装包问题
sudo yum install docker-ce docker-ce-cli containerd.io -y --allowerasing 更换容器镜像 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors
cd /etc/docker
vim daemon.json
# url改成自己的加速器地址，亦可使用该地址 { &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://k01sfudd.mirror.aliyuncs.com&amp;#34;] } systemctl daemon-reload systemctl restart docker Re: https://blog.csdn.net/jcmj123456/article/details/117742182
https://www.jianshu.com/p/6d9e725da273</description>
    </item>
    
    <item>
      <title>汉程网</title>
      <link>https://6923403.github.io/post/hanchengwang/</link>
      <pubDate>Fri, 09 Jul 2021 22:37:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/hanchengwang/</guid>
      <description>几天前聚餐小饮一杯48度蒸馏酒，微醺。回家之, 看书有感，口出惊言: &amp;ldquo;道可道也&amp;hellip;， 生之，养之&amp;hellip;&amp;rdquo;
趁着还有点意识利用以前写过的项目拼凑了一下获取了一部道德经
https://github.com/6923403/hanchengwang.git 天下皆知美之为美, 恶已; 皆知善为善，斯不善矣。
项目只需修改参数亦可下载其他古籍， 请自行研究使用
项目提供本人制作的道德经成品mobi\word版本, 已内置目录
项目提供本人制作的成品mobi\word版本, 已内置目录
这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取
这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取
这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取
程序支持跨平台, 但仅测试了mac</description>
    </item>
    
    <item>
      <title>TCP_三次握手与四次挥手</title>
      <link>https://6923403.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Sun, 20 Jun 2021 18:12:03 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>三次握手 第一次握手:
(客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。)
Client端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。
第二次握手:
(服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。)
Server端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack=seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK=1、SYN=1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。
第三次握手:
(客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1)
Client收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。
四次挥手 第一次挥手
(主动方发送Fin+Ack报文,并置发送序号为x)
假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN=1，这个控制位代表客户端想要断开连接；序列号seq=u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。
第二次挥手
(被动方送ACK报文,并置发送序号为Z,在确认序号为x+1)
服务端收到客户端的报文后发出确认报文，控制位ACK=1；确认号ack=u+1；序列号seq=v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。
第三次挥手
(被动方发送Fin+Ack报文,并置发送序号为Y,在确认序号为x)
客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN=1，表示服务端向客户端发送断开连接请求；确认标志ACK=1；确认序号ack=u+1；序号seq=w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。
第四次挥手
(主动方发送ack报文,并置发送序号为x,在确认序号为Y)
客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK=1；确认号ack=w+1;序号seq=u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。
相关面试题
TCP三次握手？为什么不是两次？为什么不是四次？
第一次握手, 目的端确认源端的发送能力、目的端确认目的端的接受能力 第二次握手, 源端确认源端的发送能力、源端确认源端的接受能力、源端确认目的端的发送能力、源端确认目的端的接收能力 第三次握手, 目的端确认源端的接收能力、目的端确认目的端的发送能力 因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。
TCP四次挥手？为什么不是三次？为什么不是五次？
第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN=1）。
如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。
在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？
客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：
客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN=1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
Re: https://zhuanlan.zhihu.com/p/137942749
https://zhuanlan.zhihu.com/p/40013850
https://zhuanlan.zhihu.com/p/138272238</description>
    </item>
    
    <item>
      <title>Cpp_stl</title>
      <link>https://6923403.github.io/post/cpp_stl/</link>
      <pubDate>Sat, 12 Jun 2021 14:26:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_stl/</guid>
      <description>空间配置器 容器类型 标准STL序列容器: vector,string、 deque和list. 标准STL关联容器: set, multiset. map和multimap. 非标准序列容器slist和rope, slist是一个单向链表, rope本质上是一“重型&amp;quot; string 非标准的关联容器hash-set, hash-multiset. hash-map和hash-multimap 标准的非STL容器,包括数组、bitset. valarray、 stack, queue和priority_queue. Vector template &amp;lt;class T, class Alloc=alloc&amp;gt; class vector{ private: //vector的嵌套型别定义 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type&amp;amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protect: // simple_alloc是SGI STL默认的空间配置器 typedef simple_alloc&amp;lt;value_type, Alloc&amp;gt; data_allocator; iterator start;	// 表示目前使用空间的头 iterator finish;	// 表示目前使用空间的尾 iterator end_of_storage;	// 表示目前可用空间的尾 }; vector提供的接口：包括得到vector的属性接口、vector的操作接口以及构造函数：</description>
    </item>
    
    <item>
      <title>Chrono_use</title>
      <link>https://6923403.github.io/post/chrono_use/</link>
      <pubDate>Tue, 01 Jun 2021 15:57:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/chrono_use/</guid>
      <description>时间戳获取 using namespace std::chrono; auto millisec_since_epoch = duration_cast&amp;lt;milliseconds&amp;gt;(system_clock::now().time_since_epoch()).count(); auto msec = duration_cast&amp;lt;microseconds&amp;gt;(system_clock::now().time_since_epoch()).count(); auto sec_since_epoch = duration_cast&amp;lt;seconds&amp;gt;(system_clock::now().time_since_epoch()).count(); std::cout &amp;lt;&amp;lt; &amp;#34;seconds since epoch: &amp;#34; &amp;lt;&amp;lt; sec_since_epoch &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;milliseconds since epoch: &amp;#34; &amp;lt;&amp;lt; millisec_since_epoch &amp;lt;&amp;lt; std::endl; 秒seconds since epoch: 1622534342 微妙 milliseconds since epoch: 1622534342050 标准年月日+时间获取 std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()); char re_time[256] = {0}; std::strftime(re_time, sizeof(re_time), &amp;#34;%Y-%m-%d %X&amp;#34;, std::localtime(&amp;amp;now)); std::cout &amp;lt;&amp;lt; “注册时间 ” &amp;lt;&amp;lt; re_time &amp;lt;&amp;lt; std::endl; 注册时间: 2021-06-01 15:56:42</description>
    </item>
    
    <item>
      <title>B_Tree</title>
      <link>https://6923403.github.io/post/b_tree/</link>
      <pubDate>Wed, 19 May 2021 22:48:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/b_tree/</guid>
      <description>主角得拿出来文字记录下。 一个m阶的B树具有如下属性:
每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。 在含有n个关键字的B树上查找时，从根结点到关键字结点的 路径上涉及的结点数不超过log |m/2| ((n+1)/2)+1。
不错的讲解
https://www.yiibai.com/data_structure/b-tree.html https://blog.nowcoder.net/n/ef07c1ad8f8346078eeab66518152bf0 https://blog.csdn.net/alzzw/article/details/97633941 一棵m阶的B+树和m阶的B树的差异在于:
有n棵子树的结点中包含有n个关键字； 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录 的指针，叶子结点本身依关键字的大小自小而大顺序链接； 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或 最小）关键字。 实现
https://blog.csdn.net/liu1064782986/article/details/7982290
2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩（我们称它为2结点）或三个孩子（我们称它为3结点）。
一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。
这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。
一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。</description>
    </item>
    
    <item>
      <title>Kindle 防止自动更新</title>
      <link>https://6923403.github.io/post/kindle_%E5%8E%BB%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Sun, 09 May 2021 23:34:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/kindle_%E5%8E%BB%E6%9B%B4%E6%96%B0/</guid>
      <description>本来想等着越狱来着 没想到还会自动更新。。
去更新 创建了个zip再改名为update.bin.tmp.partial
chmod a=r update.bin.tmp.partial 查看文件权限 ls -ld update.bin.tmp.partial -rw-r--r-- 1 root root 208 5月 10 2021 update.bin.tmp.partial 当亚马逊向你的 Kindle 推送更新固件时，会在 Kindle 根目录创建一个名为 update.bin.tmp.partial 的临时文件（该临时文件其实就是未下载完成的新固件文件，即便网络不稳定，它也会不断续传直至下载完毕），但是如果 Kindle 根目录有同名文件，它就无法创建了，从而达到阻止 Kindle 固件自动更新的目的。
chattr 这个问题相关解答很少 帖子也很老 算了
#这个保护命令没成 root@: mount --bind /media/root/Kindle/ /mnt/kindle/ root@: chattr +i update.bin.tmp.partial - chattr: 对设备不适当的 ioctl 操作 读取 update.bin.tmp.partial 的标志时 Re:
书伴 https://bookfere.com/post/472.html</description>
    </item>
    
    <item>
      <title>Computer_network</title>
      <link>https://6923403.github.io/post/computer_network/</link>
      <pubDate>Thu, 06 May 2021 10:09:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/computer_network/</guid>
      <description>计算机网络 应用层 HTTP HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。
Cookie
HTTP 是一种不保存状态，即无状态（stateless）协议。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。 请求方法
OPTIONS
请求一些选项信息，允许客户端查看服务器的性能 GET
请求指定的页面信息，并返回实体主体 HEAD
类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST
向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 PUT
从客户端向服务器传送的数据取代指定的文档的内容 DELETE
请求服务器删除指定的页面 TRACE
回显服务器收到的请求，主要用于测试或诊断 报文
报文
是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 实体
作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。 客户端(请求报文)
请求行
用于请求的方法，请求 URI 和 HTTP 版本 状态行
含表明响应结果的状态码，原因短语和 HTTP 版本 首部字段
表示请求和响应的各种条件和属性的各类首部 通用首部 请求首部 响应首部 实体首部 服务端(响应报文) 内容同上</description>
    </item>
    
    <item>
      <title>Ubuntu20 Install Nvidia drivers</title>
      <link>https://6923403.github.io/post/install_nvidia/</link>
      <pubDate>Thu, 06 May 2021 07:29:52 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_nvidia/</guid>
      <description>2021-05-06更新 完善一下
网上教程坑特别多 这个步骤是我自己装好总结的
电脑dell
显卡1650
1. 去残留 sudo apt-get remove --purge nvidia* 2. 添加规则 vim /etc/modprobe.d/blacklist.conf
blacklist nouveau options nouveau modeset=0 3. 验证是否成功 重启 重启之后输入命令
sudo update-initramfs -u lsmod | grep nouveau 如果没有返回信息代表成功
有信息的话 先检查下步骤2 再重启, 也可忽视 我这边见过一次有返回
4.选择合适的版本 1.输入命令: ubuntu-drivers devices
2.官网：Nvidia Official website
选择合适的版本来进行安装
sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update #选择自己的版本 例如我这边安装440 sudo apt-get install nvidia-driver-440 5.选择驱动应用 ubuntu配置点击 软件和更新 ==&amp;gt; 附件驱动 然后选择合适版本的驱动
Open warehouse =&amp;gt; additional drivers =&amp;gt; choose you drivers .</description>
    </item>
    
    <item>
      <title>cpp_class权限 继承</title>
      <link>https://6923403.github.io/post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 23 Apr 2021 14:01:54 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/</guid>
      <description>补充实例： cpp_class继承: https://6923403.github.io/post/cpp_inherit
1. private, public, protected 访问标号的访问范围
private：只能由1.该类中的函数、2.其友元函数访问。 不能被任何其他访问，该类的对象也不能访问。
protected：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问。 但不能被该类的对象访问。
public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。
注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。
2 类被继承后方法属性变化
private 属性不能够被继承。 使用private继承， 父类的protected和public属性在子类中变为private； 使用protected继承，父类的protected和public属性在子类中变为protected； 使用public继承， 父类的protected和public属性不发生改变;
3 private继承和public继承的适用情况
C++将public继承视为is-a关系。private继承则并不意味着is-a关系，private继承意味着implemented-in-terms-of（根据某物实现出）。private继承意味着只有实现部分被继承，接口部分被略去。private继承在软件设计层面上没有意义，其意义只在于软件实现层面。
private继承：
1）编译器不会自动将一个子类对象转换为一个父类对象，而public继承会；
2）子类中由父类继承而来的成员（protected和public）都变为private。
implemented-in-terms-of也可以由复合实现。在应用域，复合意味着has-a；在实现域，复合意味着is-implemented-in-terms-of。尽可能使用复合实现这种关系，必要时（涉及protected成员或virtual函数时）才使用private继承。
原文链接：https://blog.csdn.net/kingzone_2008/article/details/10066181 虚继承 C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。解决二义性。
class sum {}; class a : virtual public sum { ... } class b : virtual public sum { ... }; class c:: public a, public b { ... }; </description>
    </item>
    
    <item>
      <title>Server sum</title>
      <link>https://6923403.github.io/post/server_sum/</link>
      <pubDate>Sun, 04 Apr 2021 18:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/server_sum/</guid>
      <description>c++标准网络库对比 https://6923403.github.io/post/c++标准网络库/ socket struct整理 https://6923403.github.io/post/socket_struct/ socket编程需要的头文件整理 https://6923403.github.io/post/socket_file/ socket function https://6923403.github.io/post/socket/ I/O复用 https://6923403.github.io/post//io多路复用 sem function https://6923403.github.io/post/sem/ server io actor https://6923403.github.io/post/server_actor/ timer function https://6923403.github.io/post/timer_function/ Linux Pthread 线程创建与使用 https://6923403.github.io/post/pthread/
C++11 thread https://6923403.github.io/post/cppthread/
Unp note https://6923403.github.io/post/unp_note/
TCP_IP | 计算机网络 https://6923403.github.io/post/computer_network/
exception class 异常类 https://6923403.github.io/post/cpp_exception/</description>
    </item>
    
    <item>
      <title>getopt_long</title>
      <link>https://6923403.github.io/post/getopt_long/</link>
      <pubDate>Sun, 14 Mar 2021 14:26:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/getopt_long/</guid>
      <description>2021-5-31更新
#include &amp;lt;unistd.h&amp;gt; extern char *optarg; extern int optind, opterr, optopt; #include &amp;lt;getopt.h&amp;gt; int getopt(int argc, char * const argv[],const char *optstring); int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); 参数以及返回值介绍（以上三个函数都适用）：
1、argc和argv和main函数的两个参数一致。
2、optstring: 表示短选项字符串。
形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下：
只有一个字符，不带冒号——只表示选项， 如-c 一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100 一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格,形式应该如-b 3、longopts：表示长选项结构体。结构如下：
struct option { const char *name; int has_arg; int *flag; int val; }; static struct option longOpts[] = { { &amp;#34;daemon&amp;#34;, no_argument, NULL, &amp;#39;D&amp;#39; }, { &amp;#34;dir&amp;#34;, required_argument, NULL, &amp;#39;d&amp;#39; }, { &amp;#34;out&amp;#34;, required_argument, NULL, &amp;#39;o&amp;#39; }, { &amp;#34;log&amp;#34;, required_argument, NULL, &amp;#39;l&amp;#39; }, { &amp;#34;split&amp;#34;, required_argument, NULL, &amp;#39;s&amp;#39; }, { &amp;#34;http-proxy&amp;#34;, required_argument, &amp;amp;lopt, 1 }, { &amp;#34;http-user&amp;#34;, required_argument, &amp;amp;lopt, 2 }, { &amp;#34;http-passwd&amp;#34;, required_argument, &amp;amp;lopt, 3 }, { &amp;#34;http-proxy-user&amp;#34;, required_argument, &amp;amp;lopt, 4 }, { &amp;#34;http-proxy-passwd&amp;#34;, required_argument, &amp;amp;lopt, 5 }, { &amp;#34;http-auth-scheme&amp;#34;, required_argument, &amp;amp;lopt, 6 }, { &amp;#34;version&amp;#34;, no_argument, NULL, &amp;#39;v&amp;#39; }, { &amp;#34;help&amp;#34;, no_argument, NULL, &amp;#39;h&amp;#39; }, { 0, 0, 0, 0 } }; (1)name:表示选项的名称,比如daemon,dir,out等。</description>
    </item>
    
    <item>
      <title>Tcpdump</title>
      <link>https://6923403.github.io/post/tcpdump/</link>
      <pubDate>Fri, 05 Mar 2021 22:03:34 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcpdump/</guid>
      <description>备忘 简洁明了的教程
https://www.jianshu.com/p/d9162722f189
https://www.jianshu.com/p/a57a5b0e58f0
https://zhuanlan.zhihu.com/p/74812069</description>
    </item>
    
    <item>
      <title>Tcp_ip</title>
      <link>https://6923403.github.io/post/tcp_ip/</link>
      <pubDate>Thu, 25 Feb 2021 14:28:11 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcp_ip/</guid>
      <description>计算机体系结构 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 封装 链路层 链路层主要有三个目的：
为IP模块发送和接收IP数据报； 为ARP模块发送ARP请求和接收ARP应答； 为RARP发送RARP请求和接收RARP应答。 PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。
环回接口
re: mtu
网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输
不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。
无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。
IP 地址分类:
IP 地址 ::= {&amp;lt;网络号&amp;gt;,&amp;lt;主机号&amp;gt;} IP地址类别 网络号 网络范围 主机号 IP地址范围 A 类 8bit，第一位固定为0 0——127 24bit 1.</description>
    </item>
    
    <item>
      <title>Clion_remote_debug</title>
      <link>https://6923403.github.io/post/clion_remote_debug/</link>
      <pubDate>Mon, 22 Feb 2021 22:10:27 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/clion_remote_debug/</guid>
      <description>环境 Macos Clion2020.3.2 Server: ubuntu18 设置 1. 首先添加一个ssh
2. 部署服务器上传文件
选择SFTP协议
3. 设置本地与远程文件路径
4. 上传文件
5. 设置自动上传
环境配置 安装环境
Centos # cmake yum install cmake -y # gcc &amp;amp; gdb yum install gcc-c++ -y yum install gdb -y #gdbserver yum install gdb-gdbserver -y Ubuntu apt-get install cmake apt-get install gcc apt-get install g++ apt-get install gdb apt-get install gdbserver gdbserver配置
target remote中格式是: tcp:ip:port
远程调试 编译程序 -g 或者cmkae
cmake .. -DCMAKE_BUILD_TYPE=Debug make #注意这个10234是端口 跟上图中设置的对应 gdbserver :10234 .</description>
    </item>
    
    <item>
      <title>Use_gdb</title>
      <link>https://6923403.github.io/post/use_gdb/</link>
      <pubDate>Wed, 17 Feb 2021 23:02:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_gdb/</guid>
      <description>GDB 教程 转载自：https://github.com/DAN-AND-DNA/learn-gdb-by-example-for-c.git
内容 原理 启动gdb 退出gdb 为gdb进行编译 调试程序 CoreDump简单概念 产生CoreDump文件 调试CoreDump文件 help命令 list命令 start命令 next命令 step命令 break命令 查看断点 删除断点 tbreak命令 continue命令 backtrace命令 查看当前所处的函数堆栈帧 选择函数堆栈帧 打印函数局部变量 run命令 修改变量值 查看变量类型 查看线程运行 启动图像界面 原理 断点功能一般是通过gdb捕获特定的内核信号来实现的，然后定位目标程序停止的地址来判断断点是否成功触发。大致的流程为， 首先gdb fork()出来一个子进程，该子进程启动目标程序(通过ptrace() 和 exec())， 父进程捕获该子进程的所有的信号(通过ptrace() 和 wait())，当子进程收到信号时，子进程就会被挂起，直到父进程通知其继续运行(通过ptrace())
启动gdb 1 常规启动，非常多的提示信息:
$ gdb GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt; This is free software: you are free to change and redistribute it.</description>
    </item>
    
    <item>
      <title>Timer function</title>
      <link>https://6923403.github.io/post/timer_function/</link>
      <pubDate>Sun, 07 Feb 2021 21:45:11 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/timer_function/</guid>
      <description>非活跃，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。
定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。
定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。
定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。
Linux下提供了三种定时的方法:
socket选项SO_RECVTIMEO和SO_SNDTIMEO SIGALRM信号 I/O复用系统调用的超时参数 Socket选项 struct timeval timeout; timeout.tv_sec = time; timeout.tv_usec = 0; socklen_t time_len = sizeof(timeout); ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;amp;timeout, time_len); //发送数据超时 用返回值errno判断是否达到指定时间 (errno == SO_SNDTIMEO) SIGALRM信号 sigaction结构体
struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); } sa_handler是一个函数指针，指向信号处理函数 sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息 sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号 sa_flags用于指定信号处理的行为 SA_RESTART，使被信号打断的系统调用自动重新发起 SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号 SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程 SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号 SA_RESETHAND，信号处理之后重新设置为默认的处理方式 SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数 sa_restorer一般不使用</description>
    </item>
    
    <item>
      <title>Server actor</title>
      <link>https://6923403.github.io/post/server_actor/</link>
      <pubDate>Sun, 31 Jan 2021 22:19:30 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/server_actor/</guid>
      <description>同步IO模型通常用于实现Reactor模式, 异步IO模型则用于实现Proactor模式。
Reactor Reactor模式要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。
Reactor工作流程∶
主线程往 epoll内核事件表中注册 socket 上的读就绪事件。 主线程调用epoll_wait 等待socket上有数据可读。 当socket上有数据可读时，epoll_wait 通知主线程。主线程则将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件。 主线程调用epoll_wait 等待socket可写。 当socket可写时，epoll_wait 通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。 Procactor 将多有I/O操作都交给主线程和内核来处理, 工作线程仅负责业务逻辑
Proactor工作流程∶
主线程调用aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的 man 手册）。 主线程继续处理其他逻辑。 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。 主线程继续处理其他逻辑。 当用户缓冲区的数据被写人 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。 模拟Proactor 使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程∶
主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket上有数据可读。 当 socket 上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket上的写就绪事件。 主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll wait 通知主线程。主线程往 socket 上写人服务器处理客户请求的结果。 半同步/半异步 在I/O模型中，&amp;ldquo;同步&amp;quot;和&amp;quot;异步&amp;quot;区分的是内核向应用程序通知的是何种 I/O 事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。在并发模式中，&amp;ldquo;同步&amp;quot;指的是程序完全按照代码序列的顺序执行∶&amp;quot;异步&amp;quot;指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</description>
    </item>
    
    <item>
      <title>Linux Sem</title>
      <link>https://6923403.github.io/post/sem/</link>
      <pubDate>Sat, 23 Jan 2021 20:45:54 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/sem/</guid>
      <description>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：
P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行 V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一 int sem_init(sem_t *sem, int pshared, unsigned int value)
初始化m_sem value为指定信号量的初始值
pshared为0 信号量在进程的线程之间共享 pshared非0 信号量在进程之间共享 sem_init函数用于初始化一个未命名的信号量 sem_destory函数用于销毁信号量 sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞 sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程 调用seminit函数时，操作系统将创建信号量对象，此对象中记录着“信号量值”（semaphoreValue）整数。 该值在调用sem_post函数时增1，调用semwait函数时减1。 但信号量的值不能小于0，因此，在信号量为0的情况下调用sem一vait函数时，调用函数的线程将进人阻塞状态（因为函数未返回）。 当然，此时如果有其他线程调用sem一post函数，信号量的值将变为1，而原本阻塞的线程可以将该信号量重新减为0并跳出阻塞状态。 实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为1）。 **类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制
class sem{ public: //构造函数 sem() { //信号量初始化 if(sem_init(&amp;amp;m_sem,0,0)!=0){ throw std::exception(); } } //析构函数 ~sem() { //信号量销毁 sem_destroy(&amp;amp;m_sem); } private: sem_t m_sem; }; Reference:
https://blog.csdn.net/m0_45867846/article/details/109021863</description>
    </item>
    
    <item>
      <title>Mac install mysql_8.0</title>
      <link>https://6923403.github.io/post/mac_install_mysql/</link>
      <pubDate>Mon, 18 Jan 2021 17:20:58 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/mac_install_mysql/</guid>
      <description>Downloads mysql 社区版官网下载: https://dev.mysql.com/downloads/mysql/
Start 下载之后安装一路点继续 设置完root密码
安装完成后 需要开启/关闭Mysql 系统偏好设置-Mysql图标
停止MySQL服务 sudo mysql.server stop 重启MySQL服务 sudo mysql.server restart 查看MySQL服务状态 sudo mysql.server status Connect Mysql 终端输入 vim ~/.bash_profile
PATH=$PATH:/usr/local/mysql/bin PATH=$PATH:/usr/local/mysql/support-files 再执行 source ~/.bash_profile
Login mysql -u root -p 输入密码之后成功进入mysql
mysql&amp;gt; select version();查看MySQL版本
Reference: https://www.jianshu.com/p/07a9826898c0
https://www.cnblogs.com/nickchen121/p/11145123.htm</description>
    </item>
    
    <item>
      <title>Dell7590 install macos</title>
      <link>https://6923403.github.io/post/dell7590_install_macos/</link>
      <pubDate>Sun, 17 Jan 2021 13:19:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/dell7590_install_macos/</guid>
      <description>2021-12-13更新 系统为big sur 11.4
接近完美 可以用intel网卡连接wifi 速度还不错
已知麦克风、隔空投送不能用
镜像下载 搜素：黑果小兵
big sur用11.4
重要前提 如果你没有网线，并且没有其他PC设备联网 你需要提前下载这些
https://github.com/OpenIntelWireless/itlwm/releases/ #AirportItlwm https://5435.lanzouo.com/isRfBxjxq4f #四叶草+occ Start //OC git clone https://github.com/Pinming/Dell-Inspiron-7590-Hackintosh-Opencore //Diskgenius 官网自行下载最新版 //balennaEther 官网自行下载最新版 1. 先把Dell-Inspiron-7590-Hackintosh-Opencore重命名为OC
2. 打开OC文件夹 根据屏幕改名1080P的屏幕使用config-1080p.plist需改名成config.plist 如果你是4K屏 不需要修改
3. balennaEther烧录dmg镜像文件到U盘
4. 打开Diskgenius 进入U盘的ESP分区文件夹 删除Clover文件夹 然后将OC文件夹拖入
5. 打开U盘ESP分区中的EFI 将Diskgenius程序文件夹拖进去 备用 以免出问题
提前准备好安装空间建议300g 至少200g
6. 用Diskgenius分ESP区 建议400m
7. 双系统需要保存好windows efi
安装 1. 重启F2 关闭Secure Boot安全启动 检查磁盘模式为ACHI 百度搜
2. 进入Boot Sequence &amp;lsquo;add option&amp;rsquo; 添加一个引导 选择启动文件为自己的U盘EFI(找到EFI/OC/OpenCore.efi这个文件)
3. 重启F12 选择刚才新建的启动项 选择Install mac big sur</description>
    </item>
    
    <item>
      <title>vmware16pro unlock install macos</title>
      <link>https://6923403.github.io/post/vmware_install_macos/</link>
      <pubDate>Fri, 15 Jan 2021 20:37:54 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/vmware_install_macos/</guid>
      <description>unlocker git clone https://github.com/paolo-projects/auto-unlocker.git
Download cdr https://www.mfpud.com/topics/3888/
Tutorial https://www.mfpud.com/topics/612/
进入之后先选择磁盘工具 抹掉磁盘 安装即可
Other 安装VMware Tools，参照https://www.lovyou.top/post/52.html
调整MacOS屏幕分辨率参考https://blog.csdn.net/icarus666/article/details/79529766</description>
    </item>
    
    <item>
      <title>Ubuntu20 install opencv</title>
      <link>https://6923403.github.io/post/ubuntu20_install_opencv/</link>
      <pubDate>Thu, 14 Jan 2021 22:02:25 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu20_install_opencv/</guid>
      <description>Ubuntu20.04.1LTS 2020-01-14-Successful
lib Install apt-get install -y build-essential pkg-config cmake apt-get install -y libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev Download github: git clone https://github.com/opencv/opencv.git gitee: git clone https://gitee.com/mirrors/opencv.git Install cd opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_GTK=ON -D OPENCV_GENERATE_PKGCONFIG=YES .. make -j4 make install Set echo &amp;#34;include /usr/loacal/lib&amp;#34; &amp;gt;&amp;gt; /etc/ld.so.conf ldconfig echo &amp;#34;PKG_CONFIG_PATH=\$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig&amp;#34; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#34;export PKG_CONFIG_PATH&amp;#34; &amp;gt;&amp;gt; /etc/bash.bashrc Show version pkg-config --modversion opencv4 pkg-config --cflags opencv4 pkg-config --libs opencv4 </description>
    </item>
    
    <item>
      <title>Unp_Note</title>
      <link>https://6923403.github.io/post/unp_note/</link>
      <pubDate>Mon, 11 Jan 2021 22:40:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/unp_note/</guid>
      <description>基本流程图 示范代码: https://github.com/6923403/CPP_Test/tree/master/server/socket/practice/8_socket
TCP UDP 客户角度 服务器角度 套接字选项 config_init connect_mysql init_socket setsockopt linger </description>
    </item>
    
    <item>
      <title>Pymysqlerr 1698</title>
      <link>https://6923403.github.io/post/pymysql_err_1698/</link>
      <pubDate>Mon, 30 Nov 2020 16:24:28 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/pymysql_err_1698/</guid>
      <description>pymysql.err.OperationalError: (1698, “Access denied for user ‘root’@‘localhost’”)
sudo mysql -u root mysql&amp;gt; USE mysql; mysql&amp;gt; UPDATE user SET plugin=&amp;#39;mysql_native_password&amp;#39; WHERE User=&amp;#39;root&amp;#39;; mysql&amp;gt; FLUSH PRIVILEGES; mysql&amp;gt; exit; service mysql restart </description>
    </item>
    
    <item>
      <title>Ubuntu tim_wechat</title>
      <link>https://6923403.github.io/post/ubuntu_tim_wechat/</link>
      <pubDate>Tue, 24 Nov 2020 16:50:16 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu_tim_wechat/</guid>
      <description>字体 因为wine对HiDPI不会默认适配dpi值。解决方案:
注意WINEPREFIX这个环境变量指向你的deepin wine容器目录，比如TIM在~/.deepinwine/Deepin-TIM，微信在~/.deepinwine/Deepin-WeChat 执行以下命令
WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine winecfg 打开wine设置页面，在显示选项卡中调整屏幕分辨率的dpi值即可。比如想实现win 10的150% DPI只需要将96改到144即可，125%放大则对应120。手工调整下合适的DPI就可以了
对于中文乱码是空格的情况，安装中文字体解决
sudo apt-get install fonts-droid-fallback ttf-wqy-zenhei ttf-wqy-microhei fonts-arphic-ukai fonts-arphic-uming </description>
    </item>
    
    <item>
      <title>Socket write_send</title>
      <link>https://6923403.github.io/post/socket_write_send/</link>
      <pubDate>Sat, 21 Nov 2020 14:59:41 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_write_send/</guid>
      <description>ssize_t write(int fd, const void*buf,size_t nbytes);
write函数将buf中的nbytes字节内容写入文件描述符fd.
成功时返回写的字节数.失败时返回-1. 并设置errno变量. 在网络程序中,当我们向套接字文件描述符写时有两可能. 1)write的返回值大于0,表示写了部分或者是全部的数据. 这样我们用一个while循环来不停的写入，但是循环过程中的buf参数和nbyte参数得由我们来更新。也就是说，网络写函数是不负责将全部数据写完之后在返回的。 2)返回的值小于0,此时出现了错误.我们要根据错误类型来处理. 如果错误为EINTR表示在写的时候出现了中断错误. 如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接).
ssize_t read(int fd,void *buf,size_t nbyte)
read函数是负责从fd中读取内容.
当读成功 时,read返回实际所读的字节数,如果返回的值是0 表示已经读到文件的结束了,小于0表示出现了错误.如果错误为EINTR说明读是由中断引起 的, 如果是ECONNREST表示网络连接出了问题. 和上面一样,我们也写一个自己的读函数.
recv和send函数提供了和read和write差不多的功能.不过它们提供了第四个参数来控制读写操作.
int recv(int sockfd,void *buf,int len,int flags) int send(int sockfd,void *buf,int len,int flags) 前面的三个参数和read, write一样,第四个参数可以是0或者是以下的组合
标题 内容 MSG_DONTROUTE 不查找表 MSG_OOB 接受或者发送带外数据 MSG_PEEK 查看数据,并不从系统缓冲区移走数据 MSG_WAITALL 等待所有数据 MSG_DONTROUTE:是 send函数使用的标志.这个标志告诉IP.目的主机在本地网络上面,没有必要查找表.这个标志一般用网络诊断和路由程序里面. MSG_OOB:表示可以接收和发送带外的数据.关于带外数据我们以后会解释的.
MSG_PEEK:是recv函数的使用标志, 表示只是从系统缓冲区中读取内容,而不清除系统缓冲区的内容.这样下次读的时候,仍然是一样的内容.一般在有多个进程读写数据时可以使用这个标志.
MSG_WAITALL 是recv函数的使用标志,表示等到所有的信息到达时才返回.使用这个标志的时候recv回一直阻塞,直到指定的条件满足,或者是发生了错误. 1)当读到了指定的字节时,函数正常返回.返回值等于len 2)当读到了文件的结尾时,函数正常返回.返回值小于len 3)当操作发生错误时,返回-1,且设置错误为相应的错误号(errno)
Re:
https://blog.csdn.net/petershina/article/details/7946615</description>
    </item>
    
    <item>
      <title>Python thread parameter transfer</title>
      <link>https://6923403.github.io/post/python_thread_mis/</link>
      <pubDate>Tue, 17 Nov 2020 16:13:32 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/python_thread_mis/</guid>
      <description>import threading import time def worker(): print “worker” time.sleep(1) return for i in xrange(5): t = threading.Thread(target=worker) t.start() 这段代码就使用了多线程，但是没法传递参数，而实际使用多线程，往往是需要传递参数的，这么写实现传递参数的多线程：
import threading import time def worker(number): print “worker” time.sleep(number) return for i in xrange(5): t = threading.Thread(target=worker,args=(i,)) t.start() 第一个参数是线程函数变量，第二个参数args是一个数组变量参数，如果只传递一个值，就只需要i, 如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，元组中只包含一个元素时，需要在元素后面添加逗号。
Re:
https://blog.csdn.net/chpllp/article/details/54381141</description>
    </item>
    
    <item>
      <title>Opepyxl sytle</title>
      <link>https://6923403.github.io/post/opepyxl_sytle/</link>
      <pubDate>Sun, 15 Nov 2020 19:14:58 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/opepyxl_sytle/</guid>
      <description>font(字体类)：字号、字体颜色、下划线等 fill(填充类)：颜色等 border(边框类)：设置单元格边框 alignment(位置类)：对齐方式 number_format(格式类)：数据格式 protection(保护类)：写保护 &amp;gt;&amp;gt;&amp;gt; from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font &amp;gt;&amp;gt;&amp;gt; font = Font(name=&amp;#39;Calibri&amp;#39;, size=11, bold=False, italic=False, vertAlign=None, underline=&amp;#39;none&amp;#39;, strike=False, color=&amp;#39;FF000000&amp;#39;) &amp;gt;&amp;gt;&amp;gt; fill = PatternFill(fill_type=None, start_color=&amp;#39;FFFFFFFF&amp;#39;, end_color=&amp;#39;FF000000&amp;#39;) &amp;gt;&amp;gt;&amp;gt; border = Border(left=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;), right=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;), top=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;), bottom=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;), diagonal=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;), diagonal_direction=0, outline=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;), vertical=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;), horizontal=Side(border_style=None, color=&amp;#39;FF000000&amp;#39;) ) &amp;gt;&amp;gt;&amp;gt; alignment=Alignment(horizontal=&amp;#39;general&amp;#39;, vertical=&amp;#39;bottom&amp;#39;, text_rotation=0, wrap_text=False, shrink_to_fit=False, indent=0) &amp;gt;&amp;gt;&amp;gt; number_format = &amp;#39;General&amp;#39; &amp;gt;&amp;gt;&amp;gt; protection = Protection(locked=True, hidden=False) 以上几种样式（字体、填充、边框、位置和保护）实例一旦被创建实例的属性就不可更改，只能重新创建实例。</description>
    </item>
    
    <item>
      <title>Vim_config</title>
      <link>https://6923403.github.io/post/vim_config/</link>
      <pubDate>Tue, 13 Oct 2020 18:12:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/vim_config/</guid>
      <description>编译安装 #https://www.cnblogs.com/JoiT/p/build_from_source_for_linux_vim.html apt install libncurses5-dev libgtk2.0-dev libatk1.0-dev \ libcairo2-dev libx11-dev libxpm-dev libxt-dev apt-get remove --purge vim-tiny vim vim-runtime gvim vim-common vim-gui-common vim-nox ./configure --with-features=huge \ --enable-multibyte \ --enable-gui=gtk3 \ --enable-cscope \ --prefix=/usr/local make make install 主题配置 首先要确认你的终端支持真彩，一般来说，主流的比如iTerm2, Putty, Powershell的最新版本都已经支持了。我们可以运行以下命令检测一下
(echo -e &#39;\e[48:2:1:2:3m\eP$qm\e\\&#39; ; xxd)
&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34;=&amp;gt;全局配置&amp;lt;=&amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34; &amp;#34;关闭vi兼容模式&amp;#34; set nocompatible &amp;#34;设置历史记录步数&amp;#34; set history=1000 &amp;#34;开启相关插件&amp;#34; &amp;#34;侦测文件类型&amp;#34; filetype on &amp;#34;载入文件类型插件&amp;#34; filetype plugin on &amp;#34;为特定文件类型载入相关缩进文件&amp;#34; filetype indent on &amp;#34;当文件在外部被修改时，自动更新该文件&amp;#34; set autoread &amp;#34;激活鼠标的使用&amp;#34; set mouse=a set selection=exclusive set selectmode=mouse,key &amp;#34;保存全局变量&amp;#34; set viminfo+=!</description>
    </item>
    
    <item>
      <title>CPP_Const</title>
      <link>https://6923403.github.io/post/cppconst/</link>
      <pubDate>Tue, 06 Oct 2020 15:03:40 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cppconst/</guid>
      <description>const 作用
修饰变量，变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;amp;a; // 指针变量，指向常对象 const A &amp;amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = &amp;#34;Hello&amp;#34;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int&amp;amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const 的指针与引用 指针 指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer） 引用 指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer 用法小结 指针</description>
    </item>
    
    <item>
      <title>C/S_B/S 架构</title>
      <link>https://6923403.github.io/post/cs_bs/</link>
      <pubDate>Mon, 05 Oct 2020 16:14:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cs_bs/</guid>
      <description>什么是C/S和B/S架构？
C/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。
B/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。
第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。
第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。
优点/缺点 C/S架构的优点
a. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。
b. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。
c. 客户端直接操作界面。
C/S架构的缺点
a&amp;gt; C/S架构适用于局域网，对网速的要求比较高。
b&amp;gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。
c&amp;gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。
d&amp;gt; 系统的维护也比较麻烦。
B/S架构的优点 a&amp;gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。
b&amp;gt; 浏览器只处理一些简单的逻辑事务，负担小。
c&amp;gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。
d&amp;gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。
e&amp;gt; B/S建立在广域网上，所以需要的网速要求不高。
f&amp;gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。
g&amp;gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。
B/S架构的缺点 a&amp;gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。
b&amp;gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。
第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。 https://blog.csdn.net/qq_42828949/article/details/82822901
https://blog.csdn.net/zhengqijun_/article/details/53056624</description>
    </item>
    
    <item>
      <title>Algorithm x^n</title>
      <link>https://6923403.github.io/post/recursion/</link>
      <pubDate>Sun, 04 Oct 2020 16:09:26 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/recursion/</guid>
      <description>O(1)常数阶 &amp;lt; O(logn)对数阶 &amp;lt; O(n)线性阶 &amp;lt; O(n^2)平方阶 &amp;lt; O(n^3)(立方阶) &amp;lt; O(2^n) (指数阶)
For O(n) int function1(int x, int n) { int result = 1; // 注意 任何数的0次方等于1 for (int i = 0; i &amp;lt; n; i++) { result = result * x; } return result; } Recursion O(n) int function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } Recursion2 O(n) int function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n/2) * function3(x, n/2)*x; } return function3(x, n/2) * function3(x, n/2); } Recursion3 O(logn) int function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n/2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t*t*x; } return t*t; } </description>
    </item>
    
    <item>
      <title>Linux Pthread</title>
      <link>https://6923403.github.io/post/pthread/</link>
      <pubDate>Sun, 27 Sep 2020 17:53:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/pthread/</guid>
      <description>int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)
其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构 pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用， 默认值是PTHREAD_ PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。
注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_destroy（pthread_cond_t cond）。
也可以静态的初始化条件变量
pthread_cond_t my_condition = PTHREAD_COND_INITIALIZER; pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr); // 初始化锁变量mutex。 // attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t *mutex); // 加锁（阻塞操作） pthread_mutex_trylock(pthread_mutex_t *mutex); // 试图加锁（不阻塞操作） // 当互斥锁空闲时将占有该锁；否则立即返回 // 但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t *mutex); 销毁一个不再需要的互斥量，释放系统资源。 pthread_cond_wait() / pthread_cond_timedwait -----等待条件变量，挂起线程，区别是后者，会有timeout时间， 如果到了timeout,线程自动解除阻塞，这个时间和 time()系统调用相同意义的。以1970年时间算起。 pthread_cond_signal ----激活等待列表中的线程， pthread_cond_broadcast() -------激活所有等待线程列表中最先入队的线程 条件变量
条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：
1）一个线程等待&amp;quot;条件变量的条件成立&amp;quot;而挂起； 2）另一个线程使&amp;quot;条件成立&amp;quot;（给出条件成立信号）。 为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。
注意：
1）上面这几个函数都是原子操作，可以为理解为一条指令，不会被其他程序打断
2）上面这个几个函数，必须配合使用。
3）pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，继续执行pthread_cond_wait
返回值:
pthread_mutex_lock() 和 pthread_mutex_unlock() 返回0，否则返回一个错误的提示码
pthread_mutex_trylock() 在成功获得了一个mutex的锁后返回0，否则返回一个错误提示码错误</description>
    </item>
    
    <item>
      <title>Cpp_inherit</title>
      <link>https://6923403.github.io/post/cpp_inherit/</link>
      <pubDate>Fri, 25 Sep 2020 17:44:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_inherit/</guid>
      <description>class derived-class: access-specifier base-class
class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; Rectangle rect; rect.setWidth(3); rect.setHeight(5); #rect result = 15 cout &amp;lt;&amp;lt; rect.getArea() &amp;lt;&amp;lt; endl; 访问控制和继承
访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 </description>
    </item>
    
    <item>
      <title>CPP_Mysql_use</title>
      <link>https://6923403.github.io/post/mysql_use/</link>
      <pubDate>Fri, 25 Sep 2020 16:40:02 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/mysql_use/</guid>
      <description>Mysql ex mysql_init() 获取或初始化MYSQL结构 mysql_real_connect() 连接到MySQL服务器。 mysql_query() 执行指定为“以Null终结的字符串”的SQL查询 mysql_use_result() 初始化逐行的结果集检索 mysql_field_count() 返回上次执行语句的结果集的列数 mysql_fetch_row() 从结果集中获取下一行 mysql_num_fields() 返回结果集中的字段数 class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; }; 基本步骤
使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接 Re:
https://blog.csdn.net/lisonglisonglisong/article/details/25071793</description>
    </item>
    
    <item>
      <title>Centos7 Install mongodb</title>
      <link>https://6923403.github.io/post/install_mongodb/</link>
      <pubDate>Mon, 21 Sep 2020 13:44:35 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_mongodb/</guid>
      <description>Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo
[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc Install Mongodb sudo yum install -y mongodb-org Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use Re:
https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</description>
    </item>
    
    <item>
      <title>Centos7 Install_redis</title>
      <link>https://6923403.github.io/post/install_redis/</link>
      <pubDate>Mon, 21 Sep 2020 13:32:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_redis/</guid>
      <description>升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo &amp;#34;source /opt/rh/devtoolset-9/enable&amp;#34; &amp;gt;&amp;gt; /etc/profile gcc -v 安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis 配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf
daemonize no 改为 daemonize yes 开机自启 vim /etc/systemd/system/redis.service
[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.service systemctl enable redis.</description>
    </item>
    
    <item>
      <title>Centos7 Install mysql</title>
      <link>https://6923403.github.io/post/install_mysql/</link>
      <pubDate>Sun, 20 Sep 2020 22:36:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_mysql/</guid>
      <description>1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled
3.安装Mysql5.7 sudo yum -y install mysql-community-server
4.启动Mysql sudo systemctl start mysqld
5.设置系统启动时自动启动 sudo systemctl enable mysqld
6.查看启动状态 sudo systemctl status mysqld
7.root 密码 cat /var/log/mysqld.log | grep -i &#39;temporary password&#39;
8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等
mysql_secure_installation
9.设置数据库编码为utf8 sudo vim /etc/my.cnf
[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect=&amp;#39;SET NAMES utf8&amp;#39; character-set-server = utf8 reboot sudo systemctl restart mysqld</description>
    </item>
    
    <item>
      <title>Mysql_use</title>
      <link>https://6923403.github.io/post/mysqluse/</link>
      <pubDate>Sat, 19 Sep 2020 12:08:34 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/mysqluse/</guid>
      <description>创建数据库 CREATE DATABASE IF NOT EXISTS vctest DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. CREATE DATABASE IF NOT EXISTS mytestdb;
删除数据库 drop database test1; 2. DROP DATABASE IF EXISTS mytestdb;
查看All DB show databases;
导入sql source test.sql
select
use vctest select city, phone, country from `offices`; SELECT语句由以下列表中所述的几个子句组成：
语句中的SELECT和FROM语句是必须的，其他部分是可选的。
SELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。 即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。
SELECT lastname, firstname, jobtitle FROM employees WHERE jobtitle = &amp;#39;Sales Rep&amp;#39;; INSERT 创建表</description>
    </item>
    
    <item>
      <title>Left_Right</title>
      <link>https://6923403.github.io/post/leftright/</link>
      <pubDate>Thu, 17 Sep 2020 21:49:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/leftright/</guid>
      <description>形参（形式参数）
在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。
实参（实际参数）
函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。
形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。
Re: http://c.biancheng.net/view/1853.html 左值和右值
http://c.biancheng.net/view/1510.html
常量和变量
https://www.runoob.com/cprogramming/c-variables.html
https://www.runoob.com/cprogramming/c-constants.html
http://c.biancheng.net/cpp/html/19.html</description>
    </item>
    
    <item>
      <title>About function: Volatile</title>
      <link>https://6923403.github.io/post/volatile/</link>
      <pubDate>Sun, 13 Sep 2020 18:12:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/volatile/</guid>
      <description>https://zhuanlan.zhihu.com/p/33074506
https://www.runoob.com/w3cnote/c-volatile-keyword.html</description>
    </item>
    
    <item>
      <title>Socket struct</title>
      <link>https://6923403.github.io/post/socket_struct/</link>
      <pubDate>Sun, 13 Sep 2020 17:03:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_struct/</guid>
      <description>struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。
但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：
struct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息
sin_family指代协议族，在socket编程中只能是AF_INET
sin_port存储端口号（使用网络字节顺序）
sin_addr存储IP地址，使用in_addr这个数据结构
struct in_addr { unsigned long s_addr; }; 这个数据结构是由于历史原因保留下来的，主要用作与以前的格式兼容。</description>
    </item>
    
    <item>
      <title>Socket file</title>
      <link>https://6923403.github.io/post/socket_file/</link>
      <pubDate>Sun, 13 Sep 2020 16:43:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_file/</guid>
      <description>socket编程中需要用到的头文件
sys/types.h：数据类型定义
sys/socket.h：提供socket函数及数据结构
netinet/in.h：定义数据结构sockaddr_in
arpa/inet.h：提供IP地址转换函数
netdb.h：提供设置及获取域名的函数
sys/ioctl.h：提供对I/O控制的函数
sys/poll.h：提供socket等待测试机制的函数
其他在网络程序中常见的头文件
unistd.h：提供通用的文件、目录、程序及进程操作的函数
errno.h：提供错误号errno的定义，用于错误处理
fcntl.h：提供对文件控制的函数
time.h：提供有关时间的函数
crypt.h：提供使用DES加密算法的加密函数
pwd.h：提供对/etc/passwd文件访问的函数
shadow.h：提供对/etc/shadow文件访问的函数
pthread.h：提供多线程操作的函数
signal.h：提供对信号操作的函数
sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数
建议：在编写网络程序时，可以直接使用下面这段头文件代码
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;malloc.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;sys/ioctl.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; 涉及到用户权限及密码验证问题时加入如下语句：
#include &amp;lt;shadow.h&amp;gt; #include &amp;lt;crypt.h&amp;gt; #include &amp;lt;pwd.h&amp;gt; 需要注意的是，应该在编译时链接加密算法库，即增加编译选项：-lcrypt
涉及到文件及时间操作加入如下语句
#include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;utime.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;sys/file.</description>
    </item>
    
    <item>
      <title>Cpp exception class</title>
      <link>https://6923403.github.io/post/cpp_exception/</link>
      <pubDate>Sun, 13 Sep 2020 15:13:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_exception/</guid>
      <description>class exception{ public: exception () throw(); //构造函数 exception (const exception&amp;amp;) throw(); //拷贝构造函数 exception&amp;amp; operator= (const exception&amp;amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。
exception 类的继承层次: exception 类 直接派生类
exceptopn explain login_error logic error runtime_error 运行时错误 bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常 bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常 bad_cast 使用 dynamic_cast 转换失败时抛出的异常 ios_base::failure io 过程中出现的异常 bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型 logic_error 的派生类</description>
    </item>
    
    <item>
      <title>Linux cpp put Backtrace</title>
      <link>https://6923403.github.io/post/backtrace/</link>
      <pubDate>Wed, 02 Sep 2020 14:10:18 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/backtrace/</guid>
      <description>获取Backtrace #include &amp;lt;execinfo.h&amp;gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file.</description>
    </item>
    
    <item>
      <title>Cpp11 move</title>
      <link>https://6923403.github.io/post/move/</link>
      <pubDate>Sun, 30 Aug 2020 19:57:05 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/move/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; int main() { std::string str = &amp;#34;Hello&amp;#34;; std::vector&amp;lt;std::string&amp;gt; v; //调用常规的拷贝构造函数，新建字符数组，拷贝数据 v.push_back(str); std::cout &amp;lt;&amp;lt; &amp;#34;After copy, str is \&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34;\n&amp;#34;; //调用移动构造函数，掏空str，掏空后，最好不要使用str v.push_back(std::move(str)); std::cout &amp;lt;&amp;lt; &amp;#34;After move, str is \&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34;\n&amp;#34;; std::cout &amp;lt;&amp;lt; &amp;#34;The contents of the vector are \&amp;#34;&amp;#34; &amp;lt;&amp;lt; v[0] &amp;lt;&amp;lt; &amp;#34;\&amp;#34;, \&amp;#34;&amp;#34; &amp;lt;&amp;lt; v[1] &amp;lt;&amp;lt; &amp;#34;\&amp;#34;\n&amp;#34;; } Cout:
After copy, str is &amp;#34;Hello&amp;#34; After move, str is &amp;#34;&amp;#34; The contents of the vector are &amp;#34;Hello&amp;#34;, &amp;#34;Hello&amp;#34; 函数原型 template &amp;lt;typename T&amp;gt; typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; t) { return static_cast&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t); } 原型定义中的原理实现: 公式一）X&amp;amp; &amp;amp;、X&amp;amp;&amp;amp; &amp;amp;、X&amp;amp; &amp;amp;&amp;amp;都折叠成X&amp;amp;，用于处理左值</description>
    </item>
    
    <item>
      <title>CPP11_thread</title>
      <link>https://6923403.github.io/post/cppthread/</link>
      <pubDate>Sat, 29 Aug 2020 11:44:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cppthread/</guid>
      <description>create_thread Ex 1.导入#include&amp;mdash;用于创建线程
2.导入#include&amp;ndash;用于时间延时 获取时间之类的
定义一个线程对象t1，这就自动创建了一个线程，参数就是你要线程去执行的函数，t1是变量名字 随便取
std::thread t1(func);
下面这里返回一个毫秒级别的时间间隔参数值，间隔10毫秒
std::chrono::milliseconds(10) this_thread::sleep_for（）就是让此线程休眠，可以传入休眠的时间 this_thread::sleep_for(std::chrono::milliseconds(10));让本线程休眠10毫秒 thread4
join()就是阻塞线程 阻塞的目的就是让Main主线程等待一下创建的线程，免得我函数还在跑，程序就直接结束了。 detach()将线程与线程对象分离 thread5
c++11还提供了一个lock_guard类，它利用了RAII机制可以保证安全释放mutex。
在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。
在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。
lock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；
而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。
thread6
c++11还提供了std::unique_lock
类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 unique_lock比lock_guard使用更加灵活，功能更加强大。 使用unique_lock需要付出更多的时间、性能成本。 thread7
互斥量很像的条件变量的知识
条件变量std::condition_variable的使用 std::condition_variable 是为了解决死锁而生的。 当互斥操作不够用而引入的。
比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。
std::condition_variable:
notify_one()用于唤醒一个线程； notify_all() 则是通知所有线程。 C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。
thread8
原子变量的使用
在新标准C++11，引入了原子操作的概念，原子操作更接近内核，并通过这个新的头文件提供了多种原子操作数据类型.
例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。
thread9
future与promise的使用
在c++11中增加的线程库很方便的让我们去使用线程，但是因为做出了一些改变，我们并不能像往常一样直接使用thread.join()获取线程函数的返回值了，而我们有时候又确实要利用线程函数的返回值。
thread库提供了future用来访问异步操作的结果，因为一个异步操作的结果往往不能立即获取，只能在未来的某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future .
future和promise的作用是在不同线程之间传递数据。
假设线程1需要线程2的数据，那么组合使用方式如下:
线程1初始化一个promise对象和一个future对象，promise传递给线程2，相当于线程2对线程1的一个承诺；future相当于一个接受一个承诺，用来获取未来线程2传递的值
线程2获取到promise后，需要对这个promise传递有关的数据，之后线程1的future就可以获取数据了。
如果线程1想要获取数据，而线程2未给出数据，则线程1阻塞，直到线程2的数据到达
thread10
future与package_task的使用
std::packaged_task包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果。
std::packaged_task将其包装的可调用对象的执行结果传递给一个std::future对象，与std::promise某种程度上是很像的，promise保存一个共享状态的值，而package_task保存的是一个函数。
thread11
线程异步操作函数async的用法
std::async比std::packaged_task，std::promise中，std::thread更高一层，它可以直接用来创建异步的task，异步的结果也保存在future中。完成后，外面再通过future.get/wait来获取这个未来的结果，强烈推荐使用async，我们不需要关注异步任务的结果，只要等待任务完成获取值就行了。
现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args...)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：
std::launch::async 在调用async就开始创建线程。 std::launch::deferred 延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。 第二个参数是线程函数，第三个参数是线程函数的参数。</description>
    </item>
    
    <item>
      <title>epoll use</title>
      <link>https://6923403.github.io/post/epoll_use/</link>
      <pubDate>Thu, 27 Aug 2020 12:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/epoll_use/</guid>
      <description>简介 #include &amp;lt;sys/epoll.h&amp;gt;
epoll与select
Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
触发模式 epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件 //LevelTriggered(LT) //缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。
边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。 //Edge Triggered(ET) //高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)
假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除， 则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。 总结: LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。 ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据, 也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样; 而LT模式是只要有数据没有处理就会一直通知下去的. 1. 创建一个epoll的句柄 int epoll_create(int size); 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。
这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
2. 将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //op为注册事件 epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</description>
    </item>
    
    <item>
      <title>Socket function</title>
      <link>https://6923403.github.io/post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket/</guid>
      <description>setsockopt
获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 SO_LINGER选项
struct linger { int l_onoff; int l_linger; }; l_onoff = 0, 数据保持发送完成后立即返回 l_onoff = 1, l_linger = 0, 立即放回 放弃发送, 发送rst 自身立即复位 l_onoff = 1, l_linger = 1, 阻塞到超时或数据发送完成, 保持尝试发送,超时后立即结束 SO_REUSEADDR选项
改变了通配绑定时处理源地址冲突的处理方式, 让端口释放后立即就可以被再次使用
允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。一般不用于tco服务器 允许完全重复的捆绑 Re:
https://www.cnblogs.com/my_life/articles/5174585.html
https://www.jianshu.com/p/141aa1c41f15
https://blog.csdn.net/u010144805/article/details/78579528
int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：</description>
    </item>
    
    <item>
      <title>Docker use Tutorial</title>
      <link>https://6923403.github.io/post/docker_tutorial/</link>
      <pubDate>Sat, 22 Aug 2020 16:42:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/docker_tutorial/</guid>
      <description>2021-5-30 更新 老方法不行了
Install docker apt-get install apt-transport-https ca-certificates software-properties-common curl curl -fsSL https://download.docker.com/linux/ubuntu/gpg|sudo apt-key add - sudo add-apt-repository &amp;#34;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) stable&amp;#34; apt-get update apt-get install docker-ce docker run hello-world # 重启 service docker restart Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version Dockerfile # from based nginx # run start FROM nginx # exec: RUN[&amp;#34;./go&amp;#34;, &amp;#34;dev&amp;#34;, &amp;#34;offline&amp;#34;] RUN echo &amp;#39;Nginx image&amp;#39; &amp;gt; /usr/share/nginx/html/index.</description>
    </item>
    
    <item>
      <title>Makefile template</title>
      <link>https://6923403.github.io/post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/makefile_template/</guid>
      <description>V1 ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $&amp;lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET) Reference: Makefile 文件 -只有include和src文件夹</description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://6923403.github.io/post/binary_tree/</link>
      <pubDate>Tue, 18 Aug 2020 14:40:25 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/binary_tree/</guid>
      <description>性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。
性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。
性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数 为n 2 ,则n 0 =n 2 +1。
性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x 的最大整数)。
性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序 编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:
1.如果i=1,则结点i是二叉树的根,无双亲;如果i&amp;gt;1,则其双亲是结 点。
2.如果2i&amp;gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是 结点2i。
3.如果2i+1&amp;gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。
树转换为二叉树 将树转换为二叉树的步骤如下
1.加线。在所有兄弟结点之间加一条连 线。
2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删 除它与其他孩子结点之间的连线。
3.层次调整。以树的根结点为轴心, 将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子 是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子
森林转换为二叉树 森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .
1.把每个树转换为二叉树。 2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵 二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。 当所有的二叉树连接起来后就得到了由森林转换来的二叉树。 二叉树转换为树 二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。
1.加线。若某结点的左孩子结点存在,则将 这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右 孩子结点&amp;hellip;&amp;hellip;哈,反正就是左孩子的n个右孩子结点都作为此结点的孩 子。将该结点与这些右孩子结点用线连接起来。 2.去线。删除原二叉树中所有结点与其右孩子结点的连线。 3.层次调整。使之结构层次分明。 二叉树转换为森林 判断一棵二叉树能够转换成一棵树还是森林,标准很简单,那就是只要 看这棵二叉树的根结点有没有右孩子,有就是森林,没有就是一棵树。
1.从根结点开始,若右孩子存在,则把与右孩子结点的连线删除,再查看分离后的二叉树,若右孩子存在,则连线删除&amp;hellip;&amp;hellip;,直到所有右孩子连线都删除为止,得到分离的二 叉树。 2.再将每棵分离后的二叉树转换为树即可。 树与森林的遍历 树的遍历分为两种方式。
1.一种是先根遍历树,即先访问树的根结点, 然后依次先根遍历根的每棵子树。 2.另一种是后根遍历,即先依次后根 遍历每棵子树,然后再访问根结点。比如图tree6/7中右下方的树,它的 先根遍历序列为ABEFCDG,后根遍历序列为EFBCGDA。 森林的遍历也分为两种方式:
1.前序遍历:先访问森林中第一棵树的根 结点,然后再依次先根遍历根的每棵子树,再依次用同样方式遍历除去 第一棵树的剩余树构成的森林。比如图6-11-5下面三棵树的森林,前序 遍历序列的结果就是ABCDEFGHJI。 2.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; auto ponit</title>
      <link>https://6923403.github.io/post/cpp_auto_ponit/</link>
      <pubDate>Mon, 17 Aug 2020 15:10:13 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_auto_ponit/</guid>
      <description>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 1.shared_ptr shared_ptr&amp;lt;T&amp;gt; sp
多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。
支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 3. make_shared make_shared&amp;lt;T&amp;gt;(args)
shared_ptr&amp;lt;int&amp;gt; p = make_shared&amp;lt;int&amp;gt;(42); 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象
3.weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。
可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 4.unique_ptr unique_ptr&amp;lt;T&amp;gt; up
unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</description>
    </item>
    
    <item>
      <title>Constexpr</title>
      <link>https://6923403.github.io/post/constexpr/</link>
      <pubDate>Fri, 14 Aug 2020 16:16:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/constexpr/</guid>
      <description>0.Array int url[10]; //true int url[6 + 4] //true int len = 10; int url[len] //flase 1.Constexpr #include &amp;lt;iostream&amp;gt; using namespace std; int main() { /* * If have not constexpr, CPP throw error */ constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts&amp;lt;&amp;lt; url[1] &amp;lt;&amp;lt; endl; return 0; } 2.Only have one &amp;lsquo;return&amp;rsquo; # Error constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } # True constexpr int display(int x) { return 1 + 2 + x; } 3.</description>
    </item>
    
    <item>
      <title>Shell_command($!, $@...)</title>
      <link>https://6923403.github.io/post/shell_commans/</link>
      <pubDate>Sat, 01 Aug 2020 21:31:50 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/shell_commans/</guid>
      <description>./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value $* 1 2 3 4 </description>
    </item>
    
    <item>
      <title>Arch Beautify desktop</title>
      <link>https://6923403.github.io/post/arch_desktop/</link>
      <pubDate>Thu, 30 Jul 2020 18:04:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_desktop/</guid>
      <description>1. install xorg systemctl enable dhcpcd pacman -S xorg-server xorg-xinit install tool pacman -S zsh alacritty fctix fcitx-im fcitx-configtool i3 git sh -c &amp;#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;#34; install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts add user 这一步随意
useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim login new user touch .</description>
    </item>
    
    <item>
      <title>Vmware install Archlinux </title>
      <link>https://6923403.github.io/post/arch_install/</link>
      <pubDate>Thu, 30 Jul 2020 16:43:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_install/</guid>
      <description>0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso 准备最新景象
选择UEFI引导
1. Start ls /sys/firmware/efi/efivars 这条命令检测是否在EFI模式下
禁用 reflector
systemctl stop reflector.service
检查网络, ping qq.com
Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.
Update systime
timedatectl set-ntp true 2. Partition the disks cfdisk /dev/sda #choose gpt Move to Write , enter, yes, last Quit . 3. Format the partitions 3.</description>
    </item>
    
    <item>
      <title>Hugo &amp; Markdown</title>
      <link>https://6923403.github.io/post/hugomarkdown/</link>
      <pubDate>Wed, 29 Jul 2020 18:27:35 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/hugomarkdown/</guid>
      <description>0. Hugo &amp;amp; Markdown Hugo &amp;amp;&amp;amp; MarkDown
1. MarkDown template --- title: &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; date: {{ .Date }} lastmod: {{ .Date }} draft: false tags: [ ] categories: [ ] comment: true --- 2. Hugo command hugo #build html havn&amp;#39;t draft=true hugo -D #build html and dragt=true hugo server #Start hugo server 3. Other Reference</description>
    </item>
    
    <item>
      <title>Variable function(fun(char *, ...)) and vsnprintf()</title>
      <link>https://6923403.github.io/post/variable_function/</link>
      <pubDate>Tue, 28 Jul 2020 14:44:30 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/variable_function/</guid>
      <description>void fun(char * fmt, &amp;hellip;); int vsprintf(char *str, const char *format, va_list arg);
Test programming #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; /* * Re: https://github.com/antirez/kilo/kilo.c * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html */ char buffer[80]; int editorSetstatus(const char * fmt, ...) { va_list ap; va_start(ap, fmt); int ret; ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap); va_end(ap); return (ret); } int main(int argc, char **argv) { int len = 20; editorSetstatus(&amp;#34;%d&amp;#34;, len); printf(&amp;#34;%s \n&amp;#34;, buffer); return 0; } gcc -Wall -g fun.</description>
    </item>
    
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>https://6923403.github.io/post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_install_boost/</guid>
      <description>Boost C++ is Cpp programming language that provides support for tasks and structures
Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压) Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc Compile &amp;amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr Test programming #include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;#34;func1:&amp;#34; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;#34;\tfunc2:&amp;#34; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl; sleep(2); } } int main() { boost::thread thread1(&amp;amp;func1); boost::thread thread2(&amp;amp;func2); system(&amp;#34;read&amp;#34;); isRuning = false; thread2.</description>
    </item>
    
    <item>
      <title>Ubuntu20 install FFmpeg</title>
      <link>https://6923403.github.io/post/ffmpeg_install/</link>
      <pubDate>Mon, 27 Jul 2020 17:41:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ffmpeg_install/</guid>
      <description>Start Download FFmpeg Install tool 1. install yasm
sudo apt-get install yasm if not installed yasm, os will output &amp;ldquo;nasm/yasm not found or too old. Use &amp;ndash;disable-x86asm for a crippled build.&amp;rdquo;
2. install SDL2
SDL2-2.0.12(stable)
tar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg
cd ffmpeg/ ./configure sudo make -j4 sudo make install 3. Check ffmpeg -version ffplay -version </description>
    </item>
    
  </channel>
</rss>
