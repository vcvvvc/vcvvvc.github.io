<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Vcvc Blog</title>
    <link>https://6923403.github.io/post/</link>
    <description>Recent content in Posts on Vcvc Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 04 Jan 2022 15:27:33 +0800</lastBuildDate><atom:link href="https://6923403.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022_01_04_随笔</title>
      <link>https://6923403.github.io/post/2022_01_04_note/</link>
      <pubDate>Tue, 04 Jan 2022 15:27:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2022_01_04_note/</guid>
      <description>今天AAPL突破3T$。
AAPL是我的第一重仓。
最近加仓两次都是低点入场，收益率可观。
 恭喜AAPL拿下3万亿里程碑，期待AR
 再次更新，这次截到图了。</description>
    </item>
    
    <item>
      <title>区块链｜Blockchain</title>
      <link>https://6923403.github.io/post/blockchain/</link>
      <pubDate>Fri, 31 Dec 2021 22:54:32 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/blockchain/</guid>
      <description>区块链的确是个很好的想法。
 区块链（Blockchain） 网上有说是账本，有说数据库的，我先不下定义。
起源是2008年中本聪比特币白皮书提出。区块链有望令诸多行业收益，不过目前让机构拿来玩起了资本游戏。
  比特币白皮书: https://bitcoin.org/bitcoin.pdf
  中文版本: https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf
  #维基百科 区块链是借由密码学串接并保护内容的串连文字记录（又称区块）。 每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易资料（通常用默克尔树（Merkle tree）算法计算的散列值表示）， 这样的设计使得区块内容具有难以篡改的特性。用区块链技术所串接的分布式账本能让两方有效记录交易，且可永久查验此交易。  运作 集中化： | 去中心化：| 分布式：&amp;ndash;
区块链是一种记录保存系统，在将条目添加到数据链之前会有多个源来验证该条目。数据一旦添加，便无法更改，记录随之分布到网络中的多个位置。向区块链序列添加新记录（称为区块）需要由连接到区块链网络的多个成员进行验证。这些数据区块相互链接而形成链。区块链中的全部交易对其中的所有人公开，但所有个人身份都是隐藏的。
区块链技术使用算法为每个区块分配加密哈希（包含字母和数字的唯一字符串，有时也称为“数字指纹”）。除哈希以外，每个区块还包含带时间戳的先前交易的记录集，以及前一个区块的哈希。正是这种机制确保了在链中的连续区块之间建立起不可变的链接。
加密术和时间戳的组合确保了区块链技术能自动验证这个增长的哈希序列永远不会更改。这种操作机制能够防止不按顺序插入新区块，从而防止交易数据事后被更改或伪造。
区块链由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条：
 优势 比较突出的就这几点 我直接复制过来
 去中心化 点对点 防篡改 通过共识同步化 消除了对第三方验证机构的需求 特定区块链中的全部交易对涉及的各方都可见  透明性：所有参与者都可以查看区块链中的信息，但不能修改信息。这有助于减少风险和欺诈，同时建立信任。 安全性：得益于其分布式和加密的特性，区块链很难受到非法攻击。因此，该技术能够保障业务和物联网的安全性。 消除中间商：区块链是真正意义上的点对点网络，将减少企业对某些第三方中间商的依赖。这有助于提高流程效率，减少数据输入错误几率和交易费用。 可追溯性：由于区块链数据不可篡改，因此非常适合复杂供应链中的物品跟踪和追踪或溯源。 提高效率和投资回报率：分布式账本将帮助企业打造更精简、更高效且更具盈利能力的流程，让他们快速获得投资回报。 加快流程速度：区块链可以加快多方交易场景中的流程执行速度，不受办公时间的限制，加快交易处理。 自动化：区块链具有可编程的特点。通过编程，在满足条件的情况下，区块链技术可以自动触发行动、事件和付款。 数据隐私：虽然信息在添加到区块链之前需要通过共识流程进行验证，但数据本身通过哈希代码被转换成了一系列字母和数字。网络中的参与者无法在没有密钥的情况下破译这些信息。  四种类型  公共区块链：  比特币和以太坊 (Ethereum) 是最早和最典型的区块链网络，也是公共网络。所有人都能读取公共区块链，向公共区块链发送交易，或者参与公共区块链的共识流程。公共区块链无需许可，每笔交易都是公开的，而且用户可以保持匿名状态。   半私有区块链：  半私有区块链由单一企业运行，该企业为所有满足预设标准的用户提供访问权限。尽管并未真正去中心化，但在 B2B 用例和政府应用领域，这类许可区块链仍然极具吸引力。   私有区块链：  私有区块链也是由单一企业控制，该企业决定谁可以读取区块链、向区块链发送交易和参与共识流程。但是，这种区块链完全中心化，因此只适合用作沙箱环境，无法用于实际生产。   共同体区块链： -目前，在建立区块链网络的四种方法中，共同体区块链最受欢迎。在共同体区块链中，共识流程由预先选定的团体（如企业团体）控制。可能每个人都可以读取区块链和向区块链提交交易，也可能仅限于参与者。共同体区块链被认为是“许可区块链”，最适合用于商业领域。   智能合约 智能合约是以区块链技术为基础，能够自我执行的条约；一旦满足条件，就可以自动触发行为或付款。不久的将来，智能合约将能利用资产 GPS 数据等实时信息触发事件，比如转移所有权和资金。</description>
    </item>
    
    <item>
      <title>以太坊_ETH</title>
      <link>https://6923403.github.io/post/eth/</link>
      <pubDate>Fri, 31 Dec 2021 00:17:17 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/eth/</guid>
      <description>前言 谈到ETH就需要先了解区块链跟BTC，单独写了一篇：
Blockchain &amp;amp; BTC
 ETH https://ethereum.org/
以太坊（Ethereum）是一个去中心化的开源的有智能合约功能的公共区块链平台。 以太币（ETH 或 Ξ）是以太坊的原生加密货币。截止 2021 年 12 月，以太币是市值第二高的加密货币，仅次于比特币。以太坊是使用最多的区块链。 以太坊的特点包括下列：
 智能合约（smart contract）：存储在区块链上的程序，由各节点执行，需要执行程序的人支付手续费给节点的矿工或权益人。[6] 分布式应用程序：以太坊上的分布式应用程序不会停机，也不能被关掉。 代币（tokens）：智能合约可以创造代币供分布式应用程序使用。分布式应用程序的代币化让用户、投资者以及管理者的利益一致。代币也可以用来进行首次代币发行。 叔块（uncle block）：将因为速度较慢而未及时被收入母链的较短区块链并入，以提升交易量。使用的是有向无环图的相关技术。[6] 权益证明（proof-of-stake）：相较于工作量证明更有效率，可节省大量在挖矿时浪费的电脑资源，并避免特殊应用集成电路造成网络中心化。平行运作中，预计2022年与主链合并。 燃料（gas）：由交易手续费的概念扩展，在执行各种运算（computation）时需计算燃料消耗量，并缴交燃料费，包括发送以太币或者其他代币也被视为一种运算动作。 分片（sharding）：减少每个节点所需纪录的资料量，并透过平行运算提升效率。预计于2022年实现。  以太坊白皮书原版：https://ethereum.org/zh/whitepaper/#further-reading
以太坊白皮书中英对照：https://zhuanlan.zhihu.com/p/33779523
以太坊白皮书简体中文：https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6
 以太币 以太坊区块链上的代币称为以太币（Ether），代码为ETH，可在许多加密货币的外汇市场上交易，它也是以太坊上用来支付交易手续费和运算服务的介质
 DEFI 去中心化金融 (DEcentralized FInance）。
  CeFi = Centralized Finance 中心化金融（传统金融）
  DEFI - The Future Of Finance Explained: https://www.youtube.com/watch?v=H-O3r2YMWJ4&amp;amp;t=2s
  What is DEFI? Decentralized Finance Explained: https://www.youtube.com/watch?v=k9HYC0EJU6E
  DEBI是一种基于区块链的金融，它不依赖券商、交易所或银行等金融机构提供金融工具，而是利用区块链上的智能合约（例如以太坊）进行金融活动。DeFi平台允许人们向他人借出或借入资金，交易加密货币，并在类似储蓄的账户中获得利息
 去中心化金融（又名“DeFi”或“开放金融”）是指构建开放金融基础设施的许多去中心化协议。这些协议很有价值，因为它们正在创建必要的管道，使世界上任何拥有互联网连接的人都能够访问自主主权、抗审查的金融服务。  DeFi 如何运作？</description>
    </item>
    
    <item>
      <title>云计算</title>
      <link>https://6923403.github.io/post/cloud/</link>
      <pubDate>Fri, 31 Dec 2021 00:10:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cloud/</guid>
      <description>未填的坑6
云服务 saas 边缘计算</description>
    </item>
    
    <item>
      <title>恐慌与贪婪指数</title>
      <link>https://6923403.github.io/post/fear-and-greed/</link>
      <pubDate>Wed, 29 Dec 2021 14:31:41 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/fear-and-greed/</guid>
      <description>未填的坑4
Fear and Greed </description>
    </item>
    
    <item>
      <title>企业估值</title>
      <link>https://6923403.github.io/post/business-valuation/</link>
      <pubDate>Wed, 22 Dec 2021 15:23:02 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/business-valuation/</guid>
      <description>未填的坑3
 基本分析  财务报表 企业护城河 影响因素 企业估值 市盈率   投资策略  价值投资 成长投资 事件驱动投资 技术分析 限时限额加码止盈投资法     基本面分析 https://zh.wikipedia.org/wiki/Category:%E5%9F%BA%E6%9C%AC%E9%9D%A2%E5%88%86%E6%9E%90
 基本面分析是一种证券或股票估价的方法，利用财务分析和经济学上的研究来评估企业价值或预测证券（如股票或债券等）价值的走势。这些被分析的基本资料可以包含一家公司的财务报表和非财务上的信息，如商品需求增长性的预测、企业比较、新制度的影响分析或人口的改变。它通常和所谓的技术分析相对，技术分析在研究证券价值的趋势时，并不使用到市场本身以外的因素来做预测。
 投资者使用基本分析来检验一家公司的财务状况、其内部运作和其产业市场，用以来了解这家公司的稳定性和增长潜力。被检验的项目可能包括有发放股息、公司管理资金方法、公司的负债值和公司收支增长。一个利用基本分析的人会看基本分析的结果来决定要操作多头或空头。
基本面分析的目标可能有：
 对公司股票进行估值，并预测未来价格趋势。 预测公司未来表现。 评价公司管理体系，为内部商业决策做支持。 计算违约风险。   企业估值 资产估值: 维基百科
 Reference:
http://abcexchange.io/terms/b/business-valuation.asp
聊聊“市盈率”那点事
东财-股民学校
MBA智库百科
投资策略</description>
    </item>
    
    <item>
      <title>市盈率</title>
      <link>https://6923403.github.io/post/per/</link>
      <pubDate>Wed, 22 Dec 2021 15:21:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/per/</guid>
      <description>未填的坑2
市盈率 ＝ ∑(收盘价×发行数量)/∑(每股收益×发行数量) </description>
    </item>
    
    <item>
      <title>Ubuntu20_install_mysql</title>
      <link>https://6923403.github.io/post/ubuntu_install_mysql/</link>
      <pubDate>Sat, 18 Dec 2021 17:36:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu_install_mysql/</guid>
      <description>安装mysql8.0 apt-get update apt-get install mysql-server  初始化 #初始化 mysql_secure_installation 1. NO 2. 输入密码 3. 其余全部默认 # 检查 systemctl status mysql.service 设置远程访问 #远程 vim /etc/mysql/mysql.conf.d/mysqld.cnf bind-address改为0.0.0.0 #重启 /etc/init.d/mysql restart #设置权限与密码 use mysql; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;密码&#39;; #使用mysql_native_password修改加密规则 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;密码&#39; PASSWORD EXPIRE NEVER; #更新一下用户的密码 UPDATE user SET host = &#39;%&#39; WHERE user = &#39;root&#39;; #允许远程访问 #刷新cache中配置 刷新权限 flush privileges; quit;  状态 #开启 service mysql start # 关闭 service mysql stop # 重启 service mysql restart # 状态 systemctl status mysql.</description>
    </item>
    
    <item>
      <title>通过typeid()获取类名</title>
      <link>https://6923403.github.io/post/typeid_get_class_name/</link>
      <pubDate>Wed, 15 Dec 2021 19:39:23 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/typeid_get_class_name/</guid>
      <description>时间一长，模版跟继承还多容易忘，这样比看代码更效率些。
 template&amp;lt;typename T&amp;gt; TC_LockT&amp;lt;T&amp;gt;::TC_LockT(const T &amp;amp;mutex) { std::cout &amp;lt;&amp;lt; &amp;quot;1class name = &amp;quot; &amp;lt;&amp;lt; typeid(mutex).name() &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;2class name = &amp;quot; &amp;lt;&amp;lt; typeid(*this).name() &amp;lt;&amp;lt; std::endl; } </description>
    </item>
    
    <item>
      <title>2007_Apple_iphone</title>
      <link>https://6923403.github.io/post/2007_apple_iphone/</link>
      <pubDate>Sat, 11 Dec 2021 13:13:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2007_apple_iphone/</guid>
      <description>过去就像现在, 也是未来。  2021_12_13日——随笔 需要提前想明天的新闻标题了。
&amp;quot;市值突破3w亿，苹果是否还具有想象力？&amp;quot; “三万亿不追，等九万亿再追吗？” 亲身参与，体验果然不一般。
看好今晚的AAPL, 看好未来的AR。
2021-12-14日：达到了2.99w亿，然后瞬间砸盘。 机器人都卡着线呢？
 2021_12_11_随笔 以下为11日随笔
最新通胀
 6.8% 2021-12-10  没想到通胀符合wall street预期, 纳斯达克微跌，拉升走高。
 AAPL 苹果尾盘拉升涨幅2.8%，站稳2.94万亿市值。
我吹吹票给自己搞点信心，反正美股这个很多人想买，很少人能买，风险大收益高。
苹果来到2.94w，估计12月冲3w没什么问题，应该会配合12月15提前收缩购债的决定，
预计苹果走到新高3万亿之后会下跌15%左右，这次不是很想减仓，其实主要是不能T0导致。
现在许多早期投资者、大V也出来说话了，都挺激动的。
 过去 现在的Metaverse就像过去的新iphone的发布，唱空者，失败论者居多。
发布会之前满天飞的滑动、翻盖手机概念图。
只可惜事情发生在07年，有些遥远，看不到当时具体的背景、事件, 让我这个善于用搜索的人也有些为难。
不过最多的声音是质疑、失败。
https://www.theregister.com/2006/12/23/iphone_will_fail/?page=2
https://www.nytimes.com/2006/12/28/technology/28phone.html
https://www.cnet.com/pictures/photos-apple-iphone-concepts/7/
https://www.neowin.net/forum/topic/519463-cnet-apples-iphone-will-fail/ 讨论
2006年的ipod https://www.bilibili.com/video/BV1xf4y147tp/
发布1 https://electronics.howstuffworks.com/iphone-qotd.htm
发布2 https://www.zdnet.com/article/jobs-today-apple-is-going-to-reinvent-the-phone/
 现在 Apple, 17年推出arkit，迈出ar的一步。
过去就像现在, 也是未来。</description>
    </item>
    
    <item>
      <title>氦气概念</title>
      <link>https://6923403.github.io/post/%E6%B0%A6%E6%B0%94%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 08 Dec 2021 00:01:52 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E6%B0%A6%E6%B0%94%E6%A6%82%E5%BF%B5/</guid>
      <description>2021-12-08: 氦气短缺的背后
 百科 百度百科：https://baike.baidu.com/item/氦气/8572782
氦气，是一种稀有气体，英文名为Helium，元素符号为He，原子序数2。 [1] 为无色无味的惰性气体，化学性质不活泼，一般状态下很难和其它物质发生反应。  德国林德 氦寡头垄断企业
百度百科：https://baike.baidu.com/item/林德集团/2174084
林德（Linde）是全球领先的工业气体和工程公司之一，是工业气体、工艺与特种气体的全球领先供应商。2020年销售额为270亿美元（240亿欧元）。其所触及的终端市场涵盖众多行业，包括化工与精炼、食品与饮料、电子、医疗健康、制造业以及初级金属等。而林德所生产的工业气体则应用于各种领域——从医院用氧到用于电子行业的高纯及特种气体，再到用于清洁能源的氢气等。  简单分析   1、氦气作为稀缺战略资源，可广泛用于各行各业，以下行业氦气用量还在持续增长。
  航空航天
  汽车及运输设备
  电子
  医疗保健
  焊接及金属加工
    2、天然气分离法是目前唯一工业化获取氦气途径, 且成本高，不易存储。
  3、中国氦气主要依赖进口, 并且价格在持续的增长
  4、 当前环境氦气资源紧张，可能探索早已展开，不过进展不大。
  5、中国开展氦气相关资源探索、储备。
 又近一步！我国启动首座大型氦气厂(2020年07月28日)     Re: http://www.cigia.org.cn/?m=home&amp;amp;c=View&amp;amp;a=index&amp;amp;aid=4227
https://xueqiu.com/4065438410/176599996
https://max.book118.com/html/2021/0602/8107126070003105.shtm
https://bg.qianzhan.com/report/detail/300/200327-592d351b.html</description>
    </item>
    
    <item>
      <title>2021_12_07_随笔</title>
      <link>https://6923403.github.io/post/2021_12_07_note/</link>
      <pubDate>Tue, 07 Dec 2021 22:54:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_12_07_note/</guid>
      <description>开盘大涨 上次说的看到三月之前, 维持判断并随市场趋势不断调整。
新型cd并未给美国带来重大打击也可能是麻了。。
目前美国国债走高，经济\就业等继续向好的方向发展, 意味着加息到来的还是很快，完全不可能是当前预测的6、7月份。
接下来就等待12月15日的美联储发布会了。
投资者恐慌指数也从极度恐慌的20到现在的31。
 Meta 最近还在思考要不要买A股的Meta相关，今天想明白了，
根本完全没必要。
苹果、微软、Meta、谷歌、英伟达皆在我持仓范围内，我没有必要买，根本不需要，最上游都在仓内，何必过多的关心下游产业链条, 徒增烦恼也。
 Wi-Fi6 中京电子不错，我当时提问的问题还上了各大财经的即时新闻，同花顺还置顶了一天, 不错。
中京应该主要给华为，小米供货。
 友情提醒 &amp;amp; 小道消息 我的小管家提醒我资产风险过高，建议我减少30%的仓位去买文件名型理财。
原来美股属于高风险，的确说高也高，回报更高。
煤炭已经灵了陕煤走高，不过看不太懂，没敢买。
现在来个新消息氦气
 开盘冲高 本次加仓虽然不是很完美但是还是有一定收益。
期待苹果冲击三万亿，这个过程我将亲身参与，比新闻上的感受要深的多。参与感与个人满足感。
 属于是降准降到对面的盘子上去了  </description>
    </item>
    
    <item>
      <title>2021_12_04_随笔</title>
      <link>https://6923403.github.io/post/2021_12_04_note/</link>
      <pubDate>Fri, 03 Dec 2021 23:08:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_12_04_note/</guid>
      <description>我代表纳斯达克谢谢你 中丐, c艹。</description>
    </item>
    
    <item>
      <title>Ubuntu20.10 install vscode</title>
      <link>https://6923403.github.io/post/ubuntu2010_install_vscode/</link>
      <pubDate>Thu, 02 Dec 2021 16:06:36 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu2010_install_vscode/</guid>
      <description>20.10有点下问题，得简单配置下
 添加到bashrc 或zshrc cd ~ mkdir vscode alias code=&#39;code --user-data-dir $HOME/vscode&#39;  root运行 vim /usr/bin/code # 跟谷歌浏览器一样 添加 --no-sandbox </description>
    </item>
    
    <item>
      <title>Ubuntu20.4 install gcc11.2.0</title>
      <link>https://6923403.github.io/post/ubuntu20_install_gcc11/</link>
      <pubDate>Thu, 02 Dec 2021 11:08:36 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu20_install_gcc11/</guid>
      <description>编译安装 make时间比较长。
#直接存sh里 wget https://mirrors.ustc.edu.cn/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.gz tar -zxvf gcc-11.2.0.tar.gz cd gcc-11.2.0 ./contrib/download_prerequisites mkdir build cd build ../configure configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-11.2 --enable-checking=release --enable-languages=c,c++ --disable-multilib --program-suffix=-11.2 make -j4 make install  设置默认gcc ln -s /usr/local/gcc-11.2/bin/g++-11.2 /usr/bin/g++-11.2 ln -s /usr/local/gcc-11.2/bin/gcc-11.2 /usr/bin/gcc-11.2 update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11.2 100 update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11.2 100 #选择版本 就一个选项的不会提供选择 update-alternatives --config gcc update-alternatives --config g++ gcc -v g++ -v  Re: https://blog.csdn.net/wbvalid/article/details/119945557
https://blog.csdn.net/EternallyAccompany/article/details/108865331</description>
    </item>
    
    <item>
      <title>Wifi6与Wifi6e</title>
      <link>https://6923403.github.io/post/wifi6_6e/</link>
      <pubDate>Wed, 01 Dec 2021 11:24:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/wifi6_6e/</guid>
      <description>2021-12-01： 写在市场Wi-Fi6概念未爆发前。
以下非科普，只做了一些整理
 发展历程  WI-FI 6 维基百科：https://zh.wikipedia.org/wiki/IEEE_802.11ax
百度百科：https://baike.baidu.com/item/Wi-Fi6
**Wi-Fi 6（原称：IEEE 802.11.ax）即第六代无线网络技术，是Wi-Fi标准的名称。是Wi-Fi联盟创建于IEEE 802.11标准的无线局域网技术。Wi-Fi 6将允许与多达8个设备通信，最高速率可达9.6Gbps。**o
主要先进功能:
速度更快、延时更低、容量更大、更安全、更省电
  向下兼容11a/b/g/n/ac
  正交频分多址（OFDMA）：在要求严格的环境中，同时面向上行链路和下行链路有效共享信道，以提高网络效率并降低延迟。
  多用户多输入多输出（MU-MIMO）：允许一次传送更多下行链路数据，使接入点能够同时将数据传送到更多的设备。
  160MHz信道：增大带宽，从而能够以低延迟提供更高性能。
  1024正交幅度调制模式（1024-QAM）：通过在同样数量的频谱中编码更多数据，提高Wi-Fi设备的吞吐量。
  目标唤醒时间（TWT）：显著延长Wi-Fi设备的电池寿命，例如物联网（IoT）设备。
  发送波束成形：在给定范围内支持更高的数据速率，从而提供更大的网络容量。
  4倍OFDM符号时间（symbol duration）
  自适应的空闲信道评估（Adaptive CCA）
  安全标准升级为WPA3
   WI-FI 6E Wi-Fi 6 Extension
6GHz频段是一个全球统一的连续频谱块，范围从5925MHz扩展到7125MHz，共计1200MHz频谱，意味着额外提供了提供7个160MHz信道，或14个80MHz信道，或29个40MHz信道或59个20MHz信道。
  新增6GHz频段
  容量提升
  速率新突破
  时延更低</description>
    </item>
    
    <item>
      <title>2021_11_30_随笔</title>
      <link>https://6923403.github.io/post/2021_11_30_note/</link>
      <pubDate>Tue, 30 Nov 2021 01:26:58 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_11_30_note/</guid>
      <description>上午0点 上个周五有多么惨淡，这个夜晚就有多么红火。
上周五的大跌持仓跌了5个点，今天就涨回来了，纳斯达克调整的真快，不做作。
虽然回调是我的意料之中，我还提前减仓了，但是调整的确快，就加了一丢丢仓。
现在美国国债涨了3个点 白天接近5个点 今晚跌了
 最近在研究一个目前概念热度很高但是技术关注度不高很有前景的技术。
没有学cpp时难，但是这次比较迷茫，两眼一抹黑，没有前人之路，我成了先行人。XYZ六个自由度的世界。
找不到最新的资料，教程也没有新版，官方文档就一点简介，也没个具体例子，遇到bug甚至都没有解决方案的，因为这个问题压根没人提起过。
目前大多教学、资料等都集中在2017-2019这段时间，现在技术不火也没有人在这块投入很大的精力来做教学，可是每年更新一个版本，只能靠悟性了。
目前国内的资料就一本书跟一个18年的教程，视频都没有，我在外网也找了老半天。
其次是在外网纯英语学习肯定不如母语学习的快，有点生词就得查，幸亏有谷歌翻译，视频还有自动翻译，要不然真就是难上加难了。
 下午11点 今天看完了udacity的视频，没怎么学明白 教程17年的有点脱节，只能说有收获吧。
 现在在直播关于新cd的事情(美联储主席鲍威尔告诉国会，欧美光变体可能威胁美国经济复苏)，好像是个听证会。
目前cnn市场指数依然是恐慌，目前美国的确在担忧新病毒的影响，如果传染性强与德尔塔并且疫苗有效性对其过低，的确是个大麻烦。
之后病毒叠加通胀，结果就是某一天撑不住就崩了。
https://www.foxbusiness.com/markets/fed-chair-powell-to-tell-congress-that-omicron-variant-could-threaten-u-s-economic-recovery
11月3号美联储决议声明，不用想都知道维持0-0.25%
Theranos创始人戴上口罩的确好看。
 今晚又看了几个A股的票，一个wifi6概念的，另一个是陕煤。
今晚上调整组合先买了点，我再观察观察。
今天知乎热榜有个2亿租房，耳机保研，越来越离谱了。 不过也没啥惊讶的，放弃幻想，就像股票一样轻仓观望。
 临时添加 正写着呢 果子突然拉升2个点了，来自中国市场的利好？
富时今天提了下滴滴，滴滴好像传言要退市吧，现在连点动静都没有。
&amp;ndash;
突发 纳指闪崩
鲍威尔-可能提前Taper</description>
    </item>
    
    <item>
      <title>2021_11_27_随笔</title>
      <link>https://6923403.github.io/post/2021_11_27_note/</link>
      <pubDate>Sat, 27 Nov 2021 00:41:42 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_11_27_note/</guid>
      <description>目前凌晨12点，今天美股一点关门，目前纳斯达克跌了两个点, 今晚疫苗股领涨，科技跌。
今天没有通胀，没有加息，没有利率，没有国债，只有一个New Covid。
说实话国内太平和了，我第一时间都没意识到这个新的cd对海外影响这么大。
我看了全球股市指数，今天就印度涨了0.2%，可太🐂了。
现在又是通胀，又是新的cd，估计市场又得动荡起来了。
其实就看经济预期是否变好就行了, 美国国债最近也在跌，现在是1.4990，疫情来的时候搞到0.342&amp;hellip;
这波短期情绪恐慌，还是多听消息吧。
 最近看股票有点多，搞得我好像不务正业，主要还是最近这段时间特殊，今天又来个新cd
 下午6点
rm -rf * pandir 清空了整个/root 我手残加个星号干啥啊。。。
我存的数据幸亏大多数都在网盘同步，不过还是损失了一部分明细数据。 云服务器就一个盘还不能down 装上ext4恢复工具 编译覆写就差不多没了，真的难。今天亏大了。</description>
    </item>
    
    <item>
      <title>利率、国债、股市</title>
      <link>https://6923403.github.io/post/%E5%A4%AE%E8%A1%8C%E5%88%A9%E7%8E%87_%E5%9B%BD%E5%80%BA%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Fri, 26 Nov 2021 21:36:16 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E5%A4%AE%E8%A1%8C%E5%88%A9%E7%8E%87_%E5%9B%BD%E5%80%BA%E5%85%B3%E7%B3%BB/</guid>
      <description>国债 百度百科-国债：https://baike.baidu.com/item/国债/801020
国债（national debt; government loan），又称国家公债，是国家以其信用为基础，按照债的一般原则，通过向社会筹集资金所形成的债权债务关系。国债是由国家发行的债券，是中央政府为筹集财政资金而发行的一种政府债券，是中央政府向投资者出具的、承诺在一定时期支付利息和到期偿还本金的债权债务凭证，由于国债的发行主体是国家，所以它具有最高的信用，被公认为是最安全的投资工具。
 简单说就是,政府借老百姓钱, 写张欠条,欠债要还钱，国债一到期, 政府就得连本带息还给老百姓。  利率 百度百科-利率：https://baike.baidu.com/item/利率
利率是指一定时期内利息额与借贷资金额（本金）的比率。利率是决定企业资金成本高低的主要因素，同时也是企业筹资、投资的决定性因素，对金融环境的研究必须注意利率现状及其变动趋势。
利率是指借款、存入或借入金额（称为本金总额）中每个期间到期的利息金额与票面价值的比率。借出或借入金额的总利息取决于本金总额、利率、复利频率、借出、存入或借入的时间长度。利率是借款人需向其所借金钱所支付的代价，亦是放款人延迟其消费，借给借款人所获得的回报。利率通常以一年期利息与本金的百分比计算。
央行基准利率 百度百科-央行基准利率: https://baike.baidu.com/item/央行基准利率
基准利率是人民银行公布的商业银行存款、贷款、贴现等业务的指导性利率，各金融机构的存款利率可以在基准利率基础上下浮10%，贷款利率可以在基准利率基础上下浮20%。
基准利率是金融市场上具有普遍参照作用的利率，其他利率水平或金融资产价格均可根据这一基准利率水平来确定。基准利率是利率市场化的重要前提之一，在利率市场化条件下，融资者衡量融资成本，投资者计算投资收益，客观上都要求有一个普遍公认的利率水平作参考。所以，基准利率是利率市场化机制形成的核心。
加息 百度百科-加息：https://baike.baidu.com/item/加息
加息是一个国家或地区的中央银行提高利息的行为，从而使商业银行对中央银行的借贷成本提高，进而迫使市场的利息也进行增加。加息的目的包括减少货币供应、压抑消费、压抑通货膨胀、鼓励存款、减缓市场投机等等。加息也可作为提升本国或本地区货币对其它货币的币值（汇率）的间接手段。
 国债是追逐低风险投资者的首选，国债投资除了吃利息之外，收益还取决于国债价格浮动。国债价格受全球交易市场决定，其价格和收益率成反比（比如10年期100元面额的国债的固定收益是2元每年，你的年化收益率大概1.84%，而如果国债价格上涨至110元，你的年化收益大概1.69%）。
国债跟利率是相反走势，利率下降，国债价格上涨，利率上升，国债价格下跌。
例如国债票面利率是 5%，而银行利率变成 10%，如果保持原票面利率，计算国债应该的价格，假设为X X * （1 + 10%） = 100 * （1 + 5%） 意思是说虽然银行利率变化了，但你还是按国债票面利率获得最终收益，最后还是拿到 105。 计算 X 约等于 95.45，这就是国债的理论价格。 相反，当银行利率下降时，为了保持固定的票面利率，国债价格会上升，还是保证你最后拿到 105。 看了三个文章简单理解
由美国十年国债的曲线图可以看出 国债与股市成反比，国债大幅度下跌，股价上升。
国债上涨，代表未来预期变好，资金撤离，国债利率大于股市股息更没必要投资股市了, 同时预期变好可能伴随着之后政策的收紧。
 Re: https://www.zhihu.com/question/438523362/answer/1668529153
https://zhuanlan.zhihu.com/p/21471980
https://zhuanlan.zhihu.com/p/353299450</description>
    </item>
    
    <item>
      <title>readv_writev</title>
      <link>https://6923403.github.io/post/readv_writev/</link>
      <pubDate>Fri, 26 Nov 2021 20:31:17 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/readv_writev/</guid>
      <description>readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）。
#include &amp;lt;sys/uio.h&amp;gt; ssize_t readv(int filedes, const struct iovec *iov, int iovcnt); #散布读 ssize_t writev(int filedes, const struct iovec *iov, int iovcnt); #聚集写 其中的iovec
#include &amp;lt;sys/uio.h&amp;gt; struct iovec { ptr_t iov_base; /* Starting address */ size_t iov_len; /* Length in bytes */ }; 代码：https://github.com/6923403/CPP_Test/tree/master/test/writev
 Re: https://www.cnblogs.com/nufangrensheng/p/3559304.html
https://www.cnblogs.com/youngerchina/p/5624567.html</description>
    </item>
    
    <item>
      <title>2021_11_23_随笔</title>
      <link>https://6923403.github.io/post/2021_11_23_note/</link>
      <pubDate>Tue, 23 Nov 2021 22:56:58 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_11_23_note/</guid>
      <description>昨天热搜苹果的同工同酬牌，晚上果子的股价开盘3个点。
今天有家英国银行每周工作4天，不减薪酬。
小米三季度出货量下降，被果子超了。
看来果子的货虽然紧张但是绝对是增长的，市场反应还是不错的，应该又是一个丰收年。
产品虽然一直被黑，我也不是很关心这些黑点， 因为我自己的iphone体验一直很好，我更关心股价，只要没有什么突发大事件就好。
不知道库克的AR眼镜如何了，不过我依然很有耐心并且期待它的出现。
我的投资风格逐渐成熟，加上我本身就是个理性居多，耐心等待即可。
 昨日鲍威尔提名美联储下一任主席，美股大涨之后跳水, 今日果断加仓，看多纳斯达克。
目前通胀这块依旧是个热点, 加息推测从7月变为了6月，不过也得根据后面市场新的反应来完善这个推断，如果依旧保持高点，这个肯定得提前更多，最坏的结果就是明年三月份之后。
不过由于The house of Representatives passed a $1.75 trillion Biden plan, 短期来看还好。
 刚在cnn看到个新闻，如何在投资组合避开中丐股，笑死。。
我就很想问为什么短视频这块为什么不打击，明明这是最乱的地方, 关了都没问题，对长期发展有害无益, 反而影响少年人价值观。
 回调了？</description>
    </item>
    
    <item>
      <title>ip转换函数</title>
      <link>https://6923403.github.io/post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 21 Nov 2021 22:08:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</guid>
      <description>主机字节序（大端） 和 网络字节序（小端)
  大端: 0x12 | 0x32 | 0x56
  小端: 0x56 | 0x34 | 0x12
  Host to Network long/short
Network to Host long/short
uint32_t htonl(uint32_t hostlong); //将主机的无符号长整型数转换成网络字节序 uint16_t htons(uint16_t hostshort); //将主机的无符号短整形数转换成网络字节序 uint32_t ntohl(uint32_t netlong); //将一个无符号长整型数从网络字节序转换为主机字节序 uint16_t ntohs(uint16_t netshort); //将一个无符号短整形数从网络字节序转换为主机字节序 https://github.com/6923403/CPP_Test/tree/master/test/hostto
 #把ip地址转化为用于网络传输的二进制数值(32位) in_addr_t inet_addr(const char *cp); #少用了 int inet_aton(const char * cp, struct in_addr *inp); #将网络传输的二进制数值转化为成点分十进制的ip地址 char* inet_ntoa(struct in_addr in); #这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。 地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。 int inet_pton(int family, const char *strptr, void *addrptr); const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);  Re: https://www.</description>
    </item>
    
    <item>
      <title>股权投资之区分融资轮</title>
      <link>https://6923403.github.io/post/%E5%8C%BA%E5%88%86%E8%9E%8D%E8%B5%84%E8%BD%AE/</link>
      <pubDate>Sun, 21 Nov 2021 00:50:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E5%8C%BA%E5%88%86%E8%9E%8D%E8%B5%84%E8%BD%AE/</guid>
      <description>可转债之后第二篇,何为种子轮、天使轮、PreA轮、A轮、B轮、C轮
 种子轮 https://baike.baidu.com/item/种子轮/22415260 种子轮即种子融资，是指最早阶段进行的融资方式。虽然大多数初创企业都依靠创始人自己的或其直系亲属和朋友的资金，一些企业还是会寻求第三方的“种子融资”，这是一种最早期阶段进行的融资方式。 其特点是创业者已经有了创业的方向、思路，但是还没有成形的核心团队、没有产品原型。
此时主要是依靠自身或者经典F4（Founders/其他创始人、Family/家人、Friends/朋友、Fools/傻子）
 天使轮 https://baike.baidu.com/item/天使轮/22415261 天使轮，即天使投资（Angel Investment），是指个人出资协助具有专门技术或独特概念而缺少自有资金的创业家进行创业，并承担创业中的高风险和享受创业成功后的高收益，或者说是自由投资者或非正式风险投资机构对原创项目构思或小型初创企业进行的一次性的前期投资。天使投资是风险投资的一种特殊形式。 特点是核心创业团队已经成形，有了产品原型或者基本商业模式，但是产品还没有研发完成、商业模式还没有验证。
天使轮的投资人多是专业的早期投资机构和天使投资人，投资金额通常在几百万元，但是对于少部分领域和团队比较特殊的项目，天使轮的融资金额就可能突破千万元。
 Pre-A轮 A轮前的加油续航
PreA轮是一个夹层轮，融资人可以根据自身项目的成熟度，再决定是否需要融资，倘诺项目前期整体数据已经具有一定规模，只是还未占据市场前列，那么就可以进行PreA轮融资。 特点是产品/商业尚未初具规模但是钱却没了
Pre-A轮的投资人通常是现有的天使轮投资人和部分新引进的投资人。Pre-A轮的估值通常会比天使轮略高，但又不会达到A轮可以给出的有实质性不同的估值。
以及后面还可能有A+(Pre-B)
 A轮 https://wiki.mbalib.com/wiki/A轮融资 A轮融资指创业企业成立开始运营之后的第一次对外融资。 特点是较完善的产品已经上线，公司业务顺利运营，拥有一定数量的核心用户，有一定的数据支撑。证明这是一个有未来的、切实可行的项目。
A轮开始，投资人通常会是专业的创业投资机构，天使投资人会变得很少见
A轮融资的成功将会给企业带来一个翻天覆地的变化, 同时也对企业内外部起若重要作用。
 B轮 B轮融资阶段 是A轮融资阶段的延续， 团队、产品、商业模式、资金、运营 等方面都是在A轮融资基础上做进一步的推进和发展以谋求企业的终极目标。. 在B轮阶段，企业的商业模式及盈利模式需要进一步完善，开始盈利的企业需要持续发力，获取更大的盈利；处于亏损的企业需要寻找新的盈利点。. 在B轮阶段多数企业开始拓展产品线，拓展新的业务领域，以获取更大的利益。 产品/商业模式得到了充足的验证，需要进一步扩大规模, 抢占市场。
此时投资人更看重商业模式的应用场景及覆盖人群。
 C轮 恭喜，公司成熟，你也成为了行业翘楚。准备完成敲钟的理想。 特点产品/商业模式成熟，盈利强劲且稳定增长，业内具有一定影响力。
C轮以后的投资者更多的是大的投资机构、互联网巨头、上市公司、战略投资人等，他们对于项目的上市预期更明确。因此，对赌、回购这些在A轮、B轮项目中还可有可无的条款，在C轮以后的投资协议中会成为标配，并且往往非常严格。
以及之后的D, E, F，Pre-IPO都是为了上市做准备
 Re: https://zhuanlan.zhihu.com/p/40306174
https://zhuanlan.zhihu.com/p/54320363
https://zhuanlan.zhihu.com/p/352456135</description>
    </item>
    
    <item>
      <title>2021_11_14_随笔</title>
      <link>https://6923403.github.io/post/2021_11_14_note/</link>
      <pubDate>Sun, 14 Nov 2021 00:28:15 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_11_14_note/</guid>
      <description>元宇宙上了热搜，真正能看到其价值的不足10%。
我不止是在股票看好这个概念，我早些年就体验了VR，雪球真是个不错的平台，总会有清醒的人，兴趣相投的朋友，感谢与他们的巧遇，每一次的交流都太对了。
不过现在我更看好AR增强现实的相关应用。
目前我知道的是下面这些框架跟工具，用过的只有ARkit, Unity
 苹果: ARkit, RealityKit 谷歌: ARcore Meta: Sparkar 华为: AREngine Unity、Unreal  AR肯定会改变我们的生活以及产业的升级。
当然改变生活、产业升级不只局限于AR，如果Apple真的做出现在只存在视频中的AR眼镜，那毫无疑问，下一个还是Apple，还是AR。
 7年前的VR眼镜, 10元买的青春版了解下,
好像那时候都是放手机吧，当时最强的是暴风魔镜吧，也是放手机。</description>
    </item>
    
    <item>
      <title>2021_11_11_随笔</title>
      <link>https://6923403.github.io/post/2021_11_12_note/</link>
      <pubDate>Thu, 11 Nov 2021 23:59:59 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_11_12_note/</guid>
      <description>2021-11-11随笔 最近美国所有经济、市场类新闻离不开一个单词inflation。
10号晚上我也吃了不小的跌幅, 一片绿油油 特斯拉减持带崩了纳斯达克, 好在今晚回来了一点。
 我感觉下个中短期热点应该是wifi6，元宇宙设备硬件连接网络需要更低的延迟，更流畅的体验。
5g的成本不论未来还是以后显然是都是大于wifi6的，并且超大流量稳定传输肯定是用wifi这类， 所以wifi6必然是不可缺少的一项技术。
 为什么是中短期，因为长期我看好元宇宙这个大方向，wifi6只是个技术分支，就那么几家。  今天11号中午看到政府发了个ipv6相关，这个也很关键，国内ip明显是不够用的，us又不需要，只能自己玩了。
不过未来国内的这些企业能不能打真不好说，感觉之前挺应付没当回事，布局上远没有隔壁几大巨头深远。
如果未来fb决定进入国内市场就好了，股票翻一倍轻轻松松。另外非常期待苹果的AR眼镜，毕竟我看好的是AR。
 好配合 刚截完图就绿了一个~~</description>
    </item>
    
    <item>
      <title>2021_11_4_随笔</title>
      <link>https://6923403.github.io/post/2021_11_4_note/</link>
      <pubDate>Thu, 04 Nov 2021 11:24:02 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/2021_11_4_note/</guid>
      <description>2021-11-4随笔 月初买入了微软、苹果、Meta、谷歌、英伟达以及少量特斯拉、Salesforce、Adobe以及ASML。
另美联储今日Taper，每月减少购债150亿美元, 不过今天醒来纳斯达克涨了一个点，真意外。
目前我感觉抓住这几个基本就抓住了元宇宙的未来，甚至可能看到某巨头的没落。
A股元宇宙大热，关注的硬件歌尔、建筑装饰的风语筑涨幅也不低，不过我还是做出了我认为对的选择。
除了歌尔，A股元宇宙我目前没发现还有可以长期上行的公司, 现在的炒作之风来的快去的也快，唯有真实的技术、出色的产品与运营才是发展的长期道路。
 FB改名为Meta更让我看到了极大的决心，并且Oculus的成绩表现非常出色。
微软昨日也表现出了态度，还没有到来的苹果眼镜。
我有耐心来等待结果。
经历过PC互联网、移动互联网直到现在的元宇宙浪潮, 这是个可以参与其中的机会，第三代互联网打造一个真正虚拟的世界。
 We are at the beginning of the next chapter for the internet.
 2021_11_4 下午10点39分
真正的技术水平永远少不了回报，并且是加倍回报。</description>
    </item>
    
    <item>
      <title>Cpp内存管理</title>
      <link>https://6923403.github.io/post/cpp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 31 Oct 2021 21:51:37 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>Re: 收集 总结的真不错
https://www.cnblogs.com/findumars/p/5929831.html</description>
    </item>
    
    <item>
      <title>Metaverse</title>
      <link>https://6923403.github.io/post/metaverse/</link>
      <pubDate>Fri, 22 Oct 2021 22:59:25 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/metaverse/</guid>
      <description>元宇宙 | Metaverse We are at the beginning of the next chapter for the internet.
趋势明显，顺势而为。
 Augmented reality 个人练手小项目:
  wave(波)基于arkit制作: https://www.bilibili.com/video/BV1n44y147pY
  unity+easyar简单用例演示: https://www.bilibili.com/video/BV1wu411f7yH
  unity+easyar识别指定图片或物品播放音乐: https://www.bilibili.com/video/BV1X3411C7EW
  练手项目arkit制作的小地球: https://www.bilibili.com/video/BV1DR4y1J7xM
  练手项目arkit制作的小地球2: https://www.bilibili.com/video/BV1xq4y1G76k
   讯息 2021-10-29：Facebook将公司名称更改为“META”，公司股票代码将从12月1日起变更为“MVRS”。 </description>
    </item>
    
    <item>
      <title>天涯 kkndme备份</title>
      <link>https://6923403.github.io/post/tianya_kk/</link>
      <pubDate>Fri, 15 Oct 2021 22:57:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tianya_kk/</guid>
      <description>随笔 原文链接: https://github.com/shengcaishizhan/kkndme_tianya
关于kk的分析贴 时间已经给出了答案 我也在根据他的分析、他的思路来做出下一步的判断
本文章只是对此贴进行一份备份
 导航（持续更新中&amp;hellip;）  天涯神贴「2010年的房地产调控，我们收获了什么？写在房价暴涨前」脱水版，内容时间顺序和原贴一致，原贴中的优质非楼主写的内容，添加了引用格式便于区分。
  希望调控可以降房价，希望终有一天房价下跌是人们的一厢情愿  1、人人都有居住权。房子是用来住的，不是用来炒的。 2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。 3、房价上涨造成物价上涨，人民生活变得困难   房地产调控的真正目的：防范金融风险 &amp;amp; 通过垄断实现gj利益最大化 官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真 税收从来都是向下游转嫁的 &amp;amp; 房产税迟迟不出台的真正原因 房地产的现状 房价持续上涨的本质是稀缺性让好房子成为资金最好的去处 关于垄断  1、垄断的好处是没有风险 2、垄断可以解决社会稳定 3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难   为什么政府没有那么在意民生问题？ 房产税的制定原则 维稳的本质是人民能吃饱饭 公租房是为体制内服务的 房产税一定会转嫁给租房人 巨大的税收消耗也决定了GDP必须快速增长 调控的好处是让zf利益最大化&amp;amp;防范金融风险 垄断可以控制价格，维持稳定 体制内的住房问题有国家保驾护航 依靠但又不能完全依靠开发商建公租房 体制内的住房问题不难解决 解决体制外的住房问题：国家垄断，细水长流收租 普通人买得起「优质商品房」就尽早买把 商品房和公租房的区别 提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢） 调控带来的影响 农产品的价格关系到影响稳定的吃饭问题 农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管 资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力 资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢 资金流向规律决定了洼地不会一直是洼地 大城市对近距离的小城市有虹吸效应 决定房价的因素有很多，具体情况具体分析 房价暴涨是相对于钱而言的，不是相对于实际购买力而言的 土地不稀缺，优质土地稀缺 集中发展大城市是导致优质土地稀缺的原因 为人民服务是说给人民听的 历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙 zf限制政策房的利润，那kfs就一定会偷工减料 屁股决定脑袋，人民不知厉害关系选房子，政府选农产品 各个阶层的住房问题都安排的妥妥的 顶层的岁月静好来自于底层的负重前行 底层指的是体制外底薪白领 资金终会流向具有稀缺性的资产 土地的稀缺决定了大多数人永远买不起想买的房子 不同阶层的人对收入高低有不同的理解 一二线买房只会越来越难，最终租房会成为主流 人需要一个安身之所，能买早买比晚买好 股市 如果房价不涨，那其他产品会怎么涨 zf如何利用公租房控制租房市场 城中村不会长期存在 三四线城市的未来 房租价格涨不上去，本质是买房还看起来有希望 稀缺房的价格永远涨 粮食和房子的不同是，房子无法和土地剥离 购买房价基数低的省会城市，怎么都不会亏的 房地产是资本市场还是实体经济？ 什么是傻空 什么是真买不起房 具体情况具体分析，如果看不懂，一定是没有抓住问题本质 桂林 vs 南宁 公租房的量级不会冲击到商品房的市场 贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体 重庆：高层和别墅怎么选？ 货币贬值 为什么美国人工高于中国，大多数商品的物价却低于中国 穷人赶紧买房 武汉：城市发展空间的大小，往往和房价的升值空间成正比 权利让革族成为苗族的一支 房价是否会跌，如果会，会怎么跌 通货膨胀是减缓灭亡最好的良药 货币供应不足是明朝的真正原因 经济问题是导致清朝灭亡 房产投资的几点建议 人民币对外升值，对内贬值 南宁买房建议 经济适用房都是内部分配的 普通人怎么办：尽早买房，努力挣钱抵御通胀 房价会出现很多上下波动 买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到） 收入分配改革跟体制外的人没关系 体制外的人要早早考虑养老问题 永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你 当个农民也要懂政策，要顺政策而为 存钱不如存资产，钱会贬值，资产会升值 房子越早买越好，zf想钱想疯了 利益才是zf行为的指挥棒 建议一定是建立在严肃考察的基础上 石家庄 投资最重要的是稀缺性，买房首选公务员小区 远离垃圾人 高房价或许有天会崩盘，但你等不到那一天 房子不仅要早买，而且有能力的话不要怕压力，争取一步到位 金融杠杆是炒房赚钱的放大器 要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松 性格决定命运 2012年不取消调控，还有房价维稳顺利换届考虑 洼地最终都会被填平，多数城市是早买胜于晚买 西部 短期波动属于正常现象，需要关注的是长期趋势 领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运 对于具备投资属性的商品，供求关系是指货币与商品之间的关系 早买的风险小于晚买 小开发商的房子能不能买？ 大兴土木搞建设的城市，房价都底不了 北京老式砖混板楼的最终命运？ 把房买在政府边，差不了 天子脚下：二手老房买得好，拆迁补偿少不了 3万入手北京四环，你也是幸运的 君为贵，商人、技工次之，农民为轻，打工人为底 10年的调控和08年调控的区别、带来的影响、机会 历史总是惊人的相似 关于房贷 买卖商品房会逐渐变成富人的游戏 政府还是更在意农民问题 治国需要用贪官、反贪官 二线城市典型代表 关于商铺和住宅投资 关于房产调控 关于房产税 老公房的拆迁问题 投资新房还是老公房 高端盘有房价带动作用 买房和没买房的差距 房产交易历史 契税的历史 廉租房的历史 历史上买房最好的朝代 未来房地产市场的发展 房产到期 买学区房问题 历史的结局 人口普查 昆山房价分析与买房 为什么现在租售比这么低 &amp;amp; 同小区买一套大还是两套小 买房难之回不去的乡 &amp;amp; 拉美人过得比你想象的好 租房的苦 北京西三旗 买房争取一步到位 收入稳定的家庭如何买房 北京回龙观 贷款还是全款 00后的买房需求从何而来 意大利的住房模式 中国的学术 北京远洋山水 精英的资产 北京三环塔楼 普通人买房的未来 北京房价超香港 中国的新闻不可信，精英的有钱是你想象不到的 40年的商住房没有70年的住宅有投资价值 限贷对精英没用 外汇管制决定了大部分有钱人只能在国内投资 外国国籍在中国生活是更好的选择 分期付款买房，如果房价上涨，很容易毁约 &amp;amp; 自住要选大品牌开发商 通货膨胀和房价的关系 南京买房分析 &amp;amp; 买房要做好调查分析工作 北京华清嘉园 中国的朝代更替 中国可以无限印钞吗 读史读的不是故事，还是找历史规律，以古鉴今 毛太阳的往事 北京大兴 贵阳 富人越富、穷人越穷 通货膨胀的形成原因 深圳 &amp;amp; 昆明仇书记 &amp;amp; 通货膨胀体制内高枕无忧、体制外自求多福 长春 佛山 首付提高的逻辑 四线城市 苏州工业园 住房公积金利率 济南 &amp;amp; 大规律拆迁的城市房价不会下降 公务员小区牛逼 房屋朝向只要不是纯北西就行 &amp;amp; 买房首选市中心、公园地产 政府搬迁 俄罗斯 珠海 &amp;amp; 唯一自住房不只是投资 &amp;amp; 调控是最佳的选房时机 经济崩溃，最后接盘的是老百姓 命运之矛 除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘 kkndme聊北宋、唐朝 宋代房奴 ZG民主 王安石的青苗法之国家出政策的动机 什么是社会公平 还是有很多有钱人 双轨制之体制内的福利 开发商思维 农民政权的缺点 郑州有前景 公园地产是稀缺资源 张献忠屠川 洪秀全、黄巢、李自成 朱元璋 曹参治国 晁错 民营小企业的老板和打工者 郭解 2010年的中国房地产 房奴算不上不幸，相当当不了才算 精英人群的平均收入决定房价 内地不是香港、海南 历史是一面镜子 买房一次性到位比较好 外汇管制 一线和二线 吕后篡权 小产权房 商铺和住宅 体制内外 2010年的上海 买房：物业与房贷 收紧住房贷款 买房：物业与房贷 奸臣蔡京 体制内的28原则 贾谊 kkndme 推荐的历史书 年轻人要早买房 不要低估通货膨胀 二三线城市与重庆 城区和郊区 守着金碗要饭吃 人制的社会，人就是制度 准公务员的好处 小城市房价会因为人民币贬值涨价，但依然难变现 一线杭州 二三线城市的发展靠拆迁 转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫” 拆迁补偿 城市底层 垄断企业 农村自来水 袁盎 二三线城市，选新城还是老城 在中国，普通人手上闲钱不多的人被剥削 三分天注定七分靠打拼 人的前程有的时候不掌握在自己手里 河南郑州与洛阳 杭州 西安与重庆 谢国中「空置率」 打工不如有一技之长的小老板 一线、二线的生活 讲故事含沙射影ZG之房子不属于市场经济 什么是好的政策 李商隐「渣男」祖师爷 西五环内的别墅，是相当稀缺的资源   正文 希望调控可以降房价，希望终有一天房价下跌是人们的一厢情愿 2010年的房地产调控，让很多人看到了希望：让房价降得再猛烈些吧。还有人更是幸灾乐祸似的呼喊：让房地产赶紧崩盘吧。让没房子的好好看看有房子的笑话，是人生的一大快事。</description>
    </item>
    
    <item>
      <title>I/O多路复用</title>
      <link>https://6923403.github.io/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Sun, 10 Oct 2021 10:00:00 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>I/O模型 https://6923403.github.io/post/server_actor/
 I/O多路复用 Select、Poll、Epoll, 多路是指？多个业务方（句柄）并发下来的 IO 。 复用是指？复用这一个后台处理程序。
 Select select()函数主要解决的是accept()函数阻塞问题，而没有解决recv()和send()函数阻塞问题
#include &amp;lt;sys/select.h&amp;gt; int select(int nfds, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout);   nfds参数指定被监听的文件描述符的总数。
  readfds, writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。
  #include &amp;lt;sys/select.h&amp;gt; int FD_ZERO(int fd, fd_set *fdset); //一个 fd_set类型变量的所有位都设为 0 int FD_CLR(int fd, fd_set *fdset); //清除某个位时可以使用 int FD_SET(int fd, fd_set *fd_set); //设置变量的某个位置位 int FD_ISSET(int fd, fd_set *fdset); //测试某个位是否被置位  timeout参数用来设置select函数的超时时间  struct timeval{ long tv_sec; /*秒 */ long tv_usec; /*微秒 */ } select示例代码: select.</description>
    </item>
    
    <item>
      <title>总结mmap(零拷贝)</title>
      <link>https://6923403.github.io/post/use_mmap/</link>
      <pubDate>Mon, 04 Oct 2021 21:10:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_mmap/</guid>
      <description>总结分析传统io, mmap, sendfile
传统IO 通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过write()写入到socket缓冲区，最后写入目标。
整个过程发生了4次用户态和内核态的上下文切换和4次拷贝
 用户进程通过read()方法向操作系统发起调用，此时上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，read()返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将应用缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回   mmap #用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize); 调用 mmap() 系统调用对文件进行映射后，用户对映射后的内存进行读写实际上是对文件缓存的读写，所以减少了一次系统调用，从而加速了对文件读写的效率。
整个过程发生了4次用户态和内核态的上下文切换和3次拷贝，具体流程如下：
 用户进程通过mmap()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 上下文从内核态转为用户态，mmap调用返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回  munmap int munmap(void *addr, size_t len); munmap()用来取消参数start 所指的映射内存起始地址，参数length 则是欲取消的内存大小。当进程结束或利用exec 相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。
 Sendfile sendfile函数在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。
ssize_t senfile(int out_fd,int in_fd,off_t* offset,size_t count); 整个过程发生了2次用户态和内核态的上下文切换和3次拷贝
 用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，sendfile调用返回   sendfile+DMA Scatter/Gather 它将读缓冲区中的数据描述信息&amp;ndash;内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程</description>
    </item>
    
    <item>
      <title>Ubuntu20开机自启脚本</title>
      <link>https://6923403.github.io/post/ubuntu20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Sun, 03 Oct 2021 12:08:21 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/</guid>
      <description>我测试了好几篇文章,终于有个成功了
 local.service vim /etc/systemd/system/rc-local.service
输入以下内容:
[Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.local [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardOutput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target  rc.local vim /etc/rc.local
#!/bin/sh -e ## rc.local sh /root/startup.sh exit 0  收尾   授权 chmod +x /etc/rc.local
  自启动 systemctl enable rc-local
  运行 systemctl start rc-local.service
  查看状态 systemctl status rc-local.service
  先别重启, ps -x配合grep搜索关键字看看进程启动没有
之后保存好文件重启进行测试 再次查看是否启动
 Re: https://www.cnblogs.com/Deskew/p/13798595.html</description>
    </item>
    
    <item>
      <title>Brew_ffmpeg_install</title>
      <link>https://6923403.github.io/post/brew_ffmpeg_install/</link>
      <pubDate>Tue, 07 Sep 2021 20:25:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/brew_ffmpeg_install/</guid>
      <description>2021-09-07 发帖时间为安装时间 有些包下载较慢可以挂vpn
ffmpeg 完全安装 解决brew install ffmpeg会报错
 install brew tap homebrew-ffmpeg/ffmpeg brew options homebrew-ffmpeg/ffmpeg/ffmpeg brew install ffmpeg --HEAD ffmpeg -version 安装过程如果缺库 https://formulae.brew.sh/formula/ffmpeg 到这个链接查
 现在这步好像不需要了
#完全安装 brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-chromaprint --with-fdk-aac --with-game-music-emu --with-libbluray --with-libbs2b --with-libcaca --with-libgsm --with-libmodplug --with-librsvg --with-libsoxr --with-libssh --with-libvidstab --with-libvmaf --with-libxml2 --with-opencore-amr --with-openh264 --with-openjpeg --with-openssl --with-rav1e --with-rtmpdump --with-rubberband --with-speex --with-srt --with-tesseract --with-two-lame --with-webp --with-xvid --with-zeromq --with-zimg  Re: http://www.manks.top/ffmpeg-install-mac.html
https://www.jianshu.com/p/85fffceddf04
https://zhuanlan.zhihu.com/p/90099862</description>
    </item>
    
    <item>
      <title>News-M Tutorial</title>
      <link>https://6923403.github.io/post/news_wps/</link>
      <pubDate>Fri, 27 Aug 2021 16:40:00 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/news_wps/</guid>
      <description>https://github.com/VcSpace/News-M.git 闻讯——获取主流财经新闻网站新闻信息获取, 将数据聚合、归类并写入表格中 。
News-M &amp;ndash;News Spider, Crawling news from mainstream financial news websites, categorize and write data into tables .
 目的 时间与精力是有限的 为了节省查阅信息的时间成本故此创作News-M用来快捷提取有效信息, 节约时间, 放松精力。
Time and energy are limited. In order to save the time cost of consulting information, news-m is created to quickly extract effective information, save time and relax energy.
 运行程序 #Run pip install -r requirements.txt python3 main.py 如果你想启用网盘功能 在命令行运行bypy info获取token, 在main.py将bd_flag改为True
If you want to enable the network disk function, run bypy info on the command line to get the token, and BD will be displayed in main.</description>
    </item>
    
    <item>
      <title>News M定时运行</title>
      <link>https://6923403.github.io/post/news-m%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Tue, 24 Aug 2021 21:50:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/news-m%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C/</guid>
      <description>#把原来的main设置为start函数 在末尾添加如下代码即可 #https://blog.csdn.net/ainivip/article/details/106296599 if __name__ == &#39;__main__&#39;: while True: logger = logging.getLogger() logger.setLevel(logging.INFO) log_time = time.strftime(&amp;quot;%Y_%m_%d&amp;quot;, time.localtime()) # 刷新 logfile = &amp;quot;./&amp;quot; + log_time + &amp;quot;.log&amp;quot; fh = logging.FileHandler(logfile,mode=&#39;w&#39;) fh.setLevel(logging.INFO) while True: formatter = logging.Formatter(&amp;quot;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&amp;quot;) fh.setFormatter(formatter) logger.addHandler(fh) time_now = time.strftime(&amp;quot;%H&amp;quot;, time.localtime()) # 刷新 if time_now == &amp;quot;21&amp;quot; or time_now == &amp;quot;10&amp;quot;: # 设置要执行的时间 start() logger.info(&amp;quot;sleep(20000) start news_d&amp;quot;) time.sleep(1500) elif time_now == &amp;quot;00&amp;quot;: logger.info(&amp;quot;new day, log end&amp;quot;) time.</description>
    </item>
    
    <item>
      <title>Linux_ssh_nohup</title>
      <link>https://6923403.github.io/post/linux_ssh_nohup/</link>
      <pubDate>Sun, 22 Aug 2021 22:03:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_ssh_nohup/</guid>
      <description>Linux系统SSH客户端断开后保持进程继续运行配置方法
nohup python3 main.py &amp;amp;  Re: https://help.aliyun.com/document_detail/42523.html</description>
    </item>
    
    <item>
      <title>Python每天固定时间运行某程序代码</title>
      <link>https://6923403.github.io/post/python%E6%AF%8F%E5%A4%A9%E5%9B%BA%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E6%9F%90%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 22 Aug 2021 22:01:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/python%E6%AF%8F%E5%A4%A9%E5%9B%BA%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E6%9F%90%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/</guid>
      <description>import time while True: time_now = time.strftime(&amp;quot;%H%M&amp;quot;, time.localtime()) # 刷新 if time_now == &amp;quot;00:01&amp;quot;: # 设置要执行的时间 # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 elif time_now == &amp;quot;08:01&amp;quot;: # 设置要执行的时间: # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 elif time_now == &amp;quot;16:01&amp;quot;: # 设置要执行的时间: # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。  Re: 原文链接：https://blog.csdn.net/ainivip/article/details/106296599</description>
    </item>
    
    <item>
      <title>个人理解可转债</title>
      <link>https://6923403.github.io/post/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%8F%AF%E8%BD%AC%E5%80%BA/</link>
      <pubDate>Thu, 19 Aug 2021 21:35:40 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%8F%AF%E8%BD%AC%E5%80%BA/</guid>
      <description>结合了个人理解 可能有差错 可以评论指出
由于最近个人关注的股有一支要发转债, 故来了解下。
 什么是可转换债券 可转换债券是债券持有人可按照发行时约定的价格将债券转换成公司的普通股票的债券。如果债券持有人不想转换，则可以继续持有债券，直到偿还期满时收取本金和利息，或者在流通市场出售变现。如果持有人看好发债公司股票增值潜力，在宽限期之后可以行使转换权，按照预定转换价格将债券转换成为股票，发债公司不得拒绝。该债券利率一般低于普通公司的债券利率，企业发行可转换债券可以降低筹资成本。可转换债券持有人还享有在一定条件下将债券回售给发行人的权利，发行人在一定条件下拥有强制赎回债券的权利。
这里自己去查下百科就行了： https://baike.baidu.com/item/可转换债券/397601
 基本概念 三大特征:
   债权性    股权性    可转换性    可转债有可能赚但不会亏的保底性质
比如可转债的转股价为10元, 而当前股价为20， 一张债券100块面额根据转股价可转为10股 收益率100%。
当股价为5元时此时转股亏损50%，正常人都不会转股。选择不转股到期拿回本金和利息，保底性质
 发债前打压股价 上市公司正股价是由市场决定，但是转股价是在发行前就可以制定的。根据相关规定，转股价为可转债募集说明书公告日前20个交易日公司股票交易均价和前一交易日公司股票交易均价二者之间的较高者。
所以上市公司发行可转债前打压股价就是为了让转股价更低一点，从而促使投资者转股。如果转股价定得太高，转债上市后正股价低于转股价，那么投资者是不会愿意转股的。
可转债发布之后，利好消息推高股价。
转股之后债权变成了股权，企业也不必再支付额外的利息。
 核心就是转股价低于正股价 想方设法让你转股，符合条件的强制赎回。  有点人家吃肉我喝汤的感觉。
 两个重要条款 可转债有转股价下调条款，强制赎回条款。
  转股价向下修正条款: https://baike.baidu.com/item/转股价向下修正条款/10596894
  赎回条款：https://wiki.mbalib.com/wiki/赎回条款
   Re:
https://zhuanlan.zhihu.com/p/367802793
https://www.csai.cn/licai/1306470.html</description>
    </item>
    
    <item>
      <title>类静态成员初始化、赋值</title>
      <link>https://6923403.github.io/post/%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 18 Aug 2021 19:29:15 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>类静态成员类外初始化与在另一个类成员函数赋值
 为什么类的静态成员要在类外初始化 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
C++的静态成员是需要初始化的（实际上需要分配一个内存，不一定需要赋值），初始化是赋一个初始值，而定义是分配内存。静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义。 静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用于相同的情况下会导致重名的问题。
 静态常量成员可以在类内初始化   类的静态成员变量在另一个类赋值 //头文件代码 a.h class SPostMsgToMain { public: //存储消息线程的指针 static CWinThread* m_pThread; }; //a.cpp SPostMsgToMain::m_pThread=NULL; //此处为静态成员的定义。该定义要写在实现文件里面，不能写在头文件里面 //thread.cpp QueryThread::QueryThread(void) { SPostMsgToMain::m_pThread = this; }  Re:
https://blog.csdn.net/sevenjoin/article/details/81772792
https://blog.csdn.net/lvquanye9483/article/details/81946116
下面是09年已经删除的帖子，这是bing保存的快照:
http://cncc.bingj.com/cache.aspx?q=类的静态成员变量在另一个类赋值</description>
    </item>
    
    <item>
      <title>grpc install</title>
      <link>https://6923403.github.io/post/grpc_install/</link>
      <pubDate>Thu, 22 Jul 2021 00:13:51 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/grpc_install/</guid>
      <description>macos11.4下 grpc-cpp安装
 lib brew install autoconf automake libtool shtool gflags cmake pkg-config  grpc-cpp git clone https://github.com/grpc/grpc.git git checkout -b v1.38.x # 下载所有子模块 git submodule update --init --recursive  protobuf3 install git clone https://github.com/google/protobuf.git cd protobuf git checkout v3.9.0 sh ./autogen.sh ./configure --prefix=/usr/local/protobuf/ make sudo make install 查看版本
cd /usr/local/protobuf/bin/ ./protoc --version 将下面指令加入.bash_profiile中之后执行source ~/.bash_profile
export PATH=$PATH:/usr/local/protobuf/bin/  grpc install cd grpc export MY_INSTALL_DIR=$HOME/.local mkdir -p $MY_INSTALL_DIR export PATH=&amp;quot;$MY_INSTALL_DIR/bin:$PATH&amp;quot; mkdir -p cmake/build pushd cmake/build cmake -DgRPC_INSTALL=ON \ -DgRPC_BUILD_TESTS=OFF \ -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \ .</description>
    </item>
    
    <item>
      <title>Centos8 install redis</title>
      <link>https://6923403.github.io/post/centos8_install_redis/</link>
      <pubDate>Mon, 12 Jul 2021 13:28:17 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/centos8_install_redis/</guid>
      <description>安装过程(转)
https://blog.csdn.net/qq_34892981/article/details/110181452</description>
    </item>
    
    <item>
      <title>Centos8 install docker</title>
      <link>https://6923403.github.io/post/centos8_install_docker/</link>
      <pubDate>Mon, 12 Jul 2021 12:25:06 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/centos8_install_docker/</guid>
      <description>yum update -y sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io -y sudo yum install docker-ce docker-ce-cli sudo systemctl start docker docker --version sudo systemctl enable docker 出现安装包问题
sudo yum install docker-ce docker-ce-cli containerd.io -y --allowerasing  更换容器镜像 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors
cd /etc/docker
vim daemon.json
# url改成自己的加速器地址，亦可使用该地址 { &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://k01sfudd.mirror.aliyuncs.com&amp;quot;] } systemctl daemon-reload systemctl restart docker  Re: https://blog.csdn.net/jcmj123456/article/details/117742182
https://www.jianshu.com/p/6d9e725da273</description>
    </item>
    
    <item>
      <title>汉程网</title>
      <link>https://6923403.github.io/post/hanchengwang/</link>
      <pubDate>Fri, 09 Jul 2021 22:37:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/hanchengwang/</guid>
      <description>几天前聚餐小饮一杯48度蒸馏酒，微醺。回家之, 看书有感，口出惊言: &amp;ldquo;道可道也&amp;hellip;， 生之，养之&amp;hellip;&amp;quot;
趁着还有点意识利用以前写过的项目拼凑了一下获取了一部道德经
 https://github.com/6923403/hanchengwang.git   天下皆知美之为美, 恶已; 皆知善为善，斯不善矣。
  项目只需修改参数亦可下载其他古籍， 请自行研究使用
  项目提供本人制作的道德经成品mobi\word版本, 已内置目录
  项目提供本人制作的成品mobi\word版本, 已内置目录
  这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取
  这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取
  这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取
  程序支持跨平台, 但仅测试了mac
   </description>
    </item>
    
    <item>
      <title>TCP_三次握手与四次挥手</title>
      <link>https://6923403.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Sun, 20 Jun 2021 18:12:03 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>三次握手 
第一次握手:
(客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。)
Client端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。
第二次握手:
(服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。)
Server端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack=seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK=1、SYN=1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。
第三次握手:
(客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1)
Client收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。
 四次挥手 
第一次挥手
(主动方发送Fin+Ack报文,并置发送序号为x)
假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN=1，这个控制位代表客户端想要断开连接；序列号seq=u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。
第二次挥手
(被动方送ACK报文,并置发送序号为Z,在确认序号为x+1)
服务端收到客户端的报文后发出确认报文，控制位ACK=1；确认号ack=u+1；序列号seq=v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。
第三次挥手
(被动方发送Fin+Ack报文,并置发送序号为Y,在确认序号为x)
客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN=1，表示服务端向客户端发送断开连接请求；确认标志ACK=1；确认序号ack=u+1；序号seq=w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。
第四次挥手
(主动方发送ack报文,并置发送序号为x,在确认序号为Y)
客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK=1；确认号ack=w+1;序号seq=u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。
 相关面试题
  TCP三次握手？为什么不是两次？为什么不是四次？
 第一次握手, 目的端确认源端的发送能力、目的端确认目的端的接受能力 第二次握手, 源端确认源端的发送能力、源端确认源端的接受能力、源端确认目的端的发送能力、源端确认目的端的接收能力 第三次握手, 目的端确认源端的接收能力、目的端确认目的端的发送能力  因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。
  TCP四次挥手？为什么不是三次？为什么不是五次？
第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN=1）。
如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。
  在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？
客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：
  客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN=1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；
  等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
  注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</description>
    </item>
    
    <item>
      <title>Cpp_stl</title>
      <link>https://6923403.github.io/post/cpp_stl/</link>
      <pubDate>Sat, 12 Jun 2021 14:26:45 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_stl/</guid>
      <description>空间配置器  容器类型  标准STL序列容器: vector,string、 deque和list. 标准STL关联容器: set, multiset. map和multimap. 非标准序列容器slist和rope, slist是一个单向链表, rope本质上是一“重型&amp;quot; string 非标准的关联容器hash-set, hash-multiset. hash-map和hash-multimap 标准的非STL容器,包括数组、bitset. valarray、 stack, queue和priority_queue.   Vector template &amp;lt;class T, class Alloc=alloc&amp;gt; class vector{ private: //vector的嵌套型别定义 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type&amp;amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protect: // simple_alloc是SGI STL默认的空间配置器 typedef simple_alloc&amp;lt;value_type, Alloc&amp;gt; data_allocator; iterator start;	// 表示目前使用空间的头 iterator finish;	// 表示目前使用空间的尾 iterator end_of_storage;	// 表示目前可用空间的尾 }; vector提供的接口：包括得到vector的属性接口、vector的操作接口以及构造函数：</description>
    </item>
    
    <item>
      <title>Chrono_use</title>
      <link>https://6923403.github.io/post/chrono_use/</link>
      <pubDate>Tue, 01 Jun 2021 15:57:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/chrono_use/</guid>
      <description>时间戳获取 using namespace std::chrono; auto millisec_since_epoch = duration_cast&amp;lt;milliseconds&amp;gt;(system_clock::now().time_since_epoch()).count(); auto msec = duration_cast&amp;lt;microseconds&amp;gt;(system_clock::now().time_since_epoch()).count(); auto sec_since_epoch = duration_cast&amp;lt;seconds&amp;gt;(system_clock::now().time_since_epoch()).count(); std::cout &amp;lt;&amp;lt; &amp;quot;seconds since epoch: &amp;quot; &amp;lt;&amp;lt; sec_since_epoch &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;milliseconds since epoch: &amp;quot; &amp;lt;&amp;lt; millisec_since_epoch &amp;lt;&amp;lt; std::endl;  秒seconds since epoch: 1622534342 微妙 milliseconds since epoch: 1622534342050   标准年月日+时间获取 std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()); char re_time[256] = {0}; std::strftime(re_time, sizeof(re_time), &amp;quot;%Y-%m-%d %X&amp;quot;, std::localtime(&amp;amp;now)); std::cout &amp;lt;&amp;lt; “注册时间 ” &amp;lt;&amp;lt; re_time &amp;lt;&amp;lt; std::endl; 注册时间: 2021-06-01 15:56:42</description>
    </item>
    
    <item>
      <title>B_Tree</title>
      <link>https://6923403.github.io/post/b_tree/</link>
      <pubDate>Wed, 19 May 2021 22:48:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/b_tree/</guid>
      <description>主角得拿出来文字记录下。  一个m阶的B树具有如下属性:
 每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。  在含有n个关键字的B树上查找时，从根结点到关键字结点的 路径上涉及的结点数不超过log |m/2| ((n+1)/2)+1。
不错的讲解
 https://www.yiibai.com/data_structure/b-tree.html https://blog.nowcoder.net/n/ef07c1ad8f8346078eeab66518152bf0 https://blog.csdn.net/alzzw/article/details/97633941   一棵m阶的B+树和m阶的B树的差异在于:
 有n棵子树的结点中包含有n个关键字； 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录 的指针，叶子结点本身依关键字的大小自小而大顺序链接； 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或 最小）关键字。  实现
https://blog.csdn.net/liu1064782986/article/details/7982290
 2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩（我们称它为2结点）或三个孩子（我们称它为3结点）。
一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。
这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。
 一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。</description>
    </item>
    
    <item>
      <title>Kindle 防止自动更新</title>
      <link>https://6923403.github.io/post/kindle_%E5%8E%BB%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Sun, 09 May 2021 23:34:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/kindle_%E5%8E%BB%E6%9B%B4%E6%96%B0/</guid>
      <description>本来想等着越狱来着 没想到还会自动更新。。
 去更新 创建了个zip再改名为update.bin.tmp.partial
chmod a=r update.bin.tmp.partial  查看文件权限 ls -ld update.bin.tmp.partial -rw-r--r-- 1 root root 208 5月 10 2021 update.bin.tmp.partial 当亚马逊向你的 Kindle 推送更新固件时，会在 Kindle 根目录创建一个名为 update.bin.tmp.partial 的临时文件（该临时文件其实就是未下载完成的新固件文件，即便网络不稳定，它也会不断续传直至下载完毕），但是如果 Kindle 根目录有同名文件，它就无法创建了，从而达到阻止 Kindle 固件自动更新的目的。
 chattr 这个问题相关解答很少 帖子也很老 算了
#这个保护命令没成 root@: mount --bind /media/root/Kindle/ /mnt/kindle/ root@: chattr +i update.bin.tmp.partial - chattr: 对设备不适当的 ioctl 操作 读取 update.bin.tmp.partial 的标志时  Re:
书伴 https://bookfere.com/post/472.html</description>
    </item>
    
    <item>
      <title>Computer_network</title>
      <link>https://6923403.github.io/post/computer_network/</link>
      <pubDate>Thu, 06 May 2021 10:09:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/computer_network/</guid>
      <description>计算机网络 应用层 HTTP   HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。
  Cookie
 HTTP 是一种不保存状态，即无状态（stateless）协议。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。    请求方法
  OPTIONS
 请求一些选项信息，允许客户端查看服务器的性能    GET
 请求指定的页面信息，并返回实体主体    HEAD
 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头    POST
 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改    PUT
 从客户端向服务器传送的数据取代指定的文档的内容    DELETE
 请求服务器删除指定的页面    TRACE
 回显服务器收到的请求，主要用于测试或诊断      报文</description>
    </item>
    
    <item>
      <title>Ubuntu20 Install Nvidia drivers</title>
      <link>https://6923403.github.io/post/install_nvidia/</link>
      <pubDate>Thu, 06 May 2021 07:29:52 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_nvidia/</guid>
      <description>2021-05-06更新 完善一下
  网上教程坑特别多 这个步骤是我自己装好总结的
  电脑dell
  显卡1650
   1. 去残留 sudo apt-get remove --purge nvidia*  2. 添加规则 vim /etc/modprobe.d/blacklist.conf
blacklist nouveau options nouveau modeset=0  3. 验证是否成功 重启 重启之后输入命令
sudo update-initramfs -u lsmod | grep nouveau 如果没有返回信息代表成功
有信息的话 先检查下步骤2 再重启, 也可忽视 我这边见过一次有返回
 4.选择合适的版本   1.输入命令: ubuntu-drivers devices
  2.官网：Nvidia Official website
  选择合适的版本来进行安装
sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update #选择自己的版本 例如我这边安装440 sudo apt-get install nvidia-driver-440  5.</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43; 下</title>
      <link>https://6923403.github.io/post/effective_cpp_2/</link>
      <pubDate>Sat, 24 Apr 2021 20:40:36 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/effective_cpp_2/</guid>
      <description>条款41:了解隐式接口和编译期多态 template&amp;lt;typename T&amp;gt; void doProcessing (T&amp;amp; w) { if (w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNastywidget) { T temp(w); temp.normalize(); temp.swap(w); } }  w必须支持哪一种接口,系由template中执行于w身上的操作来决定。 凡涉及w的任何函数调用,例如operator&amp;gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates&amp;quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。  显式接口和隐式接口的差异
显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。
 其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。  隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。
template&amp;lt;typename T&amp;gt; void doProcessing( T&amp;amp; w) { if (w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNastywidget) { ... } }  它必须提供一个名为size的成员函数,该函数返回一个整数值。 它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T  本文要点
 classes和templates都支持接口(interfaces)和多态(polymorphism) 。 对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。 对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。   条款42: 了解typename的双重意义 template&amp;lt;class T&amp;gt; class widget; //使用&amp;#34;class&amp;#34; template&amp;lt;typename T&amp;gt; class Widget; //使用&amp;#34;typename&amp;#34;  C++并不总是把class和typename视为等价。有时候你一定得使用 typename。  template&amp;lt;typename C&amp;gt; void print2nd(const C&amp;amp; container) { if (container.</description>
    </item>
    
    <item>
      <title>cpp_class权限 继承</title>
      <link>https://6923403.github.io/post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 23 Apr 2021 14:01:54 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/</guid>
      <description>补充实例： cpp_class继承: https://6923403.github.io/post/cpp_inherit
 1. private, public, protected 访问标号的访问范围
private：只能由1.该类中的函数、2.其友元函数访问。 不能被任何其他访问，该类的对象也不能访问。
protected：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问。 但不能被该类的对象访问。
public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。
注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。
2 类被继承后方法属性变化
private 属性不能够被继承。 使用private继承， 父类的protected和public属性在子类中变为private； 使用protected继承，父类的protected和public属性在子类中变为protected； 使用public继承， 父类的protected和public属性不发生改变;
3 private继承和public继承的适用情况
C++将public继承视为is-a关系。private继承则并不意味着is-a关系，private继承意味着implemented-in-terms-of（根据某物实现出）。private继承意味着只有实现部分被继承，接口部分被略去。private继承在软件设计层面上没有意义，其意义只在于软件实现层面。
private继承：
1）编译器不会自动将一个子类对象转换为一个父类对象，而public继承会；
2）子类中由父类继承而来的成员（protected和public）都变为private。
implemented-in-terms-of也可以由复合实现。在应用域，复合意味着has-a；在实现域，复合意味着is-implemented-in-terms-of。尽可能使用复合实现这种关系，必要时（涉及protected成员或virtual函数时）才使用private继承。
 原文链接：https://blog.csdn.net/kingzone_2008/article/details/10066181   虚继承 C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。解决二义性。
class sum {}; class a : virtual public sum { ... } class b : virtual public sum { ... }; class c:: public a, public b { ... }; </description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43; 总结</title>
      <link>https://6923403.github.io/post/effective_cpp/</link>
      <pubDate>Sun, 11 Apr 2021 14:44:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/effective_cpp/</guid>
      <description>条款01: 将C++视为一个语言联邦 C++已经是个多重范型编程语言 (multiparadigm programming language）
同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。
 条款02：尽量以 const，enum，inline替换#define 也可以说是 宁可以编译器替换预处理器
#define 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间
第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：
class Gameplayer { private: static const int NumTurns = 5; //常量声明式  int scores[NumTurns]; ... }; 第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的&amp;quot;the enum hack&amp;quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”
enum hack的行为某方面说比较像#define而不像const
class Gameplayer { private: enum {NumTurns = 5}; int scores[NumTurns]; ... }; 本文要点
  对于单纯常量,最好以const对象或enums替换#defines.
  对于形似函数的宏(macros) ,最好改用inline函数替换#defines.
   条款03: 尽可能使用const 如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。
作用
 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。  char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量  // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int&amp;amp; Var); // 引用参数在函数内为常量  // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:你曾经承诺不改动的那个对象被改动了。这就是为什么&amp;quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。</description>
    </item>
    
    <item>
      <title>Server sum</title>
      <link>https://6923403.github.io/post/server_sum/</link>
      <pubDate>Sun, 04 Apr 2021 18:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/server_sum/</guid>
      <description>socket struct整理  https://6923403.github.io/post/socket_struct/  socket编程需要的头文件整理  https://6923403.github.io/post/socket_file/  socket function  https://6923403.github.io/post/socket/  I/O复用  https://6923403.github.io/post//io多路复用  sem function  https://6923403.github.io/post/sem/  server io actor  https://6923403.github.io/post/server_actor/  timer function  https://6923403.github.io/post/timer_function/   Linux Pthread 线程创建与使用 https://6923403.github.io/post/pthread/
C++11 thread https://6923403.github.io/post/cppthread/
 Unp note https://6923403.github.io/post/unp_note/
TCP_IP | 计算机网络 https://6923403.github.io/post/computer_network/
 exception class 异常类 https://6923403.github.io/post/cpp_exception/</description>
    </item>
    
    <item>
      <title>getopt_long</title>
      <link>https://6923403.github.io/post/getopt_long/</link>
      <pubDate>Sun, 14 Mar 2021 14:26:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/getopt_long/</guid>
      <description>2021-5-31更新
#include &amp;lt;unistd.h&amp;gt; extern char *optarg; extern int optind, opterr, optopt; #include &amp;lt;getopt.h&amp;gt; int getopt(int argc, char * const argv[],const char *optstring); int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); 参数以及返回值介绍（以上三个函数都适用）：
1、argc和argv和main函数的两个参数一致。
2、optstring: 表示短选项字符串。
形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下：
 只有一个字符，不带冒号——只表示选项， 如-c  一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100 一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格,形式应该如-b  3、longopts：表示长选项结构体。结构如下：
struct option { const char *name; int has_arg; int *flag; int val; }; static struct option longOpts[] = { { &amp;quot;daemon&amp;quot;, no_argument, NULL, &#39;D&#39; }, { &amp;quot;dir&amp;quot;, required_argument, NULL, &#39;d&#39; }, { &amp;quot;out&amp;quot;, required_argument, NULL, &#39;o&#39; }, { &amp;quot;log&amp;quot;, required_argument, NULL, &#39;l&#39; }, { &amp;quot;split&amp;quot;, required_argument, NULL, &#39;s&#39; }, { &amp;quot;http-proxy&amp;quot;, required_argument, &amp;amp;lopt, 1 }, { &amp;quot;http-user&amp;quot;, required_argument, &amp;amp;lopt, 2 }, { &amp;quot;http-passwd&amp;quot;, required_argument, &amp;amp;lopt, 3 }, { &amp;quot;http-proxy-user&amp;quot;, required_argument, &amp;amp;lopt, 4 }, { &amp;quot;http-proxy-passwd&amp;quot;, required_argument, &amp;amp;lopt, 5 }, { &amp;quot;http-auth-scheme&amp;quot;, required_argument, &amp;amp;lopt, 6 }, { &amp;quot;version&amp;quot;, no_argument, NULL, &#39;v&#39; }, { &amp;quot;help&amp;quot;, no_argument, NULL, &#39;h&#39; }, { 0, 0, 0, 0 } }; (1)name:表示选项的名称,比如daemon,dir,out等。</description>
    </item>
    
    <item>
      <title>Tcpdump</title>
      <link>https://6923403.github.io/post/tcpdump/</link>
      <pubDate>Fri, 05 Mar 2021 22:03:34 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcpdump/</guid>
      <description>备忘 简洁明了的教程
https://www.jianshu.com/p/d9162722f189
https://www.jianshu.com/p/a57a5b0e58f0
https://zhuanlan.zhihu.com/p/74812069</description>
    </item>
    
    <item>
      <title>Tcp_ip</title>
      <link>https://6923403.github.io/post/tcp_ip/</link>
      <pubDate>Thu, 25 Feb 2021 14:28:11 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcp_ip/</guid>
      <description>计算机体系结构 各层作用及协议    分层 作用 协议     物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器）   数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机）   网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）   运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX   会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC   表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII   应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS     封装  链路层 链路层主要有三个目的：
 为IP模块发送和接收IP数据报； 为ARP模块发送ARP请求和接收ARP应答； 为RARP发送RARP请求和接收RARP应答。  PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。
环回接口
re: mtu
 网络层  IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议）  IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</description>
    </item>
    
    <item>
      <title>Clion_remote_debug</title>
      <link>https://6923403.github.io/post/clion_remote_debug/</link>
      <pubDate>Mon, 22 Feb 2021 22:10:27 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/clion_remote_debug/</guid>
      <description>环境  Macos Clion2020.3.2 Server: ubuntu18   设置 1. 首先添加一个ssh
2. 部署服务器上传文件
选择SFTP协议
3. 设置本地与远程文件路径
4. 上传文件
5. 设置自动上传
 环境配置 安装环境
Centos # cmake yum install cmake -y # gcc &amp;amp; gdb yum install gcc-c++ -y yum install gdb -y #gdbserver yum install gdb-gdbserver -y Ubuntu apt-get install cmake apt-get install gcc apt-get install g++ apt-get install gdb apt-get install gdbserver gdbserver配置
target remote中格式是: tcp:ip:port
 远程调试 编译程序 -g 或者cmkae</description>
    </item>
    
    <item>
      <title>Use_gdb</title>
      <link>https://6923403.github.io/post/use_gdb/</link>
      <pubDate>Wed, 17 Feb 2021 23:02:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_gdb/</guid>
      <description>GDB 教程 转载自：https://github.com/DAN-AND-DNA/learn-gdb-by-example-for-c.git
 内容  原理 启动gdb 退出gdb 为gdb进行编译 调试程序 CoreDump简单概念 产生CoreDump文件 调试CoreDump文件 help命令 list命令 start命令 next命令 step命令 break命令 查看断点 删除断点 tbreak命令 continue命令 backtrace命令 查看当前所处的函数堆栈帧 选择函数堆栈帧 打印函数局部变量 run命令 修改变量值 查看变量类型 查看线程运行 启动图像界面  原理 断点功能一般是通过gdb捕获特定的内核信号来实现的，然后定位目标程序停止的地址来判断断点是否成功触发。大致的流程为， 首先gdb fork()出来一个子进程，该子进程启动目标程序(通过ptrace() 和 exec())， 父进程捕获该子进程的所有的信号(通过ptrace() 和 wait())，当子进程收到信号时，子进程就会被挂起，直到父进程通知其继续运行(通过ptrace())
启动gdb 1 常规启动，非常多的提示信息:
$ gdb GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.</description>
    </item>
    
    <item>
      <title>Timer function</title>
      <link>https://6923403.github.io/post/timer_function/</link>
      <pubDate>Sun, 07 Feb 2021 21:45:11 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/timer_function/</guid>
      <description>非活跃，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。
  定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。
  定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。
  定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。
   Linux下提供了三种定时的方法:
 socket选项SO_RECVTIMEO和SO_SNDTIMEO SIGALRM信号 I/O复用系统调用的超时参数   Socket选项 struct timeval timeout; timeout.tv_sec = time; timeout.tv_usec = 0; socklen_t time_len = sizeof(timeout); ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;amp;timeout, time_len); //发送数据超时 用返回值errno判断是否达到指定时间 (errno == SO_SNDTIMEO)  SIGALRM信号 sigaction结构体
struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); } sa_handler是一个函数指针，指向信号处理函数 sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息 sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号 sa_flags用于指定信号处理的行为 SA_RESTART，使被信号打断的系统调用自动重新发起 SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号 SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程 SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号 SA_RESETHAND，信号处理之后重新设置为默认的处理方式 SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数 sa_restorer一般不使用</description>
    </item>
    
    <item>
      <title>Server actor</title>
      <link>https://6923403.github.io/post/server_actor/</link>
      <pubDate>Sun, 31 Jan 2021 22:19:30 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/server_actor/</guid>
      <description>同步IO模型通常用于实现Reactor模式, 异步IO模型则用于实现Proactor模式。
 Reactor Reactor模式要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。
Reactor工作流程∶
 主线程往 epoll内核事件表中注册 socket 上的读就绪事件。 主线程调用epoll_wait 等待socket上有数据可读。 当socket上有数据可读时，epoll_wait 通知主线程。主线程则将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件。 主线程调用epoll_wait 等待socket可写。 当socket可写时，epoll_wait 通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。   Procactor 将多有I/O操作都交给主线程和内核来处理, 工作线程仅负责业务逻辑
Proactor工作流程∶
 主线程调用aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的 man 手册）。 主线程继续处理其他逻辑。 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。 主线程继续处理其他逻辑。 当用户缓冲区的数据被写人 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。   模拟Proactor 使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程∶
 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket上有数据可读。 当 socket 上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket上的写就绪事件。 主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll wait 通知主线程。主线程往 socket 上写人服务器处理客户请求的结果。    半同步/半异步 在I/O模型中，&amp;ldquo;同步&amp;quot;和&amp;quot;异步&amp;quot;区分的是内核向应用程序通知的是何种 I/O 事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。在并发模式中，&amp;ldquo;同步&amp;quot;指的是程序完全按照代码序列的顺序执行∶&amp;quot;异步&amp;quot;指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</description>
    </item>
    
    <item>
      <title>Linux Sem</title>
      <link>https://6923403.github.io/post/sem/</link>
      <pubDate>Sat, 23 Jan 2021 20:45:54 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/sem/</guid>
      <description>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：
 P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行 V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一   int sem_init(sem_t *sem, int pshared, unsigned int value)
初始化m_sem value为指定信号量的初始值
 pshared为0 信号量在进程的线程之间共享 pshared非0 信号量在进程之间共享   sem_init函数用于初始化一个未命名的信号量 sem_destory函数用于销毁信号量 sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞 sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程  调用seminit函数时，操作系统将创建信号量对象，此对象中记录着“信号量值”（semaphoreValue）整数。 该值在调用sem_post函数时增1，调用semwait函数时减1。 但信号量的值不能小于0，因此，在信号量为0的情况下调用sem一vait函数时，调用函数的线程将进人阻塞状态（因为函数未返回）。 当然，此时如果有其他线程调用sem一post函数，信号量的值将变为1，而原本阻塞的线程可以将该信号量重新减为0并跳出阻塞状态。 实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为1）。 **类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制
class sem{ public: //构造函数 sem() { //信号量初始化 if(sem_init(&amp;amp;m_sem,0,0)!=0){ throw std::exception(); } } //析构函数 ~sem() { //信号量销毁 sem_destroy(&amp;amp;m_sem); } private: sem_t m_sem; };  Reference:
https://blog.csdn.net/m0_45867846/article/details/109021863</description>
    </item>
    
    <item>
      <title>Mac install mysql_8.0</title>
      <link>https://6923403.github.io/post/mac_install_mysql/</link>
      <pubDate>Mon, 18 Jan 2021 17:20:58 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/mac_install_mysql/</guid>
      <description>Downloads mysql 社区版官网下载: https://dev.mysql.com/downloads/mysql/
 Start 下载之后安装一路点继续 设置完root密码
安装完成后 需要开启/关闭Mysql 系统偏好设置-Mysql图标
停止MySQL服务 sudo mysql.server stop 重启MySQL服务 sudo mysql.server restart 查看MySQL服务状态 sudo mysql.server status  Connect Mysql 终端输入 vim ~/.bash_profile
PATH=$PATH:/usr/local/mysql/bin PATH=$PATH:/usr/local/mysql/support-files 再执行 source ~/.bash_profile
Login mysql -u root -p 输入密码之后成功进入mysql
mysql&amp;gt; select version();查看MySQL版本
 Reference: https://www.jianshu.com/p/07a9826898c0
https://www.cnblogs.com/nickchen121/p/11145123.htm</description>
    </item>
    
    <item>
      <title>Dell7590 install macos</title>
      <link>https://6923403.github.io/post/dell7590_install_macos/</link>
      <pubDate>Sun, 17 Jan 2021 13:19:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/dell7590_install_macos/</guid>
      <description>2021-12-13更新 系统为big sur 11.4
接近完美 可以用intel网卡连接wifi 速度还不错
已知麦克风、隔空投送不能用
 镜像下载 搜素：黑果小兵
big sur用11.4
 重要前提 如果你没有网线，并且没有其他PC设备联网 你需要提前下载这些
https://github.com/OpenIntelWireless/itlwm/releases/ #AirportItlwm https://5435.lanzouo.com/isRfBxjxq4f #四叶草+occ  Start //OC git clone https://github.com/Pinming/Dell-Inspiron-7590-Hackintosh-Opencore //Diskgenius 官网自行下载最新版 //balennaEther 官网自行下载最新版 1. 先把Dell-Inspiron-7590-Hackintosh-Opencore重命名为OC
2. 打开OC文件夹 根据屏幕改名1080P的屏幕使用config-1080p.plist需改名成config.plist 如果你是4K屏 不需要修改
3. balennaEther烧录dmg镜像文件到U盘
4. 打开Diskgenius 进入U盘的ESP分区文件夹 删除Clover文件夹 然后将OC文件夹拖入
5. 打开U盘ESP分区中的EFI 将Diskgenius程序文件夹拖进去 备用 以免出问题
提前准备好安装空间建议300g 至少200g
6. 用Diskgenius分ESP区 建议400m
7. 双系统需要保存好windows efi
 安装 1. 重启F2 关闭Secure Boot安全启动 检查磁盘模式为ACHI 百度搜
2. 进入Boot Sequence &amp;lsquo;add option&amp;rsquo; 添加一个引导 选择启动文件为自己的U盘EFI(找到EFI/OC/OpenCore.</description>
    </item>
    
    <item>
      <title>vmware16pro unlock install macos</title>
      <link>https://6923403.github.io/post/vmware_install_macos/</link>
      <pubDate>Fri, 15 Jan 2021 20:37:54 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/vmware_install_macos/</guid>
      <description>unlocker git clone https://github.com/paolo-projects/auto-unlocker.git
 Download cdr https://www.mfpud.com/topics/3888/
 Tutorial https://www.mfpud.com/topics/612/
进入之后先选择磁盘工具 抹掉磁盘 安装即可
 Other 安装VMware Tools，参照https://www.lovyou.top/post/52.html
调整MacOS屏幕分辨率参考https://blog.csdn.net/icarus666/article/details/79529766</description>
    </item>
    
    <item>
      <title>Ubuntu20 install opencv</title>
      <link>https://6923403.github.io/post/ubuntu20_install_opencv/</link>
      <pubDate>Thu, 14 Jan 2021 22:02:25 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu20_install_opencv/</guid>
      <description>Ubuntu20.04.1LTS 2020-01-14-Successful
 lib Install apt-get install -y build-essential pkg-config cmake apt-get install -y libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev  Download github: git clone https://github.com/opencv/opencv.git gitee: git clone https://gitee.com/mirrors/opencv.git  Install cd opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_GTK=ON -D OPENCV_GENERATE_PKGCONFIG=YES .. make -j4 make install  Set echo &amp;quot;include /usr/loacal/lib&amp;quot; &amp;gt;&amp;gt; /etc/ld.so.conf ldconfig echo &amp;quot;PKG_CONFIG_PATH=\$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig&amp;quot; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;quot;export PKG_CONFIG_PATH&amp;quot; &amp;gt;&amp;gt; /etc/bash.bashrc  Show version pkg-config --modversion opencv4 pkg-config --cflags opencv4 pkg-config --libs opencv4 </description>
    </item>
    
    <item>
      <title>Unp_Note</title>
      <link>https://6923403.github.io/post/unp_note/</link>
      <pubDate>Mon, 11 Jan 2021 22:40:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/unp_note/</guid>
      <description>基本流程图 示范代码: https://github.com/6923403/CPP_Test/tree/master/server/socket/practice/8_socket
 TCP UDP 客户角度 服务器角度  套接字选项   config_init connect_mysql init_socket setsockopt linger  </description>
    </item>
    
    <item>
      <title>Pymysqlerr 1698</title>
      <link>https://6923403.github.io/post/pymysql_err_1698/</link>
      <pubDate>Mon, 30 Nov 2020 16:24:28 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/pymysql_err_1698/</guid>
      <description>pymysql.err.OperationalError: (1698, “Access denied for user ‘root’@‘localhost’”)
sudo mysql -u root mysql&amp;gt; USE mysql; mysql&amp;gt; UPDATE user SET plugin=&#39;mysql_native_password&#39; WHERE User=&#39;root&#39;; mysql&amp;gt; FLUSH PRIVILEGES; mysql&amp;gt; exit; service mysql restart </description>
    </item>
    
    <item>
      <title>Ubuntu tim_wechat</title>
      <link>https://6923403.github.io/post/ubuntu_tim_wechat/</link>
      <pubDate>Tue, 24 Nov 2020 16:50:16 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ubuntu_tim_wechat/</guid>
      <description>字体 因为wine对HiDPI不会默认适配dpi值。解决方案:
注意WINEPREFIX这个环境变量指向你的deepin wine容器目录，比如TIM在~/.deepinwine/Deepin-TIM，微信在~/.deepinwine/Deepin-WeChat 执行以下命令
WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine winecfg 打开wine设置页面，在显示选项卡中调整屏幕分辨率的dpi值即可。比如想实现win 10的150% DPI只需要将96改到144即可，125%放大则对应120。手工调整下合适的DPI就可以了
 对于中文乱码是空格的情况，安装中文字体解决
sudo apt-get install fonts-droid-fallback ttf-wqy-zenhei ttf-wqy-microhei fonts-arphic-ukai fonts-arphic-uming </description>
    </item>
    
    <item>
      <title>Socket write_send</title>
      <link>https://6923403.github.io/post/socket_write_send/</link>
      <pubDate>Sat, 21 Nov 2020 14:59:41 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_write_send/</guid>
      <description>ssize_t write(int fd, const void*buf,size_t nbytes);
write函数将buf中的nbytes字节内容写入文件描述符fd.
成功时返回写的字节数.失败时返回-1. 并设置errno变量. 在网络程序中,当我们向套接字文件描述符写时有两可能. 1)write的返回值大于0,表示写了部分或者是全部的数据. 这样我们用一个while循环来不停的写入，但是循环过程中的buf参数和nbyte参数得由我们来更新。也就是说，网络写函数是不负责将全部数据写完之后在返回的。 2)返回的值小于0,此时出现了错误.我们要根据错误类型来处理. 如果错误为EINTR表示在写的时候出现了中断错误. 如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接).
 ssize_t read(int fd,void *buf,size_t nbyte)
read函数是负责从fd中读取内容.
当读成功 时,read返回实际所读的字节数,如果返回的值是0 表示已经读到文件的结束了,小于0表示出现了错误.如果错误为EINTR说明读是由中断引起 的, 如果是ECONNREST表示网络连接出了问题. 和上面一样,我们也写一个自己的读函数.
 recv和send函数提供了和read和write差不多的功能.不过它们提供了第四个参数来控制读写操作.
int recv(int sockfd,void *buf,int len,int flags) int send(int sockfd,void *buf,int len,int flags) 前面的三个参数和read, write一样,第四个参数可以是0或者是以下的组合
   标题 内容     MSG_DONTROUTE 不查找表   MSG_OOB 接受或者发送带外数据   MSG_PEEK 查看数据,并不从系统缓冲区移走数据   MSG_WAITALL 等待所有数据    MSG_DONTROUTE:是 send函数使用的标志.</description>
    </item>
    
    <item>
      <title>Python thread parameter transfer</title>
      <link>https://6923403.github.io/post/python_thread_mis/</link>
      <pubDate>Tue, 17 Nov 2020 16:13:32 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/python_thread_mis/</guid>
      <description>import threading import time def worker(): print “worker” time.sleep(1) return for i in xrange(5): t = threading.Thread(target=worker) t.start() 这段代码就使用了多线程，但是没法传递参数，而实际使用多线程，往往是需要传递参数的，这么写实现传递参数的多线程：
import threading import time def worker(number): print “worker” time.sleep(number) return for i in xrange(5): t = threading.Thread(target=worker,args=(i,)) t.start() 第一个参数是线程函数变量，第二个参数args是一个数组变量参数，如果只传递一个值，就只需要i, 如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，元组中只包含一个元素时，需要在元素后面添加逗号。
 Re:
https://blog.csdn.net/chpllp/article/details/54381141</description>
    </item>
    
    <item>
      <title>Opepyxl sytle</title>
      <link>https://6923403.github.io/post/opepyxl_sytle/</link>
      <pubDate>Sun, 15 Nov 2020 19:14:58 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/opepyxl_sytle/</guid>
      <description>font(字体类)：字号、字体颜色、下划线等 fill(填充类)：颜色等 border(边框类)：设置单元格边框 alignment(位置类)：对齐方式 number_format(格式类)：数据格式 protection(保护类)：写保护   &amp;gt;&amp;gt;&amp;gt; from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font &amp;gt;&amp;gt;&amp;gt; font = Font(name=&#39;Calibri&#39;, size=11, bold=False, italic=False, vertAlign=None, underline=&#39;none&#39;, strike=False, color=&#39;FF000000&#39;) &amp;gt;&amp;gt;&amp;gt; fill = PatternFill(fill_type=None, start_color=&#39;FFFFFFFF&#39;, end_color=&#39;FF000000&#39;) &amp;gt;&amp;gt;&amp;gt; border = Border(left=Side(border_style=None, color=&#39;FF000000&#39;), right=Side(border_style=None, color=&#39;FF000000&#39;), top=Side(border_style=None, color=&#39;FF000000&#39;), bottom=Side(border_style=None, color=&#39;FF000000&#39;), diagonal=Side(border_style=None, color=&#39;FF000000&#39;), diagonal_direction=0, outline=Side(border_style=None, color=&#39;FF000000&#39;), vertical=Side(border_style=None, color=&#39;FF000000&#39;), horizontal=Side(border_style=None, color=&#39;FF000000&#39;) ) &amp;gt;&amp;gt;&amp;gt; alignment=Alignment(horizontal=&#39;general&#39;, vertical=&#39;bottom&#39;, text_rotation=0, wrap_text=False, shrink_to_fit=False, indent=0) &amp;gt;&amp;gt;&amp;gt; number_format = &#39;General&#39; &amp;gt;&amp;gt;&amp;gt; protection = Protection(locked=True, hidden=False) 以上几种样式（字体、填充、边框、位置和保护）实例一旦被创建实例的属性就不可更改，只能重新创建实例。</description>
    </item>
    
    <item>
      <title>Vim_config</title>
      <link>https://6923403.github.io/post/vim_config/</link>
      <pubDate>Tue, 13 Oct 2020 18:12:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/vim_config/</guid>
      <description>编译安装 #https://www.cnblogs.com/JoiT/p/build_from_source_for_linux_vim.html apt install libncurses5-dev libgtk2.0-dev libatk1.0-dev \ libcairo2-dev libx11-dev libxpm-dev libxt-dev apt-get remove --purge vim-tiny vim vim-runtime gvim vim-common vim-gui-common vim-nox ./configure --with-features=huge \ --enable-multibyte \ --enable-gui=gtk3 \ --enable-cscope \ --prefix=/usr/local make make install  主题配置 首先要确认你的终端支持真彩，一般来说，主流的比如iTerm2, Putty, Powershell的最新版本都已经支持了。我们可以运行以下命令检测一下
(echo -e &#39;\e[48:2:1:2:3m\eP$qm\e\\&#39; ; xxd)
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;=&amp;gt;全局配置&amp;lt;=&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;关闭vi兼容模式&amp;quot; set nocompatible &amp;quot;设置历史记录步数&amp;quot; set history=1000 &amp;quot;开启相关插件&amp;quot; &amp;quot;侦测文件类型&amp;quot; filetype on &amp;quot;载入文件类型插件&amp;quot; filetype plugin on &amp;quot;为特定文件类型载入相关缩进文件&amp;quot; filetype indent on &amp;quot;当文件在外部被修改时，自动更新该文件&amp;quot; set autoread &amp;quot;激活鼠标的使用&amp;quot; set mouse=a set selection=exclusive set selectmode=mouse,key &amp;quot;保存全局变量&amp;quot; set viminfo+=!</description>
    </item>
    
    <item>
      <title>CPP_Const</title>
      <link>https://6923403.github.io/post/cppconst/</link>
      <pubDate>Tue, 06 Oct 2020 15:03:40 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cppconst/</guid>
      <description>const 作用
 修饰变量，变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。   // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;amp;a; // 指针变量，指向常对象 const A &amp;amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = &amp;quot;Hello&amp;quot;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int&amp;amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7();  const 的指针与引用  指针  指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）   引用  指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer     用法小结 指针</description>
    </item>
    
    <item>
      <title>C/S_B/S 架构</title>
      <link>https://6923403.github.io/post/cs_bs/</link>
      <pubDate>Mon, 05 Oct 2020 16:14:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cs_bs/</guid>
      <description>什么是C/S和B/S架构？
C/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。
B/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。
第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。
第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。
 优点/缺点 C/S架构的优点
a. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。
b. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。
c. 客户端直接操作界面。
C/S架构的缺点
a&amp;gt; C/S架构适用于局域网，对网速的要求比较高。
b&amp;gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。
c&amp;gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。
d&amp;gt; 系统的维护也比较麻烦。
 B/S架构的优点  a&amp;gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。
b&amp;gt; 浏览器只处理一些简单的逻辑事务，负担小。
c&amp;gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。
d&amp;gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。
e&amp;gt; B/S建立在广域网上，所以需要的网速要求不高。
f&amp;gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。
g&amp;gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。
B/S架构的缺点  a&amp;gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。
b&amp;gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。
  第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。   https://blog.csdn.net/qq_42828949/article/details/82822901
https://blog.csdn.net/zhengqijun_/article/details/53056624</description>
    </item>
    
    <item>
      <title>Algorithm x^n</title>
      <link>https://6923403.github.io/post/recursion/</link>
      <pubDate>Sun, 04 Oct 2020 16:09:26 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/recursion/</guid>
      <description>O(1)常数阶 &amp;lt; O(logn)对数阶 &amp;lt; O(n)线性阶 &amp;lt; O(n^2)平方阶 &amp;lt; O(n^3)(立方阶) &amp;lt; O(2^n) (指数阶)
For O(n) int function1(int x, int n) { int result = 1; // 注意 任何数的0次方等于1 for (int i = 0; i &amp;lt; n; i++) { result = result * x; } return result; }  Recursion O(n) int function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; }  Recursion2 O(n) int function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n/2) * function3(x, n/2)*x; } return function3(x, n/2) * function3(x, n/2); }  Recursion3 O(logn) int function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n/2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t*t*x; } return t*t; } </description>
    </item>
    
    <item>
      <title>Linux Pthread</title>
      <link>https://6923403.github.io/post/pthread/</link>
      <pubDate>Sun, 27 Sep 2020 17:53:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/pthread/</guid>
      <description>int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)
其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构 pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用， 默认值是PTHREAD_ PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。
注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_destroy（pthread_cond_t cond）。
也可以静态的初始化条件变量
pthread_cond_t my_condition = PTHREAD_COND_INITIALIZER;  pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr); // 初始化锁变量mutex。 // attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t *mutex); // 加锁（阻塞操作） pthread_mutex_trylock(pthread_mutex_t *mutex); // 试图加锁（不阻塞操作） // 当互斥锁空闲时将占有该锁；否则立即返回 // 但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t *mutex); 销毁一个不再需要的互斥量，释放系统资源。 pthread_cond_wait() / pthread_cond_timedwait -----等待条件变量，挂起线程，区别是后者，会有timeout时间， 如果到了timeout,线程自动解除阻塞，这个时间和 time()系统调用相同意义的。以1970年时间算起。 pthread_cond_signal ----激活等待列表中的线程， pthread_cond_broadcast() -------激活所有等待线程列表中最先入队的线程 条件变量
条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：
 1）一个线程等待&amp;quot;条件变量的条件成立&amp;quot;而挂起； 2）另一个线程使&amp;quot;条件成立&amp;quot;（给出条件成立信号）。  为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。
注意：
  1）上面这几个函数都是原子操作，可以为理解为一条指令，不会被其他程序打断
  2）上面这个几个函数，必须配合使用。
  3）pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，继续执行pthread_cond_wait</description>
    </item>
    
    <item>
      <title>Cpp_inherit</title>
      <link>https://6923403.github.io/post/cpp_inherit/</link>
      <pubDate>Fri, 25 Sep 2020 17:44:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_inherit/</guid>
      <description>class derived-class: access-specifier base-class
class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; Rectangle rect; rect.setWidth(3); rect.setHeight(5); #rect result = 15 cout &amp;lt;&amp;lt; rect.getArea() &amp;lt;&amp;lt; endl;  访问控制和继承
   访问 public protected private     同一个类 yes yes yes   派生类 yes yes no   外部的类 yes no no     公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。  </description>
    </item>
    
    <item>
      <title>CPP_Mysql_use</title>
      <link>https://6923403.github.io/post/mysql_use/</link>
      <pubDate>Fri, 25 Sep 2020 16:40:02 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/mysql_use/</guid>
      <description>Mysql ex     mysql_init() 获取或初始化MYSQL结构   mysql_real_connect() 连接到MySQL服务器。   mysql_query() 执行指定为“以Null终结的字符串”的SQL查询   mysql_use_result() 初始化逐行的结果集检索   mysql_field_count() 返回上次执行语句的结果集的列数   mysql_fetch_row() 从结果集中获取下一行   mysql_num_fields() 返回结果集中的字段数     class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; };  基本步骤
使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接  Re:</description>
    </item>
    
    <item>
      <title>Centos7 Install mongodb</title>
      <link>https://6923403.github.io/post/install_mongodb/</link>
      <pubDate>Mon, 21 Sep 2020 13:44:35 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_mongodb/</guid>
      <description>Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo
[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc  Install Mongodb sudo yum install -y mongodb-org  Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use  Re:
https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</description>
    </item>
    
    <item>
      <title>Centos7 Install_redis</title>
      <link>https://6923403.github.io/post/install_redis/</link>
      <pubDate>Mon, 21 Sep 2020 13:32:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_redis/</guid>
      <description>升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo &amp;quot;source /opt/rh/devtoolset-9/enable&amp;quot; &amp;gt;&amp;gt; /etc/profile gcc -v  安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis  配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf
daemonize no 改为 daemonize yes  开机自启 vim /etc/systemd/system/redis.service
[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.</description>
    </item>
    
    <item>
      <title>Centos7 Install mysql</title>
      <link>https://6923403.github.io/post/install_mysql/</link>
      <pubDate>Sun, 20 Sep 2020 22:36:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_mysql/</guid>
      <description>1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled
3.安装Mysql5.7 sudo yum -y install mysql-community-server
4.启动Mysql sudo systemctl start mysqld
5.设置系统启动时自动启动 sudo systemctl enable mysqld
6.查看启动状态 sudo systemctl status mysqld
7.root 密码 cat /var/log/mysqld.log | grep -i &#39;temporary password&#39;
8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等
mysql_secure_installation
9.设置数据库编码为utf8 sudo vim /etc/my.cnf
[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect=&#39;SET NAMES utf8&#39; character-set-server = utf8 reboot sudo systemctl restart mysqld</description>
    </item>
    
    <item>
      <title>Mysql_use</title>
      <link>https://6923403.github.io/post/mysqluse/</link>
      <pubDate>Sat, 19 Sep 2020 12:08:34 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/mysqluse/</guid>
      <description>创建数据库 CREATE DATABASE IF NOT EXISTS vctest DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. CREATE DATABASE IF NOT EXISTS mytestdb;
删除数据库 drop database test1; 2. DROP DATABASE IF EXISTS mytestdb;
查看All DB show databases;
导入sql source test.sql
 select
use vctest select city, phone, country from `offices`; SELECT语句由以下列表中所述的几个子句组成：
语句中的SELECT和FROM语句是必须的，其他部分是可选的。
 SELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。  即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。
SELECT lastname, firstname, jobtitle FROM employees WHERE jobtitle = &#39;Sales Rep&#39;;  INSERT 创建表</description>
    </item>
    
    <item>
      <title>Left_Right</title>
      <link>https://6923403.github.io/post/leftright/</link>
      <pubDate>Thu, 17 Sep 2020 21:49:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/leftright/</guid>
      <description>形参（形式参数）
在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。
实参（实际参数）
函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。
形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。
 Re: http://c.biancheng.net/view/1853.html   左值和右值
http://c.biancheng.net/view/1510.html
 常量和变量
https://www.runoob.com/cprogramming/c-variables.html
https://www.runoob.com/cprogramming/c-constants.html
http://c.biancheng.net/cpp/html/19.html</description>
    </item>
    
    <item>
      <title>About function: Volatile</title>
      <link>https://6923403.github.io/post/volatile/</link>
      <pubDate>Sun, 13 Sep 2020 18:12:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/volatile/</guid>
      <description>https://zhuanlan.zhihu.com/p/33074506
https://www.runoob.com/w3cnote/c-volatile-keyword.html</description>
    </item>
    
    <item>
      <title>Socket struct</title>
      <link>https://6923403.github.io/post/socket_struct/</link>
      <pubDate>Sun, 13 Sep 2020 17:03:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_struct/</guid>
      <description>struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。
 但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：
struct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息
  sin_family指代协议族，在socket编程中只能是AF_INET
  sin_port存储端口号（使用网络字节顺序）
  sin_addr存储IP地址，使用in_addr这个数据结构</description>
    </item>
    
    <item>
      <title>Socket file</title>
      <link>https://6923403.github.io/post/socket_file/</link>
      <pubDate>Sun, 13 Sep 2020 16:43:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_file/</guid>
      <description>socket编程中需要用到的头文件
  sys/types.h：数据类型定义
  sys/socket.h：提供socket函数及数据结构
  netinet/in.h：定义数据结构sockaddr_in
  arpa/inet.h：提供IP地址转换函数
  netdb.h：提供设置及获取域名的函数
  sys/ioctl.h：提供对I/O控制的函数
  sys/poll.h：提供socket等待测试机制的函数
   其他在网络程序中常见的头文件
  unistd.h：提供通用的文件、目录、程序及进程操作的函数
  errno.h：提供错误号errno的定义，用于错误处理
  fcntl.h：提供对文件控制的函数
  time.h：提供有关时间的函数
  crypt.h：提供使用DES加密算法的加密函数
  pwd.h：提供对/etc/passwd文件访问的函数
  shadow.h：提供对/etc/shadow文件访问的函数
  pthread.h：提供多线程操作的函数
  signal.h：提供对信号操作的函数
  sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数
   建议：在编写网络程序时，可以直接使用下面这段头文件代码
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.</description>
    </item>
    
    <item>
      <title>Cpp exception class</title>
      <link>https://6923403.github.io/post/cpp_exception/</link>
      <pubDate>Sun, 13 Sep 2020 15:13:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_exception/</guid>
      <description>class exception{ public: exception () throw(); //构造函数 exception (const exception&amp;amp;) throw(); //拷贝构造函数 exception&amp;amp; operator= (const exception&amp;amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。
 exception 类的继承层次:  exception 类 直接派生类
   exceptopn explain     login_error logic error   runtime_error 运行时错误   bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常   bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常   bad_cast 使用 dynamic_cast 转换失败时抛出的异常   ios_base::failure io 过程中出现的异常   bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型     logic_error 的派生类</description>
    </item>
    
    <item>
      <title>Linux cpp put Backtrace</title>
      <link>https://6923403.github.io/post/backtrace/</link>
      <pubDate>Wed, 02 Sep 2020 14:10:18 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/backtrace/</guid>
      <description>获取Backtrace #include &amp;lt;execinfo.h&amp;gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file.</description>
    </item>
    
    <item>
      <title>Cpp11 move</title>
      <link>https://6923403.github.io/post/move/</link>
      <pubDate>Sun, 30 Aug 2020 19:57:05 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/move/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; int main() { std::string str = &amp;quot;Hello&amp;quot;; std::vector&amp;lt;std::string&amp;gt; v; //调用常规的拷贝构造函数，新建字符数组，拷贝数据 v.push_back(str); std::cout &amp;lt;&amp;lt; &amp;quot;After copy, str is \&amp;quot;&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;quot;\&amp;quot;\n&amp;quot;; //调用移动构造函数，掏空str，掏空后，最好不要使用str v.push_back(std::move(str)); std::cout &amp;lt;&amp;lt; &amp;quot;After move, str is \&amp;quot;&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;quot;\&amp;quot;\n&amp;quot;; std::cout &amp;lt;&amp;lt; &amp;quot;The contents of the vector are \&amp;quot;&amp;quot; &amp;lt;&amp;lt; v[0] &amp;lt;&amp;lt; &amp;quot;\&amp;quot;, \&amp;quot;&amp;quot; &amp;lt;&amp;lt; v[1] &amp;lt;&amp;lt; &amp;quot;\&amp;quot;\n&amp;quot;; } Cout:
After copy, str is &amp;quot;Hello&amp;quot; After move, str is &amp;quot;&amp;quot; The contents of the vector are &amp;quot;Hello&amp;quot;, &amp;quot;Hello&amp;quot;  函数原型 template &amp;lt;typename T&amp;gt; typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; t) { return static_cast&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t); }  原型定义中的原理实现: 公式一）X&amp;amp; &amp;amp;、X&amp;amp;&amp;amp; &amp;amp;、X&amp;amp; &amp;amp;&amp;amp;都折叠成X&amp;amp;，用于处理左值</description>
    </item>
    
    <item>
      <title>CPP11_thread</title>
      <link>https://6923403.github.io/post/cppthread/</link>
      <pubDate>Sat, 29 Aug 2020 11:44:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cppthread/</guid>
      <description>create_thread Ex   1.导入#include&amp;mdash;用于创建线程
  2.导入#include&amp;ndash;用于时间延时 获取时间之类的
  定义一个线程对象t1，这就自动创建了一个线程，参数就是你要线程去执行的函数，t1是变量名字 随便取
std::thread t1(func);
下面这里返回一个毫秒级别的时间间隔参数值，间隔10毫秒
std::chrono::milliseconds(10) this_thread::sleep_for（）就是让此线程休眠，可以传入休眠的时间 this_thread::sleep_for(std::chrono::milliseconds(10));让本线程休眠10毫秒  thread4
 join()就是阻塞线程 阻塞的目的就是让Main主线程等待一下创建的线程，免得我函数还在跑，程序就直接结束了。 detach()将线程与线程对象分离   thread5
c++11还提供了一个lock_guard类，它利用了RAII机制可以保证安全释放mutex。
在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。
在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。
lock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；
而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。
 thread6
c++11还提供了std::unique_lock
类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 unique_lock比lock_guard使用更加灵活，功能更加强大。 使用unique_lock需要付出更多的时间、性能成本。  thread7
互斥量很像的条件变量的知识
条件变量std::condition_variable的使用 std::condition_variable 是为了解决死锁而生的。 当互斥操作不够用而引入的。
比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。
std::condition_variable:
 notify_one()用于唤醒一个线程； notify_all() 则是通知所有线程。  C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。
 thread8
原子变量的使用
在新标准C++11，引入了原子操作的概念，原子操作更接近内核，并通过这个新的头文件提供了多种原子操作数据类型.
例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。
 thread9
future与promise的使用
在c++11中增加的线程库很方便的让我们去使用线程，但是因为做出了一些改变，我们并不能像往常一样直接使用thread.join()获取线程函数的返回值了，而我们有时候又确实要利用线程函数的返回值。
thread库提供了future用来访问异步操作的结果，因为一个异步操作的结果往往不能立即获取，只能在未来的某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future .
 future和promise的作用是在不同线程之间传递数据。
 假设线程1需要线程2的数据，那么组合使用方式如下:</description>
    </item>
    
    <item>
      <title>epoll use</title>
      <link>https://6923403.github.io/post/epoll_use/</link>
      <pubDate>Thu, 27 Aug 2020 12:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/epoll_use/</guid>
      <description>简介 #include &amp;lt;sys/epoll.h&amp;gt;
epoll与select
Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
 触发模式 epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
 水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件  //LevelTriggered(LT) //缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。
 边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。  //Edge Triggered(ET) //高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)
假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除， 则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。 总结: LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。 ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据, 也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样; 而LT模式是只要有数据没有处理就会一直通知下去的.  1. 创建一个epoll的句柄 int epoll_create(int size); 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。
这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
2. 将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //op为注册事件 epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</description>
    </item>
    
    <item>
      <title>Socket function</title>
      <link>https://6923403.github.io/post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket/</guid>
      <description>setsockopt
获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 SO_LINGER选项
struct linger { int l_onoff; int l_linger; };  l_onoff = 0, 数据保持发送完成后立即返回 l_onoff = 1, l_linger = 0, 立即放回 放弃发送, 发送rst 自身立即复位 l_onoff = 1, l_linger = 1, 阻塞到超时或数据发送完成, 保持尝试发送,超时后立即结束  SO_REUSEADDR选项
改变了通配绑定时处理源地址冲突的处理方式, 让端口释放后立即就可以被再次使用
 允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。一般不用于tco服务器 允许完全重复的捆绑  Re:
https://www.cnblogs.com/my_life/articles/5174585.html
https://www.jianshu.com/p/141aa1c41f15
https://blog.csdn.net/u010144805/article/details/78579528
 int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：</description>
    </item>
    
    <item>
      <title>Docker use Tutorial</title>
      <link>https://6923403.github.io/post/docker_tutorial/</link>
      <pubDate>Sat, 22 Aug 2020 16:42:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/docker_tutorial/</guid>
      <description>2021-5-30 更新 老方法不行了
Install docker apt-get install apt-transport-https ca-certificates software-properties-common curl curl -fsSL https://download.docker.com/linux/ubuntu/gpg|sudo apt-key add - sudo add-apt-repository &amp;quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) stable&amp;quot; apt-get update apt-get install docker-ce docker run hello-world # 重启 service docker restart  Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version  Dockerfile # from based nginx # run start FROM nginx # exec: RUN[&amp;quot;./go&amp;quot;, &amp;quot;dev&amp;quot;, &amp;quot;offline&amp;quot;] RUN echo &#39;Nginx image&#39; &amp;gt; /usr/share/nginx/html/index.</description>
    </item>
    
    <item>
      <title>Makefile template</title>
      <link>https://6923403.github.io/post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/makefile_template/</guid>
      <description>V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $&amp;lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹</description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://6923403.github.io/post/binary_tree/</link>
      <pubDate>Tue, 18 Aug 2020 14:40:25 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/binary_tree/</guid>
      <description>性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。
  性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。
  性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数 为n 2 ,则n 0 =n 2 +1。
  性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x 的最大整数)。
  性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序 编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:
   1.如果i=1,则结点i是二叉树的根,无双亲;如果i&amp;gt;1,则其双亲是结 点。
  2.如果2i&amp;gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是 结点2i。
  3.如果2i+1&amp;gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。
  树转换为二叉树 将树转换为二叉树的步骤如下
  1.加线。在所有兄弟结点之间加一条连 线。
  2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删 除它与其他孩子结点之间的连线。
  3.层次调整。以树的根结点为轴心, 将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子 是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子
   森林转换为二叉树 森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .
 1.把每个树转换为二叉树。 2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵 二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。 当所有的二叉树连接起来后就得到了由森林转换来的二叉树。   二叉树转换为树 二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; auto ponit</title>
      <link>https://6923403.github.io/post/cpp_auto_ponit/</link>
      <pubDate>Mon, 17 Aug 2020 15:10:13 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_auto_ponit/</guid>
      <description>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。   1.shared_ptr shared_ptr&amp;lt;T&amp;gt; sp
多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。
 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁   3. make_shared make_shared&amp;lt;T&amp;gt;(args)
shared_ptr&amp;lt;int&amp;gt; p = make_shared&amp;lt;int&amp;gt;(42); 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象
 3.weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。
 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题   4.</description>
    </item>
    
    <item>
      <title>Constexpr</title>
      <link>https://6923403.github.io/post/constexpr/</link>
      <pubDate>Fri, 14 Aug 2020 16:16:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/constexpr/</guid>
      <description>0.Array int url[10]; //true int url[6 + 4] //true int len = 10; int url[len] //flase  1.Constexpr #include &amp;lt;iostream&amp;gt; using namespace std; int main() { /* * If have not constexpr, CPP throw error */ constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts&amp;lt;&amp;lt; url[1] &amp;lt;&amp;lt; endl; return 0; }  2.Only have one &amp;lsquo;return&amp;rsquo; # Error constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } # True constexpr int display(int x) { return 1 + 2 + x; }  3.</description>
    </item>
    
    <item>
      <title>Shell_command($!, $@...)</title>
      <link>https://6923403.github.io/post/shell_commans/</link>
      <pubDate>Sat, 01 Aug 2020 21:31:50 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/shell_commans/</guid>
      <description>./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value   $* 1 2 3 4  </description>
    </item>
    
    <item>
      <title>Arch Beautify desktop</title>
      <link>https://6923403.github.io/post/arch_desktop/</link>
      <pubDate>Thu, 30 Jul 2020 18:04:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_desktop/</guid>
      <description>updat&amp;hellip;
1. install xorg pacman -S xorg-server xorg-xinit 2. install zsh, feh, i3gapsr, compton, oh-my-zsh pacman -S zsh xfce4-terminal feh compton i3-gaps nautilus i3lock sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;  install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts  add user useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim  startx exit login new user touch .</description>
    </item>
    
    <item>
      <title>Vmware install Archlinux </title>
      <link>https://6923403.github.io/post/arch_install/</link>
      <pubDate>Thu, 30 Jul 2020 16:43:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_install/</guid>
      <description>0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso You should installed Vmware and download Archlinux iso .
Change your firmwaretype to UEFI (The way many tutorials did not say)  1. Start ls /sys/firmware/efi/efivars The command detect UEFI files and if your dir not include files your firmwaretype is BIOS .
Then, ping google.com, detect interent connection
 Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.</description>
    </item>
    
    <item>
      <title>Hugo &amp; Markdown</title>
      <link>https://6923403.github.io/post/hugomarkdown/</link>
      <pubDate>Wed, 29 Jul 2020 18:27:35 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/hugomarkdown/</guid>
      <description>0. Hugo &amp;amp; Markdown Hugo &amp;amp;&amp;amp; MarkDown
 1. MarkDown template --- title: &amp;quot;{{ replace .Name &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot; date: {{ .Date }} lastmod: {{ .Date }} draft: false tags: [ ] categories: [ ] comment: true ---  2. Hugo command hugo #build html havn&#39;t draft=true hugo -D #build html and dragt=true hugo server #Start hugo server  3. Other Reference</description>
    </item>
    
    <item>
      <title>Variable function(fun(char *, ...)) and vsnprintf()</title>
      <link>https://6923403.github.io/post/variable_function/</link>
      <pubDate>Tue, 28 Jul 2020 14:44:30 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/variable_function/</guid>
      <description>void fun(char * fmt, &amp;hellip;); int vsprintf(char *str, const char *format, va_list arg);
  Test programming #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; /* * Re: https://github.com/antirez/kilo/kilo.c * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html */ char buffer[80]; int editorSetstatus(const char * fmt, ...) { va_list ap; va_start(ap, fmt); int ret; ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap); va_end(ap); return (ret); } int main(int argc, char **argv) { int len = 20; editorSetstatus(&amp;quot;%d&amp;quot;, len); printf(&amp;quot;%s \n&amp;quot;, buffer); return 0; }  gcc -Wall -g fun.</description>
    </item>
    
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>https://6923403.github.io/post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_install_boost/</guid>
      <description>Boost C++ is Cpp programming language that provides support for tasks and structures
 Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile &amp;amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;func1:&amp;quot; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;\tfunc2:&amp;quot; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl; sleep(2); } } int main() { boost::thread thread1(&amp;amp;func1); boost::thread thread2(&amp;amp;func2); system(&amp;quot;read&amp;quot;); isRuning = false; thread2.</description>
    </item>
    
    <item>
      <title>Ubuntu20 install FFmpeg</title>
      <link>https://6923403.github.io/post/ffmpeg_install/</link>
      <pubDate>Mon, 27 Jul 2020 17:41:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ffmpeg_install/</guid>
      <description>Start Download FFmpeg  Install tool 1. install yasm
sudo apt-get install yasm  if not installed yasm, os will output &amp;ldquo;nasm/yasm not found or too old. Use &amp;ndash;disable-x86asm for a crippled build.&amp;rdquo;
 2. install SDL2
SDL2-2.0.12(stable)
tar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install  Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg
cd ffmpeg/ ./configure sudo make -j4 sudo make install  3. Check ffmpeg -version ffplay -version </description>
    </item>
    
  </channel>
</rss>
