[{"content":"https://github.com/VcSpace/News-M.git 闻讯——获取主流财经新闻网站新闻信息获取, 将数据聚合、归类并写入表格中 。\nNews-M \u0026ndash;News Spider, Crawling news from mainstream financial news websites, categorize and write data into tables .\n 目的 时间与精力是有限的 为了节省查阅信息的时间成本故此创作News-M用来快捷提取有效信息, 节约时间, 放松精力。\nTime and energy are limited. In order to save the time cost of consulting information, news-m is created to quickly extract effective information, save time and relax energy.\n 运行程序 #Run pip install -r requirements.txt python3 main.py  Note 1. 操作完成后生成Finace文件夹 Windows系统在桌面 Linux在运行目录下\n1. After the operation, the finace folder will be generated. The windows system is on the desktop and the Linux is in the running directory\n2. 表格行高列宽是可以自动调整的 不用自己手动一行行的调整 具体操作看图\n2. The height and width of a table row can be adjusted automatically. You don't need to adjust one row manually. See the figure for the specific operation\n3. 享受阅读的乐趣\n3. Enjoy reading\n","href":"https://6923403.github.io/post/news_wps/","tags":"News-M ; Python ; Tutorial","title":"News-M Tutorial"},{"content":"三次握手 \n第一次握手:\n(客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。)\nClient端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。\n第二次握手:\n(服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。)\nServer端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack=seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK=1、SYN=1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。\n第三次握手:\n(客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1)\nClient收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。\n 四次挥手 \n第一次挥手\n(主动方发送Fin+Ack报文,并置发送序号为x)\n假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN=1，这个控制位代表客户端想要断开连接；序列号seq=u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。\n第二次挥手\n(被动方送ACK报文,并置发送序号为Z,在确认序号为x+1)\n服务端收到客户端的报文后发出确认报文，控制位ACK=1；确认号ack=u+1；序列号seq=v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。\n第三次挥手\n(被动方发送Fin+Ack报文,并置发送序号为Y,在确认序号为x)\n客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN=1，表示服务端向客户端发送断开连接请求；确认标志ACK=1；确认序号ack=u+1；序号seq=w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。\n第四次挥手\n(主动方发送ack报文,并置发送序号为x,在确认序号为Y)\n客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK=1；确认号ack=w+1;序号seq=u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。\n 相关面试题\n  TCP三次握手？为什么不是两次？为什么不是四次？\n 第一次握手, 目的端确认源端的发送能力、目的端确认目的端的接受能力 第二次握手, 源端确认源端的发送能力、源端确认源端的接受能力、源端确认目的端的发送能力、源端确认目的端的接收能力 第三次握手, 目的端确认源端的接收能力、目的端确认目的端的发送能力  因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。\n  TCP四次挥手？为什么不是三次？为什么不是五次？\n第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN=1）。\n如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。\n  在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？\n客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：\n  客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN=1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；\n  等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。\n  注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n     Re: https://zhuanlan.zhihu.com/p/137942749\nhttps://zhuanlan.zhihu.com/p/40013850\nhttps://zhuanlan.zhihu.com/p/138272238\n","href":"https://6923403.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","tags":"TCP","title":"TCP_三次握手与四次挥手"},{"content":"空间配置器  容器类型  标准STL序列容器: vector,string、 deque和list. 标准STL关联容器: set, multiset. map和multimap. 非标准序列容器slist和rope, slist是一个单向链表, rope本质上是一“重型\u0026quot; string 非标准的关联容器hash-set, hash-multiset. hash-map和hash-multimap 标准的非STL容器,包括数组、bitset. valarray、 stack, queue和priority_queue.   Vector template \u0026lt;class T, class Alloc=alloc\u0026gt; class vector{ private: //vector的嵌套型别定义 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type\u0026amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protect: // simple_alloc是SGI STL默认的空间配置器 typedef simple_alloc\u0026lt;value_type, Alloc\u0026gt; data_allocator; iterator start;\t// 表示目前使用空间的头 iterator finish;\t// 表示目前使用空间的尾 iterator end_of_storage;\t// 表示目前可用空间的尾 }; vector提供的接口：包括得到vector的属性接口、vector的操作接口以及构造函数：\n 构造函数：vector()、vector(size_type n、const T\u0026amp; value)、vector(size_type n)； 属性函数：begin、end、size、capacity、empty、operator[]、front和back 操作函数：push_back()、pop_back()、erase()、resize()、clear()。  ","href":"https://6923403.github.io/post/cpp_stl/","tags":"CPP ; STL","title":"Cpp_stl"},{"content":"时间戳获取 using namespace std::chrono; auto millisec_since_epoch = duration_cast\u0026lt;milliseconds\u0026gt;(system_clock::now().time_since_epoch()).count(); auto msec = duration_cast\u0026lt;microseconds\u0026gt;(system_clock::now().time_since_epoch()).count(); auto sec_since_epoch = duration_cast\u0026lt;seconds\u0026gt;(system_clock::now().time_since_epoch()).count(); std::cout \u0026lt;\u0026lt; \u0026quot;seconds since epoch: \u0026quot; \u0026lt;\u0026lt; sec_since_epoch \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026quot;milliseconds since epoch: \u0026quot; \u0026lt;\u0026lt; millisec_since_epoch \u0026lt;\u0026lt; std::endl;  秒seconds since epoch: 1622534342 微妙 milliseconds since epoch: 1622534342050   标准年月日+时间获取 std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()); char re_time[256] = {0}; std::strftime(re_time, sizeof(re_time), \u0026quot;%Y-%m-%d %X\u0026quot;, std::localtime(\u0026amp;now)); std::cout \u0026lt;\u0026lt; “注册时间 ” \u0026lt;\u0026lt; re_time \u0026lt;\u0026lt; std::endl; 注册时间: 2021-06-01 15:56:42\n Re:\nhttps://www.delftstack.com/howto/cpp/how-to-get-time-in-milliseconds-cpp/\nhttp://cn.voidcc.com/question/p-ynucfjxu-sk.html\n","href":"https://6923403.github.io/post/chrono_use/","tags":"CPP ; Chrono ; Time","title":"Chrono_use"},{"content":"安装 不是root自行加sudo\napt-get update apt-get install mysql-server apt-get install libmysqld-dev  配置 mysql_secure_installation 1. NO 2. 输入密码 3. 其余全部默认 修改root密码 8.0\nuse mysql; update user set authentication_string='' where user='root';--将字段置为空 ALTER user 'root'@'localhost' IDENTIFIED BY 'root';--修改密码为root  状态 #开启 service mysql start # 关闭 service mysql stop # 重启 service mysql restart # 状态 systemctl status mysql.service  Re:\nhttps://blog.csdn.net/u010520724/article/details/107444032\nhttps://blog.csdn.net/weixin_38924500/article/details/106261971\nhttps://blog.csdn.net/wolf131721/article/details/93004013\n","href":"https://6923403.github.io/post/ubuntu_install_mysql/","tags":"Mysql","title":"Ubuntu_install_mysql"},{"content":"主角得拿出来文字记录下。  一个m阶的B树具有如下属性:\n 每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。  在含有n个关键字的B树上查找时，从根结点到关键字结点的 路径上涉及的结点数不超过log |m/2| ((n+1)/2)+1。\n不错的讲解\n https://www.yiibai.com/data_structure/b-tree.html https://blog.nowcoder.net/n/ef07c1ad8f8346078eeab66518152bf0 https://blog.csdn.net/alzzw/article/details/97633941   一棵m阶的B+树和m阶的B树的差异在于:\n 有n棵子树的结点中包含有n个关键字； 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录 的指针，叶子结点本身依关键字的大小自小而大顺序链接； 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或 最小）关键字。  实现\nhttps://blog.csdn.net/liu1064782986/article/details/7982290\n 2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩（我们称它为2结点）或三个孩子（我们称它为3结点）。\n一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。\n这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。\n 一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。\n","href":"https://6923403.github.io/post/b_tree/","tags":"数据结构 ; CPP","title":"B_Tree"},{"content":"本来想等着越狱来着 没想到还会自动更新。。\n 去更新 创建了个zip再改名为update.bin.tmp.partial\nchmod a=r update.bin.tmp.partial  查看文件权限 ls -ld update.bin.tmp.partial -rw-r--r-- 1 root root 208 5月 10 2021 update.bin.tmp.partial 当亚马逊向你的 Kindle 推送更新固件时，会在 Kindle 根目录创建一个名为 update.bin.tmp.partial 的临时文件（该临时文件其实就是未下载完成的新固件文件，即便网络不稳定，它也会不断续传直至下载完毕），但是如果 Kindle 根目录有同名文件，它就无法创建了，从而达到阻止 Kindle 固件自动更新的目的。\n chattr 这个问题相关解答很少 帖子也很老 算了\n#这个保护命令没成 root@: mount --bind /media/root/Kindle/ /mnt/kindle/ root@: chattr +i update.bin.tmp.partial - chattr: 对设备不适当的 ioctl 操作 读取 update.bin.tmp.partial 的标志时  Re:\n书伴 https://bookfere.com/post/472.html\n","href":"https://6923403.github.io/post/kindle_%E5%8E%BB%E6%9B%B4%E6%96%B0/","tags":"Kindle","title":"Kindle 防止自动更新"},{"content":"计算机网络 应用层 HTTP   HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。\n  Cookie\n HTTP 是一种不保存状态，即无状态（stateless）协议。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。    请求方法\n  OPTIONS\n 请求一些选项信息，允许客户端查看服务器的性能    GET\n 请求指定的页面信息，并返回实体主体    HEAD\n 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头    POST\n 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改    PUT\n 从客户端向服务器传送的数据取代指定的文档的内容    DELETE\n 请求服务器删除指定的页面    TRACE\n 回显服务器收到的请求，主要用于测试或诊断      报文\n  报文\n 是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。    实体\n 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。    客户端(请求报文)\n  请求行\n 用于请求的方法，请求 URI 和 HTTP 版本    状态行\n 含表明响应结果的状态码，原因短语和 HTTP 版本    首部字段\n 表示请求和响应的各种条件和属性的各类首部 通用首部 请求首部 响应首部 实体首部      服务端(响应报文) 内容同上\n    内容编码\n  压缩传输的内容编码\n 内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。    分块传输编码\n 在传输大容量数据时，通过把数据分割成 多块，能够让浏览器逐步显示页面。 每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标 记。    多部分对象集合\n  MIME\n Multipurpose Internet Mail Extensions    Content-type\n  在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。\n  multipart/form-data\n 在 Web 表单文件上传时使用。    multipart/byteranges\n 状态码 206（Partial Content，部分内容）响应报文包含了多个范 围的内容时使用。    multipart/form-data\n  multipart/byteranges\n      范围请求(Range Request)\n Range: bytes=5000-    内容协商(Content Negotiation)\n 服务器驱动协商（Server-driven Negotiation） 客户端驱动协商（Agent-driven Negotiation） 透明协商（Transparent Negotiation） Accept Accept-Charset Accept-Encoding Accept-Language Content-Language      返回状态码\n  状态码\n  1XX\n Informational（信息性状态码） 接收的请求正在处理    2XX\n Success（成功状态码） 请求正常处理完毕 200 OK 204 No Content 206 Partial Content    3XX\n  Redirection（重定向状态码）\n  需要进行附加操作以完成请求\n  3XX 重定向\n  301 Moved Permanently\n  302 Found\n 临时性质    303 See Other\n  304 Not Modified\n  307 Temporary Redirect\n 临时重定向。与 302 Found 有着相同的含义      4XX\n Client Error（客户端错误状态码） 服务器无法处理请求 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found    5XX\n Server Error（服务器错误状态码） 服务器处理请求出错 500 Internal Server Error 503 Service Unavailable        报文首部\n  请求报文\n 方法 HTTP 版本 HTTP 首部字段    首部字段\n  首部\n 由首部字段名和字段值构成 中间用冒号“:” 分 隔。 首部字段名: 字段值 端到端首部（End-to-end Header） 逐跳首部（Hop-by-hop Header）    请求首部字段（Request Header Fields）\n  从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加 内容、客户端信息、响应内容相关优先级等信息。\n  Accept\n 通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。 若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。    Accept-Charset\n 通知服务器用户代理支持的字符集及 字符集的相对优先顺序。应用于内容协商机制的服务器驱动协商。    Accept-Encoding\n 告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。    Accept-Language\n 告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级    Authorization\n 告知服务器，用户代理的认证信息（证书值）。    Expect\n 期望出现的某种特定行 为。    From\n 服务器使用用户代理的用户的电子邮件地 址。    Host\n 请求的资源所处的互联网主机名和端口号。    If-Match\n 为条件请求。服务器接 收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。    If-Modified-Since\n 若 If- Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应。    If-None-Match\n 指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。    If-Range\n If- Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。    If-Unmodified-Since\n 告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。    Max-Forwards\n 接收到 Max-Forwards 值为 0 的请求 时，则不再进行转发，而是直接返回响应。    Proxy-Authorization\n 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。    Range\n 对于只需获取部分资源的范围请求    Referer\n 首部字段 Referer 会告知服务器请求的原始资源的 URI。    TE\n 服务器客户端能够处理响应的传输编码方式及相 对优先级。    User-Agent\n 将创建请求的浏览器和用户代理名称等信息传 达给服务器。      通用首部字段（General Header Fields）\n  请求报文和响应报文两方都会使用的首部。\n  Cache-Control\n 能够控制缓存的行为    Connection\n  控制不再转发给代理的首部字段\n Connection: 不再转发的首部字段名    管理持久连接\n Connection: close      Date\n 创建 HTTP 报文的日期和时间。    Pragma\n 仅作为与 HTTP/1.0 的向后兼容而定义。 Pragma: no-cache    Trailer\n 事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。    Transfer-Encoding\n 规定了传输报文主体时采用的编码方式。    Upgrade\n 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。    Via\n 追踪客户端与服务器之间的请求和响应报文 的传输路径。    Warning\n 告知用户一些与缓存相关的问题的警告。      响应首部字段（Response Header Fields）\n  从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加 内容，也会要求客户端附加额外的内容信息。\n  Accept-Ranges\n 客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。    Age\n 告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。    ETag\n  告知客户端实体标识。\n  强 ETag 值\n 不论实体发生多么细微的变化都会改变其值。 ETag: \u0026ldquo;usagi-1234\u0026rdquo;    弱 Tag 值\n 只用于提示资源是否相同。只有资源发生了根本改变，产 生差异时才会改变 ETag 值。 ETag: W/\u0026ldquo;usagi-1234\u0026rdquo;      Location\n 将响应接收方引导至某个与请求 URI 位置 不同的资源。    Proxy-Authenticate\n 把由代理服务器所要求的认证信息发送 给客户端。    Retry-After\n 告知客户端应该在多久之后再次发送请求。    Server\n 告知客户端当前服务器上安装的 HTTP 服务器应用程 序的信息。    Vary\n 可对缓存进行控制。    WWW-Authenticate\n 用于 HTTP 访问认证。      实体首部字段（Entity Header Fields）\n  针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更 新时间等与实体有关的信息。\n  Allow\n 通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。    Content-Encoding\n 告知客户端服务器对实体的主体部分选 用的内容编码方式。    Content-Language\n 告知客户端， 体主体使用的自然语言 （指中文或英文等语言）。    Content-Length\n 表明了实体主体部分的大小（单位是字 节）。    Content-Location\n 给出与报文主体部分相对应的 URI。    Content-MD5\n 是一串由 MD5 算法生成的值，其目的在于检 查报文主体在传输过程中是否保持完整，以及确认传输到达。    Content-Range\n 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。    Content-Type\n 说明了实体主体内对象的媒体类型。    Expires\n 会将资源失效的日期告知客户端。    Last-Modified\n 指明资源最终修改的时间。      Cookie首部\n  Set-Cookie\n  开始状态管理所使用的Cookie信息(响应首部字段)\n  expires\n Cookie 的有效期    path\n 将服务器上的文件目录作为Cookie的适用对象（若不指定则默 认为文档所在的文件目录）    domain\n 作为 Cookie 适用对象的域名    Secure\n 仅在 HTTPS 安全通信时才会发送 Cookie    HttpOnly\n 加以限制，使 Cookie 不能被 JavaScript 脚本访问      Cookie\n 服务器接收到的Cookie信息(请求首部字段)      其他首部字段\n  X-Frame-Options\n 用于控制网站内容 在其他 Web 网站的 Frame 标签内的显示问题。    X-XSS-Protection\n 属于 HTTP 响应首部 它是针对跨站脚本 攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。    DNT\n Do Not Track 的简 称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方 法。    P3P\n 保护用户隐私          身份认证\n  BASIC 认证\n  DIGEST 认证\n  SSL 客户端认证\n SSL 客户端认证采用双因素认证    基于表单认证\n    HTTPS   HTTP 的缺点\n  不验证通信方的身份，因此有可能遭遇伪装\n  验证通信方的身份\n 查明对方身份, 因HTPP任何人都可发起请求 查明对手的证书      无法证明报文的完整性，所以有可能已遭篡改\n  接收到的内容可能有误\n  请求或响应在传输途中，遭攻击者拦截并篡改内容的攻 击称为中间人攻击（Man-in-the-Middle attack，MITM）。\n  防止篡改\n MD5 SHA-1 散列值校验的方法， 以及用来确认文件的数字签名方法。      通信使用明文（不加密），内容可能会被窃听\n  TCP/IP 是可能被窃听的网络\n  防止窃听\n SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议） 内容加密        HTTPS加密\n  HTTP+ 加密 + 认证 + 完整性保护 =HTTPS\n  HTTPS 是身披SSL外壳的 HTTP\n HTTP-SSL-TCP-IP SSL      加密技术\n  采用一种 叫做公开密钥加密（Public-key cryptography）的加密处理方式。\n  公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。\n  加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。\n 使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥 确保交换的密钥是安全的前提下,使用共享密钥加密方式进行通信    证明公开密钥正确性的证书\n      HTTPS通信\n 客户端通过发送 Client Hello 报文开始 SSL通信。 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。 之后服务器发送 Certificate 报文。报文中包含公开密钥证 书。 最后服务器发送 Server Hello Done 报文通知客户端，最初阶 段的 SSL握手协商部分结束。 SSL第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。 服务器同样发送 Change Cipher Spec 报文。 服务器同样发送 Finished 报文。 服务器和客户端的 Finished 报文交换完毕之后，SSL连接 就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。 应用层协议通信，即发送 HTTP 响应。 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。 在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡 改，从而保护报文的完整性。    DNS 运输层 TCP   TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。\n  状态控制码\n  TCP：状态控制码（Code，Control Flag），占 6 比特\n  URG：紧急比特（urgent）\n 当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。    ACK：确认比特（Acknowledge）\n 只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。    PSH： (Push function)\n 若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。    SYN：同步比特(Synchronous)\n SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。    FIN：终止比特(Final)\n 用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。      特征\n  面向连接\n  可靠交互\n  如何保证可靠传输？\n 确认和超时重传 数据合理分片和排序 流量控制 拥塞控制 数据校验      全双工通信\n  面向字节流\n    数据包首部\n 以太网包首部 IP包首部 TCP包首部 数据    数据单位\n  包\n 全能性述语    帧\n 数据链路层中包的单位    数据报\n 数据报是IP和UDP等网络层以上的分层中包的单位    段\n TCP数 据流中的信息    消息\n 应用协议中数据的单位      发送数据包\n  应用程序处理\n  TCP模块的处理\n  IP模块的处理\n  网络接口（以太网驱动）的处理\n 每个包首部中至少都会包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。 每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。      TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗 口控制等机制实现可靠性传输。\n  通过序列号与确认应答提高可靠性\n 在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一 个已收到消息的通知。这个消息叫做确认应答（ACK（ACK（Positive Acknowled-gement）意指已经接收。） ）。    重发超时\n 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间 间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重 发。 在每次发 包时都会计算往返时间（Round Trip Time也叫RTT。是指报文段的往返 时间。） 及其偏差（RTT时间波动的值、方差。有时也叫抖动。） 。将 这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点 的值。    连接管理\n TCP提供面向有连接的通信传输。面向有连接是指在数据通信开始 之前先做好通信两端之间的准备工作。 UDP是一种面向无连接的通信协议，因此不检查对端是否可以通 信，直接将UDP包发送出去。    TCP以段为单位发送数据\n 在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可 以称其为“最大消息长度”（MSS：Maximum Segment Size）。    窗口控制\n 使用大量的缓冲区（缓冲区（Buffer）在此处表示 临时保存收发数据的场所。通常是在计算机内存中开辟的一部分空 间。） ，通过对多个段同时进行确认应答的功能。    流控制\n TCP提供一种机制可以让发送端根据接 收端的实际接收能力控制发送的数据量。 接收端主机向发送端主机通知自己可以接收数据的大小，于 是发送端会发送不超过这个限度的数据。    拥塞控制\n  为了在发送端调节所要发送数据的量\n  在慢启动的时候，将这个拥塞窗口的大小设置为1 个数据段（1MSS） 发送数据，之后每收到一 次确认应答（ACK），拥塞窗口的值就加1。\n  随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的 增长，拥堵状况激增甚至导致网络拥塞的发生。\n 为了防止这些，引入了 慢启动阀值的概念。只要拥塞窗口的值超出这个阀值，在每收到一次确 认应答时，只允许以下面这种比例放大拥塞窗口      提高网络利用率的规范\n  Nagle算法\n 送端即使还有应该发送的数据，但如果这部分数据很 少的话，则进行延迟发送的一种处理机制。    延迟确认应答\n 接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一 个较小的窗口。那是因为刚接收完数据，缓冲区已满。    捎带应答\n 根据应用层协议，发送出去的消息到达对端，对端进行处理以后， 会返回一个回执。        UDP   UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。\n  数据报格式\n  源端口号（Source Port）\n 表示发送端端口号，字段长16位。该字段是可选项。    目标端口号（Destination Port）\n 表示接收端端口，字段长度16位。    包长度（Length）\n 保存了UDP首部的长度跟数据的长度之和    校验和（Checksum）\n 校验和是为了提供可靠的UDP首部和数据而设计。在计算校验和时，附加在UDP伪首部与UDP数据报之前。      网络层 IP   IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。\n  IP地址由网络和主机两部分标识组成\n  IP地址的分类\n 为A类、B类、C类、D类（还有一个一 直未使用的E类。)    子网掩码\n  子网与子网掩码\n 子网掩码（subnet mask）：用来判断 IP 所属网络      特点\n  不可靠\n 不可靠(unreliable)的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。    无连接\n  无连接(connectionless)这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。\n  IP属于面向无连接型\n 即在发包之前，不需要建立与对端目标地址之间的 连接。上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包 发送出去。 一是为了简化，二是为了提速。 IP为了实现简单化与 高速化采用面向无连接的方式。          三大作用模块\n  IP寻址\n  IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。\n  子网寻址\n 不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。      路由\n  将分组数据发送到最终目标地址的功能。\n  发送数据至最终目标地址\n Hop译为中文叫“跳”。它是指网络中的一个区间。IP包正是在网络 中一个个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决 定着包在下一跳被转发的路径。      IP分包与组包\n  MTU\n 在线路上传送比包长还要小的MTU    IP分片(IP Fragmentation)\n 将较大的IP包分成多个较小的IP包        广播地址\n  用于在同一个链路中相互连接的主机之间发送数据包。\n  本地广播\n 在本网络内的广播叫做本地广播    直接广播\n 在不同网络之间的广播叫做直接广播。    ARP发送一份称作 A R P请求的以太网数据帧给以太网上的每个主机。这个过程称作广ARP发送一份称作 ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播\n    IP多播\n  同时发送提高效率\n 多播用于将包发送给特定组内的所有主机。由于其直接使用IP协 议，因此也不存在可靠传输。    IP多播与地址\n 多播使用D类地址。 IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议      IPv6\n  IP地址的扩大与路由控制表的聚合\n  性能提升\n 包首部长度采用固定的值（40字节），不再采用首部检验码。    支持即插即用功能\n 即使没有DHCP服务器也可以实现自动分配IP地址。    采用认证与加密功能\n  多播、Mobile IP成为扩展功能\n  全局单播地址\n 全局单播地址是指世界上唯一的一个地址。    链路本地单播地址\n 在同一个数据链路内唯一的地址。    唯一本地地址\n 是不进行互联网通信时所使用的地址。    IPv6分段处理\n IPv6的分片处理只在作为起点的发送端主机上进行，路由器不参与 分片。这也是为了减少路由器的负荷，提高网速。 最小MTU为1280字节。      IPV4首部\n  数据报格式\n  版本（Version）\n 表示标识IP首部的版本号。    首部长度（IHL：Internet Header Length）\n 表明IP首部的大小, 单位为4字节（32比特）    区分服务（TOS：Type Of Service）\n 由8比特构成，用来表明服务质量。    DSCP段与ECN段\n DSCP（Differential Services Codepoint，差分服务代码点）是 TOS（Type Of Service）的一部分。现在统称为DiffServ ，用来进行质量控制。    总长度（Total Length）\n 表示IP首部与数据部分合起来的总字节数。该字段长16比特。    标识（ID：Identification）\n 由16比特构成，用于分片重组。同一个分片的标识值相同，不同分 片的标识值不同。    标志（Flags）\n  由3比特构成，表示包被分片的相关信息。\n 0 未使用。现在必须是0。 1 指示是否进行分片（don\u0026rsquo;t fragment） 0- 可以分片 1- 不能分片 2 包被分片的情况下，表示是否为最后一个包（more fragment）。 0- 最后一个分片的包 1- 分片中段的包      片偏移（FO：Fragment Offset）\n 由13比特构成，用来标识被分片的每一个分段相对于原始数据的位 置。第一个分片对应的值为0。    生存时间（TTL：Time To Live）\n 由8比特构成，它最初的意思是以秒为单位记录当前包在网络上应 该生存的期限。然而，在实际中它是指可以中转多少个路由器的意思。    协议（Protocol）\n 由8比特构成，表示IP首部的下一个首部隶属于哪个协议。    首部校验和（Header Checksum）\n 由16比特（2个字节）构成，也叫IP首部校验和。该字段只校验数 据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。    源地址（Source Address）\n 由32比特（4个字节）构成，表示发送端IP地址。    目标地址（Destination Address）\n 由32比特（4个字节）构成，表示接收端IP地址。    可选项（Options）\n 长度可变，通常只在进行实验或诊断时使用。    填充（Padding）\n 也称作填补物。在有可选项的情况下，首部长度可能不是32比特的 整数倍。为此，通过向字段填充0，调整为32比特的整数倍。        IPV6首部\n  版本（Version）\n 与IPv4一样，由4比特构成。IPv6其版本号为6，因此在这个字段上 的值为“6”。    通信量类（Traffic Class）\n 相当于IPv4的TOS（Type Of Service）字段，也由8比特构成。    流标号（Flow Label）\n 由20比特构成，准备用于服务质量（QoS：Quality Of Service）控制。    有效载荷长度（Payload Length）\n 有效载荷是指包的数据部分。IPv4的TL（Total Length）是指包括 首部在内的所有长度。然而IPv6中的这个Playload Length不包括首部， 只表示数据部分的长度。由于IPv6的可选项是指连接IPv6首部的数据， 因此当有可选项时，此处包含可选项数据的所有长度就是Playload Length    下一个首部（Next Header）\n 由8比特构成。通常表示IP的上一层协 议是TCP或UDP。不过在有IPv6扩展首部的情况下，该字段表示后面第 一个扩展首部的协议类型。    跳数限制（Hop Limit）\n 由8比特构成。与IPv4中的TTL意思相同。    源地址（Source Address）\n 由128比特（8个16位字节）构成。表示发送端IP地址。    目标地址（Destination Address）\n 由128比特（8个16位字节）构成。表示接收端IP地址。      ARP   ARP（Address Resolution Protocol，地址解析协议）\n 以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设 备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过 ARP查找下一跳路由器的MAC地址。不过ARP只适用于IPv4    RARP（Reverse Address Resolution Protocol）是将ARP反过来，从 MAC地址定位IP地址的一种协议。\n  操作字段指出四种操作类型，它们是 ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）\n  如果A R P请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托 A R P或A R P代理(Proxy ARP)。\n ARP代理也称作混合ARP (promiscuousARP)或ARP出租(ARP hack)    0x0806为arp类型\n  ICMP   ICMP（Internet Control Message Protocol，网际控制报文协议）\n  确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。\n  ICMP目标不可达消息\n IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回 一个目标不可达（Destination Unreachable Message）的ICMP消息，并在 这个消息中显示不可达的具体原因    ICMP重定向消息\n 如果路由器发现发送端主机使用了次优的路径发送数据，那么它会 返回一个ICMP重定向（ICMP Redirect Message）的消息给这个主机。    ICMP超时消息\n IP包中有一个字段叫做TTL（Time To Live，生存周期），它的值 随着每经过一次路由器就会减1（当IP包在路由器上停留1秒以上时减去 所停留的秒数，但是现在绝大多数设备并不做这样的处理。） ，直到 减到0时该IP包会被丢弃    ICMP回送消息\n 用于进行通信的主机或路由器之间，判断所发送的数据包是否已经 成功到达对端的一种消息。    ICMP原点抑制消息\n 。ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。    ICMP路由器探索消息\n 主要用于发现与自己相连网络中的路由器。    ICMP地址掩码消息\n 主要用于主机或路由器想要了解子网掩码的情况。      不会产生的条件\n ICMP差错报文(但是, ICMP查询报文可能会产生ICMP差错报文)。 目的地址是广播地址或多播地址(D类地址)的IP数据报。 作为链路层广播的数据报。 不是IP分片的第一片 源地址不是单个主机的数据报。这就是说,源地址不能为零地址、环回地址、广播地址或多播地址。    IGMP  IGMP（Internet Group Management Protocol，网际组管理协议）  DHCP  为了实现自动设置IP地址、统一管理IP地址分配  NAT  NAT（Network Address Translator）是用于在本地网络中使用私有 地址，在连接互联网时转而使用全局IP地址的技术。  路由控制   互联网是由路由器连接的网络组合而成的。为了能让数据包正确达 地到达目标主机，路由器必须在途中进行正确地转发。这种向“正确的 方向”转发数据所进行的处理就叫做路由控制或路由。\n  静态路由\n 静态路由是指事先设置好路由器和主机中并将路由信息固定的一种 方法。    动态路由\n 动态路由是指让路由协议在运行过程中自动地设置路由控制信 息的一种方法。    路由控制的范围\n IGP（Interior Gateway Protocol） EGP（Exterior Gateway Protocol）    自治系统（路由选择域）\n 内部动态路由采用的协议是域内路由协 议，即IGP。而自治系统之间的路由控制采用的是域间路由协议，即 EGP。    数据链路层 三个目的  为I P模块发送和接收IP数据报 为ARP模块发送ARP请求和接收ARP应答 为RARP发送RARP请求和接收RARP应答。  以太网 无线LAN PPP(光纤) 主要信道   点对点信道\n  点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议\n  数据单元：帧\n  三个基本问题\n 封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）      广播信道\n  数据链路的段是指一个被分割的网络。  从网络层的概念看，它是一个网络（逻辑上）→即，从网络层的 立场出发，这两条网线组成一个段。 从物理层的概念看，两条网线分别是两个物体（物理上）→即， 从物理层的观点出发，一条网线是一个段。  网络拓扑  网络的连接和构成的形态称为网络拓扑（Topology）。网络拓扑 包括总线型、环型、星型、网状型等。  相关技术   MAC地址\n  识别数据链路中互连的节点\n  根据MAC地址转发\n  交换机转发方式\n  存储转发\n 检查以太网数据帧末尾的FCS位后再进行转发。可以避免发送由于冲 突而被破坏的帧或噪声导致的错误帧。    直通转发\n 不需要将整个帧全部接收下来以后再进行转发          共享介质型网络\n  指由多个设备共享一个通信介质的一种网络。\n  争用方式\n 争用方式（Contention）是指争夺获取数据传输的权力，也叫 CSMA（载波监听多路访问）。    令牌传递方式\n 发送一种叫做“令牌”的特殊报文      非共享介质网络\n 指不共享介质，是对介质采取专用的一种传输控 制方式。 全双工通信方式 半双工是指，只发送或只接收的通信方式    环路检测技术\n  最坏的情况下，数据帧会在环路 中被一而再再而三地持续转发。而一旦这种数据帧越积越多将会导致网 络瘫痪。\n  生成树方式\n 每个网桥必须在每1～10秒内相互交换 BPDU（Bridge Protocol Data Unit）包，从而判断哪些端口使用哪些不使 用，以便消除环路。    源路由法\n 判断发送数据的源 地址是通过哪个网桥实现传输的，并将帧写入RIF（Routing Information Field）。网桥则根据这个RIF信息发送帧给目标地址。      VLAN\n 采用带有 VLAN技术的网桥，就不用实际修改网络布线，只需修改网络的结构即 可。    以太网 无线通信 PPP  点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议   在串行链路上封装 I P数据报的方法。    建立、配置及测试数据链路的链路控制协议（ LCP：Link Control Protocol）。    针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。    双工 MTU   最大传输单元MTU\n 如果IP层有一个数据报要传,而且数据的长度比链路层的MTU还大,那么IP层 就需要进行分片( fragmentation),把数据报分成若干片,这样每一片都小于MTU    路径MTU\n 两台通信主机路径中的最小MTU.    物理层 物理层 各层作用/协议  RJ45、CLOCK、IEEE802.3（中继器，集线器） 通过媒介传输比特，确定机械及电气规范（比特 Bit）  数据链路层 各层作用/协议  PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 将比特组装成帧和点到点的传递（帧 Frame）  网络层 各层作用/协议  IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 负责数据包从源到宿的传递和网际互连（包 Packet）  运输层 各层作用/协议  TCP、UDP、SPX 提供端到端的可靠报文传递和错误恢复（ 段Segment）  会话层 各层作用/协议  NFS、SQL、NETBIOS、RPC 建立、管理和终止会话（会话协议数据单元 SPDU）  表示层 各层作用/协议  JPEG、MPEG、ASII 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）  应用层 各层作用/协议  FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 允许访问OSI环境的手段（应用协议数据单元 APDU）  ","href":"https://6923403.github.io/post/computer_network/","tags":"Http ; TCP","title":"Computer_network"},{"content":"2021-05-06更新 完善一下\n  网上教程坑特别多 这个步骤是我自己装好总结的\n  电脑dell\n  显卡1650\n   1. 去残留 sudo apt-get remove --purge nvidia*  2. 添加规则 vim /etc/modprobe.d/blacklist.conf\nblacklist nouveau options nouveau modeset=0  3. 验证是否成功 重启 重启之后输入命令\nsudo update-initramfs -u lsmod | grep nouveau 如果没有返回信息代表成功\n有信息的话 先检查下步骤2 再重启, 也可忽视 我这边见过一次有返回\n 4.选择合适的版本   1.输入命令: ubuntu-drivers devices\n  2.官网：Nvidia Official website\n  选择合适的版本来进行安装\nsudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update #选择自己的版本 例如我这边安装440 sudo apt-get install nvidia-driver-440  5.选择驱动应用 ubuntu配置点击 软件和更新 ==\u0026gt; 附件驱动 然后选择合适版本的驱动\nOpen warehouse =\u0026gt; additional drivers =\u0026gt; choose you drivers .\n 6. End 重启 之后输入命令\nnvidia-smi #完成 ","href":"https://6923403.github.io/post/install_nvidia/","tags":"Linux ; Ubuntu","title":"Ubuntu20 Install Nvidia drivers"},{"content":"条款41:了解隐式接口和编译期多态 template\u0026lt;typename T\u0026gt; void doProcessing (T\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastywidget) { T temp(w); temp.normalize(); temp.swap(w); } }  w必须支持哪一种接口,系由template中执行于w身上的操作来决定。 凡涉及w的任何函数调用,例如operator\u0026gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates\u0026quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。  显式接口和隐式接口的差异\n显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。\n 其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。  隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。\ntemplate\u0026lt;typename T\u0026gt; void doProcessing( T\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastywidget) { ... } }  它必须提供一个名为size的成员函数,该函数返回一个整数值。 它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T  本文要点\n classes和templates都支持接口(interfaces)和多态(polymorphism) 。 对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。 对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。   条款42: 了解typename的双重意义 template\u0026lt;class T\u0026gt; class widget; //使用\u0026#34;class\u0026#34; template\u0026lt;typename T\u0026gt; class Widget; //使用\u0026#34;typename\u0026#34;  C++并不总是把class和typename视为等价。有时候你一定得使用 typename。  template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { if (container.size() \u0026gt;= 2) { C::const iterator iter(container.begin()); ++iter; int value = *iter; std::cout \u0026lt;\u0026lt; value; } } template内出现的名 称如果相依于某个template参数, 称之为从属名称(dependent names)。如果从属 名称在class内呈嵌套状,我们称它为嵌套从属名称(nested dependent name) 。int是一个不依赖任何template参数的名称，为非从属名称(non-dependent names)。\ntemplate\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { if(container.size() \u0026gt;=2) C::const_iterator iter(container.begin()); //假设为非类型 } 如果解析器在template中遭遇一个嵌套从属名称,它便假设这名称不是个类型,除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。\n#正确版本 template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { //这是合法的CH+代码  if (container.size() \u0026gt;=2) { typename C::const_iterator iter(container.begin()); } } 一般性规则很简单:任何时候当你想要在template中指涉一个嵌套从属类型名称,就必须在紧临它的前一个位置放上关键字typename\n\u0026ldquo;typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是, typename不可以出现在base classes list内的嵌套从属类型名称之前,也不可在 member initialization list (成员初值列)中作为base class修饰符。\ntemplate\u0026lt;typename T\u0026gt; class Derived: public Base\u0026lt;T\u0026gt;::Nested { //不允许 public: explicit Derived(int x) : Base\u0026lt;T\u0026gt;::Nested(x) //不允许  { typename Base\u0026lt;T\u0026gt;::Nested temp; //允许  ... } ... }; 由于std::iterator-traits: :value-type是个嵌套从属类型名 称(value-type被嵌套于iterator-traits之内而IterT是个template参数) ,所以我们必须在它之前放置typename\ntemplate\u0026lt;typename IterT\u0026gt; void workwithiterator(IterT iter) typename std::iterator traits\u0026lt;IterT\u0026gt;::value type temp (*iter); 本文要点\n 声明template参数时,前缀关键字class和typename可互换。 请使用关键字typename标识嵌套从属类型名称;但不得在base class lists (基类 列)或member initialization list (成员初值列)内以它作为base class修饰符。   条款43: 学习处理模板化基类内的名称 class MsgInfo { ... }; template\u0026lt;typename Company\u0026gt; class MsgSender { public: void sendClear(const MsgInfo\u0026amp; info) { std::string msg; 这儿,根据info产生信息; Company c; c.sendcleartext (msg); } void sendSecret (const MsgInfo\u0026amp; info) { ... } }; template\u0026lt;typenane Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: void sendClearMsg (const MsgInfo\u0026amp; info) { //将“传送前”的信息写至log;  sendClear (info); //调用base class函数;这段码无法通过编译。  //将“传送后”的信息写至1og;  } ... }; 上面问题在于,当编译器遭遇class template LoggingMsgSender定义式时,并不知 道它继承什么样的class。当然它继承的是MsgSender,但其中的Company 是个template参数,不到后来(当LoggingMsgSender被具现化)无法确切知道它 是什么。而如果不知道Company是什么,就无法知道class MsgSender看起来像什么\u0026ndash;更明确地说是没办法知道它是否有个sendClear函数。\n解决办法\ntemplate\u0026lt;\u0026gt; class MsgSender\u0026lt;Companyz\u0026gt; { public: ... //删除了sendclear  void sendSecret(const MsgInfo\u0026amp; info) { ... } }； 注意class定义式最前头的\u0026quot;template\u0026lt;\u0026ldquo;语法象征这既不是template也不是 标准class,而是个特化版的MsgSender template,在template实参是Companyz时被使用。这是所谓的模板全特化(total template specialization)。\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsqSender\u0026lt;Company\u0026gt; { public: void sendClearMsg (const MsgInfo\u0026amp; info) { //将“传送前”的信息写至log;  sendClear(info); //如果company == Companyz,这个函数不存在。将“传送后”的信息写至log;  //将“传送后”的信息写至log;  } ... }; 它知道base class templates有可能被特化,而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在templatized base classes (模板化基类, 本例的MsgSenderkCompany\u0026gt;)内寻找继承而来的名称(本例的SendClear) 。\n为了重头来过,我们必须有某种办法令C++“不进入templatized base classes观察”的行为失效。 有三个办法,第一是在base class函数调用动作之前加上this-\u0026gt;\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsqSender\u0026lt;Company\u0026gt; { public: void sendClearMsq (const MsgInfo\u0026amp; info) { //将“传送前”的信息写至log;,  this-\u0026gt;sendClear(info); //将“传送后”的信息写至log;  } ... }; 第二是使用using声明式。\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: using MsgSender\u0026lt;Company\u0026gt;::sendClear; ... void sendClearMsg (const MsgInfo\u0026amp; info) { ... sendClear (info); ... } ... }; 第三个做法是,明白指出被调用的函数位于base class内:\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: void sendClearMsg (const MsgInfo\u0026amp; info) { ... MsgSender\u0026lt;Company\u0026gt;::sendClear(info); ... } ... }; 但这往往是最不让人满意的一个解法,因为如果被调用的是virtual函数,上述的明确资格修饰(explicit qualification)会关闭\u0026quot;virtual绑定行为”。\n从名称可视点(visibility point)的角度出发,上述每一个解法做的事情都相同:对编译器承诺\u0026quot;base class template的任何特化版本都将支持其一般(泛化)版本所提供的接口”。\nLoggingMsgSender\u0026lt;Companyz\u0026gt; zMsgSender; MsgInfo msgData; ... zMsgSender.sendClearMsg(msgData); //错误 因为在那个点上,编译器知道base class是个template特化版本Msgsender,而且它们知道那个 class不提供sendClear函数,而后者却是sendClearMsg尝试调用的函数。\n本文要点\n 可在derived class templates内通过\u0026quot;this-\u0026gt;\u0026ldquo;指涉base class templates内的成员名称,或藉由一个明白写出的\u0026quot;base class资格修饰符”完成。   条款44: 将与参数无关的代码抽离templates template\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix { public: ... void invert(); // 求逆矩阵 } SquareMatrix\u0026lt;double,5\u0026gt; sml; ... sm1.invert(); //调用SquareMatrix\u0026lt;double,5\u0026gt;::invert SquareMatrix\u0026lt;double,10\u0026gt; sm2; ... sm2.invert(); 这会具现两份invert。这些函数并非完全相同，但除了常量5和10，其他部分都相同，这是template引出代码膨胀的一个典型例子。\n下面是第一次修改\ntemplate\u0026lt;typename T\u0026gt; //与尺寸无关的base class class SquareMatrixBase{ protected: void invert(std::size_t matrixSize); //以给定的尺寸求逆矩阵 }; template\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SquareMatrixBase\u0026lt;T\u0026gt;{ private: using SquareMatrixBase\u0026lt;T\u0026gt;::invert;//避免遮掩base版的invert public: void invert() {this-\u0026gt;invert(n);} //制造一个inline调用，用this-\u0026gt;为了不被derived classes的函数名称掩盖 }; 带参数的invert位于base class中。和SquareMatrix一样，也是个template，不同的是他只对“矩阵元素对象的类型”参数化，不对矩阵的尺寸参数化。因此对于给定的元素对象类型，所有矩阵共享同一个(也是唯一一个）SquareMatrixBase class。也将因此而共享这唯一一个class内的invert。\n另一个办法是令SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存。而只要它存储了那些东西，也就可能存储矩阵尺寸：\ntemplate\u0026lt;typename T\u0026gt; class SquareMatrixBase{ protected: SquareMatrixBase(std::size_t n, T* pMem) :size(n), pData(pMem){} void setDataPtr(T* ptr){pData = ptr;} private: std::size_t size; T* pData; }; 这允许derived classes决定内存分配方式。某些实现版本也许会将矩阵数据存储在SquareMatrix对象内部：\ntemplate\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SquareMatrixBase\u0026lt;T\u0026gt;{ public: SquareMatrix(): SquareMatrixBase\u0026lt;T\u0026gt;(n, data) {} private: T data[n*n]; } 另一种做法是把每个矩阵的数据放进heap：\ntemplate\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SquareMatrixBase\u0026lt;T\u0026gt;{ public: SquareMatrix() :SquareMatrixBase\u0026lt;T\u0026gt;(n, 0),//base class的数据指针设为null  pData(new T[n*n])//为内容分配内存，将指向该内存的指针存储起来  { this-\u0026gt;setDataPtr(pData.get());//将pData的一个副本交给base class  } private: boost::scoped_array\u0026lt;T\u0026gt; pData; }; 本文要点\n Templates生成多个classes和多个函数,所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。 因非类型模板参数(non-type template parameters)而造成的代码膨胀,往往可消除,做法是以函数参数或class成员变量替换template参数。 因类型参数(type parameters)而造成的代码膨胀,往往可降低,做法是让带有 完全相同二进制表述(binary representations)的具现类型(instantiation types)共享实现码。   条款45: 运用成员函数模板接受所有兼容类型 Templates和泛型编程(Generic Programming)\n构造模版, 这样的模板(templates)是所谓member function templates (常简称为member templates) ,其作用是为class生成函数\ntemplate\u0026lt;typename\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; SmartPtr (const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other); }; template\u0026lt;typename\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; SmartPtr(const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other) : heldPtr (other.get ()) {..} T* get() const { return heldPtr; } private: T* heldptr; }; 使用成员初值列(member initialization list)来初始化SmartPtr之内类型为T*的成员变量,并以类型为U*的指针(由SmartEtrU\u0026gt;持有)作为初值。这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译,\n成员函数模版也支持赋值操作\ntemplate\u0026lt;class T\u0026gt; class shared_ptr { public: template\u0026lt;class Y\u0026gt; explicit shared_ptr(Y* p); template\u0026lt;class Y\u0026gt; shared_ptr(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); template\u0026lt;class Y\u0026gt; explicit shared_ptr(weak_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); template\u0026lt;class Y\u0026gt; explicit shared_ptr(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator-(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); }; 上述所有构造函数都是explicit,惟有“泛化copy构造函数\u0026quot;除外。那意味从某个sharedptr类型隐式转换至另一个sharedptr类型是被允许的,但从某个内置指针或从其他智能指针类型进行隐式转换则不被认可(如果是显式转换如cast强制转型动作倒是可以)。\nmember templates并不改变语言规则,而语言规则说,如果程序需要一个copy构造函数,你却没有声明它,编译器会为你暗自生成一个。在class内声明泛化copy构造函数(是个member template)并不会阻止编译器生成它们自己的copy构造函数(一个non-template)\n所以如果你想要控制copy构造的方方面面,你必须同时声明泛化copy构造函数和“正常的” copy构造函数。\ntemplate\u0026lt;class T\u0026gt; class shared ptr { public: shared_ptr(shared_ptr const\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); shared_ptr\u0026amp; operator=(shared_ptr const\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator= (shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); }; 本文要点\n 请使用member function templates (成员函数模板)生成“可接受所有兼容类型”的函数。 如果你声明member templates用于“泛化copy构造\u0026quot;或“泛化assignment操作\u0026rdquo;,你还是需要声明正常的copy构造函数和copy assignment操作符。   条款46:需要类型转换时请为模板定义非成员函数 条款24的模版化\ntemplate\u0026lt;typename т\u0026gt; class Rational { public: Rational (const T\u0026amp; numerator = 0, const T\u0026amp; denominator = 1); const T numerator() const; const T denominator() const; ... }; template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026amp; 1hs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { ... } Rational\u0026lt;int\u0026gt; oneHalf(1, 2);\nRational\u0026lt;int\u0026gt; result = oneHalf * 2;\n 在template实参推导过程中从不将隐式类型转换函数纳入考虑。  方法一: template class内的friend声明式可以指涉某个特定函数。那意味class Rational可以声明operator*是它的一个friend函数。令Rationalclass声明适当的operator*为其friend函数,可简化整个问题\ntemplate\u0026lt;typename T\u0026gt; class Rational { public: ... friend const Rational operator* (const Rational\u0026amp; 1hs, const Rational\u0026amp; rhs); }; template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator* (const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { ... } 当对象oneHalf被声 明为一个Rational, class Rational于是被具现化出来,而作为过程的 一部分, friend函数operator*(接受Rational参数)也就被自动声明出来。后者身为一个函数而非函数模板(function template) ,因此编译器可在调用它时使用隐式转换函数(例如Rational的non-explicit构造函数)\n混合式代码通过了编译,因为编译器知道我们要调用哪个函数(就是接受一个Rationalkint\u0026gt;以及又一个Rationalkint\u0026gt;的那个operator * ) ,但那个函数只被声明于Rational内,并没有被定义出来。\n方法二: 将operator * 函数本体合并至其声明式内:\ntemplate\u0026lt;typename T\u0026gt; class Rational { public: ... friend const Rational operator*(const Rational\u0026amp; 1hs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()) } }; \u0026ldquo;Rational是个template\u0026quot;这一事实意味上述的辅助函数通常也是个template, 所以定义了Rational的头文件代码,很典型地长这个样子:\ntemplate\u0026lt;typename T\u0026gt; class Rational; //声明Rational template template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; doMultiply(const Rational\u0026lt;T\u0026gt;\u0026amp; 1hs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs); template\u0026lt;typenane T\u0026gt; class Rational ( public: friend const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return doMultiply(lhs, rhs); } }； template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; doMultiply (const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return Rational\u0026lt;T\u0026gt; (lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } 本文要点\n 当我们编写一个class template,而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时,请将那些函数定义为\u0026quot;class template内部 的friend函数”   条款47: 请使用traits classes表现类型信息 STL迭代器分类(categories)\n  input选代器 只能向前移动,一次一步,客户只可读取(不能涂写)它们所指的东西,而且只能读取一次。\n  Output迭代器 一切只为输出:它们只向前移动,一次一步,客户只可涂写它们所指的东西,而且只能涂写一次。\n  forward迭代器。 这种迭代器可以做前述两种分类所能做的每一件事,而且可以读或写其所指物一次以上。这使得它们可施行于多次性操作算法(multi-pass algorithms) 。\n  Bidirectional迭代器 比上一个分类威力更大: 它除了可以向前移动,还可以向后移动。\n  random access选代器 这种迭代器比上一个分类威力更大的地方在于它可以执行“迭代器算术”,也就是它可以在常量时间内向前或向后跳跃任意距离。\n  针对这五种分类,C++标准库分别提供专属的\u0026quot;卷标结构\u0026rdquo;(tag struct)加以区分:\nstruct input_iterator_tag{}; struct output_iterator_tag{}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_iterator_tag:public bidirectional_iterator_tag{}; traits允许我们在编译期得到类型的信息。traits并非一个关键字，而是一个编程惯例。\ntraits的另一个需求在于advance对与基本数据类型也能正常工作，比如char*。所以traits不能借助类来实现， 于是我们把traits放到模板中。比如：\ntemplate\u0026lt;typename IterT\u0026gt; // template for information about struct iterator_traits; // iterator types terator_traits\u0026lt; IterT\u0026gt;将会标识IterT的迭代器类别。iterator_traits的实现包括两部分：\n 用户定义类型的迭代器 基本数据类型的指针  用户类型的迭代器\n在用户定义的类型中，typedef该类型支持迭代器的Tag\ntemplate\u0026lt; ... \u0026gt; // template params elided class deque { public: class iterator { public: typedef random_access_iterator_tag iterator_category; }: }; 在全局的iterator_traits模板中typedef那个用户类型中的Tag，以提供全局和统一的类型识别。\ntemplate\u0026lt;typename IterT\u0026gt; struct iterator_traits { typedef typename IterT::iterator_category iterator_category; }; 基本数据类型的指针\n为了支持指针迭代器, iterator-traits特别针对指针类型提供一个偏特化版本(partial template specialization) 。\ntemplate\u0026lt;typename IterT\u0026gt; struct iterator traits\u0026lt;IterT*\u0026gt; { typedef random access iterator tag iterator category; ... }; 如何设计并实现一个traits class\n 确认若干你希望将来可取得的类型相关信息。例如对迭代器而言,我们希望将 来可取得其分类(category) 。 为该信息选择一个名称(例如iterator_category) 。 提供一个template和一组特化版本(例如稍早说的iterator-traits) ,内含你希望支持的类型相关信息。  advance的实现\ntemplate\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iterator_tag)) ... } 上述实现其实并不完美，至少if语句中的条件在编译时就已经决定，它的判断却推迟到了运行时（显然是低效的）。 在编译时作此判断，需要为不同的iterator提供不同的方法，然后在advance里调用它们。\ntemplate\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { doAdvance( // call the version  iter, d, // of doAdvance  typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category() ); } // 随机访问迭代器 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::random_access_iterator_tag) { iter += d; } // 双向迭代器 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::bidirectional_iterator_tag) { if (d \u0026gt;= 0) { while (d--) ++iter; } else { while (d++) --iter; } } // 输入迭代器 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::input_iterator_tag) { if (d \u0026lt; 0 ) { throw std::out_of_range(\u0026#34;Negative distance\u0026#34;); // see below  } while (d--) ++iter; } 总结如何使用一个traits class\n 建立一组重载函数(身份像劳工)或函数模板(例如doAdvance) ,彼此间的差异只在于各自的traits参数。令每个函数实现码与其接受之traits信息相应和。 建立一个控制函数(身份像工头)或函数模板(例如advance) ,它调用上述那些“劳工函数”并传递traits class所提供的信息。  本文要点\n Traits classes使得“类型相关信息”在编译期可用。它们以templates和\u0026quot;templates特化”完成实现。 整合重载技术(overloading)后, traits classes有可能在编译期对类型执行 if.else测试。   条款48: 认识template元编程 Template metaprogramming (TMP,模板元编程)是编写template-based C++程序并执行于编译期的过程。\n**使用TMP有两个好处: **\n 第一,它让某些事情更容易。如果没有它,那些事情 将是困难的,甚至不可能的。 第二,由于template metaprograms执行于C++编译期,因此可将工作从运行期转移到编译期。  template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iterator_tag)){ iter += d; } ... } list\u0026lt;int\u0026gt;::iterator it; advance(it, 10); 其实上述代码是不能编译的，设想以下advance\u0026lt;list::iterator, int\u0026gt;中的这条语句：\niter += d; list\u0026lt;int\u0026gt;::iterator是双向迭代器，不支持+=运算。虽然上述语句不会执行，但编译器不知道这一点。 编译时这条语句仍然会抛出类型错误。\nTMP已被证明是个“图灵完全”(Turing-complete)机器\nTMP主要是个“函数式语言” (functional language), TMP的递归甚至不是正常种类,因为TMP循环并不涉及递归函数调用,而是涉及“递归模板具现化”(recursive template instantiation) 。\ntemplate\u0026lt;unsigned n\u0026gt; struct Factorial { enum { value = n * Factorial\u0026lt;n-1\u0026gt;::value }; }; template\u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; { //Factorial\u0026lt;0\u0026gt; 值为1  enum{ value=1 }; }; int main() { std::cout \u0026lt;\u0026lt; Factorial\u0026lt;5\u0026gt;::value; //印出120  std::cout \u0026lt;\u0026lt; Factorial\u0026lt;10\u0026gt;::value; //印出3628800 } 为了更好地理解TMP的重要性，我们来看看TMP能干什么：\n 确保量纲正确。在科学计算中，量纲的结合要始终保持正确。比如一定要单位为”m”的变量和单位为”s”的变量相除才能得到一个速度变量（其单位为”m/s”）。 使用TMP时，编译器可以保证这一点。因为不同的量纲在TMP中会被映射为不同的类型。 优化矩阵运算。比如矩阵连乘问题，TMP中有一项表达式模板（expression template）的技术，可以在编译期去除临时变量和合并循环。 可以做到更好的运行时效率。 自定义设计模式的实现。设计模式往往有多种实现方式，而一项叫基于策略设计（policy-based design）的TMP技术可以帮你创建独立的设计策略（design choices），而这些设计策略可以以任意方式组合。生成无数的设计模式实现方式。  本文要点\n Template metaprogramming (TMP,模板元编程)可将工作由运行期移往编译期,因而得以实现早期错误侦测和更高的执行效率。 TMP可被用来生成“基于政策选择组合\u0026rdquo; (based on combinations of policychoices)的客户定制代码,也可用来避免生成对某些特殊类型并不适合的代码。   了解C++内存管理例程的行为。这场游戏的两个主角是分配例程和归还例程(allocation and deallocation routines,也就是operator new和operator delete), 配角是new-handler, 这是当operator new无法满足客户的内存需求时所调用的函数。\noperator new和operator delete只适合用来分配单一对 象。Arrays所用的内存由operator new1]分配出来,并由operator delete[]归还(注意两个函数名称中的[])\n条款49: 了解new-handler的行为 new_handler函数运行代码\n当operator new抛出异常以反映一个未获满足的内存需求之前,它会先调用个客户指定的错误处理函数,一个所谓的new-handler。\nnamespace std { typedef void(*new handler) (); new_handler set_new_handler(new_handler p) throw(); } //以下是当operator new无法分配足够内存时, 该被调用的函数\nvoid outOfMem(){ std::cout \u0026lt;\u0026lt; \u0026#34;Unable to alloc memory\u0026#34;; std::abort(); } int main(){ std::set_new_handler(outOfMem); int *p = new int[100000000L]; } 当operator new无法满足内存申请时,它会不断调用new-handler函数,直到找到足够内存。\n一个设计良好的new-handler函数必须做以下事情:\n 使更多内存可用； 安装一个新的”new-handler”； 卸载当前”new-handler”，传递null给set_new_handler即可； 抛出bad_alloc（或它的子类）异常； 不返回，可以abort或者exit。  std::set_new_handler设置的是全局的bad_alloc的错误处理函数，C++并未提供类型相关的bad_alloc异常处理机制。 但我们可以重载类的operator new，当创建对象时暂时设置全局的错误处理函数，结束后再恢复全局的错误处理函数。\n比如Widget类，首先需要声明自己的set_new_handler和operator new：\nclass Widget{ public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc); private: static std::new_handler current; }; // 静态成员需要定义在类的外面 std::new_handler Widget::current = 0; std::new_handler Widget::set_new_handler(std::new_handler p) throw(){ std::new_handler old = current; current = p; return old; } 关于abort, exit, terminate的区别：abort会设置程序非正常退出，exit会设置程序正常退出，当存在未处理异常时C++会调用terminate， 它会回调由std::set_terminate设置的处理函数，默认会调用abort。\n最后来实现operator new，该函数的工作分为三个步骤：\n 调用std::set_new_handler，把Widget::current设置为全局的错误处理函数； 调用全局的operator new来分配真正的内存； 如果分配内存失败，Widget::current将会抛出异常； 不管成功与否，都卸载Widget::current，并安装调用Widget::operator new之前的全局错误处理函数。  我们通过RAII类来保证原有的全局错误处理函数能够恢复，让异常继续传播。关于RAII可以参见Item 13。 先来编写一个保持错误处理函数的RAII类：\nclass NewHandlerHolder{ public: explicit NewHandlerHolder(std::new_handler nh): handler(nh){} ~NewHandlerHolder(){ std::set_new_handler(handler); } private: std::new_handler handler; NewHandlerHolder(const HandlerHolder\u0026amp;); // 禁用拷贝构造函数  const NewHandlerHolder\u0026amp; operator=(const NewHandlerHolder\u0026amp;); // 禁用赋值运算符 }; Widget::operator new的实现\nvoid * Widget::operator new(std::size_t size) throw(std::bad_alloc){ NewHandlerHolder h(std::set_new_handler(current)); return ::operator new(size); // 调用全局的new，抛出异常或者成功 } // 函数调用结束，原有错误处理函数恢复 客户使用Widget的方式也符合基本数据类型的惯例：\nvoid outOfMem(); Widget::set_new_handler(outOfMem); Widget *p1 = new Widget; // 如果失败，将会调用outOfMem string *ps = new string; // 如果失败，将会调用全局的 new-handling function，当然如果没有的话就没有了 Widget::set_new_handler(0); // 把Widget的异常处理函数设为空 Widget *p2 = new Widget; // 如果失败，立即抛出异常 仔细观察上面的代码，很容易发现自定义”new-handler”的逻辑其实和Widget是无关的。我们可以把这些逻辑抽取出来作为一个模板基类：\ntemplate\u0026lt;typename T\u0026gt; class NewHandlerSupport{ public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc); private: static std::new_handler current; }; template\u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::current = 0; template\u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::set_new_handler(std::new_handler p) throw(){ std::new_handler old = current; current = p; return old; } template\u0026lt;typename T\u0026gt; void * NewHandlerSupport\u0026lt;T\u0026gt;::operator new(std::size_t size) throw(std::bad_alloc){ NewHandlerHolder h(std::set_new_handler(current)); return ::operator new(size); } 有了这个class template,为widget添加set-new-handler支持能力就轻而易举了:\n只要令widget继承自NewHandlerSupport\u0026lt;widget\u0026gt;就好\nclass Widget: public NewHandlerSupport\u0026lt;Widget\u0026gt; { ... //和先前一样但不必声明set_new_handler或operator new }; operator new则应该抛出bad alloc异常\nclass widget{ ....}; widget* pw1 = new widget; //分配失败 抛出bad_alloc if (pw1 == 0) ... //一定失败 widget* pw2 = new (std::nothrow) widget; //分配失败返回0 if (pw2 == 0) ... //可能成功 本文要点\n set-new_handler允许客户指定一个函数,在内存分配无法获得满足时被调用。 Nothrow new是一个颇为局限的工具,因为它只适用于内存分配;后继的构造函数调用还是可能抛出异常。   条款50: 了解new和delete的合理替换时机 替换编译器提供的operator new或operator delete理由:\n 检测使用错误。new得到的内存如果没有delete会导致内存泄露，而多次delete又会引发未定义行为。如果自定义operator new来保存动态内存的地址列表，在delete中判断内存是否完整，便可以识别使用错误，避免程序崩溃的同时还可以记录这些错误使用的日志。 提高效率。全局的new和delete被设计为通用目的（general purpose）的使用方式，通过提供自定义的new，我们可以手动维护更适合应用场景的存储策略。 收集使用信息。在继续自定义new之前，你可能需要先自定义一个new来收集地址分配信息，比如动态内存块大小是怎样分布的？分配和回收是先进先出FIFO还是后进先出LIFO？ 实现非常规的行为。比如考虑到安全，operator new把新申请的内存全部初始化为0. 其他原因，比如抵消平台相关的字节对齐，将相关的对象放在一起等等。  定制型operator new\nstatic const int signature = 0xDEADBEEF; // 边界符 typedef unsigned char Byte; void* operator new(std::size_t size) throw(std::bad_alloc) { // 多申请一些内存来存放占位符  size_t realSize = size + 2 * sizeof(int); // 申请内存  void *pMem = malloc(realSize); if (!pMem) throw bad_alloc(); // 写入边界符  *(reinterpret_cast\u0026lt;int*\u0026gt;(static_cast\u0026lt;Byte*\u0026gt;(pMem)+realSize-sizeof(int))) = *(static_cast\u0026lt;int*\u0026gt;(pMem)) = signature; // 返回真正的内存区域  return static_cast\u0026lt;Byte*\u0026gt;(pMem) + sizeof(int); } 这个operator new的缺点主要在于它疏忽了身为这个特殊函数所应该具备的“坚持C++规矩”的态度。\n所有operator news都应该内含一个循环,反复调用某个new-handling函数。\n齐位(alignment)意义重大,因为C++要求所有operator news返回的指针都有适当的对齐(取决于数据类型)。\n本条款的主题是,了解何时可在“全局性的”或\u0026quot;class专属的”基础上合理替换缺省的new和delete:\n 为了检测运用错误 为了收集动态分配内存之使用统计信息 为了增加分配和归还的速度。 为了降低缺省内存管理器带来的空间额外开销。 为了弥补缺省分配器中的非最佳齐位(suboptimal alignment)。 为了将相关对象成簇集中。 为了获得非传统的行为。  本文要点\n 有许多理由需要写个自定的new和delete,包括改善效能、对heap运用错误进行调试、收集heap使用信息。   条款51: 编写new和delete时需固守常规 实现一致性operator new必得返回正确的值,内存不足时必得调用new-handling函数 ,必须有对付零内存需求的准备,还需避免不慎掩盖正常形式的new。\noperator new的返回值十分单纯。如果它有能力供应客户申请的内存,就返回一个指针指向那块内存。如果没有那个能力,就遵循条款49描述的规则,并抛出一个badalloc异常。然而其实也不是非常单纯,因为operatornew实际上不只一次尝试分配内存,并在每次失败后调用new-handling函数。\n奇怪的是C++规定,即使客户要求0bytes, operator new也得返回一个合法指针。\nnon-member operator new\nvoid* operator new(std::size_t size) throw(std::bad_alloc) { using namespace std; if (size ==0) { size = 1; } while (true) { 尝试分配size bytes; if (分配成功) return (一个指针,指向分配得来的内存); //分配失败;找出目前的new-handling函数(见下)  new_handler globalHandler = set_new_handler(0); set_new_handler(globalHandler); if (globalHandler) (*globalHandler)(); else throw std::bad_alloc(); } }  size == 0时申请大小为1看起来不太合适，但它非常简单而且能正常工作。况且你不会经常申请大小为0的空间吧？ 两次set_new_handler调用先把全局”new handler”设置为空再设置回来，这是因为无法直接获取”new handler”，多线程环境下这里一定需要锁。 while(true)意味着这可能是一个死循环。所以Item 49提到，”new handler”要么释放更多内存、要么安装一个新的”new handler”，如果你实现了一个无用的”new handler”这里就是死循环了。  谈到operator new内含一个无穷循环,而上述伪码明白表明出这个循环: \u0026ldquo;while (true)\u0026ldquo;就是那个无穷循环。\n退出此循环的唯一办法是:内存被成功分配或new-handling函数做了一件描述于条款49的事情:让更多内存可用、安装 另一个new-hander、卸除new-handler、抛出badalloc异常(或其派生物) ,或是承认失败而直接return。\n重载operator new为成员函数通常是为了对某个特定的类进行动态内存管理的优化，而不是用来给它的子类用的。 因为在实现Base::operator new()时，是基于对象大小为sizeof(Base)来进行内存管理优化的。\n当然，有些情况你写的Base::operator new是通用于整个class及其子类的，这时这一条规则不适用。\nclass Base{ public: static void* operator new(std::size_t size) throw(std::bad_alloc); }; class Derived: public Base{...}; Derived *p = new Derived; //调用了Base::operator new 子类继承Base::operator new()之后，因为当前对象不再是假设的大小，该方法不再适合管理当前对象的内存了。 处理此情势的最佳做法是将“内存申请量错误”的调用行为改采标准operator new\nvoid *Base::operator new(std::size_t size) throw(std::bad_alloc){ if(size != sizeof(Base)) return ::operator new(size); ... } 上面的代码没有检查size == 0！这是C++神奇的地方，大小为0的独立对象会被插入一个char（见Item 39）。 所以sizeof(Base)永远不会是0，所以size == 0的情况交给::operator new(size)去处理了。\n这里提一下operator new[]，它和operator new具有同样的参数和返回值， 要注意的是你不要假设其中有几个对象，以及每个对象的大小是多少，所以不要操作这些还不存在的对象。因为：\n 你不知道对象大小是什么。上面也提到了当继承发生时size不一定等于sizeof(Base)。 size实参的值可能大于这些对象的大小之和。因为Item 16中提到，数组的大小可能也需要存储。  operatore delete\nC++保证“删除null指针永远安全”\nvoid operator delete(void *rawMem) throw(){ if(rawMem == 0) return; // 释放内存 } 万一你的class专属的operator new将大小有误的分配行为转交::operator new执行,你也必须将大小有误的删除行为转交::operator delete执行:\nclass Base{ public: static void * operator new(std::size_t size) throw(std::bad_alloc); static void operator delete(void *rawMem, std::size_t size) throw(); }; void Base::operator delete(void *rawMem, std::size_t size) throw(){ if(rawMem == 0) return; // 检查空指针  if(size != sizeof(Base)){ ::operator delete(rawMem); } // 释放内存 } 如果即将被删除的对象派生自某个base class而后者欠缺virtual析 构函数,那么C++传给operatordelete的sizet数值可能不正确。\n本文要点\n operator new应该内含一个无穷循环,并在其中尝试分配内存,如果它无法满足内存需求,就该调用new_handler,它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。   条款52: 写了placement new也要写placement delete “placement new”通常是专指指定了位置的new(std::size_t size, void *mem)，用于vector申请capacity剩余的可用内存。 但广义的”placement new”指的是拥有额外参数的operator new。\nnew和delete是要成对的，因为当构造函数抛出异常时用户无法得到对象指针，因而delete的责任在于C++运行时。 运行时需要找到匹配的delete并进行调用。因此当我们编写了”placement new”时，也应当编写对应的”placement delete”， 否则会引起内存泄露。在编写自定义new和delete时，还要避免不小心隐藏它们的正常版本。\nclass widget { public: //非正常形式的new  static void* operator new(std::size t size, std: :ostream\u0026amp; logStream) throw (std::bad alloc); //正常的class专属delete  static void operator delete (void* pMemory std::size_t size) throw(); }; 如果operatornew接受的参数除了一定会有的那个sizet之外还有其他,这 便是个所谓的placement new。因此,上述的operator new是个placement版本。众多placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”:\nvoid* operator new(std::size_t, void* pMemory) throw(); 那个class将引起微妙的内存泄漏\nwidget* pw = new (std::cerr)widget; 如果内存分配成功,而widget构造函数抛出异常,运行期系统有责任取消operator new的分配并恢复旧观。然而运行期系统无法知道真正被调用的那个operator new如何运作,因此它无法取消分配并恢复旧观,所以上述做法行不通。\n运行期系统寻找“参数个数和类型都与operator new相同”的某个operator delete。如果找到,那就是它的调用对象。\nvoid operator delete(void*, std::ostream\u0026amp;) throw(); 如果一个带额外参数的operator new没有“带相同额外参数”的对应版operator delete,那么当new的内存分配动作需要取消并恢复旧观时就没有任何operator delete会被调用。\nclass widget { public: static void* operator new(std::size t size, std::ostream\u0026amp; logstream) throw (std::bad alloc); static void operator delete (void* pMemory) throw(); static void operator delete (void* pMemory, std::ostream\u0026amp; logstream) throw(); }; placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针(例如上述的pw)施行delete绝不会导致调用 placement delete, 这意味着避免内存泄漏我们需要一个正常的operatordelete(用于构造期间无任何异常被抛出)和一个placement版本(用于构造期间有异常被抛出)。后者的额外参数必须和operator new一样。\n由于成员函数的名称会掩盖其外围作用域中的相同名称(见条款33),你必须小心避免让class专属的news掩盖客户期望的其他news (包括正常版 本) 。\nclass Base { public: static void* operator new(std::size t size, std::ostream\u0026amp; logStream) throw(std::bad alloc); }; Base* pb = new Base; //错误!因为正常形式的operator new被掩盖. Base* pb = new (std::cerr) Base; //正确,调用Base的placement new. 为了避免全局的”new”被隐藏，先来了解一下C++提供的三种全局”new”：\nvoid* operator new(std::size_t) throw(std::bad_alloc); //normal new void* operator new(std::size_t, void*) throw(); //placement new void* operator new(std::size_t, const std::nothrow_t\u0026amp;) throw(); //见Item 49 对于每一个可用的operator new也请确定提供对应的operator delete。如果你希望这些函数有着平常的行为,只要令你的class专属版本调用global版本即可。\nclass StandardNewDeleteForms { public: // normal new/delete  static void* operator new(std::size_t size) throw(std::bad_alloc) { return ::operator new(size); } static void operator delete(void *pMemory) throw() { ::operator delete(pMemory); } // placement new/delete  static void* operator new(std::size_t size, void *ptr) throw() { return ::operator new(size, ptr); } static void operator delete(void *pMemory, void *ptr) throw() { return ::operator delete(pMemory, ptr); } // nothrow new/delete  static void* operator new(std::size_t size, const std::nothrow_t\u0026amp; nt) throw() { return ::operator new(size, nt); } static void operator delete(void *pMemory, const std::nothrow_t\u0026amp;) throw() { ::operator delete(pMemory); } }; 凡是想以自定形式扩充标准形式的客户,可利用继承机制及using声明式, 取得标准形式:\nclass widget: public StandardNewDeleteForms { public: using StandardNewDeleteForms::operator new; using standardNewDeleteForms::operator delete; static void* operator new(std::size t size std: :ostrean\u0026amp; logSt.ream) throw (std::bad alloc); static void operator delete(void* pMemory, std::ostream\u0026amp; logstream) throw(); ... }; 本文要点\n 当你写一个placement operator new,请确定也写出了对应的placementoperator delete。如果没有这样做,你的程序可能会发生隐微而时断时续的内存泄漏。 当你声明placement new和placement delete,请确定不要无意识(非故意)地遮掩了它们的正常版本。   条款53: 不要轻忽编译器的警告 编译警告在C++中很重要，因为它可能是个错误啊！ 不要随便忽略那些警告，因为编译器的作者比你更清楚那些代码在干什么。 所以，\n 请严肃对待所有warning，要追求最高warning级别的warning-free代码； 但不要依赖于warning，可能换个编译器有些warning就不在了。  一个常见错误\nclass B{ public: virtual void f() const; }; class D:public B{ public: virtual void f(); }; 这里希望以D::f重新定义virtual函数B::,但其中有个错误: B中的f是个const成员函数,而在D中它未被声明为const。我手上的一个编译器于是这样说 话了：\nwarning: D::f() hides virtual B::f() 这个编译器试图告诉你声明于B中的f并未在D中被重新声明, 而是被整个遮掩了。\n本文要点\n 严肃对待编译器发出的警告信息。努力在你的编译器的最高(最严苛)警告级别下争取“无任何警告”的荣誉。 不要过度倚赖编译器的报警能力,因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上,你原本倚赖的警告信息有可能消失。   条款54: 让自己熟悉包括TR1在内的标准程序库 本文要点\n C++标准程序库的主要机能由STL, iostreams、 locales组成。并包含C99标准程序库。 TR1添加了智能指针(例如trl::shared ptr)、一般化函数指针(tr1:: function) 、 hash-based容器、正则表达式(regular expressions)以及另外10个组件的支持。 TR1自身只是一份规范。为获得TR1提供的好处,你需要一份实物。一个好的 实物来源是Boost   条款55: 让自己熟悉Boost 本文要点\n Boost是一个社群,也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在CH+标准化过程中扮演深具影响力的角色。 Boost提供许多TR1组件实现品,以及其他许多程序库。   Re:\nhttps://blog.csdn.net/qq_36915078/article/details/104751688\nhttps://harttle.land/tags.html#Effective-C++\n","href":"https://6923403.github.io/post/effective_cpp_2/","tags":"cpp","title":"Effective C++ 下"},{"content":"补充实例： cpp_class继承: https://6923403.github.io/post/cpp_inherit\n 1. private, public, protected 访问标号的访问范围\nprivate：只能由1.该类中的函数、2.其友元函数访问。 不能被任何其他访问，该类的对象也不能访问。\nprotected：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问。 但不能被该类的对象访问。\npublic：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。\n注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。\n2 类被继承后方法属性变化\nprivate 属性不能够被继承。 使用private继承， 父类的protected和public属性在子类中变为private； 使用protected继承，父类的protected和public属性在子类中变为protected； 使用public继承， 父类的protected和public属性不发生改变;\n3 private继承和public继承的适用情况\nC++将public继承视为is-a关系。private继承则并不意味着is-a关系，private继承意味着implemented-in-terms-of（根据某物实现出）。private继承意味着只有实现部分被继承，接口部分被略去。private继承在软件设计层面上没有意义，其意义只在于软件实现层面。\nprivate继承：\n1）编译器不会自动将一个子类对象转换为一个父类对象，而public继承会；\n2）子类中由父类继承而来的成员（protected和public）都变为private。\nimplemented-in-terms-of也可以由复合实现。在应用域，复合意味着has-a；在实现域，复合意味着is-implemented-in-terms-of。尽可能使用复合实现这种关系，必要时（涉及protected成员或virtual函数时）才使用private继承。\n 原文链接：https://blog.csdn.net/kingzone_2008/article/details/10066181   虚继承 C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。解决二义性。\nclass sum {}; class a : virtual public sum { ... } class b : virtual public sum { ... }; class c:: public a, public b { ... }; ","href":"https://6923403.github.io/post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/","tags":"cpp","title":"cpp_class权限 继承"},{"content":"条款01: 将C++视为一个语言联邦 C++已经是个多重范型编程语言 (multiparadigm programming language）\n同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。\n 条款02：尽量以 const，enum，inline替换#define 也可以说是 宁可以编译器替换预处理器\n#define 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间\n第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：\nclass Gameplayer { private: static const int NumTurns = 5; //常量声明式  int scores[NumTurns]; ... }; 第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的\u0026quot;the enum hack\u0026quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”\nenum hack的行为某方面说比较像#define而不像const\nclass Gameplayer { private: enum {NumTurns = 5}; int scores[NumTurns]; ... }; 本文要点\n  对于单纯常量,最好以const对象或enums替换#defines.\n  对于形似函数的宏(macros) ,最好改用inline函数替换#defines.\n   条款03: 尽可能使用const 如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。\n作用\n 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。  char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量  // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026amp; Var); // 引用参数在函数内为常量  // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:你曾经承诺不改动的那个对象被改动了。这就是为什么\u0026quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。\nnon-const成员函数本来就可以对其对象做任何动作,所以在其中调用一个const成员函数并不会带来风险。这就是为什么本例以static_cast作用于*this的原因: 这里并不存在const相关危险。\n观点\n 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。 编译器强制实施bitwise constness,但你编写程序时应该使用“概念上的常量性” (conceptual constness) 当const和non-const成员函数有着实质等价的实现时,令non-const版本调用const版本可避免代码重复。   条款04: 确定对象被使用前已先被初始化 第一、 读取未初始化的值会导致不明确的行为。\n第二、使用构造函数初始化列表进行初始化为佳\n#2这个构造函数和#1的最终结果相同,但通常效率较高。基于赋值的那个版 本(本例第一版本)首先调用default构造函数为theName, theAddress和thePhones设初值,然后立刻再对它们赋予新值。 default构造函数的一切作为因此浪费了。\nclass ABEntry { public: ABEntry(); private: int a; int b; int c; }; # 1 ABEntry::ABEntry() { a = 0; b = 0; c = 0; } #2 ABEntry::ABEntry() : a(0), b(0), c(0) {} 有些情况下即使面对的成员变量属于内置类型(那么其初始化与赋值的成本相同) ,也一定得使用初值列。是的,如果成员变量是const或references,它们就一定需要初值,不能被赋值。\n第三、 防止初始化次序问题 合理运用单例模式\n#1 class Filesystem { public: ... static Filesystem* fts(); }; Filesystem* Filesystem::GetInstance() { static connection_pool connPool; return \u0026amp;connPool; } #2 class Filesystem { private: static Filesystem* fts; Filesystem(){}; public: static Filesystem* getInstance() { if (fts == nullptr) { fts = new Filesystem(); } return fts; } }; 本文要点\n 为内置型对象进行手工初始化,因为C++不保证初始化它们。 构造函数最好使用成员初值列(member initialization list) ,而不要在构造函数 本体内使用赋值操作(assignment) 。初值列列出的成员变量,其排列次序应该和它们在class中的声明次序相同。 为免除“跨编译单元之初始化次序”问题,请以local static对象替换non-local static对象。   条款05: 了解C++默默编写并调用哪些函数 编译器可以暗自为class创建默认构造函数、拷贝构造函数、拷贝赋值操作符、以及析构函数。记住，这些函数不是类一创建出来就有的，惟有当这些函数被需要（调用），它们才会被编译器创建出来。\n当然，如果你在创建类时，自己声明了那些函数，编译器就不会再创建了。\n 条款06: 若不想使用编译器自动生成的函数，就该明确拒绝 class HomeForSale { public: ... private: HomeForSale(const HomeForSale\u0026amp;); HomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;); ... }; 本文要点\n 为驳回编译器自动(暗自)提供的机能,可将相应的成员函数声明为private并且 不予实现。使用像Uncopyable这样的base class也是一种做法。   条款07: 为多态基类声明virtual析构函数 如果base class没有virtual 会直接调用base class析构函数, derived class成员未释放。造成资源泄漏、内存浪费。\n无端地将所有classes的析构函数声明为virtual,就像从未声明它们为virtual一样,都是错误的。许多人的心得是:只有当class内含至少一个virtual函数,才为它声明virtual析构函数。\n欲实现出virtual函数,对象必须携带某些信息,主要用来在运行期决定哪一个 virtual函数该被调用。这份信息通常是由一个所谓vptr (virtual table pointer)指针指 出。vptr指向一个由函数指针构成的数组,称为vtbl(virtual table);每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数,实际被调用的函数取决于该对象的vptr所指的那个vtbl-编译器在其中寻找适当的函数指针。\n第二、 关于虚函数、纯虚函数\n 虚函数，在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func() 纯虚函数，在虚函数后加“=0”，如 virtual void func()=0 对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。 对于纯虚函数，子类必须提供纯虚函数的个性化实现。 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。 构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。  如何选用\n 当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。 当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。  本文要点\n polymorphic (带多态性质的) base classes应该声明一个virtual析构函数。如果 class带有任何virtual函数,它就应该拥有一个virtual析构函数。 Classes的设计目的如果不是作为base classes使用,或不是为了具备多态性 (polymorphically) ,就不该声明virtual析构函数。   条款08: 别让异常逃离析构函数 当vector v被销毁,它有责任销毁其内含的所有widgets。假设v内含十个Widgets,而在析构第一个元素期间,有个异常被抛出。其他九个widgets还是应该被销毁(否则它们保存的任何资源都会发生泄漏) ,因此v应该调用它们各个析构函数。但假设在那些调用期间,第二个widget析构函数又抛出异常。\nclass Widget { public: ~widget() { ... //假设可能抛出异常  }; }; void dosomething() { std:;vector\u0026lt;widget\u0026gt; v; ... } 但如果你的析构函数必须执行一个动作，如果该调用导致异常, DBConn析构函数会传播该异常,也就是允许它离开这个析构函数。\nclass DBConnection { public: static DBconnection create(); void close(); private: DBConnection db; }; 有两个方法 但是作用不大\n1. 调用abort\n如果程序遭遇一个“于析构期间发生的错误”后无法继续执行, “强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数传播出去(那会导致不明确的行为)。也就是说调用abort可以抢先制“不明确行为”于死地。\n2. 吞下因调用close而发生的异常\nDBconn::~DBconn() { try{ db.close(); } catch(...) { std::abort(); } } 一个较佳策略是重新设计DBConn接口,使其客户有机会对可能出现的问题作出反应。\n如果某个操作可能在失败时抛出异常,而又存在某种需要必须处理该异常,那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险,总会带来“过早结束程序”或“发生不明确行为”的风险。\nclass DBConn{ public: ... void close() //供客户使用的新函数 \t{ db.close(); closed = true; } ~DBConn() { if(!closed){ try{ //关闭连接（如果客户不那么做的话） \tdb.close(); } catch(...){ //如果关闭动作失败，记录下并结束程序或吞下异常 \t//制作运转记录，记下对close的调用失败； \t... } } } private: DBConnection db; bool closed; }; 本文要点\n 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下它们(不传播)或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么class应该提供一个普通函数(而非在析构函数中)执行该操作。   条款09: 绝不在构造和析构过程中调用virtual函数 BuyTransaction b;这时候被调用的logTransaction是 Transaction内的版本,不是Buyrransaction内的版本-即使目前即将建立的对象类型是BuyTransaction。base class构造期间virtual函数绝不会下降到derived classes阶层。\n非正式的说法或许比较传神: 在base class构造期间, virtual函数不是virtual函数。\nclass Transaction { public: Transaction( ); virtual void logrransaction() const=0; ... }; Transaction:: Transaction () { ... logTransaction(); } class BuyTransaction: public Transaction { public: virtual void logrransaction() const; ... }; class SellTransaction: public Transaction { public: virtual void logTransaction() const; ... }; 其他方案可以解决这个问题。一种做法是在class Transaction内将 1ogTransaction函数改为non-virtual,然后要求derived class构造函数传递必要信 息给Transaction构造函数,而后那个构造函数便可安全地调用non-virtual logTransaction。\nclass BuyTransaction: public Transaction { public: Buyrransaction ( parameters) : Transaction (createLogstring ( parameters )) {...} private: static std::string createLogstring( parameters ); }; 本文要点\n 在构造和析构期间不要调用virtual函数,因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)。   条款10: 令operator=返回一个reference to *this Widget\u0026amp; operator=(const Widget\u0026amp; rhs) //返回类型是个reference，指向当前对象 { ... return *this; //返回左侧对象 } # 实现连锁赋值 int x, y, z; x = y = z = 15; //赋值连锁形式 本文要点\n 令赋值(assignment)操作符返回一个reference to *this   条款11: 在operator=中处理“自我赋值” class Bitmap {...}; class Widget { ... private: Bitmap* pb; }; # 直接赋值不具备自我赋值安全、异常安全性  # 传统不安全做法 # 不具备异常安全性 Widget\u0026amp; Widget::operator= (const Widqet\u0026amp; rhs) { delete pb; pb = new Bitmap(*rhs.pb); return *this; } # 保证异常安全性做法 Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Bitmap* pOring = pb; pb = new Bitmap(*rhs.pb); delete pOring; return *this; } # copy-and-swap v1 Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Widget temp (rhs); swap (temp); return *this; } # copy-and-swap v2 Widget\u0026amp; Widget::operator=(Widget rhs) { Widget temp (rhs); swap (temp); return *this; } 本文要点\n 确保当对象自我赋值时operator-有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap. 确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为仍然正确。   条款12: 复制对象时勿忘其每一个成分 如果你声明自己的copying函数,意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的,会以一种奇怪的方式回敬: 当你的实现代码几乎必然出错时却不告诉你。\n当类含有其他类的成员、类发生继承\nclass Date { ... }; class Customer { public: ... private: std::string name; Date lastTransaction; }; class PriorityCustomer: public Customer { public: PrioriuyCustomer(const PriorityCustomer\u0026amp; rhs); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp; rhs); private: int priority; }; Prioritycustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : priority(rhs.priority) { logCall(\u0026#34;PriorityCustomer copy constructor\u0026#34;); } PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { logCall(\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); priority=rhs.priority; return *this; } 它们复制了Prioritycustomer声明的成员变量, 但每个PriorityCustomer还内含它所继承的Customer成员变量复件(副本) ,而那些成员变量却未被复制。\n应该让derived class的copying函数调用相应的base class函数\nPriorityCustomer::PriorityCustomer(const Prioritycustomer\u0026amp; rhs) : customer(rhs), priority(rhs.priority) { logCall (\u0026#34;PriorityCustomer copy constructor\u0026#34;); } PriorityCustomer\u0026amp; PriorityCustomer::operator=(const Prioritycustomer\u0026amp; rhs) { logCall (\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); Customer: : operator= (rhs); priority=rhs.priority; return *this; } copy assignment操作符调用copy构造函数是不合理的,因为这就像试图构造一个已经存在的对象。\n反方向\u0026ndash;令copy构造函数调用copy assignment操作符-同样无意义。构造函数用来初始化新对象,而assignment操作符只施行于已初始化对象身上。\n本文要点\n  本条款题目所说的“复制每一个成分”现在应该很清楚了。当你编写一个copying函数,请确保:\n 复制所有local成员变量 调用所有base classes内的适当的 copying函数。    Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”\n  不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中,并由两个coping函数共同调用。\n   条款13: 以对象管理资源 所谓资源就是,一旦用了它,将来必须还给系统。C++程序中最常使用的资源就是动态分配内存(如果你分配内存却从来不曾归还它,会导致内存泄漏) ,但内存只是你必须管理的众多资源之一。\n程序中过早的return、continus、goto等 略过delete， 泄漏的不只是内含投资对象的那块内存,还包括那些投资对象所保存的任何资源。\n使用智能指针\nauto_ptr在C++11已被弃用\n代替方案为 “引用计数型智慧指针\u0026quot;(reference-counting smart pointer;RCSP)\nvoid f() { std::tr1::shared_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); ... }  获得资源后立刻放进管理对象( managing object)内。 管理对象(managing object)运用析构函数确保资源被释放。  本文要点\n 为防止资源泄漏,请使用RAI1对象,它们在构造函数中获得资源并在析构函数中释放资源。 两个常被使用的RAlI classes分别是tr1::shared-ptr和autoptr,前者通常是较佳选择,因为其copy行为比较直观。若选择auto-ptr,复制动作会使它(被复制物)指向null   条款14: 在资源管理类中小心coping行为 Lock ml1 (\u0026amp;m); //锁定m Lock ml2 (ml1); //将ml1复制到m12身上。这会发生什么事? 当一个RAI1对象被复制 该怎么办:\n 禁止复制 对底层资源采用“引用计数法”(智能指针) 复制底部资源。(深度拷贝) 转移底部资源的拥有权。  本文要点\n 复制RAl1对象必须一并复制它所管理的资源,所以资源的copying行为决定 RAII对象的copying行为。 普遍而常见的RAll class copying行为是:抑制copying、施行引用计数法 (reference counting) 。不过其他行为也都可能被实现。   条款15: 在资源管理类中提供对原始资源的访问 最佳设计很可能是坚持条款18的忠告: “让接口容易被正确使用,不易被误用”。\n本文要点\n APIs往往要求访问原始资源(raw resources) ,所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。   条款16: 成对使用new和delete时要采取相同形式 本文要点\n 如果你在new表达式中使用1],必须在相应的delete表达式中也使用1]。如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[]   条款17: 以独立语句将newed对象置入智能指针 void processwidget(std::tr1::shared ptr\u0026lt;widget\u0026gt; pw, priority()); 虽然我们在此使用“对象管理式资源” (object-managingresources) ,上述调用却可能泄漏资源。\n在调用processWidget之前,编译器必须创建代码,做以下三件事:\n 调用priority 执行\u0026quot;new widget\u0026quot; 调用trl::sharedptr构造函数  c++并不是特定次序完成函数参数的核算、弹性大。如果priority出现异常 new widget返回的指针将会遗失\n本文要点\n 以独立语句将newed对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。   条款18: 让接口容易被正确使用,不易被误用 std::tr1::shared ptr\u0026lt;Investment\u0026gt; pInv( static cast\u0026lt;Investment*\u0026gt;(0), getRidofInvestment); 本文要点\n 好的接口很容易被正确使用,不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性,以及与内置类型的行为兼容。 “阻止误用”的办法包括建立新类型、限制类型上的操作,束缚对象值,以及消除客户的资源管理责任。 tr1::sharedptr支持定制型删除器(custom deleter) 。这可防范DLL问题,可被用来自动解除互斥锁(mutexes,见条款14)等等。   条款19:设计class犹如设计type 在设计class时,要考虑一系列的问题, 包括：\n 新type的对象应该如何被创建和销毁（构造和析构） 对象的初始化和对象的赋值该有什么样的差别，这个答案决定你的构造函数和赋值操作符的行为，以及其间的差异。 新的type的对象如果被pass by value，意味着什么？记住，拷贝构造函数用来定义一个type的pass-by-value该如何实现。 什么是新type的“合法值”？（约束条件）成员函数必须进行错误检查工作。 你的新type需要配合某个继承图系吗？（注意虚函数） 你的新type需要什么样的转换？（显示转换、类型转换操作符） 什么样的操作符和函数对此新type而言是合理的？这决定你为你的class声明哪些函数，哪些是成员函数，哪些不是。 什么样的标准函数应该驳回？那些正是必须声明为private者（条款6）。 什么是新type的“未声明接口” 你的新type有多么一般化？（class template） 成员函数和成员变量的可见范围（public/protected/private） 是否真的需要一个新type  本文要点\n Class的设计就是type的设计。在定义一个新type之前,请确定你已经考虑过本条款覆盖的所有讨论主题。   条款20:宁以pass-by-reference-to-const替换pass-by-value bool validatestudent(const student\u0026amp; s); 这种传递方式的效率高得多:没有任何构造函数或析构函数被调用,因为没有任何新对象被创建。修订后的这个参数声明中的const是重要的。以by reference方式传递参数也可以避免对象切割问题\n本文要点\n 尽量以pass-by-reference-to-const替换pass-by-value,前者通常比较高效,并可避免 切割问题(slicing problem) 。 以上规则并不适用于内置类型,以及STL的迭代器和函数对象。对它们而言, pass-by-value往往比较适当。   条款21: 必须返回对象时,别妄想返回其reference 任何时候看到一个引用声明式，你都应该立刻问自己，它的另一个名称是什么？\n虽然函数参数最好用引用值，但函数返回值却不要随便去用引用，这回造成很多问题，比如引用的对象在函数结束后即被销毁，或是需要付出很多成本和代码来保证其不被销毁且不重复，这大概率没有必要，就返回一个值/对象就好了。\n本文要点\n 绝不要返回pointer或reference指向一个local stack对象,或返回reference指向一 个heap-allocated对象,或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference指向一个local static对象”提供了一份设计实例。   条款22:将成员变量声明为private 封装重要性,可以确保class的约束条件总是会获得维护,因为只有成员函数可以影响它们。\nprotected并不比public更加具有封装性，因为protected修饰的成员变量一旦修改，也会造成子类的大量修改。\n从封装的角度观之,其实只有两种访问权限: private (提供封装)和其他(不提供封装)\n本文要点\n 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证,并提供class作者以充分的实现弹性。 protected并不比public更具封装性。   条款23: 宁以non-member, non-friend替换member函数 提供non-member函数可允许对webBrowser相关机能有较大的包裹弹性 (packaging flexibility) ,而那最终导致较低的编译相依度,增加webBrowser的可延伸性。\nvoid clearBrowser(WebBrowser\u0026amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } 愈少代码可以看到数据(也就是访问它) ,愈多的数据可被封装,而我们也就愈能自由地改变对象数据\n在C++,比较自然的做法是让clearBrowser成为一个non-member函数并且位于 WebBrowser所在的同一个namespace (命名空间)内:\nnamespace WebBrowserStuff{ class WebBrowser{... }; void clearBrowser(WebBrowser\u0026amp; wb); } 本文要点\n 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包 裹弹性(packaging flexibility)和机能扩充性。   条款24: 若所有参数皆需类型转换,请为此采用non-member函数 class Rational { public: const Rational operator*(const Rational\u0026amp; rhs) const; }； #没问题 Rational oneEighth(1, 8); Rational oneHalf(1, 2); Rational result = oneHalf * oneEighth; result = result * oneEighth; result = oneHalf * 2; // result = oneHalf.operator*(2);  #错误 result = 2 * oneHalf; //出错 result = 2.operator*(oneHalf); 编译器知道你正在传递一个int,而函数需要的是Rational;但它也知道只要调用Rational构造函数并赋予你所提供的int,就可以变出一个适当的Rational来。\n结论是,只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”\u0026ndash;即this对象-的那个隐喻参数,绝不是隐式转换的合格参与者。\nclass Rational{ ... }; const Rational operator* (const Rational\u0026amp; 1hs, const Rational\u0026amp; rhs) { return Rational (1hs.numerator() * rhs.numerator( ), 1hs.denominator() * rhs.denominator()); } #编译通过 Rational oneFourth (1, 4); Rational result; result = oneFourth * 2; result = 2 * oneFourth; operator* 无需设置为friend 因为operator* 可以完全藉由Rational的public接口完成任务\n结论是,只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”\u0026ndash;即this对象-的那个隐喻参数,绝不是隐式转换的合格参与者。\n本文要点\n 如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换,那么这个函数必须是个non-member.   条款25: 考虑写出一个不抛异常的swap函数 namespace WidgetStuff { class widget { public: void swap (Widget\u0026amp; other) { using std::swap; swap (pImpl, other.pImpl); } }; template\u0026lt;typename T\u0026gt; void swap(widget\u0026lt;T\u0026gt;\u0026amp; a, widget\u0026lt;T\u0026gt;\u0026amp; b) { a.swap(b); } } #调用T专属版本,并在该版本不存在的情况下调用std内的一般化版本。 template\u0026lt;typename T\u0026gt; void dosomething(T\u0026amp; a, T\u0026amp; b) { using std::swap; ... swap(a, b); } } 本文要点\n 成员函数swap版本绝不可抛出异常 当std::swap对你的类型效率不高时,提供一个swap成员函数,并确定这个函数不抛出异常。 如果你提供一个member swap,也该提供一个non-member swap用来调用前者。对 于classes (而非templates) ,也请特化std::swapo 调用swap时应针对std: :swap使用using声明式,然后调用swap并且不带任何“命名空间资格修饰” 为“用户定义类型”进行std templates全特化是好的,但千万不要尝试在std内加入某些对std而言全新的东西。   条款26: 尽可能延后变量定义式的出现时间 std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; string encrypted; if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error (\u0026#34;Password is too short\u0026#34;); } ... return encrypted; ） 如果函数encryptPassword丢出异常,你仍得付出encrypted的构造成本和析构成本。所以最好延后encrypted的定义式,直到确实需要它。\n#1 效率低 std::string encrypted; encrypted = password; #高效 std::string encrypted (password); 你不只应该延后变量的定义,直到非得使用该变量的前一刻为止,甚至应该尝试延后这份定义直到能够给它初值实参为止。\n#做法A: 1个构造函数+1个析构函数+n个赋值操作 #方法A:定义于循环外 widget w; for (int i=0; i \u0026lt;n; ++i) { w = //取决于i的某个值; } #做法B: n个构造函数+n个析构函数 #方法B:定义于循环内 for (int i=0; i\u0026lt;n; ++i) { widget w(//取决于i的某个值); }  你知道赋值成本比“构造+析构”成本低 你正在处理代码中效率高度敏感(performance-sensitive)的部分,否则你应该使用做法B  本文要点\n 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。   条款27: 尽量少做转型动作  const-cast通常被用来将对象的常量性转除(cast away the constness) dynamic-cast主要用来执行“安全向下转型” (safe downcasting) ,也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作,也是唯一可能耗费重大运行成本的转型动作 reinterpret-cast意图执行低级转型,实际动作(及结果)可能取决于编译器,这也就表示它不可移植。 static_cast用来强迫隐式转换(implicit conversions)  C不可能发生这种事,Java不可能发生这种事,C#也不可能发生这种事。但C++可能!\nclass window { public: virtual void onResize() {...} ... }； class Specialwindow: public Window { public: virtual void onResize() { static_cast\u0026lt;window\u0026gt; (*this).onResize (); ... } } 解决之道是拿掉转型动作,代之以你真正想说的话。你并不想哄骗编译器将 *this视为一个base class对象,你只是想调用base class版本的onResize函数,令它作用于当前对象身上。\nclass Specialwindow: public window { public: virtual void onResize() { #调用window:;onresize 作用于*this上  window::onResize(); } } 本文要点\n 如果可以,尽量避免转型,特别是在注重效率的代码中避免dynamic-casts.如果有个设计需要转型动作,试着发展无需转型的替代设计。 如果转型是必要的,试着将它隐藏于某个函数背后。客户随后可以调用该函数,而不需将转型放进他们自己的代码内。 宁可使用C++-style (新式)转型,不要使用旧式转型。前者很容易辨识出来, 而且也比较有着分门别类的职掌。   条款28: 避免返回handles指向对象内部成分 class Point { public: Point (int x, int y); void setx(int newVal); void setY(int newVal); ... }; struct RectData { Point ulhc; Point lrhc; }; class Rectangle { ... private: std::tr1::shared_ptr\u0026lt;RectData\u0026gt; pData; }; #根据条款20 以by reference方式传递用户自定义类型往往比以by value方式传递更高效 #错误： 两个函数都返回references指向private内部数据,调用者于是可通过这些references更改内部数据! class Rectangle { public: Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } }；  成员变量的封装性最多只等于“返回其 reference\u0026quot;的函数的访问级别。 如果const成员函数传出一个reference,后者所指数据与对象自身有关联,而它又被存储于对象之外,那么这个函数的调用者可以修改那笔数据。  通常我们认为,对象的“内部”就是指它的成员变量,但其实不被公开使用的成员函数(也就是被声明为protected或private者)也是对象“内部”的一部分。因此也应该留心不要返回它们的handles.这意味你绝对不该令成员函数返回一个指针指向“访问级别较低”的成员函数。\n#代码返回类型加上const即可 class Rectangle { public: const Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } const Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } ... }; 但即使如此, upperLeft和lowerRight还是返回了“代表对象内部”的handles,有可能在其他场合带来问题。更明确地说,它可能导致dangling handles (空悬的号码牌): 这种handles所指东西(的所属对象)不复存在。这种“不复存在的对象”最常见的来源就是函数返回值。\n本文要点\n 避免返回handles (包括references、指针、迭代器)指向对象内部。遵守这个条款可增加封装性,帮助const成员函数的行为像个const,并将发生“虚吊号码 牌” (dangling handles)的可能性降至最低。   条款29: 为“异常安全”而努力是值得的 void PrettyMenu::changeBackground (std::istream\u0026amp; imgSrc) { using std:: swap; Lock ml (\u0026amp;mutex) ; std::tr1::shared ptr\u0026lt;PMImpl\u0026gt; pNew (new PMImpl (*pImpl)); pNew-\u0026gt;bgImage.reset (new Image (imgSrc)); ++pNew-\u0026gt;imageChanges; swap (pImpl, pNew); } 当异常被抛出时,带有异常安全性的函数会:\n 不泄漏任何资源。 不允许数据败坏。  异常安全函数(Exception-safe functions)提供以下三个保证之一:\n 基本承诺:如果异常被抛出,程序内的任何事物仍然保持在有效状态下。 强烈保证:如果异常被抛出,程序状态不改变。 不抛掷( nothrow)保证,承诺绝不抛出异常,因为它们总是能够完成它们原先承诺的功能。  智能指针使用reset，当new Image(imgSrc)成功后，才会删除旧图像。\nclass PrettyMenu{ ... std::tr1::shared_ptr\u0026lt;Image\u0026gt; bgImage; ... }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { Lock m1(\u0026amp;mutex); bgImage.reset(new Image(imgSrc));//用new Image执行结果设定bgImage内部指针  ++imageChanges; } 第二、将所有“隶属对象的数据”从原对象放进另一个对象内,然后赋予原对象一个指针,指向那个所谓的实现对象(implementation object,即副本)。这种手法常被称为pimpl idiom\ncopy-and-swap策略\n当“强烈保证”不切实际时,你就必须提供“基本保证”\n一般而言并不保证函数具有强烈的异常安全性\nvoid PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { using std::swap; Lock ml(smutex); std::tr1::shared ptr\u0026lt;PMImpl\u0026gt; pNew (new PMImpl(*pImpl)); pNew-\u0026gt;bgImage.reset(new Image(imgSrc)); ++pNew-\u0026gt;imageChanges; swap(pImpl, pNew); } 如果函数哪还对另外两个函数进行操作:\nvoid someFunc() { ... f1(); f2(); ... }    假设f1只提供基本保证,那么为了让someFunc提供强烈保证,我们必须写出代码获得调用f1之前的整个程序状态、捕捉f1的所有可能异常、然后恢复原状态。    如果F1和f2都是“强烈异常安全” ,情况并不就此好转。毕竟如果f1圆满结束,程序状态在任何方面都可能有所改变,因此如果f2随后抛出异常,程序状态和someFunc被调用前并不相同,甚至当F2没有改变任何东西时也是如此。    问题出在“连带影响” (side effects) 。如果函数只操作局部性状态(local state,例如somerunc只影响其“调用者对象”的状态),便相对容易地提供强烈保证。但是当函数对“非局部性数据” (non-local data)有连带影响时,提供强烈保证就困难得多。\n本文要点\n 异常安全函数(Exception-safe functions)即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证:基本型、强烈型、不抛异常型。 “强烈保证”往往能够以copy-and-swap实现出来,但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。   条款30: 透彻了解inlining的里里外外  过度热衷inlining会造成程序体积太大(对可用空间而言)。即使拥有虚内存, inline造成的代码膨胀亦会导致额外的换页行为(paging) ,降低 指令高速缓存装置的击中率(instruction cache hit rate) ,以及伴随这些而来的效率损失。  inline只是对编译器的一个申请,不是强制命令。这项申请可以隐喻提出,也可以明确提出。隐喻方式是将函数定义于class定义式内。\nclass Person { public: int age() const { //一个隐喻的inline申请:  //age被定义于class定义式内。  return theAge; } ... private: int theAge; }; friend函数也可被定义于class内,如果真是那样,它们也是被隐喻声明为inline.\ntemplate\u0026lt;typename T\u0026gt; inline const T\u0026amp; std::max(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b : a; } Template的具现化与inlining无关。如果你写的template没有理由要求它所具现的每一个函数都是inlined,就应该避免将这个template声明为inline (不论显式或隐式) 。\n本文要点\n 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级(binary upgradability)更容易,也可使潜在的代码膨胀问题最小化,使程序的速度提升机会最大化。 不要只因为function templates出现在头文件,就将它们声明为inline.   条款31: 将文件间的编译依存关系降至最低 #include \u0026lt;string\u0026gt;#include \u0026#34;date.h\u0026#34; #include \u0026#34;address.h\u0026#34;这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系(compilation dependency)。如果这些头文件中有任何一个被改变,或这些头文件所倚赖的其他头文件有任何改变,那么每一个含入Person class的文件就得重新编译,任何使用Person class的文件也必须重新编译。\n接口与实现分离\n这个分离的关键在于以“声明的依存性”替换“定义的依存性”,那正是编译依存性最小化的本质:\n现实中让头文件尽可能自我满足,万一做不到,则让它与其他文件内的声明式(而非定义式)相依。其他每一件事都源自于这个简单的设计策略:\n 如果使用object references或object pointers可以完成任务,就不要使用objects。你可以只靠一个类型声明式就定义出指向该类型的references和pointers;但如果定义某类型的objects,就需要用到该类型的定义式。 如果能够,尽量以class声明式替换class定义式。 为声明式和定义式提供不同的头文件。  另一个制作Handle class的办法是,令Person成为一种特殊的abstract base class (抽象基类) ,称为Interface class。\n本文要点\n Handle classes和Interface classes解除了接口和实现之间的耦合关系,从而降低文件间的编译依存性(compilation dependencies) 。 支持“编译依存性最小化”的一般构想是:相依于声明式,不要相依于定义式。 基于此构想的两个手段是Handle classes和Interface classes. 程序库头文件应该以“完全且仅有声明式” (full and declaration-only forms)的 形式存在。这种做法不论是否涉及templates都适用。   virtual函数意味“接口必须被继承” , non-virtual函数意味“接口和实现都必须被继承”。\n条款32: 确定你的public继承塑模出is-a关系 以C+进行面向对象编程,最重要的一个规则是: public inheritance (公开继承)意味\u0026quot;is-a\u0026quot; (是一种)的关系。\nclass Bird { public: virtual void fly(){cout \u0026lt;\u0026lt; \u0026#34;it can fly.\u0026#34; \u0026lt;\u0026lt; endl;} }; class Penguin: public Bird { // fly()被继承过来了，可以覆写一个企鹅的fly()方法，也可以直接用父类的 }; int main() { Penguin p; p.fly(); // 问题是企鹅并不会飞！ } 方法一，在Penguin的fly()方法里面抛出异常，一旦调用了p.fly()，那么就会在运行时捕捉到这个异常。这个方法不怎么好，因为它要在运行时才发现问题。\n方法二，去掉Bird的fly()方法，在中间加上一层FlyingBird类（有fly()方法）与NotFlyingBird类（没有fly()方法），然后让企鹅继承与NotFlyingBird类。这个方法也不好，因为会使注意力分散，继承的层次加深也会使代码难懂和难以维护。\n方法三，保留所有Bird一定会有的共性（比如生蛋和孵化），去掉Bird的fly()方法，只在其他可以飞的鸟的子类里面单独写这个方法。这是一种比较好的选择，因为根本没有定义fly()方法，所以Penguin对象调用fly()会在编译期报错。\n在艰难选择方法三之后，我们回过头来思考，就是在所有public继承的背后，一定要保证父类的所有特性子类都可以满足（父类能飞，子类一定可以飞），抽象起来说，就是在可以使用父类的地方，都一定可以使用子类去替换。\n这正是Liskov替代原则告诉我们的：任何父类可以出现的地方，子类一定可以替代这个父类，只有当替换使软件功能不受影响时，父类才可以真正被复用。通俗地说，是“子类可以扩展父类的功能，但不能改变父类原有的功能”。\n本文要点\n \u0026ldquo;public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于 derived classes身上,因为每一个derived class对象也都是一个base class对象。   条款33: 避免遮掩继承而来的名称 int x; void someFunc () { double x; std::cin \u0026gt;\u0026gt;x; } 这个读取数据的语句指涉的是local变量x,而不是global变量x,因为内层作用域的名称会遮掩(遮蔽)外围作用域的名称。\nclass Base { private: int x; public: virtual void mf1() =0; virtual void mf2(); void mf3 (); }； class Derived: public Base { public: virtual void mf1(); void mf4(); }； #mf4函数实现部分 void Derived::mf4 () { ... mf2(); } 当编译器看到这里使用名称mf2,必须估算它指涉(refer to)什么东西。编译器的做法是查找各作用域,看看有没有某个名为mf2的声明式。\nclass Base { private: int x; public: virtual void mf1() = 0; virtual void mfl(int); virtual void mf2(); void mf3(); void mf3 (double); ... }; #从名称查找观点来看，base::mf1和base::mf3不再被derived继承 Derived d; int x; d.mf1 (); //没问题,调用Derived::mf1 d.mf1 (x); //错误!因为Derived: :mf1遮掩了Base::mf1 d.mf2 (); d.mf3 (); d.mf3 (x); //错误!因为Derived::mf3遮掩了Base::mf3 解决方法1 using声明\n用using声明式来在子类中声明父类的同名函数(重载函数不需要声明多个),此时父类的各重载函数就是子类可见的了。\nclass Derived:public Base { public: using Base::mf1; using Base::mf3; virtual void mf1(); void mf3(); void mf4(); }; 解决方法2 转交函数\n使用转交函数，即在子类函数的声明时进行定义，调用父类的某个具体的重载函数（此时由于在声明时定义，成为inline函数），此举可以只让需要的部分父类重载函数于子类可见。\nclass Base { public: virtual void mf1() = 0; virtual void mf1(int); } class Derived:private Base { public: virtual void mf1() { Base::mfl(); }; Derived d; int x; d.mf1(); //调用Derived::mf1 d.mf1(x); //错误！Base::mf1被遮掩了 本文要点\n derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日,可使用using声明式或转交函数(forwarding functions)   条款34: 区分接口继承和实现继承 public继承概念由两部分组成:\n 函数接口(function interfaces)继承 函数实现(function implementations)继承  这两种继承的差异很像函数声明与函数定义之间的差异。\n 成员函数的接口总是会被继承。一如条款32所说, public继承意味is-a (是一 种),所以对base class为真的任何事情一定也对其derived classes为真。 声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。 我们可以为pure virtual函数提供定义。也就是说可以为Shape::draw供应一份实现代码, C++并不会发出怨言,但调用它的唯一途径是“调用时明确指出其class名称”  Shape* ps1 = new Rectangle; ps1-\u0026gt;Shape::draw(); //调用Shape::draw  声明简朴的(非纯) impure virtual函数的目的,是让derived classes继承该函数的接口和缺省实现。  “你必须支持一个error函数,但如果你不想自己写一个,可以使用Shape class提供的缺省版本”。\nclass Shape { public: virtual void error(const std::string\u0026amp; msg); }; class Airplane { public: virtual void fly(const Airport\u0026amp; destination) = 0; //pure virtual protected: void defaultFly(const Airport\u0026amp; destination); }; void Airplane::defaultFly(const Airport\u0026amp; destination) { #缺省行为,将飞机飞至指定的目的地。 } #inline函数和virtual函数之间的交互关系 class ModelA:public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { defaultFly(destination); } }; class ModelB:public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { defaultFly(destination); } }; #Airplane 中的pure virtual函数迫使Mode1C必须提供自己的fly版本: class ModelC:public Airplane { public: virtual void fly(const Airport\u0026amp; destination); }; Airplane继承体系如何给pure virtual函数一份定义\nclass Airplane { public: virtual void fly(const Airport\u0026amp; destination) = 0; }； void Airplane::fly(const Airport\u0026amp; destination) { //缺省行为,将飞机飞至指定的目的地 } class ModelA: public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { Airplane::fly(destination); //airplane  } }; class ModelB: public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { Airplane::fly(destination); //airplane  } } class Modelc: public Airplane { public: virtual void fly(const Airport\u0026amp; destination); }； void ModelC::fly(const Airport\u0026amp; destination) { //将c型飞机飞至指定的目的地 } 如果成员函数是个non-virtual函数,意味是它并不打算在derived classes中有不同的行为。实际上一个non-virtual成员函数所表现的不变性(invariant)凌驾其 特异性(specialization) ,因为它表示不论derived class变得多么特异化,它的行为都不可以改变。\n 声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现。  class Shape { public: int objectID() const; } pure virtual函数、simple (impure) virtual函数、non-virtual函数之间的差异,使你得以精确指定你想要derived classes继承的东西:只继承接口,或是继承接口和一份缺省实现,或是继承接口和一份强制实现。\n两个常见的错误\n 第一个错误是将所有函数声明为non-virtual。这使得derived classes没有余裕空间进行特化工作。non-virtual析构函数尤其会带来问题(见条款7) 。 另一个常见错误是将所有成员函数声明为virtual  本文要点\n 接口继承和实现继承不同。在public继承之下, derived classes总是继承base class的接口。 pure virtual函数只具体指定接口继承。 简朴的(非纯) impure virtual函数具体指定接口继承及缺省实现继承。 non-virtual函数具体指定接口继承以及强制性实现继承。   条款35: 考虑virtual函数以外的其他选择 Non-Virtual Interface手法实现Template Method模式\nclass GameCharacter { public: int healthvalue() const { ... int retVal = doHealthValue (); return retVal; ... } ... private: virtual int doHealthValue() const { ... } }; 这一基本设计,也就是“令客户通过public non-virtual成员函数间接调用private virtual函数”,称为non-virtual interface (NVI)手法。\n藉由Function Pointers实现Strategy模式\nclass GameCharacter; //以下函数是计算健康指数的缺省算法。 int defaultHealthCalc (const GameCharacter\u0026amp; gc); class GameCharacter { public: typedef int (*HealthCalcFunc) (const GameCharacter\u0026amp;); explicit GameCharacter (HealthCalcFunc hcf = defaultHealthCalc) : healthFunc (hcf) {} int healthValue() const { return healthFunc(*this); } private: HealthCalcFunc healthFunc; }  同一人物类型之不同实体可以有不同的健康计算函数。  class EvilBadGuy: public GameCharacter { public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : GameCharacter (hcf) {...} ... }; int loseHealthQuickly(const GameCharacter\u0026amp;); int loseHealthslowly(const GameCharacter\u0026amp;); #相同类型的人物搭配, 不同的健康计算方式 EvilBadGuy ebg1(loseHealthQuickly); EvilBadGuy ebg2(loseHealthslowly);  某已知人物之健康指数计算函数可在运行期变更。  “健康指数计算函数不再是GameCharacter继承体系内的成员函数”这一事实意味,这些计算函数并未特别访问“即将被计算健康指数”的那个对象的 内部成分。\n 藉由tr1:function完成Strategy模式  如果我们不再使用函数指针(如前例的healthFunc) ,而是改用一个类型为tr1l:: function的对象,这些约束就全都挥发不见了。\nclass GameCharacter; //如前 int defaultHealthcalc (const GameCharacter\u0026amp; gc); //如前 class GameCharacter { public: //HealthCalcFunc可以是任何“可调用物” (callable entity) ,  //可被调用并接受任何兼容于GameCharacter之物,返回任何兼容于int的东西。详下。  typedef std::tr1::functio\u0026lt;int (const GameCharacter\u0026amp;)\u0026gt; HealthCalcFunc; explicit GameCharacter (HealthCalcFunc hcf = defaultHealthCalc) : healthFunc (hcf ) {} int healthValue () const { return healthFunc(* this); } ... private: HealthcalcFunc healthFunc; }; std::tr1::function\u0026lt;int (const GameCharacter\u0026amp;)\u0026gt;\n“接受一个reference指向const GameCharacter,并返回int\u0026rdquo;。\n这个trl::function类型(也就是我们所定义的HealthCalcFunc类型)产生的对象可以持有(保存)任何与此签名式兼容的可调用物(callable entity)。\n所谓兼容,意思是这个可调用物的参数可被隐式转换为const GameCharacterk,而其返回类型可被隐式转换为into\nshort calcHealth (const GameCharacter\u0026amp;); struct HealthCalculator { int operator () (const GameCharacter\u0026amp;) const { ..} }; class GameLevel { public: float health (const GameCharacter\u0026amp;) const; ... }； class EvilBadGuy: public GameCharacter { ... }； class EyeCandyCharacter: public GameCharacter { ... }； EvilBadGuy ebg1(calcHealth); EyeCandyCharacter eccl(HealthCalculator()); //使用某个函数对象计算健康指数 GameLevel currentLevel; ... EvilBadGuy ebg2 ( std::tr1::bind(\u0026amp;GaneLevel::health, currentLevel, _1) //使用某个成员函数计算健康指数 );  古典的Strategy模式  class GameCharacter; class HealthCalcFunc { public: virtual int calc(const GameCharacter\u0026amp; gc) const { ... } }; HealthCalcFunc defaultHealthCalc; class GameCharacter { public: explicit GameCharacter (HealthCalcFunc* phcf = \u0026amp;defaultHealthCalc) : pHealthCalc (phcf) {} int healthValue() const { return pHealthCalc-\u0026gt;calc(*this); } private: HealthcalcFunc* pHealthCalc; }; 本文要点\n 使用non-virtual interface (NVI)手法,那是Template Method设计模式的一种 特殊形式。它以public non-virtual成员函数包裹较低访问性(private或protected) 的virtual函数。 将virtual函数替换为“函数指针成员变量” ,这是Strategy设计模式的一种分解表现形式。 以tr1::function成员变量替换virtual函数,因而允许使用任何可调用物 (callable entity)搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式。 将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。 virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。 将机能从成员函数移到class外部函数,带来的一个缺点是,非成员函数无法访 问class的non-public成员。 trl::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式(target signature)兼容”的所有可调用物(callable entities)   条款36: 绝不重新定义继承而来的non-virtual函数 class B { public: void mf(); }; class D: public B{ void mf(); ... }; # D x; B* pB =\u0026amp;x; D* pD =\u0026amp;x; pb-\u0026gt;mf(); //Bmf pd-\u0026gt;mf(); //Dmf 由于pB被声明为一个pointer-to-B,通过pB调用的non-virtual函数永远是B所定义的版本,即使pB指向一个类型为“B派生之class\u0026quot;的对象, virtual函数是动态绑定, 不论是pb,pd都是导致调用Dmf, 因为pB和pD真正指的都是一个类型为D的对象。\n 适用于B对象的每一件事,也适用于D对象,因为每个D对象都是一个B对象; B的derived classes一定会继承mf的接口和实现,因为mf是B的一个non-virtual函数。  本文要点\n 绝对不要重新定义继承而来的non-virtual函数。   条款37: 绝不重新定义继承而来的缺省参数值 virtual函数系动态绑定(dynamically bound) ,而缺省参数值却是静态绑定(statically bound)\nclass Shape { public: enum ShapeColor { Red, Green, Blue }; /所有形状都必须提供一个函数,用来绘出自己 virtual void draw (ShapeColor color = Red) const =0; }; class Rectangle: public Shape { public: /注意,赋予不同的缺省参数值。这真糟糕! virtual void draw (ShapeColor color = Green) const; }; class Circle: public Shape { public: virtual void draw(ShapeColor color) const; ... }; Shape* ps; Shape* pc = new circle; //静态类型为Shape* Shape* pr = new Rectangle; //静态类型为shape*  ps = pc; ps = pr; pc-\u0026gt;draw(Shape::Red); //调用circle::draw(Shape::Red) pr-\u0026gt;draw(Shape::Red) ; //调用Rectangle::draw(Shape::Red) virtual函数是动态绑定,而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时,却使用base class为它所指定的缺省参数值\npr-\u0026gt;draw(); //调用Rectangle::draw (Shape::Red) Rectangle::draw函数的缺省参数值应该是GREEN,但由于pr的静态类型是Shape*,所以此一调用的缺省参数值来自Shape class而非Rectangle class!\nclass Shape public: enum ShapeColor { Red, Green, Blue }; virtual void draw (ShapeColor color =Red) const =0; }; class Rectangle: public Shape { public: virtual void draw (ShapeColor color =Red) const; ... } 代码重复又带着相依性(with dependencies): 如果Shape内的缺省参数值改变了,所有“重复给定缺省参数值”的那些derivedclasses也必须改变,否则它们最终会导致“重复定义一个继承而来的缺省参数值”。\nNVI方法\nclass Shape { public: enum ShapeColor { Red, Green, Blue }; void draw (ShapeColor color =Red) const { doDraw (color); } private: virtual void doDraw(ShapeColor color) const = 0; }; class Rectangle: public Shape { public: ... private: virtual void doDraw (Shapecolor color) const; //注意,不须指定缺省参数值。  ... }; 本文要点\n 绝对不要重新定义一个继承而来的缺省参数值,因为缺省参数值都是静态绑定,而virtual函数\u0026ndash;你唯一应该覆写的东西-却是动态绑定。   条款38: 通过复合塑模出has-a或\u0026quot;根据某物实现出\u0026quot; class Address{...}; class PhoneNumber {...}; class Person { public: //... private: std::string name; Address address; PhoneNumber voiceNumber; PhoneNumber faxNumber; }; 条款32曾说, \u0026ldquo;public继承”带有is-a (是一种)的意义。 复合意味has-a(有一个)或is-implemented-in-terms-of(根据某物实现出) 。 当复合发生于应用域内的对象之间,表现出has-a的关系;当它发生于 实现域内则是表现is-implemented-in-terms-of的关系。\n本文要点\n 复合(composition)的意义和public继承完全不同。 在应用域(application domain) ,复合意味has-a (有一个) 。在实现域 (implementation domain) ,复合意味is-implemented-in-terms-of (根据某物实现出)。   条款39: 明智而审慎地使用private继承 private继承主要用于“当一个意欲成为derived class者想访问 一个意欲成为base class者的protected成分,或为了重新定义一或多个virtual函数\u0026rdquo; 但这时候两个classes之间的概念关系其实是is-implemented-in-terms-of (根据某物实现出)而非is-a。\n本文要点\n Private继承意味is-mplemented-in-terms of (根据某物实现出) 。它通常比复合 (composition)的级别低。但是当derived class需要访问protected base class的成员,或需要重新定义继承而来的virtual函数时,这么设计是合理的。 和复合(composition)不同, private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言,可能很重要。   条款40: 明智而审慎地使用多重继承  多重继承(multiple inheritance; MI) 单一继承(single inheritance; SI)  当MI进入设计景框,程序有可能从一个以上的base classes继承相同名称(如函数、typedef等等)。那会导致较多的歧义(ambiguity)机会。\nclass Borrowableltem { public: void checkout(); }; class ElectronicGadget { private: bool checkOut() const; }； class MP3Player: public Borrowableltem, public ElectronicGadget {..}; MP3Player mp; mp.checkOut(); //调用哪个checkout 为了解决这个歧义,你必须明白指出你要调用哪一个base class内的函数:\nmp.Borrowableltem::checkOut();\n“钻石继承”\nclass File {...}; class Inputfile: virtual public File {...}; class Outputfile: virtual public File {...}; class IOFile: public Inputfile, public OutFile {...}; 使用virtual继承的那些classes所产生的对象往往比使 用non-virtual继承的兄弟们体积大,访问virtual base classes的成员变量时,也比访问non-virtual base classes的成员变量速度慢。种种细节因编译器不同而异,但基本重点很清楚:你得为virtual继承付出代价。\nvirtual base class忠告\n 第一,非必 要不使用virtual bases。平常请使用non-virtual继承。 第二,如果你必须使用virtualbase classes,尽可能避免在其中放置数据。  本文要点\n 多重继承比单一继承复杂。它可能导致新的歧义性,以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtualbase classes不带任何数据,将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情节涉及\u0026quot;public继承某个Interface class和\u0026quot;private继承某个协助实现的class\u0026quot;的两相组合。   Re:\nhttps://blog.csdn.net/qq_36915078/article/details/104718945\nhttps://harttle.land/tags.html#Effective-C++\n","href":"https://6923403.github.io/post/effective_cpp/","tags":"CPP","title":"Effective C++ 总结"},{"content":"socket struct整理  https://6923403.github.io/post/socket_struct/  socket编程需要的头文件整理  https://6923403.github.io/post/socket_file/  socket function  https://6923403.github.io/post/socket/  epoll function  https://6923403.github.io/post/epoll_use/  sem function  https://6923403.github.io/post/sem/  server io actor  https://6923403.github.io/post/server_actor/  timer function  https://6923403.github.io/post/timer_function/   Linux Pthread 线程创建与使用 https://6923403.github.io/post/pthread/\nC++11 thread https://6923403.github.io/post/cppthread/\n Unp note https://6923403.github.io/post/unp_note/\nTCP_IP | 计算机网络 https://6923403.github.io/post/tcp_ip/\n exception class 异常类 https://6923403.github.io/post/cpp_exception/\n","href":"https://6923403.github.io/post/server_sum/","tags":"Socket ; CPP ; Linux ; Server","title":"Server sum"},{"content":"2021-5-31更新\n#include \u0026lt;unistd.h\u0026gt; extern char *optarg; extern int optind, opterr, optopt; #include \u0026lt;getopt.h\u0026gt; int getopt(int argc, char * const argv[],const char *optstring); int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); 参数以及返回值介绍（以上三个函数都适用）：\n1、argc和argv和main函数的两个参数一致。\n2、optstring: 表示短选项字符串。\n形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下：\n 只有一个字符，不带冒号——只表示选项， 如-c  一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100 一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格,形式应该如-b  3、longopts：表示长选项结构体。结构如下：\nstruct option { const char *name; int has_arg; int *flag; int val; }; static struct option longOpts[] = { { \u0026quot;daemon\u0026quot;, no_argument, NULL, 'D' }, { \u0026quot;dir\u0026quot;, required_argument, NULL, 'd' }, { \u0026quot;out\u0026quot;, required_argument, NULL, 'o' }, { \u0026quot;log\u0026quot;, required_argument, NULL, 'l' }, { \u0026quot;split\u0026quot;, required_argument, NULL, 's' }, { \u0026quot;http-proxy\u0026quot;, required_argument, \u0026amp;lopt, 1 }, { \u0026quot;http-user\u0026quot;, required_argument, \u0026amp;lopt, 2 }, { \u0026quot;http-passwd\u0026quot;, required_argument, \u0026amp;lopt, 3 }, { \u0026quot;http-proxy-user\u0026quot;, required_argument, \u0026amp;lopt, 4 }, { \u0026quot;http-proxy-passwd\u0026quot;, required_argument, \u0026amp;lopt, 5 }, { \u0026quot;http-auth-scheme\u0026quot;, required_argument, \u0026amp;lopt, 6 }, { \u0026quot;version\u0026quot;, no_argument, NULL, 'v' }, { \u0026quot;help\u0026quot;, no_argument, NULL, 'h' }, { 0, 0, 0, 0 } }; (1)name:表示选项的名称,比如daemon,dir,out等。\n(2)has_arg:表示选项后面是否携带参数。 该参数有三个不同值，如下：\n a: no_argument(或者是0)时 ——参数后面不跟参数值，eg: \u0026ndash;version,\u0026ndash;help b: required_argument(或者是1)时 ——参数输入格式为：\u0026ndash;参数 值 或者 \u0026ndash;参数=值。eg:\u0026ndash;dir=/home c: optional_argument(或者是2)时 ——参数输入格式只能为：\u0026ndash;参数=值  (3) flag:这个参数有两个意思，空或者非空。\na:如果参数为空NULL，那么当选中某个长选项的时候，getopt_long将返回val值。eg，可执行程序 --help，getopt_long的返回值为h. b:如果参数不为空，那么当选中某个长选项的时候，getopt_long将返回0，并且将flag指针参数指向val值。eg: 可执行程序 --http-proxy=127.0.0.1:80 那么getopt_long返回值为0，并且lopt值为1。 (4) val：表示指定函数找到该选项时的返回值，或者当flag非空时指定flag指向的数据的值val。\n4、longindex：longindex非空，它指向的变量将记录当前找到参数符合longopts里的第几个元素的描述，即是longopts的下标值。\n5、全局变量：\n（1）optarg：表示当前选项对应的参数值。 （2）optind：表示的是下一个将被处理到的参数在argv中的下标值。 （3）opterr：如果opterr = 0，在getopt、getopt_long、getopt_long_only遇到错误将不会输出错误信息到标准输出流。opterr在非0时，向屏幕输出错误。 （4）optopt：表示没有被未标识的选项。 6、返回值：\n（1）如果短选项找到，那么将返回短选项对应的字符。 （2）如果长选项找到，如果flag为NULL，返回val。如果flag不为空，返回0 （3）如果遇到一个选项没有在短字符、长字符里面。或者在长字符里面存在二义性的，返回“？” （4）如果解析完所有字符没有找到（一般是输入命令参数格式错误，eg： 连斜杠都没有加的选项），返回“-1” （5）如果选项需要参数，忘了添加参数。返回值取决于optstring，如果其第一个字符是“：”，则返回“：”，否则返回“？”。 注意：\n  longopts的最后一个元素必须是全0填充，否则会报段错误\n  短选项中每个选项都是唯一的。而长选项如果简写，也需要保持唯一性。\n   #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; using namespace std; int main(int argc, char **argv) { int opt; int digit_optind = 0; int option_index = 0; /* * 形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下： * (1)只有一个字符，不带冒号——只表示选项， 如-c * (2)一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100 * (3)一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格 * 形式应该如-b200 */ char *optstring = \u0026quot;a:b:c:d\u0026quot;; static struct option long_options[] = { /* * no_argument (即 0) 表明这个长参数不带参数（即不带数值，如：--name） * required_argument (即 1) 表明这个长参数必须带参数（即必须带数值，如：--name Bob） * optional_argument（即2）表明这个长参数后面带的参数是可选的，（即--name和--name Bob均可） */ { \u0026quot;reqarg\u0026quot;, required_argument, NULL, 'r'}, { \u0026quot;noarg\u0026quot;, no_argument, NULL, 'n'}, { \u0026quot;optarg\u0026quot;, optional_argument, NULL, 'o'}, { 0, 0, 0, 0} }; /* * 如果longindex非空，它指向的变量将记录当前找到参数符合longopts里的第几个元素的描述，即是longopts的下标值。 * optind表示的是下一个将被处理到的参数在argv中的下标值。 */ while((opt = getopt_long(argc, argv, optstring, long_options, \u0026amp;option_index)) != -1) { cout \u0026lt;\u0026lt; \u0026quot;opt = \u0026quot; \u0026lt;\u0026lt; opt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;optarg = \u0026quot; \u0026lt;\u0026lt; optarg \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;optind = \u0026quot; \u0026lt;\u0026lt; optind \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;argv[optind -1] = \u0026quot; \u0026lt;\u0026lt; argv[optind - 1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;option_index = \u0026quot; \u0026lt;\u0026lt; option_index \u0026lt;\u0026lt; endl; } return 0; } root@Tk:~/git/Cplusplus/test/getopt# ./a.out -a 100 -b 200 --reqarg opt = 97(a) optarg = 100 optind = 3 argv[optind -1] = 100 option_index = 0 opt = 98(b) optarg = 200 optind = 5 argv[optind -1] = 200 option_index = 0 ./a.out: option '--reqarg' requires an argument opt = 63  Re:\nhttps://blog.csdn.net/cashey1991/article/details/7942809\nhttps://blog.csdn.net/qq_33850438/article/details/80172275\n","href":"https://6923403.github.io/post/getopt_long/","tags":"Linux ; CPP","title":"getopt_long"},{"content":"备忘 简洁明了的教程\nhttps://www.jianshu.com/p/d9162722f189\nhttps://www.jianshu.com/p/a57a5b0e58f0\nhttps://zhuanlan.zhihu.com/p/74812069\n","href":"https://6923403.github.io/post/tcpdump/","tags":"Linux ; Tcpdump","title":"Tcpdump"},{"content":"计算机体系结构 各层作用及协议    分层 作用 协议     物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器）   数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机）   网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）   运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX   会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC   表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII   应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS     封装  链路层 链路层主要有三个目的：\n 为IP模块发送和接收IP数据报； 为ARP模块发送ARP请求和接收ARP应答； 为RARP发送RARP请求和接收RARP应答。  PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。\n环回接口\nre: mtu\n 网络层  IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议）  IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输\n不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。\n无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。\nIP 地址分类:\n IP 地址 ::= {\u0026lt;网络号\u0026gt;,\u0026lt;主机号\u0026gt;}     IP地址类别 网络号 网络范围 主机号 IP地址范围     A 类 8bit，第一位固定为0 0——127 24bit 1.0.0.0——127.255.255.255   B 类 16bit，前两位固定为10 128.0——191.255 16bit 128.0.0.0——191.255.255.255   C 类 24bit，前三位固定为110 192.0.0——223.255.255 8bit 192.0.0.0——223.255.255.255   D 类 前四位固定为1110，后面为多播地址      E 类 前五位固定为11110，后面保留为今后所用       ARP 地址解析协议 ARP为IP地址到对应的硬件地址之间提供动态映射。\nRARP是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或 X终端），它需要系统管理员进行手工设置。\nARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。可以用apr -a来进行检查ARP高速缓存\nARP分组格式\nARP实例\nRARP 逆地址解析协议 RARP协议是许多无盘系统在引导时用来获取IP地址的。RARP分组格式基本上与ARP分组一致。一个RARP请求在网络上进行广播，它在分组中标明发送端的硬件地址，以请求相应IP地址的响应。应答通常是单播传送的。\nICMP 网际控制报文协议 ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。\nICMP报文通常被IP层或更高层协议（TCP或UDP）使用。一些ICMP报文把差错报文返回给用户进程。\nICMP报文是在IP数据报内部被传输的\n检验和字段覆盖整个ICMP报文。\nICMP报文类型 下面各种情况都不会导致产生ICMP差错报文:\n ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。 目的地址是广播地址或多播地址（D类地址）的IP数据报。 作为链路层广播的数据报。 不是IP分片的第一片。 源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。  对于其他类型的ICMP查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。\nping程序 IP数据报中的RR选项的一般格式\n 运输层 tcp—udp UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。\nUDP首部\nUDP数据报中的伪首部 UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。其目的是让UDP两次检查数据是否已经正确到达目的地。\nIP分片  在分片时，除最后一片外，其他每一片中的数据部分（除 I P首部外的其余部分）必须是 8 字节的整数倍。 位于@符号后的数字是从数据报开始处计算的片偏移值。 IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后） 分组是指在IP层和链路层之间传送的数据单元。 一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。  ICMP不可达差错 发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果路由器没有提供这种新的ICMP差错报文格式，那么下一站的MTU就设为0。\n ip数据报格式: https://www.jianshu.com/p/d3f9e70c6220\n","href":"https://6923403.github.io/post/tcp_ip/","tags":"TCP ; IP ; UDP ; Socket","title":"Tcp_ip"},{"content":"环境  Macos Clion2020.3.2 Server: ubuntu18   设置 1. 首先添加一个ssh\n2. 部署服务器上传文件\n选择SFTP协议\n3. 设置本地与远程文件路径\n4. 上传文件\n5. 设置自动上传\n 环境配置 安装环境\nCentos # cmake yum install cmake -y # gcc \u0026amp; gdb yum install gcc-c++ -y yum install gdb -y #gdbserver yum install gdb-gdbserver -y Ubuntu apt-get install cmake apt-get install gcc apt-get install g++ apt-get install gdb apt-get install gdbserver gdbserver配置\ntarget remote中格式是: tcp:ip:port\n 远程调试 编译程序 -g 或者cmkae\ncmake .. -DCMAKE_BUILD_TYPE=Debug make #注意这个10234是端口 跟上图中设置的对应 gdbserver :10234 ./WebServer clion设置断点之后 点击debug开始\n我写了个小脚本 方便操作\n#!/bin/bash cd /root/git/server/debug read -p \u0026quot;Enter server port: \u0026quot; port make gdbserver :$port ./WebServer  Re:\nhttps://cloud.tencent.com/developer/article/1406250\n","href":"https://6923403.github.io/post/clion_remote_debug/","tags":"Clion ; Linux","title":"Clion_remote_debug"},{"content":"GDB 教程 转载自：https://github.com/DAN-AND-DNA/learn-gdb-by-example-for-c.git\n 内容  原理 启动gdb 退出gdb 为gdb进行编译 调试程序 CoreDump简单概念 产生CoreDump文件 调试CoreDump文件 help命令 list命令 start命令 next命令 step命令 break命令 查看断点 删除断点 tbreak命令 continue命令 backtrace命令 查看当前所处的函数堆栈帧 选择函数堆栈帧 打印函数局部变量 run命令 修改变量值 查看变量类型 查看线程运行 启动图像界面  原理 断点功能一般是通过gdb捕获特定的内核信号来实现的，然后定位目标程序停止的地址来判断断点是否成功触发。大致的流程为， 首先gdb fork()出来一个子进程，该子进程启动目标程序(通过ptrace() 和 exec())， 父进程捕获该子进程的所有的信号(通过ptrace() 和 wait())，当子进程收到信号时，子进程就会被挂起，直到父进程通知其继续运行(通过ptrace())\n启动gdb 1 常规启动，非常多的提示信息:\n$ gdb GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026quot;show copying\u0026quot; and \u0026quot;show warranty\u0026quot; for details. This GDB was configured as \u0026quot;x86_64-redhat-linux-gnu\u0026quot;. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. (gdb)  2 简约启动，关闭提示信息:\n$ gdb -q (gdb)  退出gdb 1 输入quit:\n$ gdb -q (gdb) quit  2 输入Ctrl-d:\n$ gdb -q (gdb) quit  为gdb进行编译 为了获得调试信息，需要添加 CFLAGS=-g -o0 选项  具体参考gdb手册\n调试程序 //boom.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; void fun(void) { printf(\u0026#34;hello\\n\u0026#34;); } int main() { fun(); sleep(1000); return 0; } 1 直接启动:\n方法1\n$ gdb boom -q (gdb)  方法2\n$ gdb -q (gdb) file boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb)  2 调试正在运行的程序:\n$ ps ux | grep boom | grep -v 'grep' dan 5647 0.0 0.0 11520 472 pts/0 S+ 15:31 0:00 ./boom $ gdb boom 5647 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. Attaching to program: /home/dan/work/learn_core/build/bin/boom, process 5647 Reading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done. [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Loaded symbols for /lib64/libpthread.so.0 Reading symbols from /lib64/libdl.so.2...(no debugging symbols found)...done. Loaded symbols for /lib64/libdl.so.2 Reading symbols from /lib64/libm.so.6...(no debugging symbols found)...done. Loaded symbols for /lib64/libm.so.6 Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done. Loaded symbols for /lib64/libc.so.6 Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done. Loaded symbols for /lib64/ld-linux-x86-64.so.2 0x00007f1e2185be10 in __nanosleep_nocancel () from /lib64/libc.so.6 Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb)  具体参考gdb手册\nCoreDump简单概念 CoreDump即核心转储，是程序运行异常崩溃时，系统内核为该程序产生的内存、寄存器、运行栈等快照，并保存为一个二进制文件，可以利用该文件进行GDB调试，发现运行错误。\n产生CoreDump文件 # macosx sudo sysctl kern.coredump=1 :kern.coredump: 1 -\u0026gt; 1 # 设置 /cores 目录属性 sudo mkdir /cores sudo chown root:admin /cores sudo chmod 1775 /cores sudo chmod o+w /cores ulimit -c unlimited : /cores/core.* 查看系统是否已经开启了该功能:\n$ ulimit -c 0  上述输出结果为0说明当前系统已经关闭了该功能，所以需要打开该功能:\n临时启用\n$ ulimit -c unlimited $ ulimit -c unlimited  永久启用\n在/etc/security/limits.conf添加一行: * soft core unlimited 修改文件格式，例如： echo \u0026quot;core.%e.%p.%t\u0026quot; \u0026gt;/proc/sys/kernel/core_pattern or echo \u0026quot;/home/dan/mycore/core.%e.%p.%t\u0026quot; \u0026gt;/proc/sys/kernel/core_pattern  调试CoreDump文件 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main() { int* p = NULL; printf(\u0026#34;here\u0026#34;); *p = 7; sleep(1000); return 0; } 运行上述程序就会产生core dump 文件，如果修了core dump文件的位置就需要加上绝对地址如:\n方法1\n$ gdb /home/dan/work/learn_core/build/bin/boom /home/dan/mycore/core.boom.5859.1557305516 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 5859] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb)  方法2\ngdb -q (gdb) file /home/dan/work/learn_core/build/bin/boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) core /home/dan/mycore/core.boom.5859.1557305516 [New LWP 5859] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb)  如果没有修改core dump文件的位置，该文件就会在程序的当前位置产生，就可以直接启动如:\n方法1\n$ gdb boom core.boom.5941.1557306910 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 5941] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb)  方法2\n$ gdb -q (gdb) file boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) core core.boom.5941.1557306910 [New LWP 5941] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb)  help命令 简写为h，查询命令帮助手册，例如:\n$ gdb -q (gdb) help start Run the debugged program until the beginning of the main procedure. You may specify arguments to give to your program, just as with the \u0026quot;run\u0026quot; command. (gdb)  list命令 简写为l，查看源代码，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } list num 指定行号\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) l 7 void func() { printf(\u0026quot;here\u0026quot;); } int main() { int a = 0;  list function 指定函数名\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list func #include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026quot;here\u0026quot;); } int main() { int a = 0; (gdb)  list start,end 指定范围\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,22 #include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026quot;here\u0026quot;); } int main() { int a = 0; func(); a++; return 0; } (gdb)  list + 向后打印 list - 向前打印\nstart命令 start命令会给main函数的第一个可执行语句打上临时断点，然后运行程序直到该断点，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) start Temporary breakpoint 1 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb)  next命令 简写为n，继续运行到下一个代码行，遇到函数则直接运行函数，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) start Temporary breakpoint 1 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) next 11 func(); (gdb) n 12 a++; (gdb) 13 return 0; (gdb) 14 } (gdb) 0x00007ffff730e3d5 in __libc_start_main () from /lib64/libc.so.6 (gdb) Single stepping until exit from function __libc_start_main, which has no line number information. here[Inferior 1 (process 6236) exited normally] (gdb)  next num 可以指定连续运行的代码行数量，例如:\n(gdb) start Temporary breakpoint 2 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 2, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; (gdb) n 3 13 return 0; (gdb)  step命令 简写为s，继续运行到下一个代码行，遇到函数则进入函数，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) start Temporary breakpoint 1 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) step 11 func(); (gdb) func () at /home/dan/work/learn_core/boom.c:5 5 printf(\u0026quot;here\u0026quot;); (gdb) 6 } (gdb) main () at /home/dan/work/learn_core/boom.c:12 12 a++; (gdb) 13 return 0; (gdb) 14 } (gdb) 0x00007ffff730e3d5 in __libc_start_main () from /lib64/libc.so.6 (gdb) Single stepping until exit from function __libc_start_main, which has no line number information. here[Inferior 1 (process 6252) exited normally] (gdb)  break命令 简写为b，设置断点，程序运行到断点就会暂停挂起，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,20 1 #include \u0026lt;stdio.h\u0026gt; 2 3 void func() 4 { 5 printf(\u0026quot;here\u0026quot;); 6 } 7 8 int main() 9 { 10 int a = 0; 11 func(); 12 a++; 13 return 0; 14 } (gdb) b 5 Breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) run Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Breakpoint 1, func () at /home/dan/work/learn_core/boom.c:5 5 printf(\u0026quot;here\u0026quot;); Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb)  查看断点 info breakpoints 可以查看全部设置的断点，命令缩写成 i b，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,20 1 #include \u0026lt;stdio.h\u0026gt; 2 3 void func() 4 { 5 printf(\u0026quot;here\u0026quot;); 6 } 7 8 int main() 9 { 10 int a = 0; 11 func(); 12 a++; 13 return 0; 14 } (gdb) b 5 Breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) info break Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400731 in func at /home/dan/work/learn_core/boom.c:5 (gdb)  删除断点 #include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,20 1 #include \u0026lt;stdio.h\u0026gt; 2 3 void func() 4 { 5 printf(\u0026quot;here\u0026quot;); 6 } 7 8 int main() 9 { 10 int a = 0; 11 func(); 12 a++; 13 return 0; 14 } (gdb) b 5 Breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) info break Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400731 in func at /home/dan/work/learn_core/boom.c:5 (gdb) delete 1 (gdb) info break No breakpoints or watchpoints. (gdb)  tbreak命令 设置临时断点，指令简写为tb，该断点一旦触发就会失效例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) tb 5 Temporary breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) info b Num Type Disp Enb Address What 1 breakpoint del y 0x0000000000400731 in func at /home/dan/work/learn_core/boom.c:5 (gdb) run Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, func () at /home/dan/work/learn_core/boom.c:5 5 printf(\u0026quot;here\u0026quot;); Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) info b No breakpoints or watchpoints. (gdb)  continue命令 遇到断点可以选择next，step等命令继续运行到下一个代码行，也可以使用continue，继续运行整个程序，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; printf(\u0026#34;d=%d\\n\u0026#34;, d); } void func2() { int c = 3; printf(\u0026#34;c=%d\\n\u0026#34;, c); func3(); } void func1() { int b = 2; printf(\u0026#34;b=%d\\n\u0026#34;, b); func2(); } int main() { int a = 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); func1(); return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 5 Breakpoint 1 at 0x400775: file /home/dan/work/learn_core/boom.c, line 5. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. a=1 b=2 c=3 Breakpoint 1, func3 () at /home/dan/work/learn_core/boom.c:5 5 int d = 4; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) c Continuing. d=4 [Inferior 1 (process 4209) exited normally] (gdb)  backtrace命令 打印函数堆栈帧，回溯整个调用过程，之类简写为bt，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) bt #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 #3 0x000000000040079b in main () at /home/dan/work/learn_core/boom.c:29  bt full 可以打印每个函数的局部变量\n(gdb) bt full #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 d = 4 p = 0x0 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 c = 3 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 b = 2 #3 0x000000000040079b in main () at /home/dan/work/learn_core/boom.c:29 a = 1 (gdb)  查看当前所处的函数堆栈帧 通过 info frame 可以查看当前所处的函数堆栈帧信息，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } $ gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) i frame Stack level 0, frame at 0x7ffddb0d63d0: rip = 0x400744 in func3 (/home/dan/work/learn_core/boom.c:8); saved rip 0x400765 called by frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d63c0, args: Locals at 0x7ffddb0d63c0, Previous frame's sp is 0x7ffddb0d63d0 Saved registers: rbp at 0x7ffddb0d63c0, rip at 0x7ffddb0d63c8 (gdb)  选择函数堆栈帧 通过frame 可以选择指定的函数堆栈帧，该指令缩写为f，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } $ gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) bt #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 #3 0x000000000040079b in main () at /home/dan/work/learn_core/boom.c:29 (gdb) info frame Stack level 0, frame at 0x7ffddb0d63d0: rip = 0x400744 in func3 (/home/dan/work/learn_core/boom.c:8); saved rip 0x400765 called by frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d63c0, args: Locals at 0x7ffddb0d63c0, Previous frame's sp is 0x7ffddb0d63d0 Saved registers: rbp at 0x7ffddb0d63c0, rip at 0x7ffddb0d63c8 (gdb) frame 2 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 22 func2(); (gdb) info frame Stack level 2, frame at 0x7ffddb0d6410: rip = 0x400780 in func1 (/home/dan/work/learn_core/boom.c:22); saved rip 0x40079b called by frame at 0x7ffddb0d6430, caller of frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d6400, args: Locals at 0x7ffddb0d6400, Previous frame's sp is 0x7ffddb0d6410 Saved registers: rbp at 0x7ffddb0d6400, rip at 0x7ffddb0d6408 (gdb)  打印函数局部变量 通过info locals 可以打印当前函数堆栈帧内的局部变量，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } $ gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) i frame Stack level 0, frame at 0x7ffddb0d63d0: rip = 0x400744 in func3 (/home/dan/work/learn_core/boom.c:8); saved rip 0x400765 called by frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d63c0, args: Locals at 0x7ffddb0d63c0, Previous frame's sp is 0x7ffddb0d63d0 Saved registers: rbp at 0x7ffddb0d63c0, rip at 0x7ffddb0d63c8 (gdb) info locals d = 4 p = 0x0 (gdb) frame 1 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 15 func3(); (gdb) info locals c = 3 (gdb)  run命令 简写为 r，直接运行程序直到发生错误或者遇到断点，和start不同的是，不会在第一个可执行点暂停，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; printf(\u0026#34;d=%d\\n\u0026#34;, d); } void func2() { int c = 3; printf(\u0026#34;c=%d\\n\u0026#34;, c); func3(); } void func1() { int b = 2; printf(\u0026#34;b=%d\\n\u0026#34;, b); func2(); } int main() { int a = 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); func1(); return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. a=1 b=2 c=3 d=4 [Inferior 1 (process 4201) exited normally] Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) b 5 Breakpoint 1 at 0x400775: file /home/dan/work/learn_core/boom.c, line 5. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. a=1 b=2 c=3 Breakpoint 1, func3 () at /home/dan/work/learn_core/boom.c:5 5 int d = 4; (gdb)  修改变量值 利用set 命令可以修改程序变量，利用print 可以打印变量的值，缩写为p，例如:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; void func1() { int i = 0; while(i \u0026lt; 200) { sleep(1); } } int main() { func1(); return 0; } $ gdb -q (gdb) file boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 8 Breakpoint 1 at 0x40073c: file /home/dan/work/learn_core/boom.c, line 8. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Breakpoint 1, func1 () at /home/dan/work/learn_core/boom.c:8 8 while(i \u0026lt; 200) Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) p i $1 = 0 (gdb) set var i = 200 (gdb) p i $2 = 200 (gdb) s 12 } (gdb) main () at /home/dan/work/learn_core/boom.c:17 17 return 0; (gdb) 18 } (gdb) 0x00007ffff730e3d5 in __libc_start_main () from /lib64/libc.so.6 (gdb) Single stepping until exit from function __libc_start_main, which has no line number information. [Inferior 1 (process 4361) exited normally] (gdb)  要用print打印数组，如果数组的元素数量大于200，是没办法显示完全的，但是可以设置最大元素数量，如:\nset print elements 0 //不进行限制  查看变量类型 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; struct User { char openid[15]; int age; }; void func1() { struct User u = {\u0026#34;wx1234567\u0026#34;, 7}; printf(\u0026#34;openid = %s\\n\u0026#34;, u.openid); int i = 0; while(i \u0026lt; 200) { sleep(1); } } int main() { func1(); return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 17 Breakpoint 1 at 0x4007b8: file /home/dan/work/learn_core/boom.c, line 17. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. openid = wx1234567 Breakpoint 1, func1 () at /home/dan/work/learn_core/boom.c:17 warning: Source file is more recent than executable. 17 while(i \u0026lt; 200) Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) ptype u type = struct User { char openid[15]; int age; } (gdb)  查看线程运行 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void* func(void *p_arg) { while(1) { sleep(3); } } int main() { pthread_t t1; pthread_t t2; char t1n[] = \u0026#34;t1\u0026#34;; char t2n[] = \u0026#34;t2\u0026#34;; pthread_create(\u0026amp;t1, NULL, func, t1n); pthread_create(\u0026amp;t2, NULL, func, t2n); sleep(100); return 0; } info threads 可以查看全部的线程运行情况，包括线程的id和系统id以及当前栈， info thread ID 可以查看单独的线程的运行情况。\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 23 Breakpoint 1 at 0x40080b: file /home/dan/work/learn_core/boom.c, line 23. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. [New Thread 0x7ffff72eb700 (LWP 4675)] [New Thread 0x7ffff6aea700 (LWP 4676)] Breakpoint 1, main () at /home/dan/work/learn_core/boom.c:23 23 sleep(100); Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) i threads Id Target Id Frame 3 Thread 0x7ffff6aea700 (LWP 4676) \u0026quot;boom\u0026quot; 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 2 Thread 0x7ffff72eb700 (LWP 4675) \u0026quot;boom\u0026quot; 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 * 1 Thread 0x7ffff7fee740 (LWP 4671) \u0026quot;boom\u0026quot; main () at /home/dan/work/learn_core/boom.c:23 (gdb)  thread apply ID bt 命令可以打印 指定线程的调用栈\n(gdb) thread apply 3 bt Thread 3 (Thread 0x7ffff6aea700 (LWP 4676)): #0 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 #1 0x00007ffff73b0cc4 in sleep () from /lib64/libc.so.6 #2 0x00000000004007b3 in func (p_arg=0x7fffffffe3b0) at /home/dan/work/learn_core/boom.c:10 #3 0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0 #4 0x00007ffff73e9ead in clone () from /lib64/libc.so.6  thread apply all bt 命令可以打印 全部线程的调用栈\n(gdb) thread apply all bt Thread 3 (Thread 0x7ffff6aea700 (LWP 4676)): #0 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 #1 0x00007ffff73b0cc4 in sleep () from /lib64/libc.so.6 #2 0x00000000004007b3 in func (p_arg=0x7fffffffe3b0) at /home/dan/work/learn_core/boom.c:10 #3 0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0 #4 0x00007ffff73e9ead in clone () from /lib64/libc.so.6 Thread 2 (Thread 0x7ffff72eb700 (LWP 4675)): #0 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 #1 0x00007ffff73b0cc4 in sleep () from /lib64/libc.so.6 #2 0x00000000004007b3 in func (p_arg=0x7fffffffe3c0) at /home/dan/work/learn_core/boom.c:10 #3 0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0 #4 0x00007ffff73e9ead in clone () from /lib64/libc.so.6 Thread 1 (Thread 0x7ffff7fee740 (LWP 4671)): #0 main () at /home/dan/work/learn_core/boom.c:23 (gdb)  具体参考gdb手册\n启动图像界面 $ gdb boom -tui -q启动图像界面\n具体参考gdb手册\n","href":"https://6923403.github.io/post/use_gdb/","tags":"Linux ; GDB ; CPP","title":"Use_gdb"},{"content":"  非活跃，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。\n  定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。\n  定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。\n  定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。\n   Linux下提供了三种定时的方法:\n socket选项SO_RECVTIMEO和SO_SNDTIMEO SIGALRM信号 I/O复用系统调用的超时参数   Socket选项 struct timeval timeout; timeout.tv_sec = time; timeout.tv_usec = 0; socklen_t time_len = sizeof(timeout); ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, \u0026amp;timeout, time_len); //发送数据超时 用返回值errno判断是否达到指定时间 (errno == SO_SNDTIMEO)  SIGALRM信号 sigaction结构体\nstruct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); } sa_handler是一个函数指针，指向信号处理函数 sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息 sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号 sa_flags用于指定信号处理的行为 SA_RESTART，使被信号打断的系统调用自动重新发起 SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号 SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程 SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号 SA_RESETHAND，信号处理之后重新设置为默认的处理方式 SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数 sa_restorer一般不使用\n#include \u0026lt;signal.h\u0026gt;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  Re:\n定时器-Web服务器项目\n","href":"https://6923403.github.io/post/timer_function/","tags":"Linux ; Timer ; Server","title":"Timer function"},{"content":"Reactor Reactor模式要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。\nReactor工作流程∶\n 主线程往 epoll内核事件表中注册 socket 上的读就绪事件。 主线程调用epoll_wait 等待socket上有数据可读。 当socket上有数据可读时，epoll_wait 通知主线程。主线程则将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件。 主线程调用epoll_wait 等待socket可写。 当socket可写时，epoll_wait 通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。   Procactor 将多有I/O操作都交给主线程和内核来处理, 工作线程仅负责业务逻辑\nProactor工作流程∶\n 主线程调用aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的 man 手册）。 主线程继续处理其他逻辑。 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。 主线程继续处理其他逻辑。 当用户缓冲区的数据被写人 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。   模拟Proactor 使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程∶\n 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket上有数据可读。 当 socket 上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket上的写就绪事件。 主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll wait 通知主线程。主线程往 socket 上写人服务器处理客户请求的结果。    半同步/半异步 在I/O模型中，\u0026ldquo;同步\u0026quot;和\u0026quot;异步\u0026quot;区分的是内核向应用程序通知的是何种 I/O 事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。在并发模式中，\u0026ldquo;同步\u0026quot;指的是程序完全按照代码序列的顺序执行∶\u0026quot;异步\u0026quot;指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。\n工作流程 异步线程用于处理 I/O事件，相当于图8-4中的I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。\n反应堆模式 在服务器程序中，如果结合考虑两种事件处理模式和几种 I/O模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（halfsynchalf-reactive）模式\n异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听 socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接 socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。\n半同步 / 半反应堆模式存在如下缺点∶\n 主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从详 求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费 CPU时间。 每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较 少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量 CPU 时间。  高效半同步半异步 主线程只管理监听 socket，连接 socket 由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接 socket 派发给某个工作线程，此后该新 socket上的任何I/O 操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发 socket 的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新 socket上的读写事件注册到自己的 epoll 内核事件表中。\n 领导者/追随者模式 领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序都仅有一个领导者线程，它负责监听 I/O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理L/O事件。此时，新的领导者等待新的 I/O 事件，而原来的领导者则处理 I/O 事件，二者实现了并发。\n领导者/追随者模式包含如下几个组件∶句柄集（HandleSet）、线程集（ThreadSet）、事件处理器（EventHandler）和具体的事件处理器（ConcreteEventHandler）。\n1.句柄集  句柄（Handle）用于表示 I/O 资源，在Linux下通常就是一个文件描述符。句柄集管理众多句柄，它使用wait_for event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。领导者则调用绑定到Handle上的事件处理器来处理事件。领导者将 Handle 和事件处理器绑定是通过调用句柄集中的 register_handle方法实现的。  2.线程集  这个组件是所有工作线程（包括领导者线程和追随者线程）的管理者。它负责各线程之间的同步，以及新领导者线程的推选。线程集中的线程在任一时间必处于如下三种状态之一∶  Leader∶ 线程当前处于领导者身份，负责等待句柄集上的 I/O 事件。 Processing∶线程正在处理事件。领导者检测到I/O事件之后，可以转移到Processing状态来处理该事件，并调用 promote_new_leader方法推选新的领导者;也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导者，则它将成为新的领导 者，否则它就直接转变为追随者。 Follower∶线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。图 8-13 显示了这三种状态之间的转换关系。    需要注意的是，领导者线程推选新的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员 Synchronizer来同步这两个操作，以避免竞态条件。\n3. 事件处理器和具体的事件处理器 事件处理器通常包含一个或多个回调函数 handle_event。这些回调函数用于处理事件对应的业务逻辑。事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的 handle_event 方法，以处理特定的任务。\n由于领导者线程自己监听 I/O 事件并处理客户请求，因而领导者/追随者模式不需要在线程之间传递任何额外的数据，也无须像半同步/半反应堆模式那样在线程之间同步对请求队列的访问。但领导者/追随者的一个明显缺点是仅支持一个事件源集合，因此也无法像图 8-11 所示的那样，让每个工作线程独立地管理多个客户连接。\n","href":"https://6923403.github.io/post/server_actor/","tags":"Linux ; Server ; Reactor ; Proactor","title":"Server actor"},{"content":"信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：\n P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行 V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一   int sem_init(sem_t *sem, int pshared, unsigned int value)\n初始化m_sem value为指定信号量的初始值\n pshared为0 信号量在进程的线程之间共享 pshared非0 信号量在进程之间共享   sem_init函数用于初始化一个未命名的信号量 sem_destory函数用于销毁信号量 sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞 sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程  调用seminit函数时，操作系统将创建信号量对象，此对象中记录着“信号量值”（semaphoreValue）整数。 该值在调用sem_post函数时增1，调用semwait函数时减1。 但信号量的值不能小于0，因此，在信号量为0的情况下调用sem一vait函数时，调用函数的线程将进人阻塞状态（因为函数未返回）。 当然，此时如果有其他线程调用sem一post函数，信号量的值将变为1，而原本阻塞的线程可以将该信号量重新减为0并跳出阻塞状态。 实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为1）。 **类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制\nclass sem{ public: //构造函数 sem() { //信号量初始化 if(sem_init(\u0026amp;m_sem,0,0)!=0){ throw std::exception(); } } //析构函数 ~sem() { //信号量销毁 sem_destroy(\u0026amp;m_sem); } private: sem_t m_sem; };  Reference:\nhttps://blog.csdn.net/m0_45867846/article/details/109021863\n","href":"https://6923403.github.io/post/sem/","tags":"Linux ; Sem","title":"Linux Sem"},{"content":"Downloads mysql 社区版官网下载: https://dev.mysql.com/downloads/mysql/\n Start 下载之后安装一路点继续 设置完root密码\n安装完成后 需要开启/关闭Mysql 系统偏好设置-Mysql图标\n停止MySQL服务 sudo mysql.server stop 重启MySQL服务 sudo mysql.server restart 查看MySQL服务状态 sudo mysql.server status  Connect Mysql 终端输入 vim ~/.bash_profile\nPATH=$PATH:/usr/local/mysql/bin PATH=$PATH:/usr/local/mysql/support-files 再执行 source ~/.bash_profile\nLogin mysql -u root -p 输入密码之后成功进入mysql\nmysql\u0026gt; select version();查看MySQL版本\n Reference: https://www.jianshu.com/p/07a9826898c0\nhttps://www.cnblogs.com/nickchen121/p/11145123.htm\n","href":"https://6923403.github.io/post/mac_install_mysql/","tags":"Mac ; Mysql","title":"Mac install mysql_8.0"},{"content":"2021-06-09更新 系统为big sur 11.4\n接近完美 可以用intel网卡连接wifi 速度还不错\n已知麦克风、隔空投送不能用\nU盘至少16g 再来个小内存U盘或者有网线联网 分出一块磁盘空间至少100G  镜像下载 搜素：黑果小兵\nbig sur用11.4\n 重要前提 如果你没有网线，并且没有其他PC设备联网 你需要提前下载这些 并存储在另一个U盘中\nhttps://github.com/OpenIntelWireless/HeliPort/releases https://github.com/OpenIntelWireless/itlwm/releases/ https://mackie100projects.altervista.org/download-clover-configurator/ #这个往下找找不要最新几个版本 https://mackie100projects.altervista.org/download-opencore-configurator/  Start //OC git clone https://github.com/Pinming/Dell-Inspiron-7590-Hackintosh-Opencore //Diskgenius 官网自行下载最新版 //balennaEther 官网自行下载最新版 1. 先把Dell-Inspiron-7590-Hackintosh-Opencore重命名为OC\n2. 打开OC文件夹 根据屏幕改名1080P的屏幕使用config-1080p.plist需改名成config.plist 如果你是4K屏 不需要修改\n3. balennaEther烧录dmg镜像文件到U盘\n4. 打开Diskgenius 进入U盘的ESP分区文件夹 删除Clover文件夹 然后将OC文件夹拖入\n5. 打开U盘ESP分区中的EFI 将Diskgenius程序文件夹拖进去 备用 以免出问题\n提前准备好安装空间建议200g 至少100g\n6. 用Diskgenius分ESP区 建议300mb至少200mb [https://www.cnblogs.com/liuzhaoyzz/p/12348682.html]\n 安装 1. 重启F2 关闭Secure Boot安全启动 检查磁盘模式为ACHI 百度搜\n2. 进入Boot Sequence \u0026lsquo;add option\u0026rsquo; 添加一个引导 选择启动文件为自己的U盘EFI(找到EFI/OC/OpenCore.efi这个文件)\n3. 重启F12 选择刚才新建的启动项 选择Install mac big sur\n4. 选择磁盘工具先抹盘 选择你提前分好的空间 命名个macos就行 选择格式为APFS 抹不掉就先做成exft 再抹一次\n5. 左上角退出磁盘工具继续安装 然后自动重启 再次选mac启动项 (此时我读条完毕 一直在转圈 等了5分钟 我手动强制关机)\n Siri不启用 iCloud先不要登陆 先创建好一个本地账户  6. 重启f12 选择install mac 本步骤需要重复几次 直到进入系统设置 创建用户的步骤才算完成\n7.1 重启f12 选择winPE, 在我的电脑 EFI中找到Diskgenius 打开程序将U盘的EFI文件复制到桌面\n7.2 选择磁盘的ESP 将EFI拖入\n8.1 重启F2 Boot Sequence add option 这里我命名为macos 选择磁盘中EFI\\OC\\OpenCore.efi\n8.2 把选项置顶。开机自动进入 选择macos\n Wifi设置 下载\u0026mdash;点击: 前提文件\n安装HeliPort\n1. 解压itlwm.zip, 会有一个itlwm.kext\n2. 打开Clover Configurator 选择左侧栏目的挂载分区 然后右边EFI分区 挂载分区 再打开分区 EFI\\OC文件夹\n3.1 打开config.plist右键用Opencore打开 左侧内核设置把itlwm.kext拖进右边, 启用点亮\n3.2 打开EFI\\OC文件夹 把itlwm.kext拖入 kexts文件夹下 重启电脑 打开HeliPort连接wifi\n 安装成功  三码洗白 电脑提前退出账号\n删除登陆设备 手机-设置-最上方进去-找到型号删除掉\n1. 安装Clover Configurator #一定要找对自己的型号 dell7590选择``MacPro 16.1`` 2. 选择合适的SMBIOS ID 1. 生成UUID 复制到图中SmUUID中\n2. 点击生成新的序号\n复制序列号到网址检查 查询不到就是可以用\nhttps://checkcoverage.apple.com/cn/zh\n重启登陆 正常使用功能\n Reference: https://zhuanlan.zhihu.com/p/190441192\nhttps://zhuanlan.zhihu.com/p/117680791\nhttps://zhuanlan.zhihu.com/p/148640325\n三码参考 https://vlambda.com/wz_5fWCnLTxttA.html\nhttps://heipg.cn/tutorial/inject-identifier-for-hackintosh.html\n 参考视频 安装系统操作 https://www.bilibili.com/video/BV1854y1X7oP\n安装wifi操作 https://www.bilibili.com/video/BV12y4y167Qv\n","href":"https://6923403.github.io/post/dell7590_install_macos/","tags":"Dell ; Mac","title":"Dell7590 install macos"},{"content":"unlocker git clone https://github.com/paolo-projects/auto-unlocker.git\n Download cdr https://www.mfpud.com/topics/3888/\n Tutorial https://www.mfpud.com/topics/612/\n进入之后先选择磁盘工具 抹掉磁盘 安装即可\n Other 安装VMware Tools，参照https://www.lovyou.top/post/52.html\n调整MacOS屏幕分辨率参考https://blog.csdn.net/icarus666/article/details/79529766\n","href":"https://6923403.github.io/post/vmware_install_macos/","tags":"Mac ; Vmware","title":"vmware16pro unlock install macos"},{"content":"Ubuntu20.04.1LTS 2020-01-14-Successful\n lib Install apt-get install -y build-essential pkg-config cmake apt-get install -y libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev  Download github: git clone https://github.com/opencv/opencv.git gitee: git clone https://gitee.com/mirrors/opencv.git  Install cd opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_GTK=ON -D OPENCV_GENERATE_PKGCONFIG=YES .. make -j4 make install  Set echo \u0026quot;include /usr/loacal/lib\u0026quot; \u0026gt;\u0026gt; /etc/ld.so.conf ldconfig echo \u0026quot;PKG_CONFIG_PATH=\\$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig\u0026quot; \u0026gt;\u0026gt; /etc/bash.bashrc echo \u0026quot;export PKG_CONFIG_PATH\u0026quot; \u0026gt;\u0026gt; /etc/bash.bashrc  Show version pkg-config --modversion opencv4 pkg-config --cflags opencv4 pkg-config --libs opencv4 ","href":"https://6923403.github.io/post/ubuntu20_install_opencv/","tags":"Ubuntu ; Opencv","title":"Ubuntu20 install opencv"},{"content":"基本流程图  客户角度 服务器角度  套接字选项   config_init connect_mysql init_socket setsockopt linger  ","href":"https://6923403.github.io/post/unp_note/","tags":"Unp ; Linux ; Cpp","title":"Unp note"},{"content":"pymysql.err.OperationalError: (1698, “Access denied for user ‘root’@‘localhost’”)\nsudo mysql -u root mysql\u0026gt; USE mysql; mysql\u0026gt; UPDATE user SET plugin='mysql_native_password' WHERE User='root'; mysql\u0026gt; FLUSH PRIVILEGES; mysql\u0026gt; exit; service mysql restart ","href":"https://6923403.github.io/post/pymysql_err_1698/","tags":"Python ; Mysql","title":"Pymysqlerr 1698"},{"content":"字体 因为wine对HiDPI不会默认适配dpi值。解决方案:\n注意WINEPREFIX这个环境变量指向你的deepin wine容器目录，比如TIM在~/.deepinwine/Deepin-TIM，微信在~/.deepinwine/Deepin-WeChat 执行以下命令\nWINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine winecfg 打开wine设置页面，在显示选项卡中调整屏幕分辨率的dpi值即可。比如想实现win 10的150% DPI只需要将96改到144即可，125%放大则对应120。手工调整下合适的DPI就可以了\n 对于中文乱码是空格的情况，安装中文字体解决\nsudo apt-get install fonts-droid-fallback ttf-wqy-zenhei ttf-wqy-microhei fonts-arphic-ukai fonts-arphic-uming ","href":"https://6923403.github.io/post/ubuntu_tim_wechat/","tags":"Wine ; Ubuntu","title":"Ubuntu tim_wechat"},{"content":"ssize_t write(int fd, const void*buf,size_t nbytes);\nwrite函数将buf中的nbytes字节内容写入文件描述符fd.\n成功时返回写的字节数.失败时返回-1. 并设置errno变量. 在网络程序中,当我们向套接字文件描述符写时有两可能. 1)write的返回值大于0,表示写了部分或者是全部的数据. 这样我们用一个while循环来不停的写入，但是循环过程中的buf参数和nbyte参数得由我们来更新。也就是说，网络写函数是不负责将全部数据写完之后在返回的。 2)返回的值小于0,此时出现了错误.我们要根据错误类型来处理. 如果错误为EINTR表示在写的时候出现了中断错误. 如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接).\n ssize_t read(int fd,void *buf,size_t nbyte)\nread函数是负责从fd中读取内容.\n当读成功 时,read返回实际所读的字节数,如果返回的值是0 表示已经读到文件的结束了,小于0表示出现了错误.如果错误为EINTR说明读是由中断引起 的, 如果是ECONNREST表示网络连接出了问题. 和上面一样,我们也写一个自己的读函数.\n recv和send函数提供了和read和write差不多的功能.不过它们提供了第四个参数来控制读写操作.\nint recv(int sockfd,void *buf,int len,int flags) int send(int sockfd,void *buf,int len,int flags) 前面的三个参数和read, write一样,第四个参数可以是0或者是以下的组合\n   标题 内容     MSG_DONTROUTE 不查找表   MSG_OOB 接受或者发送带外数据   MSG_PEEK 查看数据,并不从系统缓冲区移走数据   MSG_WAITALL 等待所有数据    MSG_DONTROUTE:是 send函数使用的标志.这个标志告诉IP.目的主机在本地网络上面,没有必要查找表.这个标志一般用网络诊断和路由程序里面. MSG_OOB:表示可以接收和发送带外的数据.关于带外数据我们以后会解释的.\nMSG_PEEK:是recv函数的使用标志, 表示只是从系统缓冲区中读取内容,而不清除系统缓冲区的内容.这样下次读的时候,仍然是一样的内容.一般在有多个进程读写数据时可以使用这个标志.\nMSG_WAITALL 是recv函数的使用标志,表示等到所有的信息到达时才返回.使用这个标志的时候recv回一直阻塞,直到指定的条件满足,或者是发生了错误. 1)当读到了指定的字节时,函数正常返回.返回值等于len 2)当读到了文件的结尾时,函数正常返回.返回值小于len 3)当操作发生错误时,返回-1,且设置错误为相应的错误号(errno)\n Re:\nhttps://blog.csdn.net/petershina/article/details/7946615\n","href":"https://6923403.github.io/post/socket_write_send/","tags":"Linux ; Socket ; Send","title":"Socket write_send"},{"content":"import threading import time def worker(): print “worker” time.sleep(1) return for i in xrange(5): t = threading.Thread(target=worker) t.start() 这段代码就使用了多线程，但是没法传递参数，而实际使用多线程，往往是需要传递参数的，这么写实现传递参数的多线程：\nimport threading import time def worker(number): print “worker” time.sleep(number) return for i in xrange(5): t = threading.Thread(target=worker,args=(i,)) t.start() 第一个参数是线程函数变量，第二个参数args是一个数组变量参数，如果只传递一个值，就只需要i, 如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，元组中只包含一个元素时，需要在元素后面添加逗号。\n Re:\nhttps://blog.csdn.net/chpllp/article/details/54381141\n","href":"https://6923403.github.io/post/python_thread_mis/","tags":"Python ; Thread","title":"Python thread parameter transfer"},{"content":" font(字体类)：字号、字体颜色、下划线等 fill(填充类)：颜色等 border(边框类)：设置单元格边框 alignment(位置类)：对齐方式 number_format(格式类)：数据格式 protection(保护类)：写保护   \u0026gt;\u0026gt;\u0026gt; from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font \u0026gt;\u0026gt;\u0026gt; font = Font(name='Calibri', size=11, bold=False, italic=False, vertAlign=None, underline='none', strike=False, color='FF000000') \u0026gt;\u0026gt;\u0026gt; fill = PatternFill(fill_type=None, start_color='FFFFFFFF', end_color='FF000000') \u0026gt;\u0026gt;\u0026gt; border = Border(left=Side(border_style=None, color='FF000000'), right=Side(border_style=None, color='FF000000'), top=Side(border_style=None, color='FF000000'), bottom=Side(border_style=None, color='FF000000'), diagonal=Side(border_style=None, color='FF000000'), diagonal_direction=0, outline=Side(border_style=None, color='FF000000'), vertical=Side(border_style=None, color='FF000000'), horizontal=Side(border_style=None, color='FF000000') ) \u0026gt;\u0026gt;\u0026gt; alignment=Alignment(horizontal='general', vertical='bottom', text_rotation=0, wrap_text=False, shrink_to_fit=False, indent=0) \u0026gt;\u0026gt;\u0026gt; number_format = 'General' \u0026gt;\u0026gt;\u0026gt; protection = Protection(locked=True, hidden=False) 以上几种样式（字体、填充、边框、位置和保护）实例一旦被创建实例的属性就不可更改，只能重新创建实例。\n 对一个cell进行格式设置：\nws[\u0026quot;B5\u0026quot;].font = ft ws[\u0026quot;B5\u0026quot;].fill =fill ws[\u0026quot;B5\u0026quot;].border = bd ws[\u0026quot;B5\u0026quot;].alignment = alignment ws[\u0026quot;B5\u0026quot;].number_format = number_format ws[\u0026quot;B5\u0026quot;].value =\u0026quot;pynote.net\u0026quot;  编辑页面设置\nws.page_setup.orientation = ws.ORIENTATION_LANDSCAPE ws.page_setup.paperSize = ws.PAPERSIZE_TABLOID ws.page_setup.fitToHeight = 0 ws.page_setup.fitToWidth = 1  Re:\nhttps://blog.csdn.net/aishenghuomeidaoli/article/details/52165305\nhttps://www.pynote.net/archives/2229\n","href":"https://6923403.github.io/post/opepyxl_sytle/","tags":"Python ; Openpyxl","title":"Opepyxl sytle"},{"content":"编译安装 apt install libncurses5-dev libgnome2-dev ./configure --with-features=huge \\ --enable-multibyte \\ --enable-cscope \\ --prefix=/usr/local make make install  主题配置 首先要确认你的终端支持真彩，一般来说，主流的比如iTerm2, Putty, Powershell的最新版本都已经支持了。我们可以运行以下命令检测一下\n(echo -e '\\e[48:2:1:2:3m\\eP$qm\\e\\\\' ; xxd)\n\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;=\u0026gt;全局配置\u0026lt;=\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;关闭vi兼容模式\u0026quot; set nocompatible \u0026quot;设置历史记录步数\u0026quot; set history=1000 \u0026quot;开启相关插件\u0026quot; \u0026quot;侦测文件类型\u0026quot; filetype on \u0026quot;载入文件类型插件\u0026quot; filetype plugin on \u0026quot;为特定文件类型载入相关缩进文件\u0026quot; filetype indent on \u0026quot;当文件在外部被修改时，自动更新该文件\u0026quot; set autoread \u0026quot;激活鼠标的使用\u0026quot; set mouse=a set selection=exclusive set selectmode=mouse,key \u0026quot;保存全局变量\u0026quot; set viminfo+=! \u0026quot;带有如下符号的单词不要被换行分割\u0026quot; set iskeyword+=_,$,@,%,#,- \u0026quot;通过使用: commands命令，告诉我们文件的哪一行被改变过\u0026quot; set report=0 \u0026quot;被分割的窗口间显示空白，便于阅读\u0026quot; set fillchars=vert:\\ ,stl:\\ ,stlnc:\\ \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;=\u0026gt;字体和颜色\u0026lt;=\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;自动开启语法高亮\u0026quot; syntax enable \u0026quot;设置字体\u0026quot; \u0026quot;set guifont=dejaVu\\ Sans\\ MONO\\ 10 set guifont=Courier_New:h10:cANSI \u0026quot;设置颜色\u0026quot; \u0026quot;colorscheme desert \u0026quot;#set t_Co=256 记着注释或者删除这一行\u0026quot; if has(\u0026quot;termguicolors\u0026quot;) set termguicolors endif \u0026quot;高亮显示当前行\u0026quot; \u0026quot;set cursorline 白色条框 不喜欢可以关闭\u0026quot; set cursorline \u0026quot;hi cursorline guibg=#00ff00\u0026quot; \u0026quot;hi CursorColumn guibg=#00ff00\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;=\u0026gt;代码折叠功能\u0026lt;=\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;激活折叠功能\u0026quot; set foldenable \u0026quot;set nofen（这个是关闭折叠功能）\u0026quot; \u0026quot;设置按照语法方式折叠（可简写set fdm=XX）\u0026quot; \u0026quot;有6种折叠方法： \u0026quot;manual 手工定义折叠\u0026quot; \u0026quot;indent 更多的缩进表示更高级别的折叠\u0026quot; \u0026quot;expr 用表达式来定义折叠\u0026quot; \u0026quot;syntax 用语法高亮来定义折叠\u0026quot; \u0026quot;diff 对没有更改的文本进行折叠\u0026quot; \u0026quot;marker 对文中的标志进行折叠\u0026quot; set foldmethod=manual \u0026quot;set fdl=0（这个是不选用任何折叠方法）\u0026quot; \u0026quot;设置折叠区域的宽度\u0026quot; \u0026quot;如果不为0，则在屏幕左侧显示一个折叠标识列 \u0026quot;分别用“-”和“+”来表示打开和关闭的折叠 set foldcolumn=0 \u0026quot;设置折叠层数为3\u0026quot; setlocal foldlevel=3 \u0026quot;设置为自动关闭折叠\u0026quot; set foldclose=all \u0026quot;用空格键来代替zo和zc快捷键实现开关折叠\u0026quot; \u0026quot;zo O-pen a fold (打开折叠) \u0026quot;zc C-lose a fold (关闭折叠) \u0026quot;zf F-old creation (创建折叠) \u0026quot;nnoremap \u0026lt;space\u0026gt; @=((foldclosed(line('.')) \u0026lt; 0) ? 'zc' : 'zo')\u0026lt;CR\u0026gt; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;=\u0026gt;文字处理\u0026lt;=\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;使用空格来替换Tab\u0026quot; set expandtab \u0026quot;设置所有的Tab和缩进为4个空格\u0026quot; set tabstop=4 \u0026quot;设定\u0026lt;\u0026lt;和\u0026gt;\u0026gt;命令移动时的宽度为4\u0026quot; set shiftwidth=4 \u0026quot;使得按退格键时可以一次删除4个空格\u0026quot; set softtabstop=4 set smarttab \u0026quot;缩进，自动缩进（继承前一行的缩进）\u0026quot; \u0026quot;set autoindent 命令打开自动缩进，是下面配置的缩写 \u0026quot;可使用autoindent命令的简写，即“:set ai”和“:set noai” \u0026quot;还可以使用“:set ai sw=4”在一个命令中打开缩进并设置缩进级别 set ai set cindent \u0026quot;智能缩进\u0026quot; set si \u0026quot;自动换行” set wrap \u0026quot;设置软宽度\u0026quot; set sw=4 \u0026quot;行内替换\u0026quot; set gdefault \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;=\u0026gt;Vim 界面\u0026lt;=\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;增强模式中的命令行自动完成操作\u0026quot; set wildmenu \u0026quot;显示标尺\u0026quot; set ruler \u0026quot;设置命令行的高度\u0026quot; set cmdheight=1 \u0026quot;显示行数\u0026quot; set nu \u0026quot;不要图形按钮\u0026quot; set go= \u0026quot;在执行宏命令时，不进行显示重绘；在宏命令执行完成后，一次性重绘，以便提高性能\u0026quot; set lz \u0026quot;使回格键（backspace）正常处理indent, eol, start等\u0026quot; set backspace=eol,start,indent \u0026quot;允许空格键和光标键跨越行边界\u0026quot; set whichwrap+=\u0026lt;,\u0026gt;,h,l \u0026quot;设置魔术\u0026quot; set magic \u0026quot;关闭遇到错误时的声音提示\u0026quot; \u0026quot;关闭错误信息响铃\u0026quot; set noerrorbells \u0026quot;关闭使用可视响铃代替呼叫\u0026quot; set novisualbell \u0026quot;高亮显示匹配的括号([{和}])\u0026quot; set showmatch \u0026quot;匹配括号高亮的时间（单位是十分之一秒）\u0026quot; set mat=2 \u0026quot;光标移动到buffer的顶部和底部时保持3行距离\u0026quot; set scrolloff=3 \u0026quot;搜索逐字符高亮\u0026quot; set hlsearch set incsearch \u0026quot;搜索时不区分大小写\u0026quot; \u0026quot;还可以使用简写（“:set ic”和“:set noic”）\u0026quot; set ignorecase \u0026quot;用浅色高亮显示当前行\u0026quot; autocmd InsertLeave * se nocul autocmd InsertEnter * se cul \u0026quot;输入的命令显示出来，看的清楚\u0026quot; set showcmd \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;=\u0026gt;编码设置\u0026lt;=\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;设置编码\u0026quot; set encoding=utf-8 set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936 \u0026quot;设置文件编码\u0026quot; set fileencodings=utf-8,gbk,latin1 \u0026quot;设置终端编码\u0026quot; set termencoding=utf-8 \u0026quot;设置语言编码\u0026quot; set langmenu=zh_CN.UTF-8 set helplang=cn \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;=\u0026gt;其他设置\u0026lt;=\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;开启新行时使用智能自动缩进\u0026quot; set smartindent set cin set showmatch \u0026quot;在处理未保存或只读文件的时候，弹出确认\u0026quot; set confirm \u0026quot;隐藏工具栏\u0026quot; set guioptions-=T \u0026quot;隐藏菜单栏\u0026quot; set guioptions-=m \u0026quot;置空错误铃声的终端代码\u0026quot; set vb t_vb= \u0026quot;显示状态栏（默认值为1，表示无法显示状态栏）\u0026quot; set laststatus=2 \u0026quot;状态行显示的内容\u0026quot; set statusline=%F%m%r%h%w\\ [FORMAT=%{\u0026amp;ff}]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %{strftime(\\\u0026quot;%d/%m/%y\\ -\\ %H:%M\\\u0026quot;)} \u0026quot;粘贴不换行问题的解决方法\u0026quot; set pastetoggle=\u0026lt;F9\u0026gt; \u0026quot;设置背景颜色\u0026quot; set background=dark \u0026quot;文件类型自动检测，代码智能补全\u0026quot; set completeopt=longest,preview,menu \u0026quot;共享剪切板\u0026quot; set clipboard+=unnamed \u0026quot;从不备份\u0026quot; set nobackup set noswapfile \u0026quot;自动保存\u0026quot; set autowrite \u0026quot;显示中文帮助\u0026quot; if version \u0026gt;= 603 set helplang=cn set encoding=utf-8 endif \u0026quot;设置高亮相关项\u0026quot; highlight Search ctermbg=black ctermfg=white guifg=white guibg=black ","href":"https://6923403.github.io/post/vim_config/","tags":"CPP ; Vim ; Linux","title":"Vim_config"},{"content":"const 作用\n 修饰变量，变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。   // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026amp;a; // 指针变量，指向常对象 const A \u0026amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = \u0026quot;Hello\u0026quot;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7();  const 的指针与引用  指针  指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）   引用  指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer     用法小结 指针\nconst int * pOne; //指向整形常量的指针，它指向的值不能修改(指针变量，指向字符数组常量) int * const pTwo; //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改(自身是常量的指针，指向字符数组变量) const int *const pThree; //指向整形常量的常量指针 。它既不能再指向别的常量，指向的值也不能修改(自身是常量的指针，指向字符数组常量) 类定义、类成员\n// 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026amp;a; // 指针变量，指向常对象 const A \u0026amp;q = a; // 指向常对象的引用 类成员函数\nint getValue() const; //该函数为只读函数，不允许修改其中的数据成员的值。 const int getValue(); //修饰的是返回值，表示返回的是指针所指向值是常量。 引用\nint \u0026amp;a = 20; //错误 字面常量是右值 const int \u0026amp;c = b; # 常量左值引用绑定到非常量左值，编译通过 const int \u0026amp;e = c; # 常量左值引用绑定到常量左值，编译通过 const int \u0026amp;b =2; # 常量左值引用绑定到右值，编程通过 void s1(const \u0026amp;ra) //ra不可改变 ","href":"https://6923403.github.io/post/cppconst/","tags":"CPP ; Const ; Pointer","title":"CPP_Const"},{"content":"什么是C/S和B/S架构？\nC/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。\nB/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。\n第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。\n第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。\n 优点/缺点 C/S架构的优点\na. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。\nb. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。\nc. 客户端直接操作界面。\nC/S架构的缺点\na\u0026gt; C/S架构适用于局域网，对网速的要求比较高。\nb\u0026gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。\nc\u0026gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。\nd\u0026gt; 系统的维护也比较麻烦。\n B/S架构的优点  a\u0026gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。\nb\u0026gt; 浏览器只处理一些简单的逻辑事务，负担小。\nc\u0026gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。\nd\u0026gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。\ne\u0026gt; B/S建立在广域网上，所以需要的网速要求不高。\nf\u0026gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。\ng\u0026gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。\nB/S架构的缺点  a\u0026gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。\nb\u0026gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。\n  第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。   https://blog.csdn.net/qq_42828949/article/details/82822901\nhttps://blog.csdn.net/zhengqijun_/article/details/53056624\n","href":"https://6923403.github.io/post/cs_bs/","tags":"Linux ; TCP","title":"C/S_B/S 架构"},{"content":"O(1)常数阶 \u0026lt; O(logn)对数阶 \u0026lt; O(n)线性阶 \u0026lt; O(n^2)平方阶 \u0026lt; O(n^3)(立方阶) \u0026lt; O(2^n) (指数阶)\nFor O(n) int function1(int x, int n) { int result = 1; // 注意 任何数的0次方等于1 for (int i = 0; i \u0026lt; n; i++) { result = result * x; } return result; }  Recursion O(n) int function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; }  Recursion2 O(n) int function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n/2) * function3(x, n/2)*x; } return function3(x, n/2) * function3(x, n/2); }  Recursion3 O(logn) int function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n/2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t*t*x; } return t*t; } ","href":"https://6923403.github.io/post/recursion/","tags":"Algorithm ; CPP ; Recursion","title":"Algorithm x^n"},{"content":"int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)\n其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构 pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用， 默认值是PTHREAD_ PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。\n注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_destroy（pthread_cond_t cond）。\n也可以静态的初始化条件变量\npthread_cond_t my_condition = PTHREAD_COND_INITIALIZER;  pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr); // 初始化锁变量mutex。 // attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t *mutex); // 加锁（阻塞操作） pthread_mutex_trylock(pthread_mutex_t *mutex); // 试图加锁（不阻塞操作） // 当互斥锁空闲时将占有该锁；否则立即返回 // 但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t *mutex); 销毁一个不再需要的互斥量，释放系统资源。 pthread_cond_wait() / pthread_cond_timedwait -----等待条件变量，挂起线程，区别是后者，会有timeout时间， 如果到了timeout,线程自动解除阻塞，这个时间和 time()系统调用相同意义的。以1970年时间算起。 pthread_cond_signal ----激活等待列表中的线程， pthread_cond_broadcast() -------激活所有等待线程列表中最先入队的线程 条件变量\n条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：\n 1）一个线程等待\u0026quot;条件变量的条件成立\u0026quot;而挂起； 2）另一个线程使\u0026quot;条件成立\u0026quot;（给出条件成立信号）。  为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。\n注意：\n  1）上面这几个函数都是原子操作，可以为理解为一条指令，不会被其他程序打断\n  2）上面这个几个函数，必须配合使用。\n  3）pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，继续执行pthread_cond_wait\n  返回值:\npthread_mutex_lock() 和 pthread_mutex_unlock() 返回0，否则返回一个错误的提示码\npthread_mutex_trylock() 在成功获得了一个mutex的锁后返回0，否则返回一个错误提示码错误\npthread_mutex_lock() 和 pthread_mutex_unlock()失败的时候 [EINVAL] mutex在生成的时候，它的protocol属性的值是 PTHREAD_PRIO_PROTECT，同时调用线程的优先级(priority)比该mutex的当前prority上限高\n int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);\n 第一个参数为指向线程标识符的指针。 第二个参数用来设置线程属性。 第三个参数是线程运行函数的起始地址。 最后一个参数是运行函数的参数。  https://blog.csdn.net/weibo1230123/article/details/81410241\nint pthread_join(pthread_t thread, void **retval); 子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。\n  thread: 需要等待的线程,指定的线程必须位于当前的进程中，而且不得是分离线程\n  retval: 线程tid所执行的函数返回值（返回值地址需要保证有效），其中status可以为NULL\n  int pthread_detach(pthread_t tid);\n 主线程与子线程分离，子线程结束后，资源自动回收。   其他操作 #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_init(pthread_condattr_t* attr); int pthread_condattr_destroy(pthread_condattr_t* attr); //返回值：成功返回0；失败返回错误编码 pthread_condattr_init\n 功能：对条件变量属性结构体初始化 调用此函数之后，条件变量属性结构体的属性都是系统默认值，如果想要设置其他属性，还需要调用不同的函数进行设置  pthread_condattr_destroy\n 功能：对条件变量属性结构体反初始化（销毁） 只反初始化，不释放内存   #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setshared(pthread_condattr_t* attr,int pshared); int pthread_condattr_getshared(const pthread_condattr_t* restrict attr,int* restrict pshared); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setshared\n 功能：设置条件变量的进程共享属性  pthread_condattr_getshared\n 功能：获取条件变量的进程共享属性   #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setclock(pthread_condattr_t* attr,clockid_t clock_id); int pthread_condattr_getclock(const pthread_condattr_t* restrict attr,clockid_t *restrict clock_id); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setclock\n 功能：此函数用于设置pthread_cond_timewait函数使用的时钟ID  pthread_condattr_getclock\n 功能：此函数获取可被用于pthread_cond_timedwait函数的时钟ID。pthread_cond_timedwait函数使用前需要用pthread_condattr_t对条件变量进行初始化    Linux 线程库版本\ngetconf GNU_LIBPTHREAD_VERSION\npthread_create 创建一个线程\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);\n线程结束\nvoid pthread_exit(void *retval);\n线程回收\nint pthread_join(pthread_t thread, void **retval);\n取消线程\nint pthread_cancel(pthread_t thread);\n目标线程可以设置是否允许被取消以及如何取消\nint pthread_setcancelstate(int state, int *oldstate); int pthread_setcanceltype(int type, int *oldtype); 初始化线程属性对象\nint pthread_attr_init(pthread_attr_t *attr);\n销毁线程属性对象, 被销毁的线程属性对象只有再次初始化之后才能继续使用\nint pthread_attr_destroy(pthread_attr_t *attr);\nPOSIX信号量函数\n//初始化一个未命名的信号量 int sem_init(sem_t *sem, int pshared, unsigned int value); 其中sem是要初始化的信号量，pshared表示此信号量是在进程间共享还是线程间共享，value是信号量的初始值。 //用于销毁信号量 int sem_destroy(sem_t *sem); 其中sem是要销毁的信号量。只有用sem_init初始化的信号量才能用sem_destroy销毁。 等待信号量，如果信号量的值大于0,将信号量的值减1,立即返回。如果信号量的值为0,则线程阻塞。相当于P操作。成功返回0,失败返回-1。 //以原子操作的方式将信号量值减1 int sem_wait(sem_t *sem); //始终立即返回,不论被操作的信号是否有非0值 int sem_trywait(sem_t *sem); //以原子操作的方式将信号量的值加1 信号量大于0时 其他正在调用sem_wait等待信号量的线程将被唤醒** int sem_post(sem_t *sem); 释放信号量，让信号量的值加1。相当于V操作。  互斥锁 //初始化互斥锁 int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); //用于销毁互斥锁 int pthread_mutex_destroy(pthread_mutex_t *mutex); //以原子操作的方式给一个互斥锁加锁 int pthread_mutex_lock(pthread_mutex_t * mutex); //立即返回 不论被操作的互斥锁是否已经被加锁 int pthread_mutex_trylock(pthread_mutex_t * mutex); //以原子操作的方式给一个互斥锁解锁 int pthread_mutex_unlock(pthread_mutex_t * mutex); 互斥锁属性 // 初始化互斥锁属性对象 int pthread_mutexattr_init(pthread_mutexattr_t *attr); //销毁互斥锁属性对象 int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); //获取和设置互斥锁的pshared属性 int pthread_mutexattr_getpshared(const pthread_mutexttr_t * attr, int * pshred); int pthread_mutexattr_setpshared(pthread_mutex_attr_t * attr, int pshared); //获取和设置互斥锁的type属性 int pthread_mutexattr_gettype(const pthread_mutexattr_t * attr, int * type); int pthread_mutexattr_settype(pthread_mutexattr_t * attr, int type); //确保fork调用后父进程和子进程都拥有一个清楚的锁状态 int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); //1. 在主线程创建出其他子线程之前就调用 pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样做之后，实际上所有线程都不会响应被屏蔽的信号了。 //设置线程信号掩码 int pthread_sigmask(int how, const sigset_t * restrict set, sigset_t * restrict oset); //2. 在某个线程中调用如下函数来等待信号并处理之∶ int sigwait(const sigset_t *restrict set, int *restrict sig); 条件变量 //初始化条件变量 int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr); //销毁条件变量 int pthread_cond_destroy(pthread_cond_t *cv); //以广播方式唤醒所有等待目标条件变量的线程 int pthread_cond_broadcast(pthread_cond_t *cv); //释放被阻塞在指定条件变量上的一个线程 int pthread_cond_signal(pthread_cond_t * cond); //等待目标条件变量 int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);  进程池和线程池  Reference: https://blog.csdn.net/qq_41453285/article/details/90904870\nhttps://blog.csdn.net/liangxanhai/article/details/7767430\nhttps://blog.csdn.net/wushuomin/article/details/80051295\nhttps://blog.csdn.net/lovecodeless/article/details/24885127\nhttps://blog.csdn.net/weibo1230123/article/details/81410241\n","href":"https://6923403.github.io/post/pthread/","tags":"Linux ; Pthread ; CPP","title":"Linux Pthread"},{"content":"class derived-class: access-specifier base-class\nclass Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; Rectangle rect; rect.setWidth(3); rect.setHeight(5); #rect result = 15 cout \u0026lt;\u0026lt; rect.getArea() \u0026lt;\u0026lt; endl;  访问控制和继承\n   访问 public protected private     同一个类 yes yes yes   派生类 yes yes no   外部的类 yes no no     公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。  ","href":"https://6923403.github.io/post/cpp_inherit/","tags":"CPP","title":"Cpp_inherit"},{"content":"   Mysql ex     mysql_init() 获取或初始化MYSQL结构   mysql_real_connect() 连接到MySQL服务器。   mysql_query() 执行指定为“以Null终结的字符串”的SQL查询   mysql_use_result() 初始化逐行的结果集检索   mysql_field_count() 返回上次执行语句的结果集的列数   mysql_fetch_row() 从结果集中获取下一行   mysql_num_fields() 返回结果集中的字段数     class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; };  基本步骤\n使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接  Re:\nhttps://blog.csdn.net/lisonglisonglisong/article/details/25071793\n","href":"https://6923403.github.io/post/mysql_use/","tags":"Mysql ; CPP ; Linux","title":"CPP_Mysql_use"},{"content":"Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo\n[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc  Install Mongodb sudo yum install -y mongodb-org  Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use  Re:\nhttps://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n","href":"https://6923403.github.io/post/install_mongodb/","tags":"Linux ; Mongodb","title":"Centos7 Install mongodb"},{"content":"升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo \u0026quot;source /opt/rh/devtoolset-9/enable\u0026quot; \u0026gt;\u0026gt; /etc/profile gcc -v  安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis  配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf\ndaemonize no 改为 daemonize yes  开机自启 vim /etc/systemd/system/redis.service\n[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.service systemctl enable redis.service  Re:\nhttps://blog.csdn.net/wanTN/article/details/108502856\n","href":"https://6923403.github.io/post/install_redis/","tags":"Linux ; Redis","title":"Centos7 Install_redis"},{"content":"1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled\n3.安装Mysql5.7 sudo yum -y install mysql-community-server\n4.启动Mysql sudo systemctl start mysqld\n5.设置系统启动时自动启动 sudo systemctl enable mysqld\n6.查看启动状态 sudo systemctl status mysqld\n7.root 密码 cat /var/log/mysqld.log | grep -i 'temporary password'\n8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等\nmysql_secure_installation\n9.设置数据库编码为utf8 sudo vim /etc/my.cnf\n[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect='SET NAMES utf8' character-set-server = utf8 reboot sudo systemctl restart mysqld\n Re:\nhttps://juejin.im/post/6844903732145045517\n","href":"https://6923403.github.io/post/install_mysql/","tags":"Mysql ; Linux","title":"Centos7 Install mysql"},{"content":"创建数据库 CREATE DATABASE IF NOT EXISTS vctest DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. CREATE DATABASE IF NOT EXISTS mytestdb;\n删除数据库 drop database test1; 2. DROP DATABASE IF EXISTS mytestdb;\n查看All DB show databases;\n导入sql source test.sql\n select\nuse vctest select city, phone, country from `offices`; SELECT语句由以下列表中所述的几个子句组成：\n语句中的SELECT和FROM语句是必须的，其他部分是可选的。\n SELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。  即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。\nSELECT lastname, firstname, jobtitle FROM employees WHERE jobtitle = 'Sales Rep';  INSERT 创建表\nCREATE TABLE [IF NOT EXISTS] table_name( column_list ) engine=table_type; CREATE TABLE IF NOT EXISTS user ( uid INT(11) AUTO_INCREMENT, username VARCHAR(45) NOT NULL, registration_time DATE DEFAULT NULL, PRIMARY KEY(uid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;  首先，指定要在CREATE TABLE子句之后创建的表的名称。表名在数据库中必须是唯一的。 IF NOT EXISTS是语句的可选部分，允许您检查正在创建的表是否已存在于数据库中。 如果是这种情况，MySQL将忽略整个语句，不会创建任何新的表。 强烈建议在每个CREATE TABLE语句中使用IF NOT EXISTS来防止创建已存在的新表而产生错误。 其次，在column_list部分指定表的列表。字段的列用逗号(，)分隔。我们将在下一节中向您展示如何更详细地列(字段)定义。 第三，需要为engine子句中的表指定存储引擎。可以使用任何存储引擎，如：InnoDB，MyISAM，HEAP，EXAMPLE，CSV，ARCHIVE，MERGE， FEDERATED或NDBCLUSTER。如果不明确声明存储引擎，MySQL将默认使用InnoDB。  查看表的列属性\n1. show columns from user; 2. desc user; ALTER TABLE语句来设置列的自动递增属性\nALTER TABLE tasks CHANGE COLUMN task_id task_id INT(11) NOT NULL AUTO_INCREMENT; 添加新列\nALTER TABLE vendors ADD COLUMN phone VARCHAR(15) AFTER name; ALTER TABLE tasks ADD COLUMN complete DECIMAL(2,1) NULL AFTER description; 修改列的属性\n原来表dictionary的一列enword的属性为VARCHAR(32),修改为VARCHAR(64) NOT NULL. ALTER TABLE table_name MODIFY COLUMN column_name VARCHAR(64) NOT NULL; 删除列\nALTER TABLE tasks DROP COLUMN description; 重命名表\nALTER TABLE tasks RENAME TO work_items; 2. RENAME TABLE old_table_name TO new_table_name;  插入数据\nINSERT INTO tasks(subject,start_date,end_date,description) //插入到tasks表中 VALUES('Learn MySQL INSERT','2017-07-21','2017-07-22','Start learning..'); 插入多行\nINSERT INTO table(column1,column2...) VALUES (value1,value2,...), (value1,value2,...), (value1, value2,...); 插入日期出错\n#https://blog.csdn.net/weixin_50518271/article/details/113761164 select @@SQL_MODE SET @@SQL_MODE = REPLACE(@@SQL_MODE, 'NO_ZERO_DATE', '');  复制表结构\nCREATE TABLE tasks_bak LIKE tasks; INSERT INTO tasks_bak SELECT * FROM tasks;  MySQL INSERT与ON DUPLICATE KEY UPDATE\nINSERT INTO tasks(task_id,subject,start_date,end_date,description) VALUES (4,'Test ON DUPLICATE KEY UPDATE','2017-01-01','2017-01-02','Next Priority') ON DUPLICATE KEY UPDATE task_id = task_id + 1, subject = 'Test ON DUPLICATE KEY UPDATE'; 等同于UPDATE语句\nUPDATE tasks SET task_id = task_id + 1, subject = 'Test ON DUPLICATE KEY UPDATE' WHERE task_id = 4;  UPDATE\nUPDATE employees SET lastname = 'NKS', email = 'mary.new@yiibai.com' WHERE employeeNumber = 1056; 随机选择一个职位是Sales Rep的员工\nSELECT employeeNumber FROM employees WHERE jobtitle = 'Sales Rep' ORDER BY RAND() LIMIT 1; 需要更新customers表中的销售代表员工编号(employeeNumber)列\nUPDATE customers SET salesRepEmployeeNumber = (SELECT employeeNumber FROM employees WHERE jobtitle = 'Sales Rep' LIMIT 1) WHERE salesRepEmployeeNumber IS NULL;  备份数据库\nhttps://www.yiibai.com/mysql/how-to-backup-database-using-mysqldump.html\n DELETE\n删除表 DROP TABLE IF EXISTS tasks;\n删除指定条件\nDELETE FROM employees WHERE officeCode = 4; 删除表中所有行 delete from employees;\n删除指定行数\nDELETE FROM customers ORDER BY customerName LIMIT 10; //10行 删除五个法国客户\nDELETE FROM customers WHERE country = 'France' ORDER BY creditLimit LIMIT 5;  创建函数\nDELIMITER // CREATE PROCEDURE get_employee(IN p_id INT) begin SELECT first_name ,last_name ,dept_name FROM employees INNER JOIN departments using (department_id) WHERE id = p_id; END; // DELIMITER; 运行 CALL get_employee(1);\n Mysql技巧 https://www.yiibai.com/mysql/mysqltips.html\nMySQL存储过程 https://www.yiibai.com/mysql/stored-procedure.html\nRe:\nhttps://www.yiibai.com/mysql\nhttps://stackoverflow.com/questions/3401982/error-with-mysql-procedures-error-1304-error-1305\nhttps://blog.csdn.net/yuxin6866/article/details/52722913\n","href":"https://6923403.github.io/post/mysqluse/","tags":"Mysql ; Linux","title":"Mysql_use"},{"content":"形参（形式参数）\n在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。\n实参（实际参数）\n函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。\n形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。\n Re: http://c.biancheng.net/view/1853.html   左值和右值\nhttp://c.biancheng.net/view/1510.html\n 常量和变量\nhttps://www.runoob.com/cprogramming/c-variables.html\nhttps://www.runoob.com/cprogramming/c-constants.html\nhttp://c.biancheng.net/cpp/html/19.html\n","href":"https://6923403.github.io/post/leftright/","tags":"CPP","title":"Left_Right"},{"content":"https://zhuanlan.zhihu.com/p/33074506\nhttps://www.runoob.com/w3cnote/c-volatile-keyword.html\n","href":"https://6923403.github.io/post/volatile/","tags":"CPP ; Volatile","title":"About function: Volatile"},{"content":"struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。\n 但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：\nstruct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息\n  sin_family指代协议族，在socket编程中只能是AF_INET\n  sin_port存储端口号（使用网络字节顺序）\n  sin_addr存储IP地址，使用in_addr这个数据结构\n   struct in_addr { unsigned long s_addr; }; 这个数据结构是由于历史原因保留下来的，主要用作与以前的格式兼容。\ns_addr按照网络字节顺序存储IP地址\nsin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节\n 设置地址信息的示例：\nstruct sockaddr_in sa; sa.sin_family = AF_INET; sa.sin_port = htons(3490); /* short, NBO*/ sa.sin_addr.s_addr = inet_addr(\u0026quot;132.241.5.10\u0026quot;); bzero(\u0026amp;(sa.sin_zero), 8); 注意：如果sa.sin_addr.s_addr ＝ INADDR_ANY，则不指定IP地址（用于Server程序）\n","href":"https://6923403.github.io/post/socket_struct/","tags":"Sokcet ; Linux ; CPP","title":"Socket struct"},{"content":"socket编程中需要用到的头文件\n  sys/types.h：数据类型定义\n  sys/socket.h：提供socket函数及数据结构\n  netinet/in.h：定义数据结构sockaddr_in\n  arpa/inet.h：提供IP地址转换函数\n  netdb.h：提供设置及获取域名的函数\n  sys/ioctl.h：提供对I/O控制的函数\n  sys/poll.h：提供socket等待测试机制的函数\n   其他在网络程序中常见的头文件\n  unistd.h：提供通用的文件、目录、程序及进程操作的函数\n  errno.h：提供错误号errno的定义，用于错误处理\n  fcntl.h：提供对文件控制的函数\n  time.h：提供有关时间的函数\n  crypt.h：提供使用DES加密算法的加密函数\n  pwd.h：提供对/etc/passwd文件访问的函数\n  shadow.h：提供对/etc/shadow文件访问的函数\n  pthread.h：提供多线程操作的函数\n  signal.h：提供对信号操作的函数\n  sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数\n   建议：在编写网络程序时，可以直接使用下面这段头文件代码\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt;  涉及到用户权限及密码验证问题时加入如下语句：\n#include \u0026lt;shadow.h\u0026gt; #include \u0026lt;crypt.h\u0026gt; #include \u0026lt;pwd.h\u0026gt; 需要注意的是，应该在编译时链接加密算法库，即增加编译选项：-lcrypt\n 涉及到文件及时间操作加入如下语句\n#include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;utime.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/file.h\u0026gt;  涉及到多进程操作时加入如下语句\n#include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;signal.h\u0026gt;  涉及到多线程操作时加入如下语句\n#include \u0026lt;pthread.h\u0026gt; #include \u0026lt;sys/poll.h\u0026gt; 需要注意的是，应该在编译时链接线程库，即增加编译选项：-lthread\n","href":"https://6923403.github.io/post/socket_file/","tags":"Socket ; Linux ; CPP","title":"Socket file"},{"content":"class exception{ public: exception () throw(); //构造函数 exception (const exception\u0026amp;) throw(); //拷贝构造函数 exception\u0026amp; operator= (const exception\u0026amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。\n exception 类的继承层次:  exception 类 直接派生类\n   exceptopn explain     login_error logic error   runtime_error 运行时错误   bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常   bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常   bad_cast 使用 dynamic_cast 转换失败时抛出的异常   ios_base::failure io 过程中出现的异常   bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型     logic_error 的派生类\n   异常名称 说明     length_error 试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作   domain_error 参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数   out_of_range 超出有效范围   invalid_argument 参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常     runtime_error 的派生类\n   异常名称 说明     range_error 计算结果超出了有意义的值域范围   overflow_error 算术计算上溢   underflow_error 算术计算下溢     Re:\nhttp://c.biancheng.net/cpp/biancheng/view/3028.html\n","href":"https://6923403.github.io/post/cpp_exception/","tags":"CPP ; Linux ; exception","title":"Cpp exception class"},{"content":"获取Backtrace #include \u0026lt;execinfo.h\u0026gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file. */ void backtrace_symbols_fd(void *const *array, int size, int fd); int backtrace(void **buffer,int size)\n该函数用与获取当前线程的调用堆栈,获取的信息将会被存放在buffer中,它是一个指针数组。参数 size 用来指定buffer中可以保存多少个void* 元素。函数返回值是实际获取的指针个数,最大不超过size大小在buffer中的指针实际是从堆栈中获取的返回地址,每一个堆栈框架有一个返回地址。\n注意某些编译器的优化选项对获取正确的调用堆栈有干扰,另外内联函数没有堆栈框架;删除框架指针也会使无法正确解析堆栈内容\n char ** backtrace_symbols (void *const *buffer, int size)\nbacktrace_symbols将从backtrace函数获取的信息转化为一个字符串数组. 参数buffer应该是从backtrace函数获取的数组指针,size是该数组中的元素个数(backtrace的返回值)，函数返回值是一个指向字符串数组的指针,它的大小同buffer相同.每个字符串包含了一个相对于buffer中对应元素的可打印信息.它包括函数名，函数的偏移地址,和实际的返回地址\n void backtrace_symbols_fd (void *const *buffer, int size, int fd)\nbacktrace_symbols_fd与backtrace_symbols 函数具有相同的功能,不同的是它不会给调用者返回字符串数组,而是将结果写入文件描述符为fd的文件中,每个函数对应一行.它不需要调用malloc函数,因此适用于有可能调用该函数会失败的情况。\n  使用它们的时候有一下几点需要我们注意的地方：\n   backtrace的实现依赖于栈指针（fp寄存器），在gcc编译过程中任何非零的优化等级（-On参数）或加入了栈指针优化参数-fomit-frame-pointer后多将不能正确得到程序栈信息；\n  backtrace_symbols的实现需要符号名称的支持，在gcc编译过程中需要加入-rdynamic参数；\n  内联函数没有栈帧，它在编译过程中被展开在调用的位置；\n  尾调用优化（Tail-call Optimization）将复用当前函数栈，而不再生成新的函数栈，这将导致栈信息不能正确被获取。\n  Re:\nhttps://blog.csdn.net/jxgz_leo/article/details/53458366\nhttps://www.cnblogs.com/mickole/p/3246702.html\n","href":"https://6923403.github.io/post/backtrace/","tags":"Linux ; CPP ; Backtrace","title":"Linux cpp put Backtrace"},{"content":"#include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string str = \u0026quot;Hello\u0026quot;; std::vector\u0026lt;std::string\u0026gt; v; //调用常规的拷贝构造函数，新建字符数组，拷贝数据 v.push_back(str); std::cout \u0026lt;\u0026lt; \u0026quot;After copy, str is \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; //调用移动构造函数，掏空str，掏空后，最好不要使用str v.push_back(std::move(str)); std::cout \u0026lt;\u0026lt; \u0026quot;After move, str is \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; std::cout \u0026lt;\u0026lt; \u0026quot;The contents of the vector are \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;, \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; } Cout:\nAfter copy, str is \u0026quot;Hello\u0026quot; After move, str is \u0026quot;\u0026quot; The contents of the vector are \u0026quot;Hello\u0026quot;, \u0026quot;Hello\u0026quot;  函数原型 template \u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; t) { return static_cast\u0026lt;typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(t); }  原型定义中的原理实现: 公式一）X\u0026amp; \u0026amp;、X\u0026amp;\u0026amp; \u0026amp;、X\u0026amp; \u0026amp;\u0026amp;都折叠成X\u0026amp;，用于处理左值\nstring s(\u0026quot;hello\u0026quot;); std::move(s) =\u0026gt; std::move(string\u0026amp; \u0026amp;\u0026amp;) =\u0026gt; 折叠后 std::move(string\u0026amp; ) 此时：T的类型为string\u0026amp; typename remove_reference\u0026lt;T\u0026gt;::type为string 整个std::move被实例化如下 string\u0026amp;\u0026amp; move(string\u0026amp; t) //t为左值，移动后不能在使用t { //通过static_cast将string\u0026amp;强制转换为string\u0026amp;\u0026amp; return static_cast\u0026lt;string\u0026amp;\u0026amp;\u0026gt;(t); } 公式二）X\u0026amp;\u0026amp; \u0026amp;\u0026amp;折叠成X\u0026amp;\u0026amp;，用于处理右值\nstd::move(string(\u0026quot;hello\u0026quot;)) =\u0026gt; std::move(string\u0026amp;\u0026amp;) //此时：T的类型为string // remove_reference\u0026lt;T\u0026gt;::type为string //整个std::move被实例如下 string\u0026amp;\u0026amp; move(string\u0026amp;\u0026amp; t) //t为右值 { return static_cast\u0026lt;string\u0026amp;\u0026amp;\u0026gt;(t); //返回一个右值引用 } 右值经过T\u0026amp;\u0026amp;传递类型保持不变还是右值，而左值经过T\u0026amp;\u0026amp;变为普通的左值引用.\n②.对于static_cast\u0026lt;\u0026gt;的使用注意：任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。\ndouble d = 1; void* p = \u0026amp;d; double *dp = static_cast\u0026lt;double*\u0026gt; p; //正确 const char *cp = \u0026quot;hello\u0026quot;; char *q = static_cast\u0026lt;char*\u0026gt;(cp); //错误：static不能去掉const性质 static_cast\u0026lt;string\u0026gt;(cp); //正确 ③对于remove_reference是通过类模板的部分特例化进行实现的\n//原始的，最通用的版本 template \u0026lt;typename T\u0026gt; struct remove_reference{ typedef T type; //定义T的类型别名为type }; //部分版本特例化，将用于左值引用和右值引用 template \u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; //左值引用 { typedef T type; } template \u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; //右值引用 { typedef T type; } //举例如下,下列定义的a、b、c三个变量都是int类型 int i; remove_refrence\u0026lt;decltype(42)\u0026gt;::type a; //使用原版本， remove_refrence\u0026lt;decltype(i)\u0026gt;::type b; //左值引用特例版本 remove_refrence\u0026lt;decltype(std::move(i))\u0026gt;::type b; //右值引用特例版本  总结： std::move实现，首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过T\u0026amp;\u0026amp;传递类型保持不变还是右值，而左值经过T\u0026amp;\u0026amp;变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。\n然后我们通过static_cast\u0026lt;\u0026gt;进行强制类型转换返回T\u0026amp;\u0026amp;右值引用，而static_cast之所以能使用类型转换，是通过remove_refrence::type模板移除T\u0026amp;\u0026amp;，T\u0026amp;的引用，获取具体类型T。\n Re https://blog.csdn.net/p942005405/article/details/84644069\n","href":"https://6923403.github.io/post/move/","tags":"CPP ; Liux ; move","title":"Cpp11 move"},{"content":"create_thread Ex   1.导入#include\u0026mdash;用于创建线程\n  2.导入#include\u0026ndash;用于时间延时 获取时间之类的\n  定义一个线程对象t1，这就自动创建了一个线程，参数就是你要线程去执行的函数，t1是变量名字 随便取\nstd::thread t1(func);\n下面这里返回一个毫秒级别的时间间隔参数值，间隔10毫秒\nstd::chrono::milliseconds(10) this_thread::sleep_for（）就是让此线程休眠，可以传入休眠的时间 this_thread::sleep_for(std::chrono::milliseconds(10));让本线程休眠10毫秒  thread4\n join()就是阻塞线程 阻塞的目的就是让Main主线程等待一下创建的线程，免得我函数还在跑，程序就直接结束了。 detach()将线程与线程对象分离   thread5\nc++11还提供了一个lock_guard类，它利用了RAII机制可以保证安全释放mutex。\n在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。\n在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。\nlock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；\n而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。\n thread6\nc++11还提供了std::unique_lock\n类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 unique_lock比lock_guard使用更加灵活，功能更加强大。 使用unique_lock需要付出更多的时间、性能成本。  thread7\n互斥量很像的条件变量的知识\n条件变量std::condition_variable的使用 std::condition_variable 是为了解决死锁而生的。 当互斥操作不够用而引入的。\n比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。\nstd::condition_variable:\n notify_one()用于唤醒一个线程； notify_all() 则是通知所有线程。  C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。\n thread8\n原子变量的使用\n在新标准C++11，引入了原子操作的概念，原子操作更接近内核，并通过这个新的头文件提供了多种原子操作数据类型.\n例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。\n thread9\nfuture与promise的使用\n在c++11中增加的线程库很方便的让我们去使用线程，但是因为做出了一些改变，我们并不能像往常一样直接使用thread.join()获取线程函数的返回值了，而我们有时候又确实要利用线程函数的返回值。\nthread库提供了future用来访问异步操作的结果，因为一个异步操作的结果往往不能立即获取，只能在未来的某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future .\n future和promise的作用是在不同线程之间传递数据。\n 假设线程1需要线程2的数据，那么组合使用方式如下:\n  线程1初始化一个promise对象和一个future对象，promise传递给线程2，相当于线程2对线程1的一个承诺；future相当于一个接受一个承诺，用来获取未来线程2传递的值\n  线程2获取到promise后，需要对这个promise传递有关的数据，之后线程1的future就可以获取数据了。\n  如果线程1想要获取数据，而线程2未给出数据，则线程1阻塞，直到线程2的数据到达\n   thread10\nfuture与package_task的使用\nstd::packaged_task包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果。\nstd::packaged_task将其包装的可调用对象的执行结果传递给一个std::future对象，与std::promise某种程度上是很像的，promise保存一个共享状态的值，而package_task保存的是一个函数。\n thread11\n线程异步操作函数async的用法\nstd::async比std::packaged_task，std::promise中，std::thread更高一层，它可以直接用来创建异步的task，异步的结果也保存在future中。完成后，外面再通过future.get/wait来获取这个未来的结果，强烈推荐使用async，我们不需要关注异步任务的结果，只要等待任务完成获取值就行了。\n现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args...)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：\n std::launch::async 在调用async就开始创建线程。 std::launch::deferred 延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。  第二个参数是线程函数，第三个参数是线程函数的参数。\n thread12\nstd::future::wait_for()函数作用\ntemplate\u0026lt; class Rep, class Period \u0026gt; std::future_status wait_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration ) const; 等待结果变得可用。阻塞直至经过指定的 timeout_duration ，或结果变为可用，两者的先到来者。返回值鉴别结果的状态。\n此函数可能由于调度或资源争议延迟而阻塞长于 timeout_duration 。\n推荐标准库用稳定时钟度量时长。若实现用系统时钟代替，则等待时间可能也对时钟调整敏感。\n若调用此函数前 valid()== false 则行为未定义。\n   参数 解释     future_status::deferred 要计算结果的函数仍未启动   future_status::ready 结果就绪   future_status::timeout 已经过时限    异常\n 时钟、时间点或时长在执行中可能抛的任何异常（标准库提供的时钟、时间点和时长决不抛出）。  注意\n 鼓励实现在调用前检测 valid == false 的情况并抛出以 future_errc::no_state 为 error_condition 的 future_error .   Re:\nhttps://www.cnblogs.com/DOMLX/p/10945309.html\n","href":"https://6923403.github.io/post/cppthread/","tags":"CPP ; thread","title":"CPP11_thread"},{"content":"简介 #include \u0026lt;sys/epoll.h\u0026gt;\nepoll与select\nEpoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。\n 触发模式 epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。\n 水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件  //LevelTriggered(LT) //缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。\n 边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。  //Edge Triggered(ET) //高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)\n假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除， 则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。 总结: LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。 ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据, 也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样; 而LT模式是只要有数据没有处理就会一直通知下去的.  1. 创建一个epoll的句柄 int epoll_create(int size); 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。\n这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。\n2. 将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //op为注册事件 epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。\n用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。\n EPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd；  3. 等待事件触发，当超过timeout还没有事件触发时，就超时 int epoll_wait(int epfd, struct epoll_event * events, intmaxevents, int timeout);\n等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中, 并且将注册在epfd上的socket fd的事件类型给清空\n参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。\n如果下一个循环你还要关注这个socket fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,\u0026amp;ev)来重新设置socket fd的事件类型。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。\n typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合:\n  EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；\n  EPOLLOUT：表示对应的文件描述符可以写；\n  EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\n  EPOLLERR：表示对应的文件描述符发生错误；\n  EPOLLHUP：表示对应的文件描述符被挂断；\n  EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。\n  EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n   epoll IO多路复用模型实现机制 设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？ 在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。 epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统，把原先的select/poll调用分成了3个部分：\n  调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)\n  调用epoll_ctl向epoll对象中添加这100万个连接的套接字\n  调用epoll_wait收集发生的事件的连接\n  只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。\n Linux内核具体的epoll机制实现思路 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关\n/* * This structure is stored inside the \u0026quot;private_data\u0026quot; member of the file * structure and rapresent the main data sructure for the eventpoll * interface. */ struct eventpoll { /* Protect the this structure access */ spinlock_t lock; /* * This mutex is used to ensure that files are not removed * while epoll is using them. This is held during the event * collection loop, the file cleanup path, the epoll file exit * code and the ctl operations. */ struct mutex mtx; /* Wait queue used by sys_epoll_wait() */ wait_queue_head_t wq; /* Wait queue used by file-\u0026gt;poll() */ wait_queue_head_t poll_wait; /* List of ready file descriptors */ /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ struct list_head rdllist; /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/ /* RB tree root used to store monitored fd structs */ struct rb_root rbr; /* * This is a single linked list that chains all the \u0026quot;struct epitem\u0026quot; that * happened while transfering ready events to userspace w/out * holding -\u0026gt;lock. */ struct epitem *ovflist; /* The user that created the eventpoll descriptor */ struct user_struct *user; }; 每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。\n而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。\n在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示:\n/* * Each file descriptor added to the eventpoll interface will * have an entry of this type linked to the \u0026quot;rbr\u0026quot; RB tree. */ struct epitem { /* RB tree node used to link this structure to the eventpoll RB tree */ //红黑树节点 struct rb_node rbn; /* List header used to link this structure to the eventpoll ready list */ //双向链表节点 struct list_head rdllink; /* * Works together \u0026quot;struct eventpoll\u0026quot;-\u0026gt;ovflist in keeping the * single linked chain of items. */ struct epitem *next; /* The file descriptor information this item refers to */ //事件句柄信息 struct epoll_filefd ffd; /* Number of active wait queue attached to poll operations */ int nwait; /* List containing poll wait queues */ struct list_head pwqlist; /* The \u0026quot;container\u0026quot; of this item */ //指向其所属的eventpoll对象 struct ![Uploading EPOLL_663944.jpg . . .] eventpoll *ep; /* List header used to link this item to the \u0026quot;struct file\u0026quot; items list */ struct list_head fllink; /* The structure that describe the interested events and the source fd */ //期待发生的事件类型 struct epoll_event event; }; 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。\n通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。\n 代码示例 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; const int MAX_EVENT_NUMBER = 1024; const int BUFFER_SIZE = 10; int setnonblocking(int fd); void addfd(int epollfd, int fd, bool enable_et); void lt(epoll_event *events, int number, int epollfd, int listenfd); void et(epoll_event *events, int number, int epollfd, int listenfd); int main(int argc, char **argv) { int port = 20999; struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); int listenfd = socket(AF_INET, SOCK_STREAM, 0); assert(listenfd != -1); int reuse = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;reuse, sizeof(reuse)); int ret = bind(listenfd, (struct sockaddr*) \u0026amp;addr, sizeof(addr)); assert(ret != -1); ret = listen(listenfd, 10); assert(ret != -1); epoll_event events[MAX_EVENT_NUMBER]; int epollfd = epoll_create(5); assert(epollfd \u0026gt; 0); addfd(epollfd, listenfd, true); while (true) { int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1); if (ret \u0026lt; 0) { std::cout \u0026lt;\u0026lt; \u0026quot;epoll failed \u0026quot; \u0026lt;\u0026lt; std::endl; break; } //lt(events, ret, epollfd, sockfd);\t//LT模式 et(events, ret, epollfd, listenfd);\t//ET模式 } return 0; } //设置非阻塞文件描述符 int setnonblocking(int fd) { int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option; } //将描述符fd的EPOLLIN注册到epollfd提示的epoll内核事件中，参数enable_et指定是否启用ET模式 void addfd(int epollfd, int fd, bool enable_et) { epoll_event event; event.data.fd = fd; event.events = EPOLLIN; if (enable_et) { event.events |= EPOLLET; } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026amp;event); setnonblocking(fd); } //LT模式 void lt(epoll_event *events, int number, int epollfd, int listenfd) { char buf[BUFFER_SIZE]; for (int i = 0; i \u0026lt; number; i++) { int sockfd = events[i].data.fd; if (sockfd == listenfd) { struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr*)\u0026amp;client_address, \u0026amp;client_addrlength); addfd(epollfd, connfd, false); } else if (events[i].events \u0026amp; EPOLLIN) {\t//只要socket读缓存中还有未读出的数据，就会被触发 std::cout \u0026lt;\u0026lt; \u0026quot;event trigger once\u0026quot; \u0026lt;\u0026lt; std::endl; memset(buf, '\\0', BUFFER_SIZE); int ret = recv(sockfd, buf, BUFFER_SIZE-1, 0); if (ret \u0026lt;= 0) { close(sockfd); continue; } std::cout \u0026lt;\u0026lt; \u0026quot;get: \u0026quot; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; \u0026quot; bytes of content: \u0026quot; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026quot;something else happened\u0026quot; \u0026lt;\u0026lt; std::endl; } } } //ET模式 void et(epoll_event *events, int number, int epollfd, int listenfd) { char buf[BUFFER_SIZE]; for (int i = 0; i \u0026lt; number; i++) { int sockfd = events[i].data.fd; if (sockfd == listenfd) { struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr*)\u0026amp;client_address, \u0026amp;client_addrlength); addfd(epollfd, connfd, true); } else if (events[i].events \u0026amp; EPOLLIN) { std::cout \u0026lt;\u0026lt; \u0026quot;event trigger once\u0026quot; \u0026lt;\u0026lt; std::endl; int ret = 0; //因为ET模式不会重复触发，所以我们要循环读取所有数据 while (true) { memset(buf, '\\0', BUFFER_SIZE); ret = recv(sockfd, buf, BUFFER_SIZE-1, 0); if (ret \u0026lt; 0) { //对于非阻塞I/O，下面的条件成立时表示数据已全部读取完毕 if (errno == EAGAIN || errno == EWOULDBLOCK) { std::cout \u0026lt;\u0026lt; \u0026quot;read later!\u0026quot; \u0026lt;\u0026lt; std::endl; break; } close(sockfd); break; } else if (ret == 0) { close(sockfd); } else { std::cout \u0026lt;\u0026lt; \u0026quot;get \u0026quot; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; \u0026quot; bytes of content: \u0026quot; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; std::endl; } } } else { std::cout \u0026lt;\u0026lt; \u0026quot;something else happened\u0026quot; \u0026lt;\u0026lt; std::endl; } } }  Re:\nhttps://www.jianshu.com/p/718c24af400f\nhttps://www.bbsmax.com/A/l1dymR3Gde/\nhttps://www.jianshu.com/p/397449cadc9a\nhttps://zhuanlan.zhihu.com/p/165162146\n","href":"https://6923403.github.io/post/epoll_use/","tags":"Linux ; Socket ; Epoll ; Server","title":"epoll use"},{"content":"{:toc}\nsetsockopt\n获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 SO_LINGER选项\nstruct linger { int l_onoff; int l_linger; };  l_onoff = 0, 数据保持发送完成后立即返回 l_onoff = 1, l_linger = 0, 立即放回 放弃发送, 发送rst 自身立即复位 l_onoff = 1, l_linger = 1, 阻塞到超时或数据发送完成, 保持尝试发送,超时后立即结束  SO_REUSEADDR选项\n改变了通配绑定时处理源地址冲突的处理方式, 让端口释放后立即就可以被再次使用\n 允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。一般不用于tco服务器 允许完全重复的捆绑  Re:\nhttps://www.cnblogs.com/my_life/articles/5174585.html\nhttps://www.jianshu.com/p/141aa1c41f15\nhttps://blog.csdn.net/u010144805/article/details/78579528\n int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：\n 1.复制一个现有的描述符（cmd=F_DUPFD）. 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD). 3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL). 4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN). 5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).  Re: https://www.cnblogs.com/xuyh/p/3273082.html\n 非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。\n对于一个给定的描述符两种方法对其指定非阻塞I/O:\n 1.调用open获得描述符，并指定O_NONBLOCK标志 2.对已经打开的文件描述符，调用fcntl，打开O_NONBLOCK文件状态标志。  flags = fcntl( s, F_GETFL, 0 ) ) fcntl( s, F_SETFL, flags | O_NONBLOCK ) Re: https://blog.csdn.net/zhulinfeiba/article/details/5011573\n  htonl()\u0026ndash;\u0026ldquo;Host to Network Long int\u0026rdquo; 32Bytes  将主机的无符号长整形数转换成网络字节顺序。//将无符号长整型网络字节序转换为主机字节序\n ntohl()\u0026ndash;\u0026ldquo;Network to Host Long int\u0026rdquo; 32Bytes  将一个无符号长整形数从网络字节顺序转换为主机字节顺序。\n htons()\u0026ndash;\u0026ldquo;Host to Network Short int\u0026rdquo; 16Bytes  将主机的无符号短整形数转换成网络字节顺序。//将无符号短整型主机字节序转换为网络字节序\n ntohs()\u0026ndash;\u0026ldquo;Network to Host Short int\u0026rdquo; 16Bytes  将一个无符号短整形数从网络字节顺序转换为主机字节顺序。\n inet_addr()  将一个点间隔地址转换成一个in_addr\n inet_ntoa()  是编程语言，功能是将网络地址转换成“.”点隔的字符串格式。\n inet_aton()  与inet_ntoa()作用相反。本函数将点分十进制转换为整数\n atoi()  array to integer将字符串转换为整形数\n 新型网路地址转化函数inet_pton和inet_ntop 这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。\n#include \u0026lt;arpe/inet.h\u0026gt; int inet_pton(int family, const char *strptr, void *addrptr); //将点分十进制的ip地址转化为用于网络传输的数值格式 返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1 const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len); //将数值格式转化为点分十进制的ip地址格式 返回值：若成功则为指向结构的指针，若出错则为NULL   1.这两个函数的family参数既可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.\n  2.第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.\n  3.inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达式（strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。\n  inet_pton(AF_INET, ip, \u0026amp;foo.sin_addr); // 代替 foo.sin_addr.addr=inet_addr(ip); char str[INET_ADDRSTRLEN]; char *ptr = inet_ntop(AF_INET,\u0026amp;foo.sin_addr, str, sizeof(str)); // 代替 ptr = inet_ntoa(foo.sin_addr) 示例代码\nint main() { char IPdotdec[20]; // 存放点分十进制IP地址 struct in_addr s; // IPv4地址结构体 // 输入IP地址 printf(\u0026quot;Please input IP address: \u0026quot;); scanf(\u0026quot;%s\u0026quot;, \u0026amp;IPdotdec); // 转换 inet_pton(AF_INET, IPdotdec, (void *)\u0026amp;s); printf(\u0026quot;inet_pton: 0x%x\\n\u0026quot;, s.s_addr); // 注意得到的字节序 // 反转换 inet_ntop(AF_INET, (void *)\u0026amp;s, IPdotdec, 16); printf(\u0026quot;inet_ntop: %s\\n\u0026quot;, IPdotdec); } Run: Please input IP address: 127.0.0.1 inet_pton: 0x100007f inet_ntop: 127.0.0.1 Re: https://blog.csdn.net/zyy617532750/article/details/58595700\nhttps://www.cnblogs.com/wuyuxuan/p/10772779.html\n int send( SOCKET s,char *buf,int len,int flags )\n功能：不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。\n  参数一：指定发送端套接字描述符；\n  参数二：存放应用程序要发送数据的缓冲区；\n  参数三：实际要发送的数据的字节数；\n  参数四：一般置为0。\n  int recv( SOCKET s, char *buf, int len, int flags)\n功能：不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。\n  参数一：指定接收端套接字描述符；\n  参数二：指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；\n  参数三：指明buf的长度；\n  参数四 ：一般置为0。\n  Re: https://blog.csdn.net/lanzhihui_10086/article/details/40681617\n read(sock, buf, sizeof(buf) -1)\nread从套接字文件中读取数据, fd为要读取的文件的描述符，buf为要接收数据的缓冲区地址，nbytes为要读取的数据的字节数。\n  /* * 本函数向服务ip发起请求 服务器ip port 保存在sockaddr_in中 * int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); //Linux * int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows * sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。 */ connect(sock, (struct sockaddr*) \u0026amp;serv_addr, sizeof(serv_addr));  linux mutex block\npthread_mutexattr_t mattr\nint pthread_mutexattr_init(pthread_mutexattr_t *mattr)\npthread_mutex_init() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。\n Success: return 0  POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁\npthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; 动态方式是采用pthread_mutex_init()函数来初始化互斥锁\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr) 其中mutexattr用于指定互斥锁属性（见下），如果为NULL则使用缺省属性, pthread_mutex_destroy()用于注销一个互斥锁\nint pthread_mutex_destroy(pthread_mutex_t *mutex) 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。\n2.属性 3. 锁操作\nRe: https://www.cnblogs.com/lidabo/p/4566693.html\n 互斥锁的类型：有以下几个取值空间:\n  PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。\n  PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。\n  PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。\n  PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。 *pthread_mutexattr_settype(pthread_mutexattr_t attr , int type) **pthread_mutexattr_gettype(pthread_mutexattr_t attr , int type)\n  Re: https://blog.csdn.net/happylzs2008/article/details/89067028\n 销毁互斥锁属性对象\n pthread_mutexattr_destroy(3C) 可用来取消分配用于维护 pthread_mutexattr_init() 所创建的属性对象的存储空间。  对于互斥锁属性对象，必须首先通过调用pthread_mutexattr_destroy(3C)将其销毁，才能重新初始化该对象。pthread_mutexattr_init() 调用会导致分配类型为 opaque 的对象。如果未销毁该对象，则会导致内存泄漏\nRe: https://blog.csdn.net/jasmineal/article/details/8807744\n 对锁的操作主要包括加锁 pthread_mutex_lock()、解锁pthread_mutex_unlock()和测试加锁 pthread_mutex_trylock()三个。\n int pthread_mutex_lock(pthread_mutex_t *mutex) int pthread_mutex_unlock(pthread_mutex_t *mutex) int pthread_mutex_trylock(pthread_mutex_t *mutex)  pthread_mutex_trylock()语义与pthread_mutex_lock()类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待\npthread_mutex_lock 用于解决由于竞争产生的优先级反转问题。没锁更新所有权,锁住\nRe: https://blog.csdn.net/jasmineal/article/details/8807744\nhttps://blog.csdn.net/oqqYuJi12345678/article/details/100585669\n backtrace backtrace_symbols backtrace_symbols_fd To: https://6923403.github.io/post/backtrace/\n pthread_cond_broadcast(\u0026amp;cond1)的作用是唤醒所有正在pthread_cond_wait(\u0026amp;cond1,\u0026amp;mutex1)的线程。\nwhile(lock_status_[lid] == LOCKED) { pthread_cond_wait(\u0026amp;c_, \u0026amp;m_); } pthread_cond_broadcast(\u0026amp;c_); 一旦某个锁被释放，所有的阻塞线程都会被唤醒，但唯有阻塞在这个锁的线程才能真正被唤醒。\npthread_cond_signal(\u0026amp;cond1)的的作用是唤醒所有正在 pthread_cond_wait(\u0026amp;cond1,\u0026amp;mutex1)的至少一个线程。（虽然我还没碰到过多于一个线程的情况，但是man帮组手册上说的是至少一个）\nRe:\nhttps://www.cnblogs.com/XiaoXiaoShuai-/p/11855408.html\nhttps://www.cnblogs.com/zhouzhuo/p/3781511.html\n struct hostent{ char *h_name; //official name char **h_aliases; //alias list int h_addrtype; //host address type int h_length; //address lenght char **h_addr_list; //address list }  h_name：官方域名（Official domain name）。官方域名代表某一主页，但实际上一些著名公司的域名并未用官方域名注册。 h_aliases：别名，可以通过多个域名访问同一主机。同一 IP 地址可以绑定多个域名，因此除了当前域名还可以指定其他域名。 h_addrtype：gethostbyname() 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取IP地址的地址族（地址类型）信息，IPv4 对应 AF_INET，IPv6 对应 AF_INET6。 h_length：保存IP地址长度。IPv4 的长度为 4 个字节，IPv6 的长度为 16 个字节。 h_addr_list：这是最重要的成员。通过该成员以整数形式保存域名对应的 IP 地址。对于用户较多的服务器，可能会分配多个 IP 地址给同一域名，利用多个服务器进行均衡负载。  gethostbyname\nstruct hostent *gethostbyname(const char *hostname);\ngethostbyaddr 根据ip地址获取主机的完整信息\nstruct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);\nRe:\nhttp://c.biancheng.net/view/2357.html\n getservbyname 根据名称获取某个服务的完整信息\nstruct servent *getservbyname(const char *name, const char *proto)\ngetservbyport 根据端口号获取某个服务的完整信息\nstruct servent *getservbyport(int port, const char *proto)\ngetaddrinfo 通过主机名获得IP地址也能通过服务名获得端口号\nint getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);\n之后用freeaddrinfo 释放getaddrinfo所分配的内存\nvoid freeaddrinfo(struct addrinfo *res);\ngetnameinfo 通过socket地址同时获得字符串表示的主机名和服务名\nint getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);\n readv 将数据从文件描述符读到分散的内存块中\nssize_t readv(int fd, const struct iovec *iov, int iovcnt);\nwritev 将多块分散的数据一并写入文件描述符中\nssize_t writev(int fd, const struct iovec *iov, int iovcnt);\nsendfile 在两个文件描述符之间传递数据 避免内核缓冲区和用户之间的数据拷贝-零拷贝\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n mmap 申请一段内存空间 将这段内存作为进程间通信的共享内存,可以将文件直接映射到其中\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); munmap 释放mmap创建的内存空间\nint munmap(void *addr, size_t length);\nsplice 用于在两个文件描述符之间移动数据-零拷贝\nssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);\n syslog和rsyslogd 守护进程通信\nvoid syslog(int priority, const char *format, ...); openlog改变syslog默认输出方式 进一步结构化日志内容\nvoid openlog(const char *ident, int option, int facility); setlogmask 设置日志掩码\nint setlogmask(int mask);\ncloselog关闭日志功能\nvoid closelog();\n get_uid获取和设置当前进程真实用户\nuid_t getuid(void); //真实用户ID uid_t geteuid(void); //有效用户ID gid_t getgid(void); //真实组ID gid_t getegid(void); //有效组ID int setuid(uid_t uid); //设置真实用户ID int seteuid(uid_t euid); //设置有效用户ID int setgid(gid_t gid); //设置真实组ID int setegid(gid_t egid); //设置有效组ID getpgid 获取进程组ID\npid_t getpgid(pid_t pid);\nsetpgid 设置用户组ID int setpgid(pid_t pid, pid_t pgid);\nsetsid 创建一个会话\npid_t setsid(void);\ngetsid 读取sid\npid_t getsid(pid_t pid);\nrlimit 系统资源读取\\设置\nint getrlimit(int resource, struct rlimit *rlim);\nint setrlimit(int resource, const struct rlimit *rlim);\nstruct rlimit { rlim_t rlim_cur; rlim_t rlim_max; } cwd 获取进程当前工作目录和改变进程工作目录\nchar *getcwd(char *buf, size_t size);\nint chdir(const char *path);\nchroot 改变进程根目录\nint chroot(const char * path);\ndaemon 守护进程\nint daemon(int nochdir, int noclose);\n 基本框架\nreactor 要求主线程只负责监听文件描述上是否有事情发生 有的话立即将该事件通知工作线程\nproactor 将所有I/0操作都交给主线程和内核来处理 工作线程仅仅负责业务逻辑\n同步模拟的Procator\n并发模式\n半同步/半异步模式\n存在的缺点\n高效模式\n 领导者/追随者模式 是多个工作线程轮流获得事件源集合, 轮流监听、分发并处理事件的一种模式\n1. 句柄集 句柄表示I/O资源 在linux下通常是一个文件描述符 句柄集管理众多句柄\n2. 线程集 负责各线程之间的同步 以及新领导者线程的推选. 线程集里的线程在任何时间都必须处于一下三种状态之一\n领导者/追随者 工作流程图\n select 在一段指定时间内 监听用户感兴趣的文件描述符上的可读、可写、异常等事件, readfds\\writefds\\exceptfds分别指向可读、可写、异常\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\npoll 指定时间内轮询一定数量的文件描述符 测试其中是否有就绪者\nint poll(struct pollfd *fds, nfds_t nfds, int timeout); epoll 把用户关心的文件描述符上的事件放在内核里的一个事件表中, 从而无需每次调用都要重复传入文件描述符集或事件集, 但epoll需要额外的文件描述符, 来唯一标识内核中的事件表\nepoll_create 创建文件描述符\nint epoll_create(int size);\n操作epoll的内核事件表\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\nepoll_wait 在一段超时时间内等待一组文件描述符上的事件\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\nLT 水平触发是默认工作模式、ET边缘触发\nselect\\poll\\epoll 区别比较\n kill 一个进程给其他进程发送信号\nint kill(pid_t pid, int sig);\nkill出错的情况\n信号处理函数SIG_DFL使用信号的默认处理方式、SIG_IGN表示忽略目标信号\n//原型: typedef void (* __sighandler_t) (int); #define SIG_DFL((__sighandler_t) 0) #define SIG_IGN((__sighandler_t) 1) signal信号设置处理函数\nsighandler_t signal(int signum, sighandler_t handler);\nsignal更健壮的接口\nint sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);\n信号集\nint sigemptyset(sigset_t * _set) //清空信号集 int sigfillset(sigset_t * _set) //在信号集中设置所有信号 int sigaddset(sigset_t * _set, int _signo) //将信号 _signo添加至信号集中 int sigdelset(sigset_t * _set, int _signo) //将信号 _signo从信号集中删除 int sigismember(const sigset_t * _set, int _signo) //测试 _signo是否在信号集中 设置或查看进程信号掩码\nint sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\nsigpending 获得进程当前被挂起的信号集 成功返回0 失败-1\nint sigpending(sigset_t *set);\n SO_RCVTIMEO接收数据超时时间 SO_SNDTIMEO发送数据超时时间\n高性能定时器 时间轮\n fork 复制当前进程, 在内核进程表中创建一个新的进程表项\npid_t fork(void);\nexec 在子进程中执行其他程序, 即替换当前进程映像\nint execl(const char* path, const char * arg, ...); int execlp(const char* file, const char* arg, ...); int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */); int execv(const char *pathname, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[], char *const envp[]); wait 在父进程中调用, 等待子进程的结束, 并获取子进程的返回信息,避免了僵尸进程的产生或使子进程的僵尸态立即结束, wait函数将阻塞进程,直到进程的某个子进程结束运行为止\npid_t wait(int *wstatus); pid_t waitpid(pid_t pid, int *wstatus, int options); semget 系统调用创建一个新的信号量集, 或者获取一个已经存在的信号量集\nint semget(key_t key, int nsems, int semflg);\nsemop 对信号量的操作是对这些内核变量的操作\nint semop(int semid, struct sembuf *sops, size_t nsops);\nsemctl 系统调用允许调用者对信号量进行直接控制\nint semctl(int semid, int semnum, int cmd, ...);\nshmget 系统调用创建一段新的共享内存,或者获取一段已存在的共享内存\nint shmget(key_t key, size_t size, int shmflg);\nshmat shmdt 共享内存被创建\\获取后,不能立即访问,而是需要先将它关联到进程的地址空间中,使用完共享内存之后,也需要将它从进程地址空间中分离\nvoid *shmat(int shmid, const void *shmaddr, int shmflg); int shmdt(const void *shmaddr); shmctl系统调用控制内存的某些属性\nint shmctl(int shmid, int cmd, struct shmid_ds *buf);\nshm_open 创建或打开POSIX共享内存对象. Linux提供了一种利用mmap在无关进程之间共享内存的方式,这种方式无须任何文件支持,但它需要先使用shm_open 创建\\打开一个POSIX共享内存对象\n//编译时需要指定链接: -lrt int shm_open(const char *name, int oflag, mode_t mode); shm_unlink 删除创建的共享内存对象\nint shm_unlink(const char *name);\n socketpair()函数用于创建一对无名的、相互连接的套接子。\nhttps://blog.csdn.net/weixin_40039738/article/details/81095013\nint socketpair(int d, int type, int protocol, int sv[2])； 如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中。\n基本用法：\n   这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读；     如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功；     读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程。如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写。因为文件描述副sv[0]和sv[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。     sendmsg、recvmsg、send函数的使用**\n#sendmsg()用来将数据由指定的socket传给对方主机. 失败返回-1 int sendmsg(int s, const strcut msghdr *msg, unsigned int flags); #函数说明：recvmsg()用来接收远程主机经指定的socket 传来的数据. 失败返回-1 int recvmsg(int s, struct msghdr *msg, unsigned int flags); #send()用来将数据由指定的socket 传给对方主机. 失败返回-1 int send(int s, const void * msg, int len, unsigned int falgs); 函数send参数flags 一般设0, 其他数值定义如下：\n MSG_OOB 传送的数据以out-of-band 送出. MSG_DONTROUTE 取消路由表查询 MSG_DONTWAIT 设置为不可阻断运作 MSG_NOSIGNAL 此动作不愿被SIGPIPE 信号中断.  ","href":"https://6923403.github.io/post/socket/","tags":"Linux ; CPP ; Socket","title":"Socket function"},{"content":"2021-5-30 更新 老方法不行了\nInstall docker apt-get install apt-transport-https ca-certificates software-properties-common curl curl -fsSL https://download.docker.com/linux/ubuntu/gpg|sudo apt-key add - sudo add-apt-repository \u0026quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable\u0026quot; apt-get update apt-get install docker-ce docker run hello-world # 重启 service docker restart  Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version  Dockerfile # from based nginx # run start FROM nginx # exec: RUN[\u0026quot;./go\u0026quot;, \u0026quot;dev\u0026quot;, \u0026quot;offline\u0026quot;] RUN echo 'Nginx image' \u0026gt; /usr/share/nginx/html/index.html # '.' is up and down content path docker build -t nginx:tesst .  Command Copy\n# 'check' file head COPY check* /testdir/ # 'check?.log' check1.log COPY check?.log /testdir/ # nickdir all files, not dir COPY nickdir . # nickdir all files, have dir COPY nickdir ./nickdir ADD\nADD url CMD \u0026amp;\u0026amp; ENTRYPOINT\nENTRYPOINT [\u0026quot;nginx\u0026quot;, \u0026quot;-c\u0026quot;] # const CMD [\u0026quot;/etc/nginx/nginx.conf\u0026quot;] # variable # run nginx -c /etc/nginx/nginx.conf ENV\nENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;... ENV NODE_VERSION 7.2.0 RUN curl -SLO \u0026quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\u0026quot; \\ \u0026amp;\u0026amp; curl -SLO \u0026quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\u0026quot; ARG\nARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] ARG CONT_IMG_VER volume expose workdir use healthcheck onbuild\n","href":"https://6923403.github.io/post/docker_tutorial/","tags":"Linux ; Docker","title":"Docker use Tutorial"},{"content":"V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $\u0026lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹\n","href":"https://6923403.github.io/post/makefile_template/","tags":"CPP ; Linux ; Makefile","title":"Makefile template"},{"content":"  性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。\n  性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。\n  性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数 为n 2 ,则n 0 =n 2 +1。\n  性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x 的最大整数)。\n  性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序 编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:\n   1.如果i=1,则结点i是二叉树的根,无双亲;如果i\u0026gt;1,则其双亲是结 点。\n  2.如果2i\u0026gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是 结点2i。\n  3.如果2i+1\u0026gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。\n  树转换为二叉树 将树转换为二叉树的步骤如下\n  1.加线。在所有兄弟结点之间加一条连 线。\n  2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删 除它与其他孩子结点之间的连线。\n  3.层次调整。以树的根结点为轴心, 将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子 是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子\n   森林转换为二叉树 森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .\n 1.把每个树转换为二叉树。 2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵 二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。 当所有的二叉树连接起来后就得到了由森林转换来的二叉树。   二叉树转换为树 二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。\n 1.加线。若某结点的左孩子结点存在,则将 这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右 孩子结点\u0026hellip;\u0026hellip;哈,反正就是左孩子的n个右孩子结点都作为此结点的孩 子。将该结点与这些右孩子结点用线连接起来。 2.去线。删除原二叉树中所有结点与其右孩子结点的连线。 3.层次调整。使之结构层次分明。   二叉树转换为森林 判断一棵二叉树能够转换成一棵树还是森林,标准很简单,那就是只要 看这棵二叉树的根结点有没有右孩子,有就是森林,没有就是一棵树。\n 1.从根结点开始,若右孩子存在,则把与右孩子结点的连线删除,再查看分离后的二叉树,若右孩子存在,则连线删除\u0026hellip;\u0026hellip;,直到所有右孩子连线都删除为止,得到分离的二 叉树。 2.再将每棵分离后的二叉树转换为树即可。   树与森林的遍历 树的遍历分为两种方式。\n 1.一种是先根遍历树,即先访问树的根结点, 然后依次先根遍历根的每棵子树。 2.另一种是后根遍历,即先依次后根 遍历每棵子树,然后再访问根结点。比如图tree6/7中右下方的树,它的 先根遍历序列为ABEFCDG,后根遍历序列为EFBCGDA。  森林的遍历也分为两种方式:\n 1.前序遍历:先访问森林中第一棵树的根 结点,然后再依次先根遍历根的每棵子树,再依次用同样方式遍历除去 第一棵树的剩余树构成的森林。比如图6-11-5下面三棵树的森林,前序 遍历序列的结果就是ABCDEFGHJI。 2.后序遍历:是先访问森林中第一 棵树,后根遍历的方式遍历每棵子树,然后再访问根结点,再依次同样 方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5下面三棵树 的森林,后序遍历序列的结果就是BCDAFEJHIG。  ","href":"https://6923403.github.io/post/binary_tree/","tags":"CPP ; Algorithm ; DataStruct ; BinaryTree","title":"Binary Tree"},{"content":" Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。   1.shared_ptr shared_ptr\u0026lt;T\u0026gt; sp\n多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。\n 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁   3. make_shared make_shared\u0026lt;T\u0026gt;(args)\nshared_ptr\u0026lt;int\u0026gt; p = make_shared\u0026lt;int\u0026gt;(42); 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象\n 3.weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。\n 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题   4.unique_ptr unique_ptr\u0026lt;T\u0026gt; up\nunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。\n unique_ptr 用于取代 auto_ptr   5.auto_ptr 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。\nReference(1-5): github/Interview\n 6.Other p.get() 返回p中保存的指针。 若智能指针释放了其对象，返回的指针所指向的对象也就消失了。\np.use_count() 返回与p共享对象的智能指针数量 用于调试\np.unqiue() 若p.use_count = 1, return true; 反之 return false\n","href":"https://6923403.github.io/post/cpp_auto_ponit/","tags":"CPP ; point","title":"C++ auto ponit"},{"content":"0.Array int url[10]; //true int url[6 + 4] //true int len = 10; int url[len] //flase  1.Constexpr #include \u0026lt;iostream\u0026gt; using namespace std; int main() { /* * If have not constexpr, CPP throw error */ constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts\u0026lt;\u0026lt; url[1] \u0026lt;\u0026lt; endl; return 0; }  2.Only have one \u0026lsquo;return\u0026rsquo; # Error constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } # True constexpr int display(int x) { return 1 + 2 + x; }  3.Must have \u0026lsquo;return\u0026rsquo; # Error constexpr void display() { ... } # True constexpr int display() { ... }  4.Must have funciion declaration #include \u0026lt;iostream\u0026gt; using namespace std; int noconst_dis(int x); // constexpr constexpr int display(int x); constexpr int display(int x){ return 1 + 2 + x; } int main() { int a[display(3)] = { 1,2,3,4 }; cout \u0026lt;\u0026lt; a[2] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; noconst_dis(3) \u0026lt;\u0026lt; endl; return 0; } int noconst_dis(int x) { return 1 + 2 + x; }  5.\u0026lsquo;Return\u0026rsquo; must constant expession #include \u0026lt;iostream\u0026gt; using namespace std; int num = 3; constexpr int display(int x){ return num + x; } int main() { //display(3) not is constant int a[display(3)] = { 1,2,3,4 }; return 0; }  6.Constexpr struct # Error #include \u0026lt;iostream\u0026gt; using namespace std; constexpr struct myType { const char* name; int age; }; int main() { constexpr struct myType mt { \u0026quot;zhangsan\u0026quot;, 10 }; cout \u0026lt;\u0026lt; mt.name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; mt.age \u0026lt;\u0026lt; endl; return 0; } # True #include \u0026lt;iostream\u0026gt; using namespace std; struct myType { constexpr myType(char *name,int age):name(name),age(age){}; const char* name; int age; }; int main() { constexpr struct myType mt { \u0026quot;zhangsan\u0026quot;, 10 }; cout \u0026lt;\u0026lt; mt.name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; mt.age \u0026lt;\u0026lt; endl; return 0; }  7. CLass #include \u0026lt;iostream\u0026gt; using namespace std; //自定义类型的定义 class myType { public: constexpr myType(const char *name,int age):name(name),age(age){}; constexpr const char * getname(){ return name; } /* * unsupport virtual function */ constexpr int getage(){ return age; } private: const char* name; int age; //其它结构体成员 }; int main() { constexpr struct myType mt { \u0026quot;zhangsan\u0026quot;, 10 }; constexpr const char * name = mt.getname(); constexpr int age = mt.getage(); cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; return 0; }  8.Template #include \u0026lt;iostream\u0026gt; using namespace std; struct myType { const char* name; int age; }; template\u0026lt;typename T\u0026gt; constexpr T dispaly(T t){ return t; } int main() { struct myType stu{\u0026quot;zhangsan\u0026quot;,10}; struct myType ret = dispaly(stu); cout \u0026lt;\u0026lt; ret.name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ret.age \u0026lt;\u0026lt; endl; constexpr int ret1 = dispaly(10); cout \u0026lt;\u0026lt; ret1 \u0026lt;\u0026lt; endl; return 0; } ","href":"https://6923403.github.io/post/constexpr/","tags":"CPP ; const ; function","title":"Constexpr"},{"content":"./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value   $* 1 2 3 4  ","href":"https://6923403.github.io/post/shell_commans/","tags":"Linux ; shell","title":"Shell_command($!, $@...)"},{"content":"updat\u0026hellip;\n1. install xorg pacman -S xorg-server xorg-xinit 2. install zsh, feh, i3gapsr, compton, oh-my-zsh pacman -S zsh xfce4-terminal feh compton i3-gaps nautilus i3lock sh -c \u0026quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot;  install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts  add user useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim  startx exit login new user touch .zshrc cp /etc/X11/xinit/xinitrc ~/.xinitrc vim .xinitrc exec compton -b \u0026amp; exec i3 reboot startx  安装 Yaourt vim /etc/pacman.conf\n[archlinuxcn] #The Chinese Arch Linux communities packages. SigLevel = Optional TrustAll Server = https://mirrors.aliyun.com/archlinuxcn/$arch Server = http://repo.archlinuxcn.org/$arch pacman -Syu pacman -S yaourt pacman -S google-chrome pacman -S archlinuxcn-keyring  pacmain -S rofi vim ~/.config/i3/config\n#run rofi bindsym $mod+d exec rofi -show run mod+shift+r 刷新以下  set static ip pacman -S netctl - vim /etc/netctl/ens33-static Description='ens33' Interface=ens33 Connection=ethernet IP=static Address=('192.168.0.14/24') #Routes=('192.168.0.0/24 via 192.168.0.1') Gateway='192.168.0.1' DNS=('192.168.0.1') TimeoutUp=300 TimeoutCarrier=300  wallpaper feh -bg-center Downloads/jpeg vim .xinitrc exec feh -bg-center Downloads/jpeg \u0026amp;  polybar  https://www.cnblogs.com/bluestorm/p/5929478.html https://www.bilibili.com/video/BV1gW411H7Ke/ https://www.yuque.com/sunhl/mvumc2/rq64vb\n ohmysh option https://www.jianshu.com/p/17790d2fc2f6 https://www.jianshu.com/p/d194d29e488c?open_source=weibo_search https://blog.csdn.net/sgzqc/article/details/46627817 # static ip https://github.com/AshNobita/i3andpolybarconfig  ","href":"https://6923403.github.io/post/arch_desktop/","tags":"Arch ; Linux ; i3wm","title":"Arch Beautify desktop"},{"content":"0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso You should installed Vmware and download Archlinux iso .\nChange your firmwaretype to UEFI (The way many tutorials did not say)  1. Start ls /sys/firmware/efi/efivars The command detect UEFI files and if your dir not include files your firmwaretype is BIOS .\nThen, ping google.com, detect interent connection\n Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.\n Update systime\ntimedatectl set-ntp true  2. Partition the disks cfdisk /dev/sda #choose gpt Move to Write , enter, yes, last Quit .  3. Format the partitions 3.1 Format:\nmkfs.fat -F32 /dev/sda1 mkswap /dev/sda2 swapon /dev/sda2 mkfs.ext4 /dev/sda3 3.2 Mount the file systems\nmount /dev/sda3 /mnt mkdir -p /mnt/boot/EFI mount /dev/sda1 /mnt/boot/EFI lsblk #check mount  4. Install dev 4.1 According to your country choose your mirror source\nvim /etc/pacman.d/mirrorlist 4.2 install\npacstrap -i /mnt base base-devel linux-lts linux-firmware vi net-tools  5. Configure the system 5.1 Fstab\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 5.2 Check your fstab files, like the img\nvim /mnt/etc/fstab  6. System configuration 6.1 Chroot\narch-chroot /mnt 6.2 Time\nln -sf /usr/share/zoneinfo/Region/City /etc/localtime hwclock --systohc --utc 6.3 Localization\nvi /etc/locale.gen #according to your country, choose, del :wq locale-gen locale -a echo LANG=en_US.UTF-8 \u0026gt; /etc/locale.conf locale  ex: #en_US.UTF8 UTF-8 del #: en_US.UTF-8 UTF-8  6.4 hostname\necho hostname \u0026gt; /etc/hostname 6.5 hosts\nvi /etc/hosts 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.0.1 hostname.localdomain hostname 6.6 root password\npasswd  7. install UEFI pacman -S grub efibootmgr grub-install --recheck /dev/sda grub-mkconfig -o /boot/grub/grub.cfg  8. End pacman -S dhcpcd exit umount -R /mnt reboot  Arch Beautify   Reference:\nArch wiki and S.T.BLOG and V2EX\n","href":"https://6923403.github.io/post/arch_install/","tags":"Linux ; Arch","title":"Vmware install Archlinux "},{"content":"0. Hugo \u0026amp; Markdown Hugo \u0026amp;\u0026amp; MarkDown\n 1. MarkDown template --- title: \u0026quot;{{ replace .Name \u0026quot;-\u0026quot; \u0026quot; \u0026quot; | title }}\u0026quot; date: {{ .Date }} lastmod: {{ .Date }} draft: false tags: [ ] categories: [ ] comment: true ---  2. Hugo command hugo #build html havn't draft=true hugo -D #build html and dragt=true hugo server #Start hugo server  3. Other Reference\n","href":"https://6923403.github.io/post/hugomarkdown/","tags":"hugo ; markdown","title":"Hugo \u0026 Markdown"},{"content":" void fun(char * fmt, \u0026hellip;); int vsprintf(char *str, const char *format, va_list arg);\n  Test programming #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; /* * Re: https://github.com/antirez/kilo/kilo.c * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html */ char buffer[80]; int editorSetstatus(const char * fmt, ...) { va_list ap; va_start(ap, fmt); int ret; ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap); va_end(ap); return (ret); } int main(int argc, char **argv) { int len = 20; editorSetstatus(\u0026quot;%d\u0026quot;, len); printf(\u0026quot;%s \\n\u0026quot;, buffer); return 0; }  gcc -Wall -g fun.c -o fun\n./fun\nlen = 20\n","href":"https://6923403.github.io/post/variable_function/","tags":"CPP ; GCC","title":"Variable function(fun(char *, ...)) and vsnprintf()"},{"content":" Boost C++ is Cpp programming language that provides support for tasks and structures\n Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile \u0026amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include \u0026lt;boost/thread/thread.hpp\u0026gt; //boost thread #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026quot;func1:\u0026quot; \u0026lt;\u0026lt; cnt1++ \u0026lt;\u0026lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026quot;\\tfunc2:\u0026quot; \u0026lt;\u0026lt; cnt2++ \u0026lt;\u0026lt; endl; sleep(2); } } int main() { boost::thread thread1(\u0026amp;func1); boost::thread thread2(\u0026amp;func2); system(\u0026quot;read\u0026quot;); isRuning = false; thread2.join(); thread1.join(); cout \u0026lt;\u0026lt; \u0026quot;exit\u0026quot; \u0026lt;\u0026lt; endl; return 0; } g++ main.cpp -g -o main -lboost_thread -lpthread\n","href":"https://6923403.github.io/post/linux_install_boost/","tags":"Boost ; Linux ; CPP","title":"Linux install Boost c++"},{"content":"Start Download FFmpeg  Install tool 1. install yasm\nsudo apt-get install yasm  if not installed yasm, os will output \u0026ldquo;nasm/yasm not found or too old. Use \u0026ndash;disable-x86asm for a crippled build.\u0026rdquo;\n 2. install SDL2\nSDL2-2.0.12(stable)\ntar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install  Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg\ncd ffmpeg/ ./configure sudo make -j4 sudo make install  3. Check ffmpeg -version ffplay -version ","href":"https://6923403.github.io/post/ffmpeg_install/","tags":"linux ; FFmpeg ; Ubuntu","title":"Ubuntu20 install FFmpeg"}]