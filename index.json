[{"categories":null,"contents":"【最终图解版】Transformer工作原理：一步一图 目标： 让模型理解一句话的深层含义，例如：“机器人爱吃苹果”。\n🔀 起点：输入 (Input) 模型接收到的是一串词元（Tokens）。\n[机器人] [爱] [吃] [苹果]\n1️⃣ 步骤一：创建“数字身份证” (Input Embedding + Positional Encoding) 模型不认识文字，只认识数字。所以，它会执行两项操作：\n词嵌入 (Word Embedding): 将每个词元转换成一个包含其语义信息的向量（一长串数字）。 位置编码 (Positional Encoding): 因为Transformer同时处理所有词，它本身不知道词的顺序。因此，模型会为每个词的向量加上另一个代表其位置的“位置向量”。 图解:\n[机器人] [爱] [吃] [苹果]\n| | | |\n▼ ▼ ▼ ▼\n[Vec_机器人] [Vec_爱] [Vec_吃] [Vec_苹果] (\u0026lt;- 词嵌入)\n+ + + [Pos_1] [Pos_2] [Pos_3] [Pos_4] (\u0026lt;- 位置编码)\n|| || || ||\n▼ ▼ ▼ ▼\n[X_1] [X_2] [X_3] [X_4] (\u0026lt;- 最终输入向量)\n结果： 现在我们有了一组新的向量，每个向量 X 不仅知道“我是谁”（语义），还知道“我在哪”（位置）。\n2️⃣ 步骤二：进入注意力模块 - 生成Q, K, V 输入向量 X 流入**多头自注意力（Multi-Head Self-Attention）**模块。在这里，每个向量 X 都会被用来生成三份“克隆体”，分别扮演不同角色：\nQ (Query - 查询): 我要去问谁？（我的提问） K (Key - 键): 我有什么信息可供别人查询？（我的标签） V (Value - 值): 我实际代表什么？（我的内容） 图解: (以输入向量 X_2，即“爱”为例)\n┌──\u0026gt; [Q_2] (Query) | [X_2] \u0026mdash;├──\u0026gt; [K_2] (Key)\n|\n└──\u0026gt; [V_2] (Value)\n注意：实际上，因为是“多头”，所以会同时生成多组Q, K, V（比如8组），这里为简化只画1组。\n3️⃣ 步骤三：自注意力核心计算 这是信息融合的关键。我们以计算“爱”(X_2)的新向量为例。\n3a. 计算相关性得分 (Score) “爱”的 Query (Q_2) 会和所有词的 Key (K_1, K_2, K_3, K_4) 进行点积计算，以判断相关性。\n3b. 归一化得分 (Softmax) 将原始得分转换为总和为1的百分比权重，代表“注意力”的分配。\n图解:\nScore_2,1 \u0026ndash;┐\nScore_2,2 \u0026ndash;┤ ┌\u0026ndash;\u0026gt; Weight_2,1 (例如 0.6)\nScore_2,3 \u0026ndash;│ Softmax │\u0026ndash;\u0026gt; Weight_2,2 (例如 0.1)\nScore_2,4 \u0026ndash;┘ ├\u0026ndash;\u0026gt; Weight_2,3 (例如 0.1)\n└\u0026ndash;\u0026gt; Weight_2,4 (例如 0.2)\n3c. 加权融合信息 (Weighted Sum) 用得到的权重，去加权乘以所有词的 Value 向量，然后求和。\n图解:\n(Weight_2,1 * [V_1]) ──┐\n(Weight_2,2 * [V_2]) ──┤\n(Weight_2,3 * [V_3]) ──┤──\u0026gt; [Z_2] (全新的、富含上下文的“爱”向量)\n(Weight_2,4 * [V_4]) ──┘\n结果： 新向量 Z_2 已经不仅仅是“爱”了，它融合了“谁爱 (机器人)”和“爱什么 (吃苹果)”的语境信息。所有其他的词（Z_1, Z_3, Z_4）也经过了同样的过程。\n4️⃣ 步骤四：残差连接 与 层归一化 (Add \u0026amp; Norm) 为了防止信息丢失并稳定训练，模型会执行一个关键的“收尾”工作。\n残差连接 (Add): 将注意力模块的输入 (X_2) 直接加到输出 (Z_2)上。 层归一化 (Norm): 对相加后的结果进行“标准化”，使其数值稳定，方便下一层处理。 图解:\n原始输入 [X_2]\n│\n└─────┐\n▼\n注意力输出 [Z_2] ➕ [X_2] \u0026ndash;\u0026gt; [结果向量] \u0026ndash;\u0026gt; 📊 LayerNorm \u0026ndash;\u0026gt; [注意力层最终输出]\n5️⃣ 步骤五：前馈神经网络 (Feed-Forward Network) 注意力层的最终输出，还会经过一个“前馈神经网络”。这可以被理解为对融合了上下文的新信息进行一次“深度思考”和“内容提炼”。\n图解:\n[注意力层最终输出] \u0026ndash;\u0026gt; 🧠 Feed-Forward Network \u0026ndash;\u0026gt; [思考后的向量]\n最后，这里也会重复一次“步骤四：残差连接与层归一化”的操作。\n🏁 终点：输出 (Output) 经过以上所有步骤，我们就完成了一个完整的Transformer Block。从这个模块输出的向量，已经对原始句子有了非常深刻和丰富的理解。\n这个输出可以被送入下一个一模一样的Transformer Block进行更深层次的提炼，也可以作为最终结果用于生成文本或进行分类。\n","permalink":"https://vcvvvc.github.io/post/transformer_steps/","tags":["Transformer","NLP","GPT"],"title":"Transformer_steps"},{"categories":null,"contents":"项目列表 Solana 项目早期 Tag 与 Main 分支版本综合分析\nhttps://github.com/blockworks-foundation/mango https://github.com/marinade-finance/liquid-staking-program https://github.com/orca-so/whirlpools https://github.com/saber-hq/stable-swap https://github.com/cykura/cykura-protocol https://github.com/Kamino-Finance/klend 总结-A版本 | Solana 项目早期 Tag 与当前 Main 分支版本综合分析 本文对六个主流 Solana 项目的早期 Tag 版本与当前 Main 分支版本进行了对比分析。重点从以下三个方面展开讨论：\n实现方式：代码如何实现、架构设计与关键技术选型。 优点：各版本在设计和实现上的优势。 挑战：存在的复杂性、不足及学习上的难点。 下面依次介绍各项目的情况，供开发者参考学习。\n1. Mango（blockworks‐foundation/mango） 早期 Tag 版本 核心逻辑\n实现了基本的交易撮合、杠杆交易、资金池管理和风险控制等功能，是构建高性能去中心化交易平台的雏形。\n实现方式\n采用较直接的模块分层设计，各模块间的调用较为紧耦合。代码量相对较少，但为支持核心交易逻辑做了不少硬编码和简单的风险校验。\n优点\n直观展示了交易撮合和杠杆机制的基本实现。 结构较简单，便于初步了解平台整体架构和风险控制思路。 挑战\n模块之间缺乏足够的解耦，代码阅读时需要理清各模块间的交互。 功能实现较为原始，边界情况和异常处理不完善，对后续理解更复杂系统可能带来困难。 当前 Main 分支版本 功能扩展\n在早期基础上增加了更多功能，如完善的风控系统、借贷支持以及交易优化策略，整体功能更丰富。\n实现方式\n采用模块化设计，代码经过重构和优化。各组件间更为独立，异常处理、状态校验等更加健全，同时注释和文档也更完善。\n优点\n展示了一个成熟高性能交易平台的完整实现流程。 更高的代码鲁棒性和可扩展性，便于理解实际生产环境下的系统架构。 挑战\n功能复杂度大，涉及多个子系统，学习曲线陡峭。 需要投入较多精力去理解各模块间的交互和优化逻辑。 2. Marinade 的 Liquid Staking Program（marinade‐finance/liquid‐staking‐program） 早期 Tag 版本 核心逻辑\n实现 SOL 质押、权益代币生成以及流动性解锁。整个业务逻辑单一、聚焦于解决质押后流动性受限的问题。\n实现方式\n采用直接的指令分发与账户数据更新机制。实现简单、清晰，充分利用了 Solana 的账户模型和低延迟优势。\n优点\n逻辑单一，适合初学者快速入门。 代码清晰，便于理解基本的账户管理和状态更新流程。 有助于将以太坊开发经验迁移到 Solana 开发中。 挑战\n功能较为基础，部分异常处理和扩展逻辑未完善。 可能缺乏一些实际业务场景下的安全性考量，需要后续版本补充。 当前 Main 分支版本 功能扩展\n在原有基础上增加了安全优化、更多业务场景支持以及细致的错误处理逻辑，整体功能更健壮。\n实现方式\n经过重构后采用模块化设计，各子模块之间接口更清晰，状态校验和安全性增强。代码结构更符合生产级应用要求。\n优点\n安全性和扩展性显著提高。 更好的错误处理机制和用户体验优化。 便于学习项目从简单实现到成熟产品的演进过程。 挑战\n相比早期版本，代码复杂度有所提升，初学者可能需要花更多时间理解模块划分。 扩展的业务场景和安全机制带来额外的学习负担。 3. Orca 的 Whirlpools（orca‐so/whirlpools） 早期 Tag 版本 核心逻辑\n展示了集中流动性池的基本实现，重点在于在特定价格区间内集中流动性以及手续费的基本计算。\n实现方式\n采用较为直接的算法模型来实现区间流动性，代码中包含了必要的数学计算和流动性分布逻辑，但整体实现较为简化。\n优点\n清晰地展示了集中流动性概念及其基本算法。 对数学模型和算法实现有直观的呈现，适合初步了解 AMM 的核心思想。 挑战\n数学细节较多，需要一定的数学和算法基础。 简化的实现可能忽略了许多边界条件和实际运行时的复杂情况。 当前 Main 分支版本 功能扩展\n增加了更复杂的流动性管理策略、动态手续费模型和更全面的边界处理机制，适应市场多变情况。\n实现方式\n在保持核心数学模型的基础上，对代码进行了模块化重构和优化，增强了异常处理和扩展性。\n优点\n功能更完善，能够处理更多实际场景。 算法和模型经过优化，提高了资本利用率和系统稳定性。 挑战\n复杂性大幅提升，对学习者的算法理解能力提出更高要求。 模块化设计和动态调整机制增加了代码理解的难度。 4. Saber 的 Stable Swap（saber‐hq/stable‐swap） 早期 Tag 版本 核心逻辑\n基于 Curve 模型实现稳定币兑换，重点在于资产定价、价格曲线设计和低滑点交易。\n实现方式\n通过直观的数学模型实现交换算法，代码中较为详细地呈现了曲线计算与流动性分布机制。\n优点\n数学模型直观，适合学习稳定币交换的核心算法。 实现方式清晰，能帮助理解低滑点交易的原理和实现细节。 挑战\n需要扎实的数学基础来理解价格曲线和定价机制。 边界条件和异常情况处理较少，学习时需结合理论知识补充。 当前 Main 分支版本 功能扩展\n在原有基础上加入了更多安全性检查、异常处理及多资产支持，提升了系统稳定性和应用范围。\n实现方式\n采用更模块化和健壮的架构，对数学计算部分进行优化，同时增强了跨链与多资产支持功能。\n优点\n整体实现更符合生产环境要求。 兼顾了低滑点和系统扩展性，具有较高实用价值。 挑战\n实现方式更复杂，数学与编程细节增加了理解难度。 需要更多背景知识来理解优化和安全增强部分。 5. Cykura Protocol（cykura/cykura‐protocol） 早期 Tag 版本 核心逻辑\n探索性实现，可能涉及风险管理、清算机制或衍生品设计，设计思路较为前沿。\n实现方式\n采用试验性质的实现方案，代码结构和注释较为简单，更多体现创新思路而非成熟产品的严谨性。\n优点\n提供了前沿创新设计的早期探索案例。 有助于拓宽对非传统 DeFi 模型的视野和思考。 挑战\n代码成熟度不足，缺少系统性的异常处理和安全保障。 设计思路尚未完善，初学者可能难以捉摸核心思想的落地实现。 当前 Main 分支版本 功能迭代\n经过社区反馈与多次迭代，逐步增加了实用功能和安全性措施，设计趋于成熟。\n实现方式\n代码结构与注释得到改善，保留了原有的创新思路，同时引入了更多实战经验的优化策略。\n优点\n从试验到成熟的过程能帮助理解创新项目如何不断优化。 展示了前沿设计在实际应用中的改进路径。 挑战\n创新性与成熟度并存，部分设计仍存在不完善之处。 学习过程中需要结合其他成熟案例进行对比和补充。 6. Klend（Kamino‐Finance/klend） 早期 Tag 版本 核心逻辑\n展示了借贷或流动性协议的基础实现，涵盖资产抵押、借贷撮合以及初步风控措施。\n实现方式\n采用较为直接的实现方案，代码直观地反映了借贷流程和账户管理逻辑，但功能较为单一。\n优点\n适合初步学习 DeFi 借贷协议的基本原理。 实现方式简单，便于理解抵押、借贷及风险控制的基本流程。 挑战\n功能实现较基础，部分边界和安全机制缺乏完善设计。 随着业务扩展，需要理解后续引入的更复杂风控机制。 当前 Main 分支版本 功能扩展\n在早期基础上加入了更全面的风控策略、异常处理和用户体验优化，使借贷流程更为完备。\n实现方式\n经过重构后采用模块化设计，安全性和扩展性显著提升，各模块之间接口定义更清晰。\n优点\n展示了借贷协议从简单实现到成熟系统的完整演进。 有助于理解实际生产环境中信用评估和风险控制的实践方法。 挑战\n随着功能扩展，系统复杂度增加，理解整体架构需要更多时间。 风控机制与安全保障设计较为深入，新手需逐步消化。 | 综合建议 初学阶段\nMarinade 的 Liquid Staking Program：\n实现方式：早期版本实现简单、直观，易于理解 Solana 的基本开发模式；当前版本则展示了从简到繁的迭代演进。 优点：逻辑单一、代码清晰，适合入门。 挑战：当前版本功能扩展带来一定复杂性，但有助于理解实际产品的完善过程. Saber 的 Stable Swap：\n实现方式：从直观的数学模型实现到模块化优化，展示了资产交换算法的核心到扩展。 优点：适合学习低滑点交易原理和资产定价算法。 挑战：需要扎实的数学基础和对复杂优化的理解。 进阶学习\nKlend：\n实现方式：从早期直接实现借贷逻辑到当前模块化、全方位风控的设计。 优点：展示了借贷协议演进过程和风险控制实践。 挑战：系统复杂性增加，需要更深的理解和实践经验。 Orca 的 Whirlpools：\n实现方式：从简单的集中流动性实现到完善的动态调节机制。 优点：帮助掌握集中流动性与算法模型优化。 挑战：数学与编程细节较多，适合作为进阶学习内容。 高级挑战与创新探索\nMango：\n实现方式：早期版本展示核心交易逻辑；当前版本则整合了多模块协作和复杂风控。 优点：完整展示高性能交易平台的设计思路。 挑战：复杂度较高，建议在扎实基础后再进行深入研究。 Cykura Protocol：\n实现方式：从探索性实现到逐步完善安全机制的迭代过程。 优点：提供前沿创新设计的案例，拓宽技术视野。 挑战：设计尚未完全成熟，需要结合其他案例进行对比和理解。 | 最终结论 通过对比早期 Tag 与当前 Main 分支版本，你可以清楚地看到项目从初始实现到逐步迭代优化的全流程。对于刚转向 Solana 开发的你，建议：\n首选入门：选择 Marinade 的 Liquid Staking Program，利用其简单、清晰的早期版本快速掌握基本开发模式，再通过当前版本体会项目演进。 扩展学习：在掌握基础后，可进一步学习 Saber 的 Stable Swap 和 Klend，通过对比早期与当前版本，理解系统如何从简单实现走向成熟应用。 进阶挑战：待基础扎实后，再挑战 Mango 与 Orca 的 Whirlpools，同时关注 Cykura Protocol 的前沿设计，以拓宽视野和技术深度。 这种循序渐进的学习路径，不仅帮助你快速掌握 Solana 开发的核心机制，还能逐步理解复杂 DeFi 应用的设计与实现，为未来实际开发提供坚实的理论与实践支持。\n总结-B版本 | Solana 项目早期 Tag 与当前 Main 分支版本综合分析 本文对六个主流 Solana 项目的早期 Tag 版本与当前 Main 分支版本进行了对比分析，从实现方式、优点和挑战三个角度帮助开发者了解项目的设计演进，便于学习和开发。\n1. Mango（blockworks‐foundation/mango） 早期 Tag 版本 实现方式： 基于基本的交易撮合、杠杆交易、资金池管理和风险控制逻辑实现。 模块较少，结构相对直观，但已涵盖核心功能。 优点： 清晰展示了高性能交易平台的基本架构与风险控制思想。 为理解多模块协作提供了初步示例。 挑战： 即便是早期版本，复杂的交互逻辑和风险模型对初学者仍有一定难度。 当前 Main 分支版本 实现方式： 功能大幅扩展，包括更完善的风控系统、借贷模块和交易优化策略。 代码更加模块化，具备生产级错误处理和性能优化。 优点： 展示了完整高性能交易系统的全链路设计。 便于对比早期简化实现与成熟产品在架构和安全性上的提升。 挑战： 复杂度显著增加，需要更深的基础知识才能全面理解各模块的交互和优化点。 2. Marinade 的 Liquid Staking Program（marinade‐finance/liquid‐staking‐program） 早期 Tag 版本 实现方式： 实现了 SOL 质押、权益代币生成及流动性解锁的基本逻辑。 主要关注账户管理、状态更新和指令分发。 优点： 逻辑单一、结构清晰，极其适合初学者入门。 易于理解 Solana 的基本开发模式，便于经验迁移。 挑战： 功能较为基础，对极端情况和复杂业务场景覆盖有限。 当前 Main 分支版本 实现方式： 在早期基础上增加了多种安全优化、异常处理和更多业务场景支持。 采用更为模块化的架构设计，强化了状态验证和错误处理。 优点： 反映了实际生产环境下的优化策略和健壮性改进。 对比早期版本，展示了项目如何迭代升级。 挑战： 扩展后的功能和代码结构更复杂，新手需要一定基础才能全面消化。 3. Orca 的 Whirlpools（orca‐so/whirlpools） 早期 Tag 版本 实现方式： 实现了集中流动性池的基础逻辑，涵盖指定价格区间内流动性集中和手续费计算。 部分核心算法涉及数学模型和区间划分。 优点： 清楚地展示了集中流动性概念和 AMM 模型的初步实现。 为学习如何利用区间策略提升资本效率提供了实战案例。 挑战： 算法和数学模型较多，对数学基础要求较高，对初学者来说有一定难度。 当前 Main 分支版本 实现方式： 功能扩展至更复杂的流动性管理策略、动态手续费模型和自动调整机制。 对数学模型进行了细致优化和边界条件完善。 优点： 展示了从基础模型到生产级系统的迭代过程。 提升了资金利用率和系统灵活性。 挑战： 增加的算法复杂度和系统细节需要开发者具备较强的理论和实践基础。 4. Saber 的 Stable Swap（saber‐hq/stable‐swap） 早期 Tag 版本 实现方式： 基于 Curve 模型实现稳定币兑换，核心在于资产定价、价格曲线设计及低滑点交易。 直接展示了数学公式与算法实现过程。 优点： 清晰直观地呈现了稳定币交换机制和数学模型。 有助于理解如何通过算法控制交易滑点。 挑战： 对数学模型的理解要求较高，部分算法细节可能不易于初学者理解。 当前 Main 分支版本 实现方式： 在原有模型上加入了更多异常情况处理、安全性增强及跨链资产支持。 代码架构更加模块化，优化了算法性能和鲁棒性。 优点： 更贴近生产环境，展示了实际应用中如何优化和扩展算法。 对比早期版本，能更好地理解系统稳定性与扩展性的平衡。 挑战： 增加的功能和安全措施使得代码复杂度提升，阅读和理解成本较高。 5. Cykura Protocol（cykura/cykura‐protocol） 早期 Tag 版本 实现方式： 探索性实现，涵盖风险管理、清算机制或衍生品设计等前沿思路。 代码结构相对简单但不够系统化，主要为试验性质的设计。 优点： 展现了创新性思路和前沿尝试，为拓宽技术视野提供了素材。 有助于了解新颖设计在初期的实现方法。 挑战： 文档和代码注释较少，成熟度不足，可能存在较多试错和不完善之处。 当前 Main 分支版本 实现方式： 基于社区反馈和不断迭代，加入了更多实用功能和安全保障机制。 结构和注释有所改进，更接近生产级别应用。 优点： 在保留创新设计的同时，提高了稳定性和安全性。 对比早期版本，可观察到探索性设计如何向成熟产品转变。 挑战： 由于设计初衷的前沿性，部分模块可能仍然不够成熟，理解和调试难度较大。 6. Klend（Kamino‐Finance/klend） 早期 Tag 版本 实现方式： 实现了借贷或流动性协议的基础流程，包括资产抵押、借贷撮合及初步风控措施。 代码直观、流程清晰，但功能较为单一。 优点： 直观展示了 DeFi 借贷协议的基本原理，易于理解。 为学习资产管理、借贷撮合和基础风险控制提供了入门案例。 挑战： 功能较为基础，未能覆盖复杂的风控场景，对实际应用启示有限。 当前 Main 分支版本 实现方式： 在早期基础上扩展了风控策略、异常处理和用户体验优化。 采用更模块化设计，强化了安全性和扩展性。 优点： 展示了从简单实现到完善系统的演进过程，适合深入学习风险管理和信用评估机制。 更贴合生产环境，对实际开发具有较高参考价值。 挑战： 增加的复杂性和风控逻辑要求对系统整体有较深入的理解，新手可能需要逐步消化。 | 综合建议 初学阶段\nMarinade 的 Liquid Staking Program： 实现方式简单、直观，逻辑单一； 优点在于易于理解和入门，帮助快速掌握 Solana 的基本开发模式； 挑战则在于功能较为基础，覆盖面有限。 Saber 的 Stable Swap： 实现方式展示了数学模型在资产交换中的应用； 优点为算法和低滑点交易提供了清晰示例； 挑战在于数学原理需要较高理解成本。 进阶学习\nKlend： 实现方式从简单的借贷流程演进到复杂的风控体系； 优点在于系统性展示了 DeFi 借贷协议的全流程； 挑战为不断增加的风险管理细节和系统复杂度。 Orca 的 Whirlpools： 实现方式由基础集中流动性模型扩展到动态管理； 优点在于能深入理解 AMM 模型及算法优化； 挑战为数学模型和实现细节的复杂性。 高级挑战与创新探索\nMango： 实现方式由初期的交易撮合到完善的多模块协作； 优点在于展示了高性能交易系统的全链路架构； 挑战则在于整体复杂度较高，需要扎实基础后再深入。 Cykura Protocol： 实现方式从试验性设计逐步走向成熟； 优点为前沿创新提供了有价值的探索案例； 挑战在于其部分设计和实现仍存在不成熟之处，需谨慎研读。 | 最终结论 对比早期 Tag 与当前 Main 分支版本，不仅能帮助你掌握各项目的基本开发逻辑，还能体会到项目在实际生产中不断优化与演进的过程。对于刚开始转向 Solana 开发的你，推荐的学习路径是：\n入门阶段：\nMarinade 的 Liquid Staking Program：适合作为入门项目，快速掌握账户模型、指令分发及状态更新。 Saber 的 Stable Swap：如果对数学模型和算法感兴趣，帮助理解稳定币交换的基础原理。 进阶阶段：\nKlend：学习借贷协议的基本流程和风控设计，对比早期与当前版本理解系统演进。 Orca 的 Whirlpools：进一步探究集中流动性池的数学原理和高级算法实现。 高级挑战与前沿探索：\nMango：在基础扎实后挑战完整高性能交易系统的架构与多模块协作。 Cykura Protocol：关注前沿创新设计，通过对比早期与当前版本拓宽技术视野。 这种循序渐进的学习路径将帮助你从基础到前沿全面掌握 Solana 合约开发的核心技术，为未来的实际开发打下坚实的理论与实践基础。\n","permalink":"https://vcvvvc.github.io/post/solana_open_source_learn/","tags":["Solana"],"title":"Solana开源项目参考"},{"categories":null,"contents":"教程都是双语版本发布，为新手入门、原理分析教程\n总结V3主要变动 https://medium.com/@vcvckw/%E6%80%BB%E7%BB%93v3%E4%B8%BB%E8%A6%81%E5%8F%98%E5%8A%A8-3b9799d87cf6\nSummarize the main changes in V3: https://medium.com/@vcvckw/summarize-the-main-changes-in-v3-8d3c461d0cd5\n解析池子参数 https://medium.com/@vcvckw/%E8%AF%A6%E8%A7%A3%E5%BB%BA%E6%B1%A0%E5%8F%82%E6%95%B0-d171c6b5c071\nDetailed explanation of pool parameters https://medium.com/@vcvckw/detailed-explanation-of-pool-parameters-a465d91679d2\n数据分析DBR产出与TVL和层的关联，拆解DBR产出公式 https://medium.com/@vcvckw/tvl\nData analysis of the correlation between DBR output and TVL and layer, and decomposition of DBR output formula https://medium.com/@vcvckw/data-analysis-of-the-correlation-between-dbr-output-and-tvl-and-layer-and-decomposition-of-dbr-0c3a4bebb79b\n","permalink":"https://vcvvvc.github.io/post/article_doubler/","tags":["BlockChain","Doubler"],"title":"Article_doubler"},{"categories":null,"contents":"零知识证明（英语：zero-knowledge proof）或零知识协议（zero-knowledge protocol）是一方（证明者）向另一方（检验者）证明某命题的方法，特点是过程中除“该命题为真”之事外，不泄露任何资讯。因此，可理解成“零泄密证明”。\n零知识证明要具备下列三种性质：\n完备（complete）\n若所要证之事为真，则诚实（意即依协议行事）的证明者能说服诚实验证者。\n健全（sound）\n若命题为假，则作弊证明者仅得极小机会能说服诚实验证者该事为真。\n零知识（zero-knowledge）\n若命题为真，则验证者除此之外，过程中没有得悉任何其他资讯。换言之，仅知命题为真（而不知秘密本身）已足以“想像”出一个交互的情境，其中证明者的确知道该秘密。此性质能严格定义为：每个验证者皆有相应的模拟器，输入欲证事实时，无需求助于证明者，已可输出一套通讯誊本，看似诚实验证者与证明者的通讯记录。\n零知识证明的精粹在于，如何证明自己拥有该情报而不必透露情报内容。这也是零知识证明的难点\n若该命题的证明，需要知悉某秘密方能作出，则检验者单凭目睹证明，而未获悉该秘密，仍无法向第三方证明该命题（即单单转述不足以证明）。待证的命题中，必定包含证明者宣称自己知道该秘密，但过程中不能传达该秘密本身。否则，协议完结时，已给予检验者有关命题的额外的资讯。\n如果要用一个概念直观地解释零知识证明如何证明用户拥有数据，可以想象一个山洞只有一个入口，洞里面有两条路（路径A和路径B），这两条路由一扇门连接，要说出密码才能通过这扇门。Alice希望向Bob证明她知道开门的密码，但不想将密码透露给Bob。因此，Bob需要站在山洞外，Alice从其中一条路走进山洞，而Bob并不知道她选了哪条路。接着，Bob指定Alice从其中一条路回到山洞入口（注：这是随机选择的）。如果Alice最初选择从路径A走到门口，但Bob让她从路径B回来，唯一的方法就是穿过那扇门，而穿过门必须知道密码。为了充分证明Alice真的知道门的密码，而不是运气好刚好选到了同一条路，这个过程可以反复重复好几次。\nRe:\nhttps://ethereum.org/zh/zero-knowledge-proofs/ https://blog.chain.link/what-is-a-zero-knowledge-proof-zkp-zh/ https://eprint.iacr.org/2023/1784 https://vitalik.eth.limo/general/2024/04/29/binius.html https://zh.wikipedia.org/zh-cn/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E ","permalink":"https://vcvvvc.github.io/post/zkp/","tags":["BlockChain","Zkp"],"title":"零知识证明(zero-knowledge proof) - Zkp"},{"categories":null,"contents":"2024年版本\nInstall docker on Ubuntu # Add Docker\u0026#39;s official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;) stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin sudo docker run hello-world # 重启 service docker restart Install PostgreSQL docker pull postgres docker run --name mypsql -e POSTGRES_PASSWORD=my_password -d -p 5432:5432 -v /path/to/data:/var/lib/postgresql/data postgres docker exec -it mypsql psql -U postgres Docker usage # 查找镜像 docker search hello-world # 获取镜像 docker pull hello-world # 镜像列表 docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest d2c94e258dcb 12 months ago 13.3kB # 运行镜像 docker run hello-world Docker container # 查看所有容器 docker ps -a # 启动容器 docker start $id # 停止容器 docker stop $id # 重启容器 docker restart $id # 进入容器 1. docker attach $id 2. docker exec -it $id /bin/bash # 删除容器 docker rm $id # 导出容器 docker export $id \u0026gt; ubuntu.tar # 导入容器 cat docker/ubuntu.tar | docker import - test/ubuntu:v1 # 运行一个web docker pull training/webapp # 更新一个容器 docker run -it --name my_container ubuntu:18.04 bash docker run -t -i ubuntu:18.04 /bin/bash - apt-get update - apt-get install gcc docker commit -m=\u0026#34;install gcc\u0026#34; -a=\u0026#34;vvvttest\u0026#34; 3635723fd832 vvvttest/ubuntu:v1 # 创建一个容器 Dockerfile: # syntax=docker/dockerfile:1 FROM node:16-alpine WORKDIR /app COPY . . RUN yarn install --production CMD [\u0026#34;node\u0026#34;, \u0026#34;src/index.js\u0026#34;] docker build -t getting-started . docker run -dp 3000:3000 getting-started https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository\nhttps://hub.docker.com/_/postgres/\nhttps://www.dockerdocs.cn/get-started\n","permalink":"https://vcvvvc.github.io/post/docker_tutorial/","tags":["Linux","Docker"],"title":"Docker use Tutorial"},{"categories":null,"contents":"修复hardhat发布合约代码出错的问题 hardhat-verify found one or more errors during the verification process:\nEtherscan: An unexpected error occurred during the verification process. Please report this issue to the Hardhat team. Error Details: Connect Timeout Error\nnpm install \u0026ndash;save-dev undici\n在 hardhat.config.js 中添加以下代码：\nconst { ProxyAgent, setGlobalDispatcher } = require(\u0026#34;undici\u0026#34;); const proxyAgent = new ProxyAgent(\u0026#34;http://127.0.0.1:7890\u0026#34;); setGlobalDispatcher(proxyAgent); Reference: https://github.com/smartcontractkit/full-blockchain-solidity-course-js/discussions/2247#discussioncomment-5496669\n","permalink":"https://vcvvvc.github.io/post/fix_hardhat_verify_timeout/","tags":["BlockChain","Smart Contract","hardhat"],"title":"Fix_hardhat_verify_timeout"},{"categories":null,"contents":"以太坊延伸阅读\nAtoms, Institutions, Blockchains - 原子、机构、区块链(opens in a new tab) - 为什么区块链很重要？ https://stark.mirror.xyz/n2UpRqwdf7yjuiPKVICPpGoUNeDhlWxGqjulrlpyYi0\n内核(opens in a new tab) 以太坊的梦想 - Ethereal Dreamers https://www.kernel.community/en/learn/module-1/dreamers/\nThe ethereum project: learning to dream with open minds 以太坊项目：学会以开放的心态去梦想\nhttps://blog.ethereum.org/2014/07/14/the-ethereum-project\n精通以太坊 ","permalink":"https://vcvvvc.github.io/post/ethereum-extended-reading/","tags":["BlockChain","Ethereum"],"title":"Ethereum Extended Reading"},{"categories":null,"contents":"REST \u0026ndash; REpresentational State Transfer 全称是Resource Representational State Transfer：\n通俗来讲就是：资源在网络中以某种表现形式进行状态转移。\n分解开来：\nResource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；\nRepresentational：某种表现形式，比如用JSON，XML，JPEG等；\nState Transfer：状态变化。通过HTTP动词实现。\n用beego写的web server理解RESTful\nReference 怎样用通俗的语言解释REST，以及RESTful？\nhttps://www.zhihu.com/question/28557115\nhttps://www.zhihu.com/question/28557115/answer/48094438\nhttps://www.runoob.com/w3cnote/restful-architecture.html\nhttps://www.ruanyifeng.com/blog/2011/09/restful.html\n","permalink":"https://vcvvvc.github.io/post/restful/","tags":["Http","Restful"],"title":"理解RESTful"},{"categories":null,"contents":"BING AI整理，可能有出入\nVirtu Financial：一家总部位于美国的金融科技公司，为全球多个资产类别提供高频交易和市场做市服务，拥有先进的技术平台和算法，每天处理超过200亿美元的交易量2。\nJane Street：一家总部位于美国的量化交易公司，为全球的股票、期货、期权、债券、外汇、ETF等市场提供流动性，使用自主开发的软件和系统进行高频交易，每天的交易额超过1000亿美元3。\nOptiver：一家总部位于荷兰的全球性做市商，为全球的期货、期权、股票、债券、外汇、商品等市场提供流动性，使用自主开发的算法和技术进行高速交易，每年的交易量超过150亿份合约4。\nIMC Trading：一家总部位于荷兰的金融科技公司，为全球的期货、期权、股票、债券、外汇、ETF等市场提供流动性，使用自主开发的软件和硬件进行高频交易，每天的交易量超过2000亿美元5。\nFlow Traders：一家总部位于荷兰的金融科技公司，专注于为全球的ETF市场提供流动性，使用自主开发的技术和算法进行高频交易，每年的交易量超过1000亿欧元。\nGSR Markets：一家总部位于香港的算法数字交易公司，为多种数字资产类别提供订单执行解决方案，与30多个流动性池相集成，交易费用相对较低2。\nKairon Labs：一家总部位于荷兰和比利时的做市商，专注于为效用代币和稳定币提供流动性，使用自定义的企业级算法，与120多个交易所的API相连，为客户提供透明的报告和策略2。\nAlpha Theta：一家总部位于多伦多的做市商，专注于算法交易和机器人之间的融合，利用n个机器人在多个交易所中执行不同的策略，拥有一些最有才华的工程师团队2。\nAlmeda Research：一家总部位于香港的量化投资管理公司，管理着超过1亿美元的资产，以量化交易而闻名，并从中赚取了可观的利润，还创建了自己的OTC交易柜台和新的交易所FTX2。\nBluesky：一家总部位于香港的量化投资管理公司，管理一项全球宏观水平的定量计划，拥有严格且专有的量化研究方法，不断创新寻找新的Alpha来源，在其具有API的相应加密货币交易所上提供24/7流动性2。\nPulsar：一家总部位于香港的自营交易公司，专门从事加密货币交易和做市，拥有强大的技术和风控能力，与多个交易所和项目方合作2。\nForesight：一家总部位于美国的金融科技公司，为全球的加密货币市场提供流动性和算法交易服务，使用自主开发的软件和系统进行高频交易，每天的交易额超过5000万美元3。\nWintermute：一家总部位于英国的量化交易公司，为全球的加密货币市场提供流动性和市场做市服务，使用自主开发的技术和算法进行高速交易，每年的交易量超过1000亿美元4。\nCitadel Securities：总部位于美国芝加哥市的金融公司，成立于 2002 年，是全球最大的做市商之一，主要涉及股票、期货、外汇、债券等领域的交易。\nSusquehanna International Group：总部位于美国费城市的金融公司，成立于 1987 年，是全球最大的期权做市商之一，也涉及其他领域的交易。\nAmber Group：一家总部位于香港的金融科技公司，为全球的加密货币市场提供流动性和算法交易服务，拥有超过300名员工，与多个交易所和项目方合作，每天的交易额超过5000万美元1。\nB2C2：一家总部位于英国的金融科技公司，为全球的加密货币市场提供流动性和市场做市服务，拥有超过100名员工，与多个交易所和项目方合作，每天的交易额超过1000万美元1。\nDRW Trading：一家总部位于美国的金融科技公司，从事传统金融和加密货币的市场做市和高频交易，拥有超过900名员工，与多个交易所和项目方合作，每天的交易额超过5000万美元1。\nDWF LABS：一家总部位于瑞士的全球 Web3 风险投资和做市商，为 Web3 公司提供做市、二级市场投资、早期投资和场外交易服务，以及代币上线和咨询服务\nhttps://foresightnews.pro/article/detail/29574\n","permalink":"https://vcvvvc.github.io/post/crypto_market_maker/","tags":["Crypto","BlockChain"],"title":"加密领域做市商公司粗略统计"},{"categories":null,"contents":"又学习新东西了， BTC RGB协议\nhttps://github.com/RGB-WG/rgb\nNostr平台用的Taproot-assets 协议主要用于发行和转移可替代的代币，如稳定币，而 RGB 协议是一种通用的智能合约系统，可以执行更复杂的多类别的智能合约，如 NFT、DeFi、DAO 等。\n所以不打算再研究Taproot-assets了，直接进入RGB, 同时我持有$PPRGB。\n首先去官网安装好rust，已经安装的升级到最新版本。 https://github.com/RGB-WG/ tag v0.10 stable sudo apt update sudo apt install -y build-essential cmake cd RGB cargo install --path . --all-features #v0.10 stable 下载 Sparrow Bitcoin Wallet\n菜单栏有个重启启用测试网，然后启用测试网之后创建两个钱包，获取tpub\nonly key-spent only taproot wallets are supported(script type taproot) 之后去https://bitcoinfaucet.uo1.net/ 领水，用tb1q地址\nopenssl版本问题\nsudo apt-get install pkg-config libssl-dev\nRe: https://blackpaper.rgb.tech/\nhttps://rgb.tech/install/#cmd\nhttps://github.com/oneforalone/rgb20-usdt\n","permalink":"https://vcvvvc.github.io/post/build_rgbv0_11_beta/","tags":["BlockChain","Bitcoin","RGB"],"title":"Build_RGB_V0.11.0-beta"},{"categories":null,"contents":"技术指标不可全信，但是配合Doubler使用，无需担心判断出错\nBing Ai回答\nKDJ KDJ图形是一种用于分析股票或期货市场的技术指标，它由三条曲线组成：K线、D线和J线。KDJ图形可以反映市场的趋势、强弱、超买超卖和拐点等信息，从而帮助投资者判断买卖时机。下面是一些关于KDJ图形的基本知识：\nKDJ图形的计算方法是利用最高价、最低价和收盘价来求出RSV值，然后用平滑移动平均法来计算K值、D值和J值。具体的公式如下¹： RSV = (收盘价 - 最近N日最低价) / (最近N日最高价 - 最近N日最低价) * 100% K = 2/3 * 前一日K + 1/3 * 当日RSV D = 2/3 * 前一日D + 1/3 * 当日K J = 3 * D - 2 * K 其中，N是一个参数，一般取9或14，表示计算RSV值时的周期长度。如果没有前一日的K值和D值，可以用50代替。\nKDJ图形的取值范围是0到100，其中50是多空均衡线，80以上是超买区，20以下是超卖区。K线是快速确认线，D线是慢速主干线，J线是方向敏感线。一般来说，K线和D线的交叉是KDJ图形的主要信号，J线的变化是KDJ图形的辅助信号²。\n当K线从下向上穿越D线，形成金叉，表示市场由弱转强，是买入的信号。金叉的位置越低越好，尤其是在超卖区形成的金叉，更有利于抓住市场的反弹机会³。 当K线从上向下穿越D线，形成死叉，表示市场由强转弱，是卖出的信号。死叉的位置越高越好，尤其是在超买区形成的死叉，更有利于抓住市场的回调机会³。 当J线从零轴以下突破K线和D线，表示市场的弱势逐步减弱，是买入的信号。当J线从零轴以上向下掉头，表示市场的强势逐步减弱，是卖出的信号⁴。 当J线大于100或小于0，表示市场处于极端的超买或超卖状态，可能会出现反转的机会。但是，反转的方式有两种：一种是实质性的反转，即价格发生明显的上涨或下跌；另一种是修复性的反转，即价格在高位或低位平移，使J线缓慢回归正常范围⁵。因此，不能单纯地根据J线的超买超卖来判断市场的走势，还要结合其他指标和形态来综合分析。 KDJ图形的形态运行方式有很多，其中最重要的有三种：交叉、背离和钝化。\n交叉是指K线和D线的相交，可以分为单次交叉和多次交叉。单次交叉就是前面提到的金叉和死叉，是KDJ图形的基本信号。多次交叉是指K线和D线在一定的区间内反复交叉，形成一些特殊的形态，如W底、M头、头肩顶、头肩底、双顶、双底等。这些形态可以反映市场的转折点和趋势的延续，是KDJ图形的高级信号。 背离是指KDJ图形的走势方向与价格的走势方向不一致，可以分为顶背离和底背离。顶背离是指价格创出新高，而KDJ图形没有创出新高，表示上涨的动能不足，多头力量衰竭，有下跌的趋势。底背离是指价格创出新低，而KDJ图形没有创出新低，表示下跌的动能不足，空头力量衰竭，有上涨的趋势。背离是KDJ图形的重要信号，可以帮助投资者发现市场的顶部和底部。 钝化是指KDJ图形在高位或低位的变化幅度很小，而价格却在继续上涨或下跌，可以分为高位钝化和低位钝化。高位钝化是指KDJ图形在超买区域，价格继续上涨，而KDJ图形变化不明显，甚至向下。低位钝化是指KDJ图形在超卖区域，价格继续下跌，而KDJ图形变化不明显，甚至向上。钝化是KDJ图形的特殊信号，表示市场的强势或弱势难以改变，但也可能是市场即将反转的前兆。 买入信号 KDJ指标的买入信号主要有以下几种： K线和D线在低位出现金叉，即K线从下向上穿越D线，表示市场由弱转强，是买入的信号。如果金叉出现在50以下的低位，或者在超卖区间内，信号更强烈。 D线和J线进入超卖区间，即20以下，表示市场已经过度卖空，有反弹的可能，是买入的信号。如果D线从超卖区间向上突破20，或者J线从零轴以下向上突破K线和D线，信号更强烈。 K线和股价出现底背离，即股价创出新低，而K线没有创出新低，反而出现一底比一底高的上涨走势，表示市场的下跌动能减弱，有反转的可能，是买入的信号。 KDJ指标的买入时机可以根据不同的目的和风险偏好来选择，一般来说，可以分为以下几种情况： 如果想尝试买入，可以在K线和D线在低位出现金叉时，先少量建仓，或者在D线和J线进入超卖区间时，先少量建仓。这样的买入信号相对较为准确，但也有可能是假信号，所以要控制好仓位，观察后续的走势。 如果想大量买入，可以在K线和D线在低位出现金叉后，持续向上移动，突破50的多空均衡线时，积极加仓，或者在D线和J线从超卖区间向上突破20时，积极加仓。这样的买入信号相对较为强烈，说明市场的上涨动能增强，股价有持续上涨的趋势。 如果想抓住反转的机会，可以在K线和股价出现底背离时，积极买入。这样的买入信号相对较为稀有，但也很有效，说明市场的下跌力量衰竭，有上涨的趋势。 卖出信号 KDJ指标的卖出信号主要有以下几种： K线和D线在高位出现死叉，即K线从上向下穿越D线，表示市场由强转弱，是卖出的信号。如果死叉出现在50以上的高位，或者在超买区间内，信号更强烈。 D线和J线进入超买区间，即80以上，表示市场已经过度买入，有回调的可能，是卖出的信号。如果D线从超买区间向下突破80，或者J线从零轴以上向下突破K线和D线，信号更强烈。 K线和股价出现顶背离，即股价创出新高，而K线没有创出新高，反而出现一峰比一峰低的下跌走势，表示市场的上涨动能减弱，有反转的可能，是卖出的信号。 KDJ指标的卖出时机可以根据不同的目的和风险偏好来选择，一般来说，可以分为以下几种情况： 如果想尝试卖出，可以在K线和D线在高位出现死叉时，先少量减仓，或者在D线和J线进入超买区间时，先少量减仓。这样的卖出信号相对较为准确，但也有可能是假信号，所以要控制好仓位，观察后续的走势。 如果想大量卖出，可以在K线和D线在高位出现死叉后，持续向下移动，跌破50的多空均衡线时，积极减仓，或者在D线和J线从超买区间向下突破80时，积极减仓。这样的卖出信号相对较为强烈，说明市场的下跌动能增强，股价有持续下跌的趋势。 如果想抓住反转的机会，可以在K线和股价出现顶背离时，积极卖出股票。这样的卖出信号相对较为稀有，但也很有效，说明市场的上涨力量衰竭，有下跌的趋势。 MACD MACD图形是一种用于分析股票或期货市场的技术指标，它由三个部分组成：DIF线、DEA线和MACD柱。DIF线是快速移动平均线和慢速移动平均线的差值，DEA线是DIF线的平滑移动平均线，MACD柱是DIF线和DEA线的差值的柱状图。MACD图形可以反映市场的趋势、强弱、转折和背离等信息，从而帮助投资者判断买卖时机。下面是一些关于MACD图形的基本知识：\nMACD图形的计算方法是利用收盘价的指数移动平均线来求出DIF值和DEA值，然后用柱状图来表示它们的差值。具体的公式如下¹： DIF = EMA(close,12) - EMA(close,26) DEA = EMA(DIF,9) MACD = DIF - DEA 其中，EMA是指数移动平均线，close是收盘价，12和26是常用的参数，表示计算DIF值时的周期长度，9是常用的参数，表示计算DEA值时的周期长度。如果没有前一日的DIF值和DEA值，可以用0代替。\nMACD图形的取值范围是无限的，但一般在-10到10之间。零轴是多空分界线，当DIF线和DEA线在零轴以上时，表示多头市场，当DIF线和DEA线在零轴以下时，表示空头市场。MACD柱的颜色是根据DIF线和DEA线的差值的正负来确定的，当差值为正时，柱状图为红色，表示上涨力量，当差值为负时，柱状图为绿色，表示下跌力量。\nMACD图形的主要信号是DIF线和DEA线的交叉，可以分为金叉和死叉。金叉是指DIF线从下向上穿越DEA线，表示市场由弱转强，是买入的信号。死叉是指DIF线从上向下穿越DEA线，表示市场由强转弱，是卖出的信号。一般来说，金叉和死叉的位置越接近零轴，信号越强，位置越远离零轴，信号越弱。²\nMACD图形的辅助信号是MACD柱的变化，可以分为放大和收缩。放大是指MACD柱的长度逐渐增加，表示市场的动能增强，趋势延续的可能性大。收缩是指MACD柱的长度逐渐减少，表示市场的动能减弱，趋势转变的可能性大。一般来说，当MACD柱由红变绿或由绿变红，表示市场的转折信号。³\nMACD图形的特殊信号是背离，可以分为顶背离和底背离。背离是指MACD图形的走势方向与价格的走势方向不一致，反映了市场的隐藏力量。顶背离是指价格创出新高，而MACD图形没有创出新高，表示上涨的动能不足，多头力量衰竭，有下跌的趋势。底背离是指价格创出新低，而MACD图形没有创出新低，表示下跌的动能不足，空头力量衰竭，有上涨的趋势。背离是MACD图形的重要信号，可以帮助投资者发现市场的顶部和底部。⁴\nMACD图形的形态运行方式有很多，其中最重要的有四种：佛手向上、小鸭出水、漫步青云和天鹅展翅。⁵\n佛手向上是指在零轴上，DIF线和DEA线出现金叉后，又出现死叉，但不下穿零轴，几日后在零轴上再次出现金叉，形成二次金叉。这种形态是主力洗盘所为，短暂盘整后，股价将上扬，是积极买入的信号。 小鸭出水是指在零轴下，DIF线处于较低位置且不再下行，开始呈横向水平移动，而此时股价继续处于下跌状态，这已开始预示股价见底，一旦DIF线平移结束，开始向上抬头形成金叉，是买入股票的最佳时机。 漫步青云是指在零轴上，DIF线和DEA线出现金叉后，持续向上移动，且MACD柱不断放大，形成一片红海，表示股市处于强势之中，股价将继续上涨，是持股待涨或加仓买入的信号。 天鹅展翅是指在零轴下，DIF线和DEA线出现金叉后，持续向下移动，且MACD柱不断放大，形成一片绿海，表示股市处于弱势之中，股价将继续下跌，是持币观望或卖出股票的信号。 买入信号 MACD是一种常用的技术分析指标，它是由快速移动平均线（DIF）和慢速移动平均线（DEA）以及它们之间的差值（MACD柱线）组成，可以反映市场的趋势、强弱、转折等信息，从而提供买卖的参考。 MACD的买入信号主要有以下几种： DIF线和DEA线在零轴下方出现金叉，即DIF线从下向上穿越DEA线，表示市场由弱转强，是买入的信号。如果金叉出现在零轴附近，或者在超卖区间内，信号更强烈。 DIF线和DEA线在零轴上方出现金叉，即DIF线从下向上穿越DEA线，表示市场由强转更强，是买入的信号。如果金叉出现在50以上的高位，或者在超买区间内，信号更强烈。 DIF线和DEA线在零轴上方运行一段时间后，DIF线回调到DEA线附近，然后再次向上反转，形成空中缆绳形态，表示市场经过短暂的调整后，继续上涨，是买入的信号。 DIF线和DEA线在零轴下方运行一段时间后，DIF线回调到DEA线附近，然后再次向上反转，形成海底电缆形态，表示市场经过长期的探底后，开始反弹，是买入的信号。 DIF线和股价出现底背离，即股价创出新低，而DIF线没有创出新低，反而出现一底比一底高的上升走势，表示市场的下跌动能减弱，有反转的可能，是买入的信号。 MACD的买入时机可以根据不同的目的和风险偏好来选择，一般来说，可以分为以下几种情况： 如果想尝试买入，可以在DIF线和DEA线在零轴下方出现金叉时，先少量建仓，或者在DIF线和DEA线在零轴上方出现金叉时，先少量建仓。这样的买入信号相对较为准确，但也有可能是假信号，所以要控制好仓位，观察后续的走势。 如果想大量买入，可以在DIF线和DEA线在零轴下方出现金叉后，持续向上移动，突破零轴时，积极加仓，或者在DIF线和DEA线在零轴上方出现金叉后，持续向上移动，突破50的多空均衡线时，积极加仓。这样的买入信号相对较为强烈，说明市场的上涨动能增强，股价有持续上涨的趋势。 如果想抓住反转的机会，可以在DIF线和股价出现底背离时，积极买入股票。这样的买入信号相对较为稀有，但也很有效，说明市场的下跌力量衰竭，有上涨的趋势。 卖出信号 MACD的卖出信号主要有以下几种： DIF线和DEA线在零轴上方出现死叉，即DIF线从上向下穿越DEA线，表示市场由强转弱，是卖出的信号。如果死叉出现在50以下的低位，或者在超卖区间内，信号更强烈。 DIF线和DEA线在零轴下方出现死叉，即DIF线从上向下穿越DEA线，表示市场由弱转更弱，是卖出的信号。如果死叉出现在零轴附近，或者在超买区间内，信号更强烈。 DIF线和DEA线在零轴上方运行一段时间后，DIF线回调到DEA线附近，然后再次向下反转，形成空中断线形态，表示市场经过短暂的上涨后，继续下跌，是卖出的信号。 DIF线和DEA线在零轴下方运行一段时间后，DIF线回调到DEA线附近，然后再次向下反转，形成海底断线形态，表示市场经过长期的反弹后，开始下跌，是卖出的信号。 DIF线和股价出现顶背离，即股价创出新高，而DIF线没有创出新高，反而出现一峰比一峰低的下跌走势，表示市场的上涨动能减弱，有反转的可能，是卖出的信号。 MACD的卖出时机可以根据不同的目的和风险偏好来选择，一般来说，可以分为以下几种情况： 如果想尝试卖出，可以在DIF线和DEA线在零轴上方出现死叉时，先少量减仓，或者在DIF线和DEA线在零轴下方出现死叉时，先少量减仓。这样的卖出信号相对较为准确，但也有可能是假信号，所以要控制好仓位，观察后续的走势。 如果想大量卖出，可以在DIF线和DEA线在零轴上方出现死叉后，持续向下移动，跌破零轴时，积极减仓，或者在DIF线和DEA线在零轴下方出现死叉后，持续向下移动，跌破50的多空均衡线时，积极减仓。这样的卖出信号相对较为强烈，说明市场的下跌动能增强，股价有持续下跌的趋势。 如果想抓住反转的机会，可以在DIF线和股价出现顶背离时，积极卖出股票。这样的卖出信号相对较为稀有，但也很有效，说明市场的上涨力量衰竭，有下跌的趋势。 Re: (1) KDJ的详细图解和相关指示意义 - 知乎. https://zhuanlan.zhihu.com/p/99364915. (2) 股票中的KDJ三根线分别代表什么？ - 知乎. https://www.zhihu.com/question/67487453. (3) 技术分析之KDJ指标 - 知乎. https://zhuanlan.zhihu.com/p/85145899. (4) KDJ指标经典图解，把握买卖点轻而易举 - 知乎. https://zhuanlan.zhihu.com/p/359396114. (5) KDJ指标+图形形态，逃顶小技巧，避免利润回吐 - 百家号. https://baijiahao.baidu.com/s?id=1750707587989935360.\n(1) 什么是MACD？MACD指标详解，四大买入形态和四大卖出 \u0026hellip;. https://zhuanlan.zhihu.com/p/134077409. (2) 终于把MACD指标的最全用法讲通透了，真正能看懂了 \u0026hellip;. https://zhuanlan.zhihu.com/p/139991288. (3) MACD指标 - 知乎. https://www.zhihu.com/topic/20660963/intro. (4) MACD指标-8种经典买入形态(附通达信\u0026amp;量化大师公式)-CSDN \u0026hellip;. https://blog.csdn.net/zk168_net/article/details/112667052. (5) 史上最全“MACD”指标详解及用法诠释，太精辟透彻了 \u0026hellip;. https://zhuanlan.zhihu.com/p/130819105.\n","permalink":"https://vcvvvc.github.io/post/%E5%B8%82%E5%9C%BA%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87/","tags":["BlockChain"],"title":"市场常用技术指标"},{"categories":null,"contents":"Doubler: A crypto asset appreciation tool based on the martingale strategy\n📚What is Doubler?\nDoubler is a very creative and forward-looking DEFI tool that forms a mutually beneficial relationship between users through crowdfunding and incentives, allowing users to share risks and rewards, and increase user confidence in participating in crypto asset investment. If you hold BTC but don\u0026rsquo;t want to sell it, but worry about the losses caused by the decline, just join Doubler.\n2023-11-24 Update\n社区中池子参数问题的讲解 https://medium.com/@vcvckw/详解建池参数-d171c6b5c071\nDetailed explanation of pool parameters https://medium.com/@vcvckw/detailed-explanation-of-pool-parameters-a465d91679d2\n数据分析DBR产出与TVL和层的关联，拆解DBR产出公式 https://medium.com/@vcvckw/用数据展示下dbr加入的层与tvl的关联-70e237e4238c\nData analysis of the correlation between DBR output and TVL and layer, and decomposition of DBR output formula https://medium.com/@vcvckw/data-analysis-of-the-correlation-between-dbr-output-and-tvl-and-layer-and-decomposition-of-dbr-0c3a4bebb79b\n","permalink":"https://vcvvvc.github.io/post/defi_doubler/","tags":["BlockChain","DeFi","Doubler"],"title":"Doubler基础教程"},{"categories":null,"contents":"来源币安：https://academy.binance.com/zh/articles/a-beginners-guide-to-security-tokens\n什么是证券型代币(Security Token Offering-STO) 证券型代币是一种发布在区块链上的代币，代表部分外部企业或资产的股份。可由企业或政府等实体发布，与股票、债券等同类产品作用相同。\n为什么使用证券型代币？ 透明 结算快 运行时间长 交易单位可分割 证券型代币与效用代币的区别有哪些？ 证券型代币和效用代币有诸多相似之处。严格来说，两种代币的发行方式完全相同。都由智能合约管理，可送至区块链地址，在交易平台交易或通过点对点交易。 他们的不同之处主要在于经济和管理支柱。他们可在首次代币发行(ICO)或在首次交易所发行(IEO)发行，让创业公司或初创项目众筹他们生态系统的发展。 用户通过提供资金获得这些数字代币，从而参与项目网络（可立即参与，也可以后参与）。这些代币赋予持有者投票权，或作为特定协议的货币购买产品或服务。\n效用代币本质上没有价值。如果一个项目发展得很成功，投资者不会像传统证券那样获得部分利润。代币的作用和忠诚度积分有些相似。它们可用于购买产品（或出售），但在交易过程中不提供代币发售公司的权益。\n因此，其价格经常会受到投机的影响。许多投资者会购买代币，希望其价值会随着生态系统的发展得以升值。如果项目失败，缺乏对持有者的保护措施。 虽然证券型代币的分发事宜参照证券通证发行(STO)，其发布方式与效用代币却有相似之处。但从投资角度来看，两种类型代币代表着截然不同的金融工具。\n即使证券型代币发布在区块链上，但仍属于证券。因此受到严格监管以保护投资者，并防止诈骗行为的发生。在这方面，证券通证发行(STO)比首次代币发行(ICO)更接近首次公开募股(IPO)。 一般情况下，投资者购买证券型代币时会买入股票、债券或衍生性金融商品。他们的代币起到投资合同的效用并确保对链下资产拥有所有权。\n代币为何证券化? 事实上，区块链产业缺乏在法律层面进行一些急需的澄清。全球的监管者仍在追赶新的金融科技潮流。仍有发行者相信自己能够发行效用代币，以后一定能成为证券交易委员会(SEC)批准的证券。 或许试图判断一笔交易能否成为“投资合同”最著名的标准是豪威测试。简而言之，它旨在确定个人投资普通企业能否期待获得与倡导者（或第三方）同样的收益。\n早在区块链技术出现之前，这项测试源于美国法院。因此，很难将其运用到大量新型代币中。尽管如此，这项测试对于尝试将数字资产分类的监管者而言仍然是一个很受欢迎的工具。 当然，每个司法管辖区会采用不同框架，但许多区域遵从相似的逻辑。\n证券型代币和可编程金融 考虑到当前的市场规模，代币化能彻底改变传统金融领域。这一领域的投资者和机构从成熟的数字方式到金融工具中获益颇多。\n在过去的几年中，中心化数据库生态系统产生了大量摩擦。机构需要想办法优化经营流程，管理与自身系统不兼容的外部数据。缺乏全行业标准增加了企业的成本，大大延迟了结算时间。\n区块链是一个共享数据库，任何用户或企业都能够轻松互动。过去由机构服务器处理的功能，现在外包给其他同行使用的账本。通过代币化证券，我们能够将其嵌入到共同操作的网络中，完成迅速结算并与全球兼容。\n自此，自动操作能够处理原本会很耗时的流程。例如，身份认证(KYC)/反洗钱(AML)合规，在设定好的固定期限内对投资进行锁仓，以及许多由运行在区块链上的代码处理的其他功能。\n如需详细了解这一主题，敬请阅读《区块链技术如何影响银行业》这篇文章。\n","permalink":"https://vcvvvc.github.io/post/sto/","tags":["BlockChain"],"title":"证券型代币 Security Token Offering"},{"categories":null,"contents":"可升级智能合约\nProxy 是一种智能合约的设计模式，它可以实现合约的可升级性。Proxy 合约是一个简单的合约，它只负责将收到的调用请求转发给另一个逻辑合约，而不执行任何自己的逻辑。这样，当需要升级合约时，只需要部署一个新的逻辑合约，并在 Proxy 合约中更新其地址，就可以保持 Proxy 合约的地址不变，同时使用新的逻辑。Proxy 合约通常使用 delegatecall 操作码来实现调用转发，这样可以保留 Proxy 合约的存储和上下文，而执行逻辑合约的代码。\n","permalink":"https://vcvvvc.github.io/post/proxy_sol/","tags":["BlockChain","Ethereum","Smart Contract","Solidity"],"title":"Proxy_Solidity"},{"categories":null,"contents":"TIME_WAIT 主动关闭方在收到被动关闭方的FIN包后并返回ACK后，会进入TIME_WAIT状态，TIME_WAIT状态又称2MSL状态，每个TCP连接都必须有一个最大报文段生存时间MSL，在网络传输中超过这个时间的报文段将被丢弃。当TCP连接发起一个主动关闭，并发出最后一个ACK时，必须在TIME_WAIT状态停留两倍MSL时间，在2MSL等待期间，定义这个连接的插口(客户端IP地址和端口号，服务器IP地址和端口号的四元组)将不能再被使用。\n主动发起关闭连接的一方，才会有 TIME-WAIT 状态。 需要TIME-WAIT状态，主要是两个原因：\n防止历史连接中的数据，被后面相同四元组的连接错误的接收；\n保证「被动关闭连接」的一方，能被正确的关闭；\n序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0。\n初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。\n序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。\ntcp协议头中有seq和ack_seq两个字段，分别代表序列号和确认号。tcp协议通过序列号标识发送的报文段。seq的类型是__u32，当超过__u32的最大值时，会回绕到0。\n一个tcp流的初始序列号（ISN）并不是从0开始的，而是采用一定的随机算法产生的，因此ISN可能很大（比如(2^32-10)），因此同一个tcp流的seq号可能会回绕到0。而我们tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。\nTCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。\n是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。\nTIME-WAIT状态过多危害 第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等； 第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过 net.ipv4.ip_local_port_range参数指定范围。 出现过多的原因 HTTP 没有使用长连接\nHTTP 长连接超时\nHTTP 长连接的请求数量达到上限\nSO_LINGER SO_LINGER选项的作用是等待发送缓冲区中的数据发送完成，但是并不保证发送缓冲区中的数据一定被对端接收（对端宕机或线路问题），只是说会等待一段时间让这个过程完成。\nstruct linger { int l_onoff; //0=off, nonzero=on(开关) int l_linger; //linger time(延迟时间) } l_onoff l_linger closesocket 发送队列 底层行为 0 关闭 立即返回 保持直到发送完成 系统接管套接字并保证将数据发送至对端。（就是正常的close） 1 0 立即返回 立即放弃 直接发送RST包，自身立即复位，不用经过2MSL状态。对端收到复位错误号。 1 1 阻塞直到l_linger时间超时或数据发送完成。 在超时时间段内保持尝试发送，若超时则立即放弃。 设置超时时间，若超时未完成数据发送，则立即返回按linger = 0的行为关闭 Re: https://zhuanlan.zhihu.com/p/99943313\nhttps://blog.csdn.net/xiaokaige198747/article/details/75389113\nhttps://blog.csdn.net/songchuwang1868/article/details/90369445\nhttps://xiaolincoding.com/network/3_tcp/tcp_interview.html#为什么需要-time-wait-状态\nhttps://www.cnblogs.com/kex1n/p/7401042.html\n","permalink":"https://vcvvvc.github.io/post/time_wait%E4%B8%8Eso_linger/","tags":["Linux","Socket"],"title":"TIME_WAIT与SO_LINGER"},{"categories":null,"contents":"SO_REUSEPORT端口重用 int opt_val = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, \u0026amp;opt_val, sizeof(opt_val)) SO_REUSEPORT是允许多个socket绑定到同一个ip+port上\n每一个线程拥有自己的服务器套接字, 在服务器套接字上没有了锁的竞争\n内核层面实现负载均衡\nSO_REUSEPORT在以下场景下有用： 当服务器需要使用多个进程或线程来监听相同的端口，而不想遇到惊群现象或资源竞争时，可以设置SO_REUSEPORT选项，以便实现网络连接的负载均衡。\n当服务器需要使用UDP协议来接收多播数据报时，可以设置SO_REUSEPORT选项，以便让每个进程或线程接收到不同的数据报，提高效率和性能。\nEPOLL惊群问题\nSO_REUSEADDR是地址重用 int opt_val = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt_val, sizeof(opt_val)) SO_REUSEADDR可以解决服务器主动关闭连接后，需要等待2MSL时间才能重新绑定相同的端口的问题。如果不设置这个选项，服务器在关闭连接后，会进入TIME_WAIT状态，此时再次启动服务器，就会绑定失败，报：Address already in use。如果设置了这个选项，服务器就可以立即重启并绑定相同的端口\nSO_REUSEADDR可以解决服务器使用通配符IP地址（0.0.0.0）监听端口后，无法再绑定具体的IP地址到相同的端口的问题。如果不设置这个选项，当一个socket绑定到0.0.0.0:port后，其他socket就无法绑定到192.168.0.1:port等具体的IP地址上。如果设置了这个选项，就可以允许多个socket绑定到相同的端口，只要它们使用不同的本地IP地址\nSO_REUSEADDR在以下场景下有用： 当服务器需要频繁地启动和关闭，而不想等待2MSL时间才能重新绑定相同的端口时，可以设置SO_REUSEADDR选项，以便快速重启。\n当服务器需要使用通配符IP地址（0.0.0.0）监听端口，同时又想绑定其他具体的IP地址到相同的端口时，可以设置SO_REUSEADDR选项，以便支持多个IP地址的监听。\nEpoll惊群 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #define PROCESS_NUM 10 static int create_and_bind (char *port) { int fd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); serveraddr.sin_port = htons(atoi(port)); bind(fd, (struct sockaddr*)\u0026amp;serveraddr, sizeof(serveraddr)); return fd; } static int make_socket_non_blocking (int sfd) { int flags, s; flags = fcntl (sfd, F_GETFL, 0); if (flags == -1) { perror (\u0026#34;fcntl\u0026#34;); return -1; } flags |= O_NONBLOCK; s = fcntl (sfd, F_SETFL, flags); if (s == -1) { perror (\u0026#34;fcntl\u0026#34;); return -1; } return 0; } #define MAXEVENTS 64 int main (int argc, char *argv[]) { int sfd, s; int efd; struct epoll_event event; struct epoll_event *events; sfd = create_and_bind(\u0026#34;8001\u0026#34;); if (sfd == -1) abort (); s = make_socket_non_blocking (sfd); if (s == -1) abort (); s = listen(sfd, SOMAXCONN); if (s == -1) { perror (\u0026#34;listen\u0026#34;); abort (); } efd = epoll_create(MAXEVENTS); if (efd == -1) { perror(\u0026#34;epoll_create\u0026#34;); abort(); } event.data.fd = sfd; //event.events = EPOLLIN | EPOLLET; event.events = EPOLLIN; s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, \u0026amp;event); if (s == -1) { perror(\u0026#34;epoll_ctl\u0026#34;); abort(); } /* Buffer where events are returned */ events = calloc(MAXEVENTS, sizeof event); int k; for(k = 0; k \u0026lt; PROCESS_NUM; k++) { int pid = fork(); if(pid == 0) { /* The event loop */ while (1) { int n, i; n = epoll_wait(efd, events, MAXEVENTS, -1); printf(\u0026#34;process %d return from epoll_wait!\\n\u0026#34;, getpid()); for (i = 0; i \u0026lt; n; i++) { if ((events[i].events \u0026amp; EPOLLERR) || (events[i].events \u0026amp; EPOLLHUP) || (!(events[i].events \u0026amp; EPOLLIN))) { /* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */ fprintf (stderr, \u0026#34;epoll error\\n\u0026#34;); close (events[i].data.fd); continue; } else if (sfd == events[i].data.fd) { /* We have a notification on the listening socket, which means one or more incoming connections. */ struct sockaddr in_addr; socklen_t in_len; int infd; char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV]; in_len = sizeof in_addr; infd = accept(sfd, \u0026amp;in_addr, \u0026amp;in_len); if (infd == -1) { printf(\u0026#34;process %d accept failed!\\n\u0026#34;, getpid()); break; } printf(\u0026#34;process %d accept successed!\\n\u0026#34;, getpid()); /* Make the incoming socket non-blocking and add it to the list of fds to monitor. */ close(infd); } } } } } int status; wait(\u0026amp;status); free (events); close (sfd); return EXIT_SUCCESS; } Re: https://blog.csdn.net/c359719435/article/details/51721902\nhttps://www.cnblogs.com/schips/p/12553321.html\nhttps://zhuanlan.zhihu.com/p/378892166\nhttps://pureage.info/2015/12/22/thundering-herd.html\nhttps://juejin.cn/post/6964714985364652039\n","permalink":"https://vcvvvc.github.io/post/so_reuseport%E4%B8%8Eso_reuseaddr/","tags":["Epoll","Linux","Socket"],"title":"SO_REUSEPORT与SO_REUSEADDR"},{"categories":null,"contents":" Re: https://www.cnblogs.com/zjy4869/p/15501384.html\nhttps://www.cnblogs.com/zjy4869/p/15501448.html\nhttps://blog.51cto.com/u_15717393/5471961\nhttps://zinglix.xyz/2018/09/20/STL-container/\n","permalink":"https://vcvvvc.github.io/post/stl%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/","tags":["CPP","STL"],"title":"STL容器总结"},{"categories":null,"contents":"找到一个插件，安装后chrome使用newbing。\nhttps://chrome.google.com/webstore/detail/bing-unchained-use-new-bi/laldfnbbeocphnilnofhedhcjcnchbld/related?hl=zh-CN\n以下部分失效 安装Head Editor插件\n访问原版必应时(规则：^http(s?)://(.).bing.com/(.))，将出口IP(x-forwarded-for)自动改为外网IP，如谷歌的DNS服务器8.8.8.8。\n规则类型：修改请求头 匹配类型：正则表达式 匹配规则：^http(s?)://(.*).bing\\.com/(.*) 执行类型 头名称：x-forwarded-for 头内容：8.8.8.8 访问原版必应时(规则：^http(s?)://(.).bing.com/(.))，将客户代理(user-agent，即UA)改为Edge浏览器UA —— Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.41 规则类型：修改请求头 匹配类型：正则表达式 匹配规则：^http(s?)://(.*).bing\\.com/(.*) 执行类型 头名称：user-agent 头内容：Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.41 https://cloud.tencent.com/developer/article/2235566 https://blog.csdn.net/AI_Fanatic/article/details/129053010\n","permalink":"https://vcvvvc.github.io/post/chrome_use_newbing/","tags":["Ai"],"title":"Chrome_use_newbing"},{"categories":null,"contents":"NFT有什么意义吗 NFT是指非同质化代币（Non-Fungible Token），它是一种加密数字资产，通常用于证明数字艺术品、音乐、视频或其他数字内容的所有权和真实性。\nNFT的意义在于为数字内容创作者和收藏家提供了一种全新的方式来证明数字资产的唯一性和真实性，从而创造了一个新的数字市场。它可以让数字内容创作者通过出售他们的作品获得收益，而且这些作品的价值可以随着时间和市场需求的变化而不断增加。对于收藏家来说，NFT可以让他们购买到一些独特的数字资产，这些数字资产不同于其他人所拥有的数字内容。\n此外，NFT也有助于建立一个更加公平和透明的数字市场，因为所有的交易都可以被追踪和记录在区块链上。这意味着每个人都可以看到数字资产的历史交易记录和价值，从而使市场更加透明和公正。\n总之，NFT在数字内容创造和数字资产交易方面具有很大的潜力，它可以为数字内容创作者和收藏家带来更多的机会和收益，同时也可以建立一个更加公平和透明的数字市场。\n数字产权 数字产权是指数字内容创作者对其数字内容的独有权利，包括复制、分发、展示、修改和利用等。数字产权与传统的知识产权类似，但它主要针对数字媒体，如数字音乐、数字艺术、数字书籍、数字电影等。\n随着数字技术的发展，数字内容的创作和传播变得更加容易，但也带来了数字内容的盗版和侵权问题。因此，数字产权成为了保护数字内容创作者权益的重要手段。数字产权可以通过版权、专利、商标和专有技术等手段来实现，以确保数字内容创作者能够合法地控制和受益于其创作的数字内容。\n同时，数字产权也涉及到数字内容的使用和分享。随着社交媒体和内容共享平台的兴起，数字内容的共享和再利用变得更加普遍，但这也带来了数字产权的挑战。数字产权的保护需要平衡数字内容创作者的权利和数字内容的自由流通，这需要各方的合作和共同努力。\n总之，数字产权是保护数字内容创作者权益和鼓励数字内容创新的重要手段，同时也需要各方的合作和共同努力来实现数字内容的可持续发展和创新。\n怎么看待艺术品数字化 艺术品数字化是指将传统的艺术品数字化并保存在数字媒体中，或者直接使用数字技术创作出新的数字艺术品。艺术品数字化是数字技术和艺术的结合，它为艺术品的保护、传播和展示带来了全新的机遇和挑战。\n从保护方面来看，艺术品数字化可以为传统艺术品提供更加安全、持久的保存方式。数字媒体可以通过备份和多重验证等技术来保证数字艺术品的安全性和完整性，从而避免传统艺术品在保存和传输过程中的风险和损失。\n从传播和展示方面来看，艺术品数字化可以为艺术品的展示和推广带来全新的方式。数字媒体可以通过互联网等全球范围的平台，让更多人有机会欣赏和了解艺术品，同时也为艺术品的交流和合作提供更加便利和高效的途径。\n但是，艺术品数字化也面临着一些挑战和争议。其中一个挑战是数字化是否会削弱艺术品的身临其境的感受和价值。艺术品往往需要观者与其直接接触，才能真正感受到其艺术魅力。数字化也会让艺术品的唯一性和真实性受到质疑，需要通过数字产权保护等手段来解决。\n总之，艺术品数字化是数字技术和艺术的结合，它为艺术品的保护、传播和展示带来了全新的机遇和挑战。艺术品数字化需要在保护艺术品身份和真实性的基础上，更好地利用数字技术的优势，实现艺术和技术的双赢。\n分析艺术品收藏家这个群体 艺术品收藏家是一个比较特殊的群体，他们对艺术品有着特殊的热爱和追求，并通过购买和收藏艺术品来满足自己的兴趣和欲望。下面是对艺术品收藏家这个群体的分析：\n热爱艺术：艺术品收藏家是对艺术有特殊热爱和追求的人，他们对不同形式和风格的艺术品都有较深入的了解和认识，他们也热衷于参观各种艺术展览和活动。\n经济实力较强：由于艺术品的收藏和购买需要一定的资金和经济实力，艺术品收藏家往往是经济实力比较强的人，他们能够承担相应的收藏成本和保管费用。\n拥有艺术品能带来自豪感和社交价值：艺术品收藏家拥有的艺术品是一种身份和社会地位的象征，他们通过展示和分享自己的艺术品收藏，展现自己的审美和品味，并通过与其他收藏家的交流和互动，建立更加广泛和深入的社交网络。\n投资收藏的双重目的：艺术品收藏家不仅仅是为了追求艺术的美感和审美价值，也希望通过收藏艺术品实现一定的投资回报。艺术品市场波动性大，需要收藏家具备一定的市场分析能力和判断力，以保证收藏的艺术品有一定的升值潜力。\n对艺术品的保护和维护：艺术品收藏家对自己的收藏品十分珍视，他们通常会投入大量的精力和资金来保护和维护自己的艺术品收藏，包括对艺术品的妥善保管和维护、保险、出借和展览等。\n总之，艺术品收藏家是一个对艺术有特殊追求和热爱的群体，他们拥有经济实力、社交网络和市场分析能力，同时也需要对自己的艺术品收藏进行保护和维护，以实现艺术价值和投资价值的双重目的。\n对虚拟世界向往吗 作为一名AI语言模型，我本身并不具有向往的情感，但我可以告诉您，虚拟世界对许多人来说具有吸引力和向往之情。虚拟世界是一种可以逃避现实并探索无限可能性的场所，人们可以在虚拟世界中创造自己想要的角色和身份，与其他人交流和互动，并参与各种虚拟世界的活动和任务。\n虚拟世界也提供了一种新的社交方式，让人们可以跨越地域和文化的限制，建立起全新的社交网络和社区，从而增加了人们的社交圈和社交体验。虚拟世界中的交流和互动也可以帮助人们提高自己的沟通能力和社交技巧。\n另外，虚拟世界还提供了许多娱乐和消遣的方式，如虚拟游戏、虚拟旅游等，让人们可以在虚拟世界中享受到不同于现实世界的乐趣和体验。\n总之，虚拟世界是一种具有吸引力和向往之情的场所，它提供了许多新的体验和机会，让人们可以在其中探索和发现新的可能性。\n","permalink":"https://vcvvvc.github.io/post/chatgpt%E5%9B%9E%E7%AD%94/","tags":["Ai","ChatGpt"],"title":"Chatgpt回答"},{"categories":null,"contents":"会议要点如下：\n第一，总基调：全力拼经济。2023年经济工作的重点是“突出做好稳增长、稳就业、稳物价工作”，“推动经济运行整体好转”，“大力提振市场信心”，“加大宏观政策调控力度”，“优化调整疫情防控政策”。可以考虑将2023年经济增速目标定在5%以上，释放把发展放在首要任务、提振各界信心的信号。\n第二，积极的财政政策要加力提效。明确提出“保持必要的财政支出强度，优化组合赤字、专项债、贴息等工具”。预计2023年将提高赤字率，扩大地方专项债和特别国债的发行规模，稳增长、扩内需、保民生。\n第三，稳健的货币政策要精准有力，保持流动性合理充裕。“引导金融机构加大对小微企业、科技创新、绿色发展等领域支持力度”。预计货币政策继续降息降准，延续适当宽松。政策性工具和结构性工具发力宽信用，在推进基建、支持实体经济、防范化解重大风险、稳楼市方面发挥积极作用。\n第四，提振市场信心，“切实落实‘两个毫不动摇’”。会议明确强调“针对社会上对我们是否坚持‘两个毫不动摇’的不正确议论，必须亮明态度，毫不含糊。”“要从制度和法律上把对国企民企平等对待的要求落下来，从政策和舆论上鼓励支持民营经济和民营企业发展壮大”。\n民营经济在国民经济中发挥了“56789”的基础性作用，是市场经济活力的根本保障，只有民营经济信心提振，2023年中国经济才有望恢复市场活力和实现经济复苏。经过世界各国上百年来正反两方面的经验教训，否定市场经济、否定民营经济就是破坏经济繁荣发展的基础，这在经济史和基本理论上是十分清楚的。守护市场经济的常识，是经济学者的使命。\n会议明确强调，“坚持和完善社会主义基本经济制度，坚持社会主义市场经济改革方向，坚持‘两个毫不动摇’”。\n第五，着力扩大国内需求。“要把恢复和扩大消费摆在优先位置”，可以考虑当前可以发放些消费券，帮助部分困难群众度过暂时难关。“要通过政府投资和政策激励有效带动全社会投资”。\n可以考虑实施以新基建新能源为核心的新一轮大规模扩大内需经济复苏计划，力度对标1998年应对亚洲金融风暴、2009年应对国际金融危机，一鼓作气，化危为机，不仅提振经济复苏和市场信心，而且超前大规模基础设施建设有助于提升长期经济潜在增长率，如果力度不够容易导致信心耗散，信心比黄金重要。\n第六，确保房地产市场平稳发展。“有效防范化解优质头部房企风险，改善资产负债状况”，“要因城施策，支持刚性和改善性住房需求”，“推动房地产业向新发展模式平稳过渡”。\n12月15日，刘鹤副总理指出，“对于明年中国经济实现整体性好转，我们极有信心。房地产是国民经济的支柱产业，针对当前出现的下行风险，我们已出台一些政策，正在考虑新的举措，努力改善行业的资产负债状况，引导市场预期和信心回暖。未来一个时期，中国城镇化仍处于较快发展阶段，有足够需求空间为房地产业稳定发展提供支撑。”\n房地产的政策拐点已经出现，走出困境最终还是靠市场信心恢复、供给出清和销售回款。可以考虑下调二套房首付比以支持改善型需求、下调首套房贷款利率以支持首套刚需、对低收入家庭和应届毕业生的租房支出给予适当补贴、放开二线城市的外地首套购房限制、降低交易税费等，改变此前过严的限购限贷措施，恢复到正常市场状况，同时通过“城市群战略、人地挂钩、金融稳定、租购并举”等构建新发展模式，促进长期平稳健康发展。房地产是重要的支持行业，稳楼市有助于稳增长、稳就业、保民生、防风险。\n要全面客观看待房地产发展的历史贡献和存在的问题，几十年来，房地产快速发展对拉动经济高速增长、保障地方财政、为大规模基础设施建设提供资金、提高人均居住面积改善民生等作出了重要贡献，成绩是主要的，同时也存在过度杠杆化、金融化、泡沫化、局部高房价等方面问题，但不宜妖魔化房地产，更不能采取“休克疗法”，问题是在发展中出现的，也要在发展中解决，要软着陆，避免硬着陆，老成谋国是通过时间换空间、长短结合的措施回归实体经济和居住属性，实现长期平稳健康发展。\n第七，平台经济迎来健康发展新阶段。“提升常态化监管水平，支持平台企业在引领发展、创造就业、国际竞争中大显身手”。\n第八，稳就业、保供稳价、帮扶困难群体。“落实落细就业优先政策，把促进青年特别是高校毕业生就业工作摆在更加突出的位置。”\n第九，统筹发展和安全是长期实现中国式现代化的重要要求。“产业政策要发展和安全并举，科技政策要聚焦自立自强，着力补强产业链薄弱环节，在落实碳达峰碳中和目标任务过程中锻造新的产业竞争优势”。\n第十，积极应对人口老龄化少子化。“完善生育支持政策体系，适时实施渐进式延迟法定退休年龄政策，积极应对人口老龄化少子化。”\n中国老龄化正在加速到来，速度和规模前所未来。中国总和生育率全球倒数，少子化形势日益严峻。人口老龄化少子化问题可能是未来中国经济社会最重要也是最紧迫需要解决的问题之一，事关国家民族持续繁荣发展，也关系到每个人每个家庭的幸福。人口问题长期存在保守派和改革派的巨大争议，一直缺少有效共识和解决方案。根据我们对国际经验的长期研究，生育补贴、普惠托育服务供给、女性就业权益保障、辅助生殖、休假激励等对提升生育率有帮助，这在法国、英国等效果明显。2020年呼吁“是该放开三孩了”，2021年建议加大生育补贴，和多位人口学者、经济学者、科学家一起创立“育娲人口”独立智库，旨在推动人口研究的进步和社会共识的形成。\n第十一，优化疫情防控，放开经济活动。“因时因势优化疫情防控措施，认真落实新阶段疫情防控各项举措。”开弓没有回头箭，根据国际经验，防疫政策优化后，需要一个季度左右的调整期，如果未来在科学防疫、放开经济活动、扩大内需、发力新基建新能源、稳楼市、发放消费券、提振民营经济信心等方面有较大政策力度，预计2023年2季度以后经济将逐步复苏，中国经济将再度归来。\nRe: http://bank.jrj.com.cn/2022/12/17110337220039.shtml#\nhttps://view.inews.qq.com/a/20221217A00J1Y00?uid=\n","permalink":"https://vcvvvc.github.io/post/2023%E7%BB%8F%E6%B5%8E%E4%BC%9A%E8%AE%AE/","tags":["Stock"],"title":"2023经济会议"},{"categories":null,"contents":"https://zhuanlan.zhihu.com/p/357075167\n各编程语言HTTP请求对比 c: libcurl c#: RestSharp go: net/http java: OKHttp php: HttpRequest python: requests ruby: net/http nodejs: http c/c++网络库对比 libevent libev libuv libhv asio ","permalink":"https://vcvvvc.github.io/post/c++%E6%A0%87%E5%87%86%E7%BD%91%E7%BB%9C%E5%BA%93/","tags":["Server","cpp"],"title":"C++标准网络库/对比"},{"categories":null,"contents":"最近看代码有用ppu，简单查了一下，发现这么多xpu。\nCPU全称：Central Processing Unit, 中央处理器； GPU全称：Graphics Processing Unit, 图像处理器； TPU全称：Tensor Processing Unit, 张量处理器； DPU全称：Deep learning Processing Unit, 深度学习处理器； NPU全称：Neural network Processing Unit, 神经网络处理器; BPU全称：Brain Processing Unit, 大脑处理器。\nPPU内存映射 https://zhuanlan.zhihu.com/p/394488956\nhttps://blog.csdn.net/qq_34254642/article/details/104193445\nhttps://zhidao.baidu.com/question/347338299.html\n","permalink":"https://vcvvvc.github.io/post/%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%80%E4%BB%8B/","tags":["XPU"],"title":"CPU、GPU、DPU、TPU、NPU..."},{"categories":null,"contents":"以太坊白皮书 这篇介绍性文章最初由以太坊创始人 Vitalik Buterin 在 2014 年发表，而以太坊在 2015 年发布。 值得一提的是，和其他社区驱动的开源软件项目一样，以太坊自发布以来一直不断发展。\n_虽然已经过数年，但由于本文仍然可提供有用的参考并能够准确表述以太坊及其愿景，我们仍然在维护它。 若想了解以太坊的最新进展以及如何更改以太坊协议，我们推荐您阅读本指南。\n以 PDF 格式打开以太坊白皮书\n下一代智能合约和去中心化应用平台 中本聪 2009 年开发的比特币常被誉为资金和货币的一次革命性变革，作为数字资产的首个实例，它同时具有以下特点：没有实物或内在价值支撑，也没有一个中心化的发行机构或控制者。 然而，比特币实验有另一个可以说是更重要的部分，即作为分布式共识工具的底层区块链技术，并且人们的注意力正迅速地开始转移到比特币的这个方面。 经常被提到的其他区块链技术应用包括：使用链上数字资产表示自定义货币和金融工具（“彩色币”）、底层物理设备的所有权（“智能资产”）、非同质化资产例如域名（“域名币”），以及一些更复杂的应用，例如让数字资产由一段实现任意规则的代码（“智能合约”）甚至由基于区块链的“去中心化自治组织”(DAO) 直接控制。 以太坊打算提供一种内置完全成熟的图灵完备编程语言的区块链，这种语言可用来创建“合约”，而合约可用于编码任意状态转换函数，让用户可以创建上述任何系统以及我们尚未想象到的许多其他内容，只需用几行代码编写出想实现的逻辑即可。\n比特币及现有概念简介 历史 去中心化数字货币的概念以及财产登记等其他应用已经存在了几十年。 1980 年代和 1990 年代的匿名电子现金协议主要依赖于称为 Chaumian 盲签名的密码学原语，提供了一种具有高度隐私性的货币，但这些协议基本上未能获得关注，因为它们依赖于中心化中介。 1998 年，戴伟 (Wei Dai) 的 b-money 成为第一个提出通过解决计算难题来创造货币及去中心化共识等想法的协议，但该协议缺乏关于如何实际实施去中心化共识的细节。 2005 年，Hal Finney 引入了“可重复使用的工作量证明”这一概念，该系统将 b-money 的想法与 Adam Back 有计算难度的哈希现金难题相结合来创建加密货币的概念，但由于依赖可信计算作为后端，又一次未能做到完美。 2009 年，中本聪将通过公钥密码学管理所有权的成熟原语与用于跟踪货币所有者的共识算法相结合，首次真正意义上实现了一种去中心化货币，被称为“工作量证明”。\n工作量证明机制是该领域的一项突破，因为它同时解决了两个问题。 首先，它提供了一种简单且比较有效的共识算法，让网络中的节点能够全体对比特币账本状态的一组规范更新达成一致。 其次，它提供了一种允许自由进入共识过程的机制，解决了决定谁来影响共识的政治问题，同时防止了女巫攻击。 为此，在工作量证明中，将正式的参与壁垒（例如要求在特定清单上注册成为唯一实体）替换成经济壁垒，即共识投票过程中单个节点的权重与该节点的算力成正比。 此后，还提出了另一种称为权益证明的方法，节点权重与其货币持有量而非计算资源成正比；针对这两种方法相对优点的讨论不在本文范围内，但应该注意，这两种方法都可以作为加密货币的支柱。\n比特币是一个状态转换系统 从技术角度讲，诸如比特币等加密货币账本可视作一种状态转换系统，该系统有一个“状态”，由全部现存比特币的所有权状态和一个“状态转换函数”组成，状态转换函数以状态和交易为输入并输出新状态作为结果。 例如，在标准的银行系统中，状态就是一个资产负债表，一笔交易是一个从 A 帐户向 B 帐户转账$X的请求，状态转换函数将从A帐户中减去$X，向 B 帐户增加$X。 如果A帐户的余额在第一步中小于$X，状态转换函数就会返回错误提示。 所以，可以如此定义：\nAPPLY(S,TX) -\u0026gt; S\u0026#39; or ERROR 上面提到的银行系统中，状态转换函数如下：\nAPPLY({ Alice: $50, Bob: $50 },\u0026#34;send $20 from Alice to Bob\u0026#34;) = { Alice: $30, Bob: $70 } 但是：\nAPPLY({ Alice: $50, Bob: $50 },\u0026#34;send $70 from Alice to Bob\u0026#34;) = ERROR 比特币中的“状态”是指所有已铸造但尚未使用的货币（技术上称为“未使用的交易输出”或 UTXO）的集合，每个 UTXO 都有面额和所有者（由一个 20 字节的地址定义，本质上是一个加密公钥 [fn1]（注释编号））。 一个交易包括一个或多个输入以及一个或多个输出，每个输入都包含对现有 UTXO 的引用以及所有者地址相关的私钥创建的加密签名；每个输出都包含一个要添加到状态中的新 UTXO。\n状态转换函数 APPLY(S,TX) -\u0026gt; S' 的定义大体如下：\n第一步的第一部分防止交易发送者花费不存在的比特币，第二部分防止交易发送者花费其他人的比特币，第二步确保价值守恒。 为了用于支付，比特币协议如下。 假设 Alice 想给 Bob 发送 11.7 BTC。 首先，Alice 将寻找她拥有的一组总数至少为 11.7 BTC 的可用 UTXO。 事实上，Alice 不太可能正好有 11.7 BTC；假设她能得到的最小数额是 6+4+2=12。 所以，她可以创建一笔有三个输入和两个输出的交易。 第一个输出为 11.7 BTC，所有者是 Bob 的地址，第二个输出为剩下的 0.3 BTC 找零，所有者是 Alice 自己。\n挖矿 如果我们拥有可信任的中心化服务机构，状态转换系统可以很容易地实现；可以简单地将上述功能准确编码，使用中心化服务器的硬盘来记录状态。 然而，我们想把比特币构建成去中心化货币系统，为了确保每个人都同意交易的顺序，我们需要将状态转换系统与一个共识系统结合起来。 比特币的去中心化共识进程要求网络中的节点不断尝试将交易打包成“区块”。 网络计划大约每十分钟产生一个区块，每个区块包含一个时间戳、一个随机数、一个对上一个区块的引用（即哈希）和上一区块生成以来发生的所有交易列表。 随着时间推移就创建出了一个持续增长的区块链，它不断地更新，从而能够代表比特币账本的最新状态。\n检查一个区块是否有效的算法，如以下范式所示：\n检查该区块引用的上一个区块是否存在且有效。 检查该区块的时间戳是否大于上一个区块 [fn2]（注释编号）的时间戳并且在将来 2 小时以内 检查区块上的工作量证明是否有效。 令前一个区块末尾的态为 S[0]。 假设 TX 是该区块的交易列表，其中包含 n 个交易。 对于 0...n-1 中的所有 i，如果有任何应用程序返回错误，退出并返回 false，请设置 S[i+1] = APPLY(S[i],TX[i])。 返回 true，并将 S[n] 登记为该区块末尾的状态。 本质上，区块中的每笔交易都必须提供一个有效的状态转换，从交易执行前的规范状态转换到某个新状态。 注意，状态并未编码到区块。它纯粹只是校验节点记住的抽象概念，只能被任意区块从创世状态开始，按顺序加上每一个区块的每一笔交易，（安全地）计算出当前状态。 另外，需要注意矿工将交易收录进区块的顺序。如果一个区块中有 A、B 两笔交易，B 花费的是 A 创建的 UTXO，如果 A 在 B 之前，这个区块是有效的，否则，这个区块无效。\n“工作量证明”是出现在上表而其他系统没有的验证条件。 具体验证方法为，对每个区块进行两次 SHA256 哈希处理，得到一个 256 位的数值，该数值必须小于不断动态调整的目标数值，本文写作时目标数值大约是 2187。 工作量证明的目的是使创建区块有算力困难，从而阻止女巫攻击者恶意重新生成区块链。 因为 SHA256 是完全不可预测的伪随机函数，创建有效区块的唯一方法就是简单地不断试错，不断地增加随机数的数值，查看新的哈希数是否小于目标值。\n当前的目标数值是~2187，网络必须平均尝试 ~269次才能生成有效的区块。一般而言，比特币网络每隔 2016 个区块重新设定目标数值，从而保证网络中的节点平均每十分钟生成一个区块。 为了对矿工的计算工作进行激励，每一个成功生成区块的矿工有权在区块中包含一笔凭空发给他们自己 12.5 BTC 的交易。 另外，如果交易的输入额大于输出，差额部分就作为“交易费”付给矿工。 顺便提一下，这也是比特币发行的唯一机制，创世状态中并没有比特币。\n为了更好地理解挖矿的目的，让我们分析比特币网络出现恶意攻击者时会发生什么。 因为比特币的密码学基础是非常安全的，所以攻击者会选择攻击没有被密码学直接保护的部分：交易顺序。 攻击者的策略非常简单：\n向商家发送 100 个比特币以换取某种产品（最好是快速交付的数字商品） 等待商品交付 创建另一笔交易，将这 100 个比特币发送给自己 试图让网络相信他对自己的交易是先发生的。 一旦步骤 (1) 发生，几分钟后矿工将这笔交易收录到区块中，假设是编号为 270000 的区块。 大约一小时后，此区块后面将会有五个区块，每个区块间接地指向这笔交易，从而确认这笔交易。 这时卖家收到货款，并向买家发货。因为我们假设这是数字商品，交付将瞬间完成。 现在，攻击者创建另一笔交易，将相同的 100BTC 发送到自己的帐户。 如果攻击者只是单纯地向全网广播这一消息，该笔交易不会被处理；矿工将运行状态转换函数 APPLY(S,TX) ，发现这笔交易要花费已经不在状态中的 UTXO。 所以，攻击者会对区块链进行分叉，将第 269 个区块作为父区块重新生成第 270 个区块，在此区块中用新交易取代旧的。 因为区块数据是不同的，这要求重新进行工作量证明。 另外，攻击者的新版 270 区块有不同的哈希，原来的 271 到 275 的区块不指向它，所以原链和攻击者的新链是完全分离的。 规定，在发生区块链分叉时，最长链被认为是诚实的区块链，合法的矿工将会沿着原有的 275 区块挖矿，只有攻击者一人在新的 270 区块后挖矿。 攻击者为了使其区块链最长，他需要拥有比除了他以外的全网更多的算力来追赶（即“51%攻击”）。\n默克尔树 左：仅提供默克尔树上的少量节点已经足够给出分支的合法证明。\n右：对默克尔树任意部分进行改变的尝试最终都会导致链上某处不一致。\n比特币一个重要的可扩展特性是：它的区块存储在多层次数据结构中。 一个区块的哈希实际上只是区块头的哈希，区块头是一段约 200 字节的数据，包含时间戳、随机数、上个区块的哈希和默克尔树根的哈希，而默克尔树是一个存储了该区块所有交易的数据结构。 默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面是大量包含基础数据的叶节点，每个中间节点是其两个子节点的哈希，顶部的根节点也是其两个子节点的哈希。 默克尔树的目的是允许区块数据可以零散地传送：节点可以从一个源下载区块头，从其它源下载相关树的一小部分，而依然能够确认所有的数据都是正确的。 之所以如此是因为哈希向上传播：如果一个恶意用户尝试替换一个伪造的交易到树的底部，此改动将导致树的上层节点的改动，以及更上层节点的改动，最终导致根节点的改动以及区块哈希的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以肯定是带着无效的工作量证明）。\n默克尔树协议可以说是比特币长期持续性的基础。 比特币网络中的一个全节点——存储和处理所有区块全部数据的节点，在 2014 年 4 月需要占用 15GB 的磁盘空间，而且还以每个月超过 1GB 的速度增长。 目前，对台式计算机来说尚可接受，但是手机已经负载不了如此巨大的数据了，未来只有商业机构和爱好者才会充当完整节点。 简化支付确认协议（SPV）允许另一种节点存在，这样的节点被称为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树分支。 这使得轻节点只要下载整个区块链的一小部分，就可以安全地确定任何一笔比特币交易的状态和帐户的当前余额。\n其它的区块链应用 将区块链思想应用到其它领域的想法早就出现了。 2005 年，Nick Szabo 提出了“利用所有者权限确保财产权”这一概念，该文件描述了“复制数据库技术的新进展”将如何允许基于区块链的系统存储谁拥有哪些土地的登记表，创建了一个包括宅基地、违法占有和佐治亚州土地税等概念的复杂框架。 然而，不幸的是在那时还没有实用的复制数据库系统，所以这个协议没有被付诸实践。 不过，自 2009 年比特币的去中心化共识开发成功以来，大量区块链的其它应用开始快速出现。\n域名币 - 创建于 2010 年，域名币描述成去中心化的名称注册数据库最为恰当。 在 Tor、比特币和比特信等去中心化协议中，需要某种方式来识别账户，以便其他人可以与账户交互，但在所有现有解决方案中，唯一可用的标识符是伪随机哈希，如 1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy。 理想情况下，人们希望能够拥有名称的账户，比如“george”。 但是，问题在于如果一个人可以创建名为“george”的账户，那么其他人也可以按相同流程为自己注册“george”来冒充。 唯一的解决方案是“成果优先原则”范式，即第一个注册者成功后第二个注册者将失败，这个问题非常适合比特币共识协议。 域名币是应用这种想法的最早、最成功的名称注册系统实现。 彩色币 - 彩色币的作用是充当一种协议，让人们在比特币区块链上创建自己的数字货币，或者在货币只有一个单位的这种重要但琐碎情况下，创建数字代币。 在彩色币协议中，通过公开为特定的比特币 UTXO 分配一种颜色来“发行”新货币，并且该协议以递归方式将其他 UTXO 的颜色定义为与创建它们的交易所花费的输入的颜色相同（一些特殊规则适用于混合颜色输入的情况）。 这样，用户可以维护仅包含特定颜色 UTXO 的钱包，像发送普通比特币一样发送它们，并通过区块链回溯以确定他们收到的任何 UTXO 的颜色。 元币 - 元币是想要拥有一个基于比特币的协议，使用比特币交易来存储元币交易，但具有不同的状态转换函数 APPLY'。 因为元币协议无法阻止无效元币交易出现在比特币区块链中，所以增加了一条规则，如果 APPLY'(S,TX) 返回错误，该协议默认为 APPLY'( S,TX) = S。 这为创建任意加密货币协议提供了一种简单的机制，可能有无法在比特币内部实现的高级功能，但开发成本非常低，因为比特币协议已经处理了挖矿和网络的复杂性。 元币已被用于实现某些类别的金融合约、名称注册和去中心化交易所。 因此，一般而言，建立共识协议有两种方法：建立一个独立网络或把协议建立在比特币网络上。 前一种方法在域名币这样的应用中相当成功，但是该方法的实施非常困难，每个应用都要创建独立的区块链，建立并测试所有必须的状态转换函数和网络代码。 另外，我们预测去中心化共识技术应用将会服从幂律分布，大多数的应用太小不足以保证自身的安全，我们还注意到大量的去中心化应用，尤其是去中心化自治组织，需要进行应用之间的交互。\n另一方面，基于比特币的方法存在缺点，它没有继承比特币简化确认支付（SPV) 的特性。 比特币可以实现简化确认支付，因为比特币可以用区块链深度代表有效性；某种程度上，当一笔交易的祖先们距离现在足够远时，就可以安全地认为它们是合法状态的一部分。 与之相反，基于比特币区块链的元币协议不能强迫区块链剔除违反元币协议的交易。 因此，完全安全的元币协议的简化支付确认需要后向扫描所有的区块，直到比特币区块链的初始点，以确认某一交易是否有效。 目前，所有基于比特币的元币协议的“轻”实施都依赖可信任的服务器提供数据，这对主要目的之一是消除信任需要的加密货币而言，可能是一个相当次优的结果。\n脚本 即使不对比特币协议进行扩展，它也能在一定程度上实现”智能合约”。 比特币的 UTXO 并非只能被公钥拥有，也可以被用基于堆栈的编程语言所编写的更加复杂的脚本所拥有。 在这一模式下，花费这样的 UTXO，必须提供满足脚本的数据。 事实上，甚至基本的公钥所有权机制也是通过脚本实现的：脚本将椭圆曲线签名作为输入，验证该交易和拥有此 UTXO 的地址，如果验证成功则返回 1，否则返回 0。 其它更复杂的脚本用于各种不同的应用情况。 例如，人们可以创建要求集齐三个私钥签名中的两个才能进行交易确认的脚本（多重签名），对公司帐户、安全储蓄帐户和某些商业代理来说，这种脚本是非常有用的。 脚本也能用来支付解决计算问题的奖励，人们甚至可以创建这样的脚本“如果你能够提供你已经发送一定数额的狗币给我的简化确认支付证明，该比特币 UTXO 就是你的了”，本质上，比特币系统允许不同的加密货币进行去中心化交易。\n然而，比特币系统的脚本语言存在一些严重的限制：\n缺乏图灵完备性 - 也就是说，虽然比特币脚本语言支持一个很大的计算子集，但它基本上不支持所有计算。 缺少的主要类别是循环。 这样做是为了避免交易验证期间出现无限循环；理论上，对脚本程序员来说循环是一个可以克服的障碍，因为任何循环都可以通过简单地使用 if 语句多次重复执行底层代码来模拟，但这确实会导致脚本的空间效率非常低下。 例如，实现另一种椭圆曲线签名算法可能需要 256 次重复的乘法，而每次都需要单独写在代码里。 价值盲 - UTXO 脚本无法对可提取金额进行精细控制。 例如，预言机合约的一个强有力的用例是对冲合约，其中 A 和 B 存入价值 $1000 的比特币，30 天后脚本将价值 $1000 的比特币发送给 A，其余的发送给 B。这需要预言机来确定 1 个比特币的美元价值，但即便如此，与现有完全集中化的解决方案相比，这在信任和基础设施要求方面仍是一个巨大的进步。 然而，由于 UTXO 要么是全部要么是零，要实现这一目标，只能使用非常低效的破解方法，即持有许多不同面额的 UTXO（例如，面额为 2k 的 UTXO，每个 k 值都可以达到 30）并让预言机选择发送给 A 和发送给 B 的 UTXO。 缺少状态 - UTXO 可以是已使用或未使用；用于保存任何其他内部状态的多阶段合约或脚本是没有机会出现的。 这使得多阶段期权合约、去中心化交易报价或两阶段加密承诺协议（这是安全计算赏金所必需的）难以创建。 这也意味着 UTXO 只能用于构建简单的一次性合约，而不是去中心化组织等更复杂的“有状态”合约，使得元协议难以实现。 二进制状态加之价值盲也意味着另一个重要应用 — 提款限制 — 是不可能实现的。 区块链盲 - UTXO 看不到区块链的数据，例如随机数、时间戳和上一个区块的哈希。 由于该脚本语言无法通过随机性来创造可能的价值，它在博彩和其他几个类别的应用受到了严重限制。 至此，我们已经考察了在加密货币上建立高级应用的三种方法：建立一个新的区块链、在比特币区块链上使用脚本、在比特币区块链上建立元币协议。 建立新区块链的方法可以自由地实现任意的特性，但要付出开发时间、引导工作和安全性的代价。 使用脚本的方法容易实施和标准化，但是它的功能有限。元币协议尽管非常容易实现，但是存在扩展性差的缺陷。 在以太坊系统中，我们打算建立一个替代框架，使得开发更便捷、轻客户端性能更强大，同时允许应用程序共享经济环境和区块链安全性。\n以太坊 以太坊的目的是创建一个用于建立去中心化应用的替代协议，我们认为提供一套不同的折衷方案对大量去中心化应用非常有用，尤其是那些强调快速开发、小型和不常用应用的安全性，以及应用间高效交互能力的程序。 以太坊通过构建本质上是最终的抽象基础层来实现这一点：一种内置图灵完备编程语言的区块链，允许任何人编写智能合约和去中心化应用，并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。 域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。 智能合约，即包含价值、只有在满足特定条件时才能解锁的加密“盒子”，也可以在平台上构建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量，而比比特币脚本所能提供的智能合约强大得多。\n以太坊账户 在以太坊中，状态由称为“账户”的对象组成，而每个账户都有一个 20 字节的地址，状态转换是指账户之间价值和信息的直接转移。 一个以太坊账户包含四个字段：\nnonce，用于确保每笔交易只能处理一次的计数器 账户当前的以太币余额 账户的合约代码（若有） 账户的存储（默认为空） 以太币是以太坊内部的主要加密燃料，用于支付交易费。 通常有两类账户：由私钥控制的外部账户以及由其合约代码控制的合约账户。 外部账户没有代码，持有者可以通过创建和签署交易从外部账户发送消息；在合约账户中，每次合约账户收到消息时，其代码都会激活，允许该账户读取和写入内部存储，继而发送其他消息或创建合约。\n注意，以太坊中的“合约”不应被视为要“履行”或“遵守”的东西；相反，合约更像是存在于以太坊执行环境中的“自治代理”。当被交易或消息“触发”时，合约总是执行特定的代码段，并直接控制自已的以太币余额和键/值存储，以跟踪永久变量。\n消息和交易 在以太坊中，术语“交易”用来指代已签名的数据包，数据包存储着将要从外部账户发送的消息。 交易包含：\n消息接收者 用于识别发送者身份的签名 从发送者转账到接收者的以太币金额 一个可选数据字段 STARTGAS 值，表示允许交易运行的最大计算步骤数 GASPRICE 值，表示发送者每个计算步骤支付的费用 前三个是任何加密货币都有的标准字段。 默认情况下，数据字段没有函数，但虚拟机有一个操作码，合约可以使用该操作码访问数据；以这样的用例为例：如果一个合约作为区块链上的域名注册服务，那么它可能希望将传送给它的数据解释为包含两个“字段”，第一个字段是要注册的域名，第二个字段将域名注册到 IP 地址。 合约将从消息数据中读取这些值，并将其适当地存储。\nSTARTGAS 及 GASPRICE 字段对于以太坊的反拒绝服务模型至关重要。 为了防止代码中出现无意或恶意的无限循环或其他计算浪费，要求每笔交易对代码可以执行的计算步骤设置一个限制。 计算的基本单位是燃料；通常，一个计算步骤消耗 1 份燃料，但某些操作会消耗更多燃料，因为它们在计算上更加昂贵或者增加了必须存储到状态中的数据量。 交易数据中的每个字节还需支付的费用为 5 份燃料。 收费系统的意图是要求攻击者相应支付他们消耗的每一种资源，包括计算、带宽和存储；因此，任何导致网络消耗更多这些资源的交易，都必须支付大致与增加量成比例的燃料费用。\n消息 合约能够向其他合约发送“消息”。 消息是从未序列化的虚拟对象，只存在于以太坊执行环境中。 消息包含：\n消息发送者（隐含的） 消息接收者 随消息一起转账的以太币金额 一个可选数据字段 STARTGAS 值 本质上消息类似于交易，只是消息是由合约而非外部参与者产生的。 当前正在运行代码的合约执行 CALL 操作码时会产生一条消息，该操作码就是用于产生并执行消息。 像交易一样，信息导致接收者账户运行其代码。 因此，合约之间可以建立关系，方式完全与外部参与者之间建立关系相同。\n请注意，为交易或合约分配的燃料配额适用于该交易和所有子执行消耗的总燃料量。 例如，如果外部参与者 A 向 B 发送一笔配额为 1000 份燃料的交易，B 在向 C 发送消息需要消耗 600 份燃料，而 C 在内部执行需要消耗 300 份燃料才能返回结果，那么 B 再发送 100 份燃料就会消耗完燃料。\n以太坊状态转换函数 以太坊状态转换函数 APPLY(S,TX) -\u0026gt; S' 可如下定义：\n检查交易格式是否正确（即具有正确数量的值）、签名是否有效以及 Nonce 值是否与发送者账户中的 Nonce 值匹配。 若否，则返回错误。 通过 STARTGAS * GASPRICE 计算出交易费，并从签名中确定发送地址。 从发送者的账户余额中减去费用，并增加发送者的 nonce 值。 如果账户余额不足，则返回错误。 初始化 GAS = STARTGAS，并根据交易中的字节数量为每个字节扣除相应数量的燃料。 将交易数值从发送者账户转移至接收账户。 如果接收账户尚不存在，则创建此账户。 如果接收账户是合约，运行该合约的代码，直到代码运行结束或燃料耗尽。 如果由于发送者资金不足或者代码运行耗尽了燃料，而导致转账失败，则回滚除支付费用之外的所有状态变化，并将费用支付给矿工账户。 否则，将所有剩余燃料的费用退还发送者，并把为所消耗燃料而支付的费用发送给矿工。 例如，假设合约的代码如下：\nif !self.storage[calldataload(0)]: self.storage[calldataload(0)] = calldataload(32) 注意，合约代码实际上是用低级以太坊虚拟机代码编写的；为了清晰起见，此示例是用我们的一种高级语言 Serpent 编写的，它可以编译为以太坊虚拟机代码。 假设合约的存储一开始是空的，发送了一个价值为 10 个以太币的交易，消耗 2000 份燃料，燃料价格为 0.001 个以太币，并且数据包含 64 个字节，字节 0-31 代表数字 2，字节 32-63 代表字符串 CHARLIE。 在这种情况下，状态转换函数的执行过程如下：\n检查交易是否有效、格式是否正确。 检查交易发送者是否至少有 2000 * 0.001 = 2 个以太币。 若有，则从发送者账户中扣除 2 个以太币。 初始化燃料 = 2000 份，假设交易长度为 170 个字节，每字节费用 5 份燃料，减去 850 份燃料，剩下 1150 份燃料。 从发送者账户再减去 10 个以太币并增加到合约账户。 运行代码。 在本例中，运行比较简单：代码检查是否使用合约的索引 2 处的存储，若未使用，则通知；若使用，代码将索引 2 处的存储设置为值 CHARLIE。 假设该运行花费了 187 份燃料，所以余下的燃料数量是 1150 - 187 = 963 份燃料。 向发送者账户增加 963 * 0.001 = 0.963 个以太币，同时返回产生的状态。 如果交易的接收一端没有合约，那么总交易费就等于提供的 GASPRICE 乘以交易的字节长度，并且和随交易发送的数据无关。\n注意，消息在回滚方面与交易相同：如果消息执行耗尽燃料，那么该消息的执行以及该执行触发的所有其他执行都会回滚，但父执行不需要回滚。 这意味着合约调用另一份合约是“安全的”，就好像 A 使用 G 份燃料调用 B，那么可以保证 A 的执行最多损耗 G 份燃料。 最后请注意，有一个创建合约的操作码 CREATE；它的执行机制通常类似于 CALL，不同之处在于执行的输出决定了新创建合约的代码。\n代码执行 以太坊合约中的代码用一种基于堆栈的低级字节码语言编写，被称为“以太坊虚拟机代码”或“EVM 代码”。 该代码由一系列字节组成，每个字节代表一种操作。 通常，代码执行是一个无限循环，即重复执行当前程序计数器（从零开始）处的操作，然后将程序计数器增加一，直到代码执行完毕或出现错误，或者检测到 STOP 或 RETURN 指令。 操作可以访问三种数据存储空间：\n堆栈，一种后进先出容器，值可以在其中入栈和出栈 内存，一种可无限扩展的字节数组 合约的长期存储，一个键/值存储。 与堆栈和内存会在计算结束后重置不同，存储将长期持续存在。 代码可以访问传入消息的值、发送者信息和数据，可以访问区块头数据，而且代码还可以返回数据字节数组作为输出。\n以太坊虚拟机码的正式执行模型简单得令人吃惊。 当以太坊虚拟机运行时，其完整计算状态可以由元组 (block_state, transaction, message, code, memory, stack, pc, gas) 来定义，其中 block_state 是包含所有账户的全局状态并包括余额和存储。 在每一轮执行开始时，可以通过调用 code 的第 pc 个字节（或者如果 pc \u0026gt;= len(code)，则调用 0）来找到当前指令，并且每条指令在元组影响方式方面都有自己的定义。 例如，ADD 将两个项目出栈并将它们的和入栈，将 gas 减少 1 并将 pc 增加 1，SSTORE 将顶部的两个项目出栈并将第二个项目插入到合约存储中第一个项目指定的索引处。 尽管有很多通过 JIT 编译来优化以太坊虚拟机执行的方法，但只需几百行代码就可以完成以太坊的基本实现。\n区块链和挖矿 以太坊区块链在许多方面与比特币区块链相似，但确实存在一些差异。 以太坊和比特币在区块链架构方面的主要区别在于，与比特币不同，以太坊区块包含交易列表和最新状态的副本。 此外，其他两个值、区块编号和难度也存储在区块中。 以太坊中的基本区块验证算法如下：\n检查被引用的前一个区块是否存在并有效。 检查区块的时间戳是否大于被引用的前一个区块的时间戳，并且在将来 15 分钟以内。 检查区块编号、难度、交易根、叔根和燃料限制（各种以太坊特定的低级概念）是否有效。 检查区块上的工作量证明是否有效。 令前一个区块末尾的态为 S[0]。 令区块的交易列表为 TX，并包含 n 笔交易。 对于 0...n-1 中的所有 i，设置 S[i+1] = APPLY(S[i],TX[i])。 如果任何应用程序返回错误，或者直到此时区块中消耗的总燃料量超过 GASLIMIT，则返回错误。 令 S_FINAL 为 S[n]，但添加支付给矿工的区块奖励。 检查状态 S_FINAL 的默克尔树根是否等于区块头中提供的最终状态根。 如果等于，则该区块有效；否则该区块无效。 这种方法乍一看效率似乎极低，因为它需要存储每个区块的全部状态，但实际上效率应该与比特币相当。 原因是状态存储在树结构中，而且在添加每个区块后只需要更改树的一小部分。 因此一般来说，在两个相邻区块之间，树的绝大部分应该是相同的，因此数据可以用指针（即子树的哈希）存储一次和引用两次。 一种称为“帕特里夏树”的特殊类型的树用于实现此目的，它包括对默克尔树概念的修改，允许高效地插入和删除节点，而不仅仅是更改。 此外，由于所有状态信息都存在于最后一个区块内，因此无需存储整个区块链历史，如果可以应用于比特币，使用这种策略计算可以节省 5-20 倍空间。\n一个常见的问题是合约代码在物理硬件的“哪里”执行。 该问题有一个简单的答案：合约代码的执行过程是状态转换函数定义的一部分，而该函数是区块验证算法的一部分，因此如果将交易添加到区块 B 中，由该交易产生的代码执行将在现在和将来由所有节点执行，由此下载并验证区块 B。\n应用 通常，以太坊上有三种类型的应用。 第一类是金融应用，为用户提供更有效的方式来使用资金管理和签订合约。 包括子货币、金融衍生品、对冲合约、储蓄钱包、遗嘱，甚至最终包括某些类别的完整雇佣合约。 第二类是半金融应用，它们涉及金钱，但很大一部分功能也与资金无关；一个恰当的示例是针对解决计算难题的自动执行的赏金。 最后还有一些应用与金融毫不想关，例如在线投票和去中心化治理。\n代币系统 区块链上的代币系统有许多应用，从代表美元或黄金等资产的子货币到公司股票等等，单个代币可以代表智能资产、不可伪造的安全优惠券，甚至可代表作为激励积分系统并与传统价值完全没有联系的代币系统。 代币系统在以太坊中非常容易实现，让人吃惊。 要理解的重点是，从根本上讲，所有货币或代币系统都是具有这样一种操作的数据库：从 A 中减去 X 个单位并将 X 个单位添加给 B，条件是 (1) A 在交易之前至少有 X 个单位并且 (2) 交易由 A 批准。实现代币系统所需要做的就是将此逻辑实现到合约中。\n使用 Serpent 语言实现代币系统的基本代码如下所示：\ndef send(to, value): if self.storage[msg.sender] \u0026gt;= value: self.storage[msg.sender] = self.storage[msg.sender] - value self.storage[to] = self.storage[to] + value 此代码本质上是本文档前面部分详细描述的“银行系统”状态转换函数的字面实现。 需要额外添加几行代码来规定在最初以及其他一些特殊情况下分配货币单位的初始步骤，理想情况下，应该添加一个函数让其他合约查询地址的余额。 但这就足够了。 理论上，基于以太坊的代币系统在作为子货币时可能具有另一个重要特征，该特征是基于比特币的链上元货币所缺乏的，那就是直接以该货币支付交易费的能力。 实现这一点的方式是：合约会保持一定数量的以太币余额，用来向发送者退还用于支付费用的以太币；合约也会通过收取费用来收集内部货币，并在持续不断的拍卖中转售货币，以此补充以太币余额。 因此，用户需要用以太币“激活”他们的账户，但一旦账户中有以太币，就可以重复使用，因为合约每次都会向账户退还资金。\n金融衍生品和价值稳定的货币 金融衍生品是“智能合约”最常见的应用，也是通过代码实现的最简单的应用之一。 实现金融合约的主要挑战在于，其中大多数合约都需要引用外部价格自动收报机；例如，一个非常理想的应用是对冲以太币（或其他加密货币）相对于美元波动的智能合约，但对冲需要合约知道以太币/美元的价值。 要实现这一点，最简单的方法是借助由特定方（例如纳斯达克）维护的“数据馈送”合约，这种合约的设计使得特定方能够根据需要更新合约并提供一个接口，允许其他合约向该合约发送消息并返回包含价格的响应。\n鉴于这一关键因素，对冲合约将如下所示：\n等待 A 方输入 1000 个以太币。 等待 B 方输入 1000 个以太币。 在存储中记录 1000 个以太币的美元价值（通过查询数据馈送合约计算得出），假设价值是 $x。 30 天后，允许 A 或 B“重新激活”该合约，以便将价值 $x 的以太币（通过再次查询数据馈送合约获取新价格并且计算得出）发送给 A，剩余以太币发送给 B。 这种合约在加密货币交易中潜力巨大。 加密货币的主要问题之一是它的波动性。尽管许多用户和商家可能希望获得处理加密资产的安全性和便利性，但他们中许多人不希望面临在一天内资金价值损失 23% 的景象。 迄今为止，最常见的解决方案是发行人支持的资产；其想法是发行人创建一种子货币，他们有权发行和撤销这种子货币单位，并且发行人可以向给他们（离线）提供一个单位指定基础资产（例如黄金、美元）的任何人提供一个单位的货币。 然后，发行人承诺向返还一个单位加密资产的任何人提供一个单位基础资产。 这种机制使得任何非加密资产“升级”为加密资产，前提是发行人是可信的。\n但实际上，发行人并不总是值得信赖，在某些情况下，银行基础设施过于薄弱或过于不友好，以至于无法提供此类服务。 金融衍生品提供了一种替代方案。 在这种方案中，不是由单个发行人提供资金来支持资产，而是由一个去中心化的投机者市场承担了这一角色，他们押注加密参考资产（例如以太币）的价格会上涨。 与发行人不同，投机者无法在交易中违约，因为对冲合约托管他们的资金。 请注意，这种方法不是完全去中心化的，因为仍然需要一个可信来源提供价格自动收报机，但可以说在降低基础设施要求（与成为发行者不同，发布价格馈送不需要许可证并且可能被归类为自由言论）以及减少欺诈的可能性方面，这仍是一次巨大的改进。\n身份和信誉系统 最早的替代加密货币域名币尝试使用类似比特币的区块链提供一种名称注册系统，通过该系统，用户可以在公共数据库中注册他们的姓名和其他数据。 主要用例是 DNS 系统，它将诸如“bitcoin.org”等域名（在域名币的情况下，“bitcoin.bit”）映射到一个 IP 地址。 其它用例包括电子邮件身份验证系统和可能更为先进的信誉系统。 下面是一个基础合约，它在以太坊中提供与域名币类似的名称注册系统：\ndef register(name, value): if !self.storage[name]: self.storage[name] = value 该合约非常简单；它完全是以太坊网络中的一个数据库，可以向其中添加但不能修改或移除。 任何人都可以把名称注册为一个值，该注册将永久保存。 更复杂的名称注册合约还包含一个“函数子句”以及一种机制，前者允许其他合约查询它，后者允许名称的“所有者”（即第一个注册者）更改数据或转让所有权。 甚至可以在该合约上添加信誉和信任网络功能。\n去中心化文件存储 过去几年，大批受欢迎的在线文件存储初创公司不断涌现，其中最著名的是 Dropbox。Dropbox 想让用户可以上传硬盘备份、提供备份存储服务并允许用户访问备份，而用户需按月付费。 然而，在这一点上，文件存储市场有时效率相对较低。在粗略了解各种现有解决方案后会发现，主流文件存储的每月价格比整个硬盘驱动器的成本还要高，特别是在被称为“恐怖谷”的 20-200 GB 级别，既没有免费额度也没有企业级折扣。 以太坊合约让去中心化文件存储生态系统得以发展，个人用户可以在该系统中将自己的硬盘租出去以获得少量收益，而未使用的空间可用来进一步降低文件存储的成本。\n该系统的基础性构件就是我们所谓的“去中心化 Dropbox 合约”。 该合约的工作原理如下。 首先，用户将需要存储的数据拆分成几个区块并对每个区块加密以保护隐私，然后以此构建一个默克尔树。 然后创建一个含以下规则的合约，对于每 N 个区块，合约将从默克尔树中选择一个随机索引（使用能够被合约代码访问的上一个区块的哈希作为随机性来源），然后给予第一个实体 X 个以太币，以提供具有简化支付确认（例如证明树中特定索引处区块的所有权）的交易。 当用户想重新下载他们的文件时，可以使用微支付通道协议（例如每 32 KB 支付 1 个 szabo）收回文件；最节省费用的方法是支付者不到最后不发布交易，而是每 32 KB 之后，用一个更划算的具有相同 nonce 的交易取代原来的交易。\n该协议的一个重要特点是，虽然似乎用户相信许多随机节点不会丢失文件，但可以通过以下方法将这种风险降低到接近于零：通过私钥共享将文件拆分成许多部分，并通过监控合约确定每一部分仍在某个节点中。 如果合约仍在支付款项，则提供了一个加密证明，证明有人仍在存储该文件。\n去中心化自治组织 通常意义上“去中心化自治组织”是指拥有一定数量成员或股东的虚拟实体，他们大概拥有 67% 的大多数股权，有权使用实体的资金并修改其代码。 成员集体决定组织的资金分配方式。 去中心化自治组织的资金分配方式可以是奖金、薪资或者更奇特的机制等等，比如用内部货币去奖励工作。 这在本质上复制了传统公司或者非营利组织的合法手段，但仅使用加密区块链技术进行了加强。 目前为止，许多关于去中心化自治组织的讨论都围绕着去中心化自治公司的“资本家”模式，其中有可获得红利的股东和可交易的股份；作为替代方案，有一种可能被称为“去中心化自治社区”的实体将使所有成员在决策时拥有同等权利，并在增减成员时要求 67% 的现有成员多数同意。 由于每个人只能拥有一个成员资格，所以需要群体来集体执行。\n下面概括了如何用代码实现去中心化自治组织。 最简单的设计就是一段自动修改的代码，如果三分之二的成员同意更改，该代码就更改。 理论上代码是不可更改的，然而通过把代码片段放入不同的合约并将合约调用的地址存储在可更改的存储中，用户可以轻易解决这一问题，使代码事实上变得可修改。 在这种去中心化自治组织合约的简单实现中，有三种交易类型，可通过交易中提供的数据行区分：\n[0,i,K,V] 在索引 i 处注册提案，以便将存储索引 K 的地址更改为值 V [1,i] 注册一张赞成提案 i 的投票 [2,i] 如果投票有足够票数，则确认提案 i 合约为每一种交易都提供有子句。 它将维护所有开放存储更改的记录以及投票支持者的列表。 合约还包括所有成员的列表。 当任何存储更改获得三分之二成员投票赞成时，一个确认交易将执行这项更改。 更复杂的框架可能还有针对如发送交易、增减成员等功能的内置投票功能，甚至可以提供委任式民主投票委托（即任何人都可以委托另外一个人来代表自己投票，而且这种委托关系是可以传递的，如果 A 委托了 B 然后 B 委托了 C，那么 C 将决定 A 的投票）。 这种设计将使去中心化自治组织作为一个去中心化社区有机地成长，允许人们最终将筛选成员的任务委派给专家，但与“现有系统”不同，随着时间的推移，当个别社区成员改变他们的阵营时，专家可以很容易地加入或退出。\n另一个模型是去中心化公司，其中任何账户可以拥有零份或多份股份，决策需要持有三分之二多数股份。 完整框架将包括资产管理功能，即能够出价购买或出售股份并且能够接受报价（最好是合约里有订单匹配机制）。 委托还提供委任制民主形式，普及了“董事会”的概念。\n更多应用 1. 储蓄钱包。 假设 Alice 想安全地保管她的资金，但她担心自己的私钥丢失或被破解。 她把以太币放到和银行 Bob 签订的一个合约里，如下所示：\nAlice 每天最多可以单独提取 1% 的资金。 Bob 每天最多可以单独提取 1% 的资金，但 Alice 可以用她的密钥创建一个交易取消 Bob 的提取权限。 Alice 和 Bob 一起可以任意提取资金。 通常，每天 1% 的额度对于 Alice 足够了，如果 Alice 想提取更多资金，她可以联系 Bob 寻求帮助。 如果 Alice 的密钥被破解，她可以立即找到 Bob，帮她将资金转移到一个新合约里。 如果 Alice 丢失了密钥，Bob 最终会取出资金。 如果最终发现 Bob 是恶意的，她可以取消他的提取权限。\n2. 作物保险。 用户可以轻松地制订金融衍生品合约，但使用的是天气而不是任何价格指数的数据馈送。 如果爱荷华州的一位农民购买了一项金融衍生品，该产品基于爱荷华的降雨情况进行反向赔付，那么如果遇到干旱，该农民将自动收到赔付资金，而且如果降雨充沛，他会很开心，因为他的作物收成会很好。 通常，这种保险可以扩展到自然灾害保险。\n3. 去中心化数据馈送。 对于金融差价合约，实际上有可能通过一种名为“谢林币”的协议将数据馈送去中心化。 谢林币的基本工作原理如下。N 个相关方都向系统输入给定数据的值（以太币/美元价格），对这些值进行排序，在第 25 和第 75 百分位之间的每个人都会得到一个代币作为奖励。 每个人都有动力提供其他人都会提供的答案，而唯一能让众多参与者实际达成一致的值是显而易见的：真相。 这样就创建了一种去中心化的协议，它理论上可以提供任何数量的值，包括以太币/美元的价格、柏林的温度、甚至某个硬计算的结果。\n4. 智能多重签名托管。 比特币允许多重签名交易合约，例如，提供了给定五个密钥中的三个便可以使用资金。 以太坊允许更精细的控制；例如，提供五个密钥中的四个可以使用任意数额的资金，提供五个密钥中的三个可以每天最多使用 10% 的资金，提供五个密钥中的两个可以每天最多使用 0.5% 的资金。 此外，以太坊的多重签名是异步的 — 双方可以在不同时间在区块链上注册他们的签名，最后一个签名将自动发送交易。\n5. 云计算。 以太坊虚拟机技术还可以用来创建一个可验证的计算环境，让用户可以要求他人执行计算，然后有选择地索要证明，证实计算在某些随机选定的检查点处正确完成。 这就可以创建一个云计算市场，任何用户都可以用他们的台式机、笔记本电脑或专用服务器来参与，并且抽查与保证金双管齐下确保系统是值得信赖的（即节点不能通过欺骗获利）。 但是，这样的系统可能并不适合所有任务；例如，需要进行大量进程间通信的任务无法在大型节点云上轻易实现。 然而，其他任务则更容易实现并行；例如 SETI@home、folding@home 和遗传算法等项目可以方便地在这类平台上实现。\n6. 点对点赌博。 任意数量的点对点赌博协议都可以在以太坊区块链上实现，例如 Frank Stajano 和 Richard Clayton 的 Cyberdice。 最简单的赌博协议实际上只是一种关于下一个区块哈希的差价合约，并且可以在其基础上创建更高级的协议，创建接近零费用且无法作弊的赌博服务。\n7. 预测市场。 如果有预言机或谢林币，预测市场也很容易实现，预测市场与谢林币一起有可能被证明是 futarchy 的第一个主流应用，作为去中心化组织的治理协议。\n8. 链上去中心化市场，基于身份和信誉系统。\n杂项和关注 改进版 GHOST 协议的实现 “贪婪最重可观察子树”(GHOST) 协议是由 Yonatan Sompolinsky 和 Aviv Zohar 在 2013 年 12 月首次提出的一项创新。 提出 GHOST 的动机是，具有快速确认时间的区块链目前由于过时率高而安全性降低 — 因为区块需要一定的时间才能通过网络传播，如果矿工 A 开采了一个区块，然后矿工 B 碰巧在矿工 A 的区块传播到 B 之前开采了另一个区块，那么矿工 B 的区块最终会被作废，不会增加网络安全。 此外，还有一个中心化问题：如果矿工 A 是一个拥有 30% 算力的矿池，而 B 拥有 10% 算力，那么 A 将面临 70% 的时间生产陈腐区块的风险（因为在其他 30% 的时间 A 产生了最后一个区块，所以会立即获得挖矿数据），而 B 将面临 90% 的时间生产陈腐区块的风险。 因此，如果区块间隔短到足以使过时率较高，则 A 将仅仅凭借其规模而显着提高效率。 结合这两种影响，快速产生区块的区块链很可能造就一个拥有足够高比例网络算力的矿池，从而对挖矿过程拥有事实上的控制。\n正如 Sompolinsky 和 Zohar 所描述的，GHOST 通过在计算哪条链“最长”时包含陈腐区块来解决第一个问题 - 网络安全降低；也就是说，在计算哪个区块具有最大的总工作量证明支持它时，不仅区块的父块和更远的祖先，而且该区块祖先（在以太坊行话中称为“叔块”）的陈腐子代也都被添加到计算中。 为了解决第二个问题 - 中心化偏差，我们跳出了 Sompolinsky 和 Zohar 描述的协议范畴，并且还为陈腐区块提供区块奖励：陈腐区块获得其基础奖励的 87.5%，而包含陈腐区块的侄块获得剩余的 12.5%。 不过，交易费不奖励给叔块。\n以太坊实现了一个简化版的 GHOST 协议，它仅仅深入七个层级。 具体而言，它的定义如下：\n一个区块必须指定一个父块，并且必须指定零个或多个叔块 包含在区块 B 中的叔块必须具有以下属性： 它必须是区块 B 的第 k 代祖先的直系子代，其中 2 \u0026lt;= k \u0026lt;= 7。 它不能是 B 的祖先 叔块必须是有效的区块头，但不需要是之前验证过的甚至是有效的区块 叔块必须不同于前面区块中包含的所有叔块，并且不同于同一区块中包含的所有其他叔块（非双重包含） 对于区块 B 中的每个叔块 U，区块 B 的矿工获得额外 3.125% 的铸币奖励，而叔块 U 的矿工获得 93.75% 的标准铸币奖励。 这种限制版的 GHOST 协议，最多只能包含 7 代叔块，采用它有两个原因。 首先，无限制 GHOST 协议让计算给定区块的哪些叔块有效时过于复杂。 其次，无限制 GHOST 协议采用了以太坊中使用的补偿，取消了促使矿工在主链而不是公共攻击者的链上挖矿的激励措施。\n费用 由于发布到区块链中的每笔交易都会给网络带来下载和验证成本，因此需要一些监管机制（通常涉及交易费）以防滥用。 比特币中使用的默认方法是收取完全自愿性质的费用，依靠矿工充当守门人并设置动态最低费用。 这种方法在比特币社区中非常受欢迎，特别是因为它是“基于市场的”，允许由矿工和交易发送者之间的供需决定价格。 然而，这种思路的问题在于，交易处理并不符合市场规律。尽管将交易处理解释为矿工向发送者提供的服务直观上很有吸引力，但实际上矿工收录的每笔交易都需要由网络中的每个节点处理，因此绝大部分交易处理成本由第三方承担，而不是由决定是否收录交易的矿工承担。 因此，公地悲剧的问题很可能发生。\n然而结果却是，基于市场机制中的这个缺陷，在给出一个不准确的特定简化假设时，会神奇地自我抵消。 论证如下。 假设：\n交易导致 k 个操作，将提供奖励 kR 给收录它的任何矿工，其中 R 由发送者设置，k 和 R 事先（大体上）对矿工可见。 操作在任何节点的处理成本均为 C（即所有节点效率相同） 有 N 个挖矿节点，每个节点的处理能力完全相同（即为总处理能力的 1/N） 没有不挖矿的完整节点。 如果预期奖励大于成本，矿工将愿意处理交易。 因此，预期奖励是 kR/N，因为矿工有 1/N 几率处理下一个区块，而矿工的处理成本仅仅是 kC。 所以，当 kR/N \u0026gt; kC 或者 R \u0026gt; NC 时，矿工将会收录交易。 请注意，R 是发送者提供的每个操作的费用，因此是发送者从交易中获得的收益的下限，NC 是整个网络共同处理一个操作的成本。 因此，矿工有动力仅收录那些总实际收益超过成本的交易。\n然而，现实中这些假设会存在几个重要偏差：\n与其他验证节点相比，矿工处理交易的成本确实更高，因为额外的验证时间会延迟区块传播，因而增加区块变陈腐的几率。 确实存在不挖矿的完整节点。 实际中挖矿能力的分配最终可能极端不平等。 热衷于破坏网络的投机者、政敌和疯子确实存在，他们可以巧妙地设置合约，使得他们的成本远低于其他验证节点支付的成本。 (1) 让矿工趋向于收录更少的交易，并且 (2) 增加 NC；因此，这两种作用会相互抵消 一部分 。如何抵消？ (3) 和 (4) 是主要问题，为了解决它们，我们简单地制订了一个 浮动上限：没有区块能够包含比 BLK_LIMIT_FACTOR 乘以长期指数移动平均值更多的操作数。 具体如下：\nblk.oplimit = floor( (blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) / EMA_FACTOR ) BLK_LIMIT_FACTOR 和 EMA_FACTOR 是常量，暂时设置为 65536 和 1.5，但可能会在进一步分析后更改。\n还有一个因素会抑制比特币中的大区块大小：大区块将需要更长时间来传播，因此变陈腐的概率更高。 在以太坊中，燃料消耗量高的区块也可能需要更长的传播时间，因为它们的物理大小更大，而且因为它们需要更长时间来处理交易状态转换以进行验证。 这种延迟抑制因素在比特币中是一个重要的考虑因素，但在以太坊中由于 GHOST 协议而较少考虑；因此，依靠受监管的区块限制可提供更稳定的基线。\n计算和图灵完备 重要的一点是，以太坊虚拟机是图灵完备的；这意味着以太坊虚拟机代码可以对任何设想可执行的计算进行编码，包括无限循环。 以太坊虚拟机代码以两种方式实现循环。 首先，使用一个 JUMP 指令，允许程序跳回至代码中的前一个位置，还使用一个 JUMPI 指令进行条件跳转，允许诸如 while x \u0026lt; 27: x = x * 2 之类的语句。 其次，合约可以调用其他合约，有可能通过递归进行循环。 这很自然地导致了一个问题：恶意用户能够通过迫使矿工和完整节点进入无限循环而不得不关机吗？ 这个问题的出现源于计算机科学中的一个难题，称为停机问题：在一般情况下，没有办法知道一个特定的程序是否会停止运行。\n正如状态转换部分所述，我们的解决方案要求交易设置一个允许执行的最大计算步骤数，如果超过执行时间，计算就会被回滚，但仍要支付费用。 消息的工作原理相同。 为显示我们解决方案背后的动机，请看下面的示例：\n攻击者创建一个运行无限循环的合约，然后向矿工发送激活该循环的交易。 矿工将处理该交易，运行无限循环直到燃料耗尽。 即使执行耗尽了燃料并中途停止，交易仍然有效，矿工仍然向攻击者索取每个计算步骤的费用。 攻击者创建一个非常长的无限循环，目的是迫使矿工持续计算很长时间，以至于计算结束时，将有更多区块产生出来，这样矿工就不可能通过收录该交易来索取费用。 然而，攻击者需要为 STARTGAS 提交一个值，限制执行可以进行的计算步骤数，因此矿工将提前知道该计算将进行相当多的步骤数。 攻击者看到一个合约，其中的代码形式为 send(A,contract.storage[A]); contract.storage[A] = 0，然后发送一个交易，但燃料只够运行第一步而不足以运行第二步（即进行提款但不让余额减少）。 合约作者无需担心防卫此类攻击，因为如果执行中途停止，更改会被回滚。 金融合约使用九个专有数据馈送的中位数，以便最大限度降低风险。 攻击者接管其中一个数据馈送，该数据馈送设计为可通过去中心化自治组织部分描述的变量-地址-调用机制修改，并将其转换为运行无限循环，从而强制任何从金融合约索取资金的尝试都因燃料耗尽而中止。 然而，金融合约可以为消息设置一个燃料限制，防止这个问题发生。 图灵完备的替代方案是图灵不完备，其中 JUMP 和 JUMPI 不存在，并且在任何给定时间每个合约只允许有一个副本存在于调用堆栈内。 在这样的系统里，上述收费系统和关于我们解决方案效果的不确定性可能都是不需要的，因为执行一个合约的成本将被它的大小决定。 此外，图灵不完备甚至不是一个很大的限制；在我们内部构想的所有合约示例中，到目前为止只有一个需要循环，甚至那个循环也可以通过将一行代码重复 26 次来消除。 考虑到图灵完备带来的严重影响和有限的益处，为什么不简单地使用一种图灵不完备语言呢？ 然而，在现实中，图灵不完备还远远不能有效地解决问题。 要想知道原因，请思考以下合约：\nC0: call(C1); call(C1); C1: call(C2); call(C2); C2: call(C3); call(C3); ... C49: call(C50); call(C50); C50: (run one step of a program and record the change in storage) 现在，向 A 发送一笔交易。这样，在 51 笔交易中，我们有一个合约需要进行多达 250 个计算步骤。 矿工可以尝试提前检测这种逻辑炸弹，方法是为每个合约维护一个值，指定合约可以进行的最大计算步骤数，然后对递归调用其他合约的合约进行计算，但是这需要矿工禁止创建其他合约的合约（因为上面 26 个合约的创建和执行可以很容易地汇集到一个单独合约内）。 另一个问题是，消息的地址字段是一个变量，所以在一般情况下，甚至不可能提前知道某个合约将调用哪些其他合约。 于是，最终我们有了一个惊人的结论：图灵完备的管理惊人地容易，而在缺乏同样的控制时图灵不完备的管理惊人地困难，那为什么不直接让协议图灵完备呢？\n货币和发行 以太坊网络包括自己的内置货币以太币，以太币扮演双重角色：提供一个主要流动资金层，实现各种数字资产之间的高效交易；更重要的是，提供一种支付交易费的机制。 为了方便起见并避免将来出现争议（参考比特币当前的 mBTC、uBTC、satoshi 争论），不同面值的名称将提前设置如下：\n1: wei 1012：Szabo 1015：finney 1018：ETH 这应该被视为“美元”和“美分”或“BTC”和“satoshi”概念的扩展版本。 在不久的将来，我们期望“ETH”用于普通交易，“finney”用于微型交易，“szabo”和“wei”可以在围绕费用和协议实现的技术讨论中使用；其余的面额可能会在以后变得有用，但目前不应包含在客户端中。\n发行模型如下：\n以太币将以货币销售的形式发行，价格为一个比特币可购买 1000-2000 个以太币，这种机制旨在为以太坊组织筹资和支付开发费用，且已被其他平台（如 Mastercoin 和 NXT）成功应用。 早期的购买者将从较大的折扣中获益。 发售所得的比特币将全部用来支付开发者的薪资和奖金，并用来投资以太坊和加密货币生态系统中的各种营利和非营利项目。 0.099 倍的发售总量（60102216 个以太币）将分配给以太坊组织，以补偿早期贡献者，并用以太币计价的方式支付创世块诞生前的开销。 0.099 倍的发售总量将作为长期储备金保留。 发售后，将永久性地每年为矿工分配 0.26 倍的发售总量。 分组 启动时 一年后 5 年后 货币单位 1.198X 1.458X 2.498X 购买者 83.5% 68.6% 40.0% 已支用的预售准备金 8.26% 6.79% 3.96% 已使用的售后准备金 8.26% 6.79% 3.96% 矿工 0% 17.8% 52.0% 长期供应增长率（百分比） 尽管采用了线性发行方式，然而和比特币一样，以太币的长期供应增长率也趋于零。\n上述模型提供了两个主要选项：(1) 捐赠池的存在和规模，以及 (2) 永久增长的线性供应的存在，而比特币采用了限制供应的方法。 捐赠池存在的理由如下。 如果捐赠池不存在，并且线性发行量减少到总发售量的 0.217 倍以实现相同的通货膨胀率，那么以太币总量将减少 16.5％，而每个单位的价值将增加 19.8％。 因此为了均衡，将会多发售 19.8% 的以太币，所以每个单位的价值将再次与以前完全一样。 之后，该组织还将拥有 1.198 倍的比特币，可以考虑将其分成两部分：原有的比特币和增加的 0.198 倍比特币。 因此，这种情况完全等同于捐赠，但有一个重要区别：该组织仅持有比特币，因而没有动力支持以太币单位的价值。\n永久性线性供应增长模型降低了有些人认为比特币财富过度集中的风险，并为生活在当前和未来的人提供了获取货币单位的公平机会，同时又保留了让人获取并持有以太币的强效激励措施，因为长期来看，用百分比表示的“供应增长率”将趋于零。 我们还推测，由于加密货币总是会因为不小心、死亡等原因而丢失，而加密货币的损失可以被模拟为每年总供应量的百分比，因此流通中的货币总供应量实际上最终会稳定在一个等于每年发行量除以损失率的数值上（例如，在损失率为 1% 时，一旦供应量达到 26 倍，那么每年将有 0.26 倍被开采，0.26 倍丢失，形成一个平衡点）。\n注意，未来以太坊可能过渡到权益证明模型以确保安全，将每年发行量降低到 0 至 0.05 倍之间。 如果以太坊组织失去资助或出于任何其他原因而消失，我们将开放一个“社区合约”：任何人都有权创建未来的以太坊候选版本，唯一的条件是太币数量必须最多为 60102216 * (1.198 + 0.26 * n) 个，其中 n 是创世块产生后的年数。 创建者可以自由地通过众筹或其他方式，分配权益证明驱动的供应增加与最大允许供应增加之间的部分或全部差额，以支付开发费用。 不符合社区合约的候选版本升级可能被合理地分叉为兼容版本。\n挖矿中心化 比特币挖矿算法的原理是，让矿工一次又一次地对区块头稍作修改的版本进行数百万次 SHA256 计算，直到最终某个节点所产生版本的哈希小于目标值（目前大约为 2192）。 然而，这种挖矿算法容易遭受两种形式的中心化攻击。 第一种，挖矿生态系统已经被 ASIC（专用集成电路）所支配，这些计算机芯片专门为特定的比特币挖矿任务而设计，因此效率提高了数千倍。 这意味着比特币挖矿不再是一种高度去中心化和平等的事业，需要巨额资本才能有效参与。 第二种，大部分比特币矿工事实上不在本地完成区块验证；而是依赖中心化矿池提供区块头。 这个问题可以说更糟：截至撰写本文时，排名前三的矿池间接控制了比特币网络中大约 50% 的处理能力，尽管当矿池或联盟试图进行 51％ 攻击时，矿工可以转换到其他矿池这一事实缓解了该问题。\n以太坊现在的目的是使用一种挖掘算法，要求矿工从状态中获取随机数据，从区块链的最后 N 个区块中计算一些随机选择的交易，并返回结果的哈希值。 这有两个重要好处。 首先，以太坊合约可以包含任何类型的计算，因此以太坊 ASIC 本质上是用于一般计算的 ASIC，即更好的 CPU。 其次，挖矿需要访问整个区块链，这迫使矿工存储整个区块链并至少能够验证每笔交易。 这样就消除了对中心化矿池的需求；虽然矿池仍然可以起到平衡奖励分配随机性的合法作用，但没有中心化控制的点对点矿池同样也可以很好地发挥此功能。\n该模型未经测试，在将合约执行作为挖矿算法使用时，在避免某些巧妙优化的过程中可能会遇到困难。 然而，这种算法有一个值得注意的特点，任何人都可以通过将专用于抑制某些 ASIC 的大量合约引入区块链中，在“井里下毒”。 由于存在经济激励，ASIC 制造商会使用这种方法互相攻击。 因此，我们正在开发的解决方案最终是一种适应性人为经济解决方案，而不是纯粹的技术解决方案。\n可扩展性 可扩展性问题是以太坊常被关注的一个方面。 像比特币一样，以太坊也有缺陷，即网络中的每个节点都需要处理每笔交易。 使用比特币，当前区块链的大小约为 15 GB，每小时增长约 1 MB。 如果比特币网络像 Visa 一样每秒处理 2000 笔交易，它将每三秒增长 1 MB（每小时 1 GB，每年 8 TB）。 以太坊可能也会经历相似甚至更糟的增长模式，因为以太坊区块链之上还有很多应用，不像比特币区块链上只有货币，但以太坊完整节点只需存储状态而不是完整的区块链历史，这一事实让情况得到了改善。\n大区块链的问题是中心化风险。 如果区块链大小增加到 100 TB，可能的情况是只有极少数大型企业能运行完整节点，而所有普通用户将使用轻 SPV 节点。 在这种情况下，可能会出现这样的担忧：完整节点合伙欺诈牟利（例如更改区块奖励，给他们自己比特币等）。 轻节点无法立即检测到这一点。 当然，可能至少存在一个诚实的完整节点，几个小时之后有关诈骗的信息会通过 Reddit 这样的渠道泄露，但这时已为时过晚：将由普通用户相互组织协作将指定区块列入黑名单，这种大规模的、很可能不切实际的协作在规模上无异于发动一次成功的 51% 攻击。 就比特币而言，目前这是一个问题，但 Peter Todd 建议对区块链进行修改，以缓解这一问题。\n在短期内，以太坊将使用两种其他策略来应对这个问题。 首先，因为基于区块链的挖矿算法，至少每个矿工都会被强制成为一个完整节点，为完整节点的数量创建了一个下限。 其次，更重要的是，处理完每笔交易后，我们会把一个中间状态树根收录到区块链中。 即使区块验证是中心化的，只要存在一个诚实的验证节点，就可以通过验证协议规避中心化问题。 如果矿工发布了无效区块，该区块必定是格式错误，或者是状态 S[n] 不正确。 由于已知 S[0] 是正确的，因此必然存在第一个不正确的状态 S[i]，但状态 S[i-1] 是正确的。 验证节点将提供索引 i 以及“无效证明”，该证明包括处理 APPLY(S[i-1],TX[i]) -\u0026gt; S[i] 所需的帕特里夏树节点的子集。 节点将能够使用这些节点来运行该部分计算，并查看生成的 S[i] 与提供的 S[i] 是否不匹配。\n另一种更复杂的攻击涉及恶意矿工发布不完整的区块，因此甚至不存在完整信息，致使无法确定区块是否有效。 解决方案是质询-应答协议：验证节点对目标交易索引发起“质疑”，接受到质疑信息的轻节点会对相应的区块取消信任，直到另外的节点（无论是矿工还是另一个验证者）提供一个帕特里夏树节点子集作为有效性证明。\n结论 以太坊协议最初被设想为加密货币的升级版本，通过高度通用的编程语言提供高级功能，如区块链托管、提款限制、金融合约、博彩市场等。 以太坊协议不会直接“支持”任何应用，但图灵完备编程语言的存在意味着，理论上可以为任何交易类型或应用创建任意合约。 然而，关于以太坊更有趣的方面是，以太坊协议远远超出了货币的范畴。 围绕去中心化文件存储、去中心化计算和去中心化预测市场的协议以及许多其他这类概念，有可能大大提高计算行业的效率，并首次通过添加经济层来大力促进其他点对点协议的发展。 最后，还有大量与金钱完全无关的应用程序。\n以太坊协议实现的任意状态转换函数的概念提供了一个具有独特潜力的平台；而不是一种专门针对数据存储、赌博或金融领域内一系列特定应用的封闭式单用途协议，以太坊在设计上是开放式的，我们相信在今后几年中它非常适合作为大量金融和非金融协议的基础层。\n注释与延伸阅读 注释 有经验的读者可能会注意到，事实上比特币地址是椭圆曲线公钥的哈希，而非公钥本身。 然而事实上从密码学术语角度把公钥哈希称为公钥完全合理。 这是因为比特币密码学可以视为一种定制的数字签名算法。在数字签名算法中，公钥由 ECC（椭圆曲线加密算法）公钥的哈希组成，签名由连接了 ECC 签名的 ECC 公钥组成。而验证算法涉及用 ECC 公钥哈希（作为公钥提供）来检查签名中的 ECC 公钥，然后用 ECC 公钥来验证 ECC 签名。 技术上来说，前 11 个区块的中位数。 在内部，2 和 \u0026ldquo;CHARLIE\u0026rdquo; 都是数字 [fn3]（注释编号），后者采用大端序基数 256 表示。 数字可以至少为 0，最大为 2256-1。 延伸阅读 内在价值 智能资产 智能合约 B-money 可重复使用的工作量证明 利用所有者权限确保财产权 比特币白皮书 域名币 佐科三角 彩色币白皮书 万事达币白皮书 去中心化自治公司，比特币杂志 简化支付确认 默克尔树 帕特里夏树 GHOST 协议 StorJ 和自治代理，Jeff Garzik Mike Hearn 在图灵节上谈论智能资产 以太坊递归长度前缀编码 (RLP) 以太坊默克尔帕特里夏树 Peter Todd 论默克尔求和树 有关本白皮书的历史，请参阅此维基文章。\n和众多社区驱动的开源软件项目一样，以太坊自启动以来一直不断发展。 若想了解以太坊的最新进展以及如何更改以太坊协议，我们推荐您阅读本指南。\nRe https://github.com/ethereum/ethereum-org-website\n","permalink":"https://vcvvvc.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6/","tags":["Blockchain"],"title":"以太坊白皮书_zh_随时更新"},{"categories":null,"contents":"2021年整理， 2023年更新一下\n条款01: 将C++视为一个语言联邦 C++已经是个多重范型编程语言 (multiparadigm programming language）\n同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。\n条款02：尽量以 const，enum，inline替换#define 也可以说是 宁可以编译器替换预处理器\n#define 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间\n第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：\nclass Gameplayer { private: static const int NumTurns = 5; //常量声明式 int scores[NumTurns]; ... }; 第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的\u0026quot;the enum hack\u0026quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”\nenum hack的行为某方面说比较像#define而不像const\nclass Gameplayer { private: enum {NumTurns = 5}; int scores[NumTurns]; ... }; 本文要点\n对于单纯常量,最好以const对象或enums替换#defines.\n对于形似函数的宏(macros) ,最好改用inline函数替换#defines.\n条款03: 尽可能使用const 如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。\n作用\n修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:你曾经承诺不改动的那个对象被改动了。这就是为什么\u0026quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。\nnon-const成员函数本来就可以对其对象做任何动作,所以在其中调用一个const成员函数并不会带来风险。这就是为什么本例以static_cast作用于*this的原因: 这里并不存在const相关危险。\n观点\n将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。 编译器强制实施bitwise constness,但你编写程序时应该使用“概念上的常量性” (conceptual constness) 当const和non-const成员函数有着实质等价的实现时,令non-const版本调用const版本可避免代码重复。 条款04: 确定对象被使用前已先被初始化 第一、 读取未初始化的值会导致不明确的行为。\n第二、使用构造函数初始化列表进行初始化为佳\n#2这个构造函数和#1的最终结果相同,但通常效率较高。基于赋值的那个版 本(本例第一版本)首先调用default构造函数为theName, theAddress和thePhones设初值,然后立刻再对它们赋予新值。 default构造函数的一切作为因此浪费了。\nclass ABEntry { public: ABEntry(); private: int a; int b; int c; }; # 1 ABEntry::ABEntry() { a = 0; b = 0; c = 0; } #2 ABEntry::ABEntry() : a(0), b(0), c(0) {} 有些情况下即使面对的成员变量属于内置类型(那么其初始化与赋值的成本相同) ,也一定得使用初值列。是的,如果成员变量是const或references,它们就一定需要初值,不能被赋值。\n第三、 防止初始化次序问题 合理运用单例模式\n#1 class Filesystem { public: ... static Filesystem* fts(); }; Filesystem* Filesystem::GetInstance() { static connection_pool connPool; return \u0026amp;connPool; } #2 class Filesystem { private: static Filesystem* fts; Filesystem(){}; public: static Filesystem* getInstance() { if (fts == nullptr) { fts = new Filesystem(); } return fts; } }; 本文要点\n为内置型对象进行手工初始化,因为C++不保证初始化它们。 构造函数最好使用成员初值列(member initialization list) ,而不要在构造函数 本体内使用赋值操作(assignment) 。初值列列出的成员变量,其排列次序应该和它们在class中的声明次序相同。 为免除“跨编译单元之初始化次序”问题,请以local static对象替换non-local static对象。 条款05: 了解C++默默编写并调用哪些函数 编译器可以暗自为class创建默认构造函数、拷贝构造函数、拷贝赋值操作符、以及析构函数。记住，这些函数不是类一创建出来就有的，惟有当这些函数被需要（调用），它们才会被编译器创建出来。\n当然，如果你在创建类时，自己声明了那些函数，编译器就不会再创建了。\n条款06: 若不想使用编译器自动生成的函数，就该明确拒绝 class HomeForSale { public: ... private: HomeForSale(const HomeForSale\u0026amp;); HomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;); ... }; 本文要点\n为驳回编译器自动(暗自)提供的机能,可将相应的成员函数声明为private并且 不予实现。使用像Uncopyable这样的base class也是一种做法。 条款07: 为多态基类声明virtual析构函数 如果base class没有virtual 会直接调用base class析构函数, derived class成员未释放。造成资源泄漏、内存浪费。\n无端地将所有classes的析构函数声明为virtual,就像从未声明它们为virtual一样,都是错误的。许多人的心得是:只有当class内含至少一个virtual函数,才为它声明virtual析构函数。\n欲实现出virtual函数,对象必须携带某些信息,主要用来在运行期决定哪一个 virtual函数该被调用。这份信息通常是由一个所谓vptr (virtual table pointer)指针指 出。vptr指向一个由函数指针构成的数组,称为vtbl(virtual table);每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数,实际被调用的函数取决于该对象的vptr所指的那个vtbl-编译器在其中寻找适当的函数指针。\n第二、 关于虚函数、纯虚函数\n虚函数，在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func() 纯虚函数，在虚函数后加“=0”，如 virtual void func()=0 对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。 对于纯虚函数，子类必须提供纯虚函数的个性化实现。 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。 构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。 如何选用\n当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。 当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。 本文要点\npolymorphic (带多态性质的) base classes应该声明一个virtual析构函数。如果 class带有任何virtual函数,它就应该拥有一个virtual析构函数。 Classes的设计目的如果不是作为base classes使用,或不是为了具备多态性 (polymorphically) ,就不该声明virtual析构函数。 条款08: 别让异常逃离析构函数 当vector v被销毁,它有责任销毁其内含的所有widgets。假设v内含十个Widgets,而在析构第一个元素期间,有个异常被抛出。其他九个widgets还是应该被销毁(否则它们保存的任何资源都会发生泄漏) ,因此v应该调用它们各个析构函数。但假设在那些调用期间,第二个widget析构函数又抛出异常。\nclass Widget { public: ~widget() { ... //假设可能抛出异常 }; }; void dosomething() { std:;vector\u0026lt;widget\u0026gt; v; ... } 但如果你的析构函数必须执行一个动作，如果该调用导致异常, DBConn析构函数会传播该异常,也就是允许它离开这个析构函数。\nclass DBConnection { public: static DBconnection create(); void close(); private: DBConnection db; }; 有两个方法 但是作用不大\n1. 调用abort\n如果程序遭遇一个“于析构期间发生的错误”后无法继续执行, “强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数传播出去(那会导致不明确的行为)。也就是说调用abort可以抢先制“不明确行为”于死地。\n2. 吞下因调用close而发生的异常\nDBconn::~DBconn() { try{ db.close(); } catch(...) { std::abort(); } } 一个较佳策略是重新设计DBConn接口,使其客户有机会对可能出现的问题作出反应。\n如果某个操作可能在失败时抛出异常,而又存在某种需要必须处理该异常,那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险,总会带来“过早结束程序”或“发生不明确行为”的风险。\nclass DBConn{ public: ... void close() //供客户使用的新函数 { db.close(); closed = true; } ~DBConn() { if(!closed){ try{ //关闭连接（如果客户不那么做的话） db.close(); } catch(...){ //如果关闭动作失败，记录下并结束程序或吞下异常 //制作运转记录，记下对close的调用失败； ... } } } private: DBConnection db; bool closed; }; 本文要点\n析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下它们(不传播)或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么class应该提供一个普通函数(而非在析构函数中)执行该操作。 条款09: 绝不在构造和析构过程中调用virtual函数 BuyTransaction b;这时候被调用的logTransaction是 Transaction内的版本,不是Buyrransaction内的版本-即使目前即将建立的对象类型是BuyTransaction。base class构造期间virtual函数绝不会下降到derived classes阶层。\n非正式的说法或许比较传神: 在base class构造期间, virtual函数不是virtual函数。\nclass Transaction { public: Transaction( ); virtual void logrransaction() const=0; ... }; Transaction:: Transaction () { ... logTransaction(); } class BuyTransaction: public Transaction { public: virtual void logrransaction() const; ... }; class SellTransaction: public Transaction { public: virtual void logTransaction() const; ... }; 其他方案可以解决这个问题。一种做法是在class Transaction内将 1ogTransaction函数改为non-virtual,然后要求derived class构造函数传递必要信 息给Transaction构造函数,而后那个构造函数便可安全地调用non-virtual logTransaction。\nclass BuyTransaction: public Transaction { public: Buyrransaction ( parameters) : Transaction (createLogstring ( parameters )) {...} private: static std::string createLogstring( parameters ); }; 本文要点\n在构造和析构期间不要调用virtual函数,因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)。 条款10: 令operator=返回一个reference to *this Widget\u0026amp; operator=(const Widget\u0026amp; rhs) //返回类型是个reference，指向当前对象 { ... return *this; //返回左侧对象 } # 实现连锁赋值 int x, y, z; x = y = z = 15; //赋值连锁形式 本文要点\n令赋值(assignment)操作符返回一个reference to *this 条款11: 在operator=中处理“自我赋值” class Bitmap {...}; class Widget { ... private: Bitmap* pb; }; # 直接赋值不具备自我赋值安全、异常安全性 # 传统不安全做法 # 不具备异常安全性 Widget\u0026amp; Widget::operator= (const Widqet\u0026amp; rhs) { delete pb; pb = new Bitmap(*rhs.pb); return *this; } # 保证异常安全性做法 Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Bitmap* pOring = pb; pb = new Bitmap(*rhs.pb); delete pOring; return *this; } # copy-and-swap v1 Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Widget temp (rhs); swap (temp); return *this; } # copy-and-swap v2 Widget\u0026amp; Widget::operator=(Widget rhs) { Widget temp (rhs); swap (temp); return *this; } 本文要点\n确保当对象自我赋值时operator-有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap. 确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为仍然正确。 条款12: 复制对象时勿忘其每一个成分 如果你声明自己的copying函数,意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的,会以一种奇怪的方式回敬: 当你的实现代码几乎必然出错时却不告诉你。\n当类含有其他类的成员、类发生继承\nclass Date { ... }; class Customer { public: ... private: std::string name; Date lastTransaction; }; class PriorityCustomer: public Customer { public: PrioriuyCustomer(const PriorityCustomer\u0026amp; rhs); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp; rhs); private: int priority; }; Prioritycustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : priority(rhs.priority) { logCall(\u0026#34;PriorityCustomer copy constructor\u0026#34;); } PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { logCall(\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); priority=rhs.priority; return *this; } 它们复制了Prioritycustomer声明的成员变量, 但每个PriorityCustomer还内含它所继承的Customer成员变量复件(副本) ,而那些成员变量却未被复制。\n应该让derived class的copying函数调用相应的base class函数\nPriorityCustomer::PriorityCustomer(const Prioritycustomer\u0026amp; rhs) : customer(rhs), priority(rhs.priority) { logCall (\u0026#34;PriorityCustomer copy constructor\u0026#34;); } PriorityCustomer\u0026amp; PriorityCustomer::operator=(const Prioritycustomer\u0026amp; rhs) { logCall (\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); Customer: : operator= (rhs); priority=rhs.priority; return *this; } copy assignment操作符调用copy构造函数是不合理的,因为这就像试图构造一个已经存在的对象。\n反方向\u0026ndash;令copy构造函数调用copy assignment操作符-同样无意义。构造函数用来初始化新对象,而assignment操作符只施行于已初始化对象身上。\n本文要点\n本条款题目所说的“复制每一个成分”现在应该很清楚了。当你编写一个copying函数,请确保:\n复制所有local成员变量 调用所有base classes内的适当的 copying函数。 Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”\n不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中,并由两个coping函数共同调用。\n条款13: 以对象管理资源 所谓资源就是,一旦用了它,将来必须还给系统。C++程序中最常使用的资源就是动态分配内存(如果你分配内存却从来不曾归还它,会导致内存泄漏) ,但内存只是你必须管理的众多资源之一。\n程序中过早的return、continus、goto等 略过delete， 泄漏的不只是内含投资对象的那块内存,还包括那些投资对象所保存的任何资源。\n使用智能指针\nauto_ptr在C++11已被弃用\n代替方案为 “引用计数型智慧指针\u0026quot;(reference-counting smart pointer;RCSP)\nvoid f() { std::tr1::shared_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); ... } 获得资源后立刻放进管理对象( managing object)内。 管理对象(managing object)运用析构函数确保资源被释放。 本文要点\n为防止资源泄漏,请使用RAI1对象,它们在构造函数中获得资源并在析构函数中释放资源。 两个常被使用的RAlI classes分别是tr1::shared-ptr和autoptr,前者通常是较佳选择,因为其copy行为比较直观。若选择auto-ptr,复制动作会使它(被复制物)指向null 条款14: 在资源管理类中小心coping行为 Lock ml1 (\u0026amp;m); //锁定m Lock ml2 (ml1); //将ml1复制到m12身上。这会发生什么事? 当一个RAI1对象被复制 该怎么办:\n禁止复制 对底层资源采用“引用计数法”(智能指针) 复制底部资源。(深度拷贝) 转移底部资源的拥有权。 本文要点\n复制RAl1对象必须一并复制它所管理的资源,所以资源的copying行为决定 RAII对象的copying行为。 普遍而常见的RAll class copying行为是:抑制copying、施行引用计数法 (reference counting) 。不过其他行为也都可能被实现。 条款15: 在资源管理类中提供对原始资源的访问 最佳设计很可能是坚持条款18的忠告: “让接口容易被正确使用,不易被误用”。\n本文要点\nAPIs往往要求访问原始资源(raw resources) ,所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。 条款16: 成对使用new和delete时要采取相同形式 本文要点\n如果你在new表达式中使用1],必须在相应的delete表达式中也使用1]。如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[] 条款17: 以独立语句将newed对象置入智能指针 void processwidget(std::tr1::shared ptr\u0026lt;widget\u0026gt; pw, priority()); 虽然我们在此使用“对象管理式资源” (object-managingresources) ,上述调用却可能泄漏资源。\n在调用processWidget之前,编译器必须创建代码,做以下三件事:\n调用priority 执行\u0026quot;new widget\u0026quot; 调用trl::sharedptr构造函数 c++并不是特定次序完成函数参数的核算、弹性大。如果priority出现异常 new widget返回的指针将会遗失\n本文要点\n以独立语句将newed对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。 条款18: 让接口容易被正确使用,不易被误用 std::tr1::shared ptr\u0026lt;Investment\u0026gt; pInv( static cast\u0026lt;Investment*\u0026gt;(0), getRidofInvestment); 本文要点\n好的接口很容易被正确使用,不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性,以及与内置类型的行为兼容。 “阻止误用”的办法包括建立新类型、限制类型上的操作,束缚对象值,以及消除客户的资源管理责任。 tr1::sharedptr支持定制型删除器(custom deleter) 。这可防范DLL问题,可被用来自动解除互斥锁(mutexes,见条款14)等等。 条款19:设计class犹如设计type 在设计class时,要考虑一系列的问题, 包括：\n新type的对象应该如何被创建和销毁（构造和析构） 对象的初始化和对象的赋值该有什么样的差别，这个答案决定你的构造函数和赋值操作符的行为，以及其间的差异。 新的type的对象如果被pass by value，意味着什么？记住，拷贝构造函数用来定义一个type的pass-by-value该如何实现。 什么是新type的“合法值”？（约束条件）成员函数必须进行错误检查工作。 你的新type需要配合某个继承图系吗？（注意虚函数） 你的新type需要什么样的转换？（显示转换、类型转换操作符） 什么样的操作符和函数对此新type而言是合理的？这决定你为你的class声明哪些函数，哪些是成员函数，哪些不是。 什么样的标准函数应该驳回？那些正是必须声明为private者（条款6）。 什么是新type的“未声明接口” 你的新type有多么一般化？（class template） 成员函数和成员变量的可见范围（public/protected/private） 是否真的需要一个新type 本文要点\nClass的设计就是type的设计。在定义一个新type之前,请确定你已经考虑过本条款覆盖的所有讨论主题。 条款20:宁以pass-by-reference-to-const替换pass-by-value bool validatestudent(const student\u0026amp; s); 这种传递方式的效率高得多:没有任何构造函数或析构函数被调用,因为没有任何新对象被创建。修订后的这个参数声明中的const是重要的。以by reference方式传递参数也可以避免对象切割问题\n本文要点\n尽量以pass-by-reference-to-const替换pass-by-value,前者通常比较高效,并可避免 切割问题(slicing problem) 。 以上规则并不适用于内置类型,以及STL的迭代器和函数对象。对它们而言, pass-by-value往往比较适当。 条款21: 必须返回对象时,别妄想返回其reference 任何时候看到一个引用声明式，你都应该立刻问自己，它的另一个名称是什么？\n虽然函数参数最好用引用值，但函数返回值却不要随便去用引用，这回造成很多问题，比如引用的对象在函数结束后即被销毁，或是需要付出很多成本和代码来保证其不被销毁且不重复，这大概率没有必要，就返回一个值/对象就好了。\n本文要点\n绝不要返回pointer或reference指向一个local stack对象,或返回reference指向一 个heap-allocated对象,或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference指向一个local static对象”提供了一份设计实例。 条款22:将成员变量声明为private 封装重要性,可以确保class的约束条件总是会获得维护,因为只有成员函数可以影响它们。\nprotected并不比public更加具有封装性，因为protected修饰的成员变量一旦修改，也会造成子类的大量修改。\n从封装的角度观之,其实只有两种访问权限: private (提供封装)和其他(不提供封装)\n本文要点\n切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证,并提供class作者以充分的实现弹性。 protected并不比public更具封装性。 条款23: 宁以non-member, non-friend替换member函数 提供non-member函数可允许对webBrowser相关机能有较大的包裹弹性 (packaging flexibility) ,而那最终导致较低的编译相依度,增加webBrowser的可延伸性。\nvoid clearBrowser(WebBrowser\u0026amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } 愈少代码可以看到数据(也就是访问它) ,愈多的数据可被封装,而我们也就愈能自由地改变对象数据\n在C++,比较自然的做法是让clearBrowser成为一个non-member函数并且位于 WebBrowser所在的同一个namespace (命名空间)内:\nnamespace WebBrowserStuff{ class WebBrowser{... }; void clearBrowser(WebBrowser\u0026amp; wb); } 本文要点\n宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包 裹弹性(packaging flexibility)和机能扩充性。 条款24: 若所有参数皆需类型转换,请为此采用non-member函数 class Rational { public: const Rational operator*(const Rational\u0026amp; rhs) const; }； #没问题 Rational oneEighth(1, 8); Rational oneHalf(1, 2); Rational result = oneHalf * oneEighth; result = result * oneEighth; result = oneHalf * 2; // result = oneHalf.operator*(2); #错误 result = 2 * oneHalf; //出错 result = 2.operator*(oneHalf); 编译器知道你正在传递一个int,而函数需要的是Rational;但它也知道只要调用Rational构造函数并赋予你所提供的int,就可以变出一个适当的Rational来。\n结论是,只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”\u0026ndash;即this对象-的那个隐喻参数,绝不是隐式转换的合格参与者。\nclass Rational{ ... }; const Rational operator* (const Rational\u0026amp; 1hs, const Rational\u0026amp; rhs) { return Rational (1hs.numerator() * rhs.numerator( ), 1hs.denominator() * rhs.denominator()); } #编译通过 Rational oneFourth (1, 4); Rational result; result = oneFourth * 2; result = 2 * oneFourth; operator* 无需设置为friend 因为operator* 可以完全藉由Rational的public接口完成任务\n结论是,只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”\u0026ndash;即this对象-的那个隐喻参数,绝不是隐式转换的合格参与者。\n本文要点\n如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换,那么这个函数必须是个non-member. 条款25: 考虑写出一个不抛异常的swap函数 namespace WidgetStuff { class widget { public: void swap (Widget\u0026amp; other) { using std::swap; swap (pImpl, other.pImpl); } }; template\u0026lt;typename T\u0026gt; void swap(widget\u0026lt;T\u0026gt;\u0026amp; a, widget\u0026lt;T\u0026gt;\u0026amp; b) { a.swap(b); } } #调用T专属版本,并在该版本不存在的情况下调用std内的一般化版本。 template\u0026lt;typename T\u0026gt; void dosomething(T\u0026amp; a, T\u0026amp; b) { using std::swap; ... swap(a, b); } } 本文要点\n成员函数swap版本绝不可抛出异常 当std::swap对你的类型效率不高时,提供一个swap成员函数,并确定这个函数不抛出异常。 如果你提供一个member swap,也该提供一个non-member swap用来调用前者。对 于classes (而非templates) ,也请特化std::swapo 调用swap时应针对std: :swap使用using声明式,然后调用swap并且不带任何“命名空间资格修饰” 为“用户定义类型”进行std templates全特化是好的,但千万不要尝试在std内加入某些对std而言全新的东西。 条款26: 尽可能延后变量定义式的出现时间 std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; string encrypted; if (password.length() \u0026lt; MinimumPasswordLength) { throw logic_error (\u0026#34;Password is too short\u0026#34;); } ... return encrypted; ） 如果函数encryptPassword丢出异常,你仍得付出encrypted的构造成本和析构成本。所以最好延后encrypted的定义式,直到确实需要它。\n#1 效率低 std::string encrypted; encrypted = password; #高效 std::string encrypted (password); 你不只应该延后变量的定义,直到非得使用该变量的前一刻为止,甚至应该尝试延后这份定义直到能够给它初值实参为止。\n#做法A: 1个构造函数+1个析构函数+n个赋值操作 #方法A:定义于循环外 widget w; for (int i=0; i \u0026lt;n; ++i) { w = //取决于i的某个值; } #做法B: n个构造函数+n个析构函数 #方法B:定义于循环内 for (int i=0; i\u0026lt;n; ++i) { widget w(//取决于i的某个值); } 你知道赋值成本比“构造+析构”成本低 你正在处理代码中效率高度敏感(performance-sensitive)的部分,否则你应该使用做法B 本文要点\n尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。 条款27: 尽量少做转型动作 const-cast通常被用来将对象的常量性转除(cast away the constness) dynamic-cast主要用来执行“安全向下转型” (safe downcasting) ,也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作,也是唯一可能耗费重大运行成本的转型动作 reinterpret-cast意图执行低级转型,实际动作(及结果)可能取决于编译器,这也就表示它不可移植。 static_cast用来强迫隐式转换(implicit conversions) C不可能发生这种事,Java不可能发生这种事,C#也不可能发生这种事。但C++可能!\nclass window { public: virtual void onResize() {...} ... }； class Specialwindow: public Window { public: virtual void onResize() { static_cast\u0026lt;window\u0026gt; (*this).onResize (); ... } } 解决之道是拿掉转型动作,代之以你真正想说的话。你并不想哄骗编译器将 *this视为一个base class对象,你只是想调用base class版本的onResize函数,令它作用于当前对象身上。\nclass Specialwindow: public window { public: virtual void onResize() { #调用window:;onresize 作用于*this上 window::onResize(); } } 本文要点\n如果可以,尽量避免转型,特别是在注重效率的代码中避免dynamic-casts.如果有个设计需要转型动作,试着发展无需转型的替代设计。 如果转型是必要的,试着将它隐藏于某个函数背后。客户随后可以调用该函数,而不需将转型放进他们自己的代码内。 宁可使用C++-style (新式)转型,不要使用旧式转型。前者很容易辨识出来, 而且也比较有着分门别类的职掌。 条款28: 避免返回handles指向对象内部成分 class Point { public: Point (int x, int y); void setx(int newVal); void setY(int newVal); ... }; struct RectData { Point ulhc; Point lrhc; }; class Rectangle { ... private: std::tr1::shared_ptr\u0026lt;RectData\u0026gt; pData; }; #根据条款20 以by reference方式传递用户自定义类型往往比以by value方式传递更高效 #错误： 两个函数都返回references指向private内部数据,调用者于是可通过这些references更改内部数据! class Rectangle { public: Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } }； 成员变量的封装性最多只等于“返回其 reference\u0026quot;的函数的访问级别。 如果const成员函数传出一个reference,后者所指数据与对象自身有关联,而它又被存储于对象之外,那么这个函数的调用者可以修改那笔数据。 通常我们认为,对象的“内部”就是指它的成员变量,但其实不被公开使用的成员函数(也就是被声明为protected或private者)也是对象“内部”的一部分。因此也应该留心不要返回它们的handles.这意味你绝对不该令成员函数返回一个指针指向“访问级别较低”的成员函数。\n#代码返回类型加上const即可 class Rectangle { public: const Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } const Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } ... }; 但即使如此, upperLeft和lowerRight还是返回了“代表对象内部”的handles,有可能在其他场合带来问题。更明确地说,它可能导致dangling handles (空悬的号码牌): 这种handles所指东西(的所属对象)不复存在。这种“不复存在的对象”最常见的来源就是函数返回值。\n本文要点\n避免返回handles (包括references、指针、迭代器)指向对象内部。遵守这个条款可增加封装性,帮助const成员函数的行为像个const,并将发生“虚吊号码 牌” (dangling handles)的可能性降至最低。 条款29: 为“异常安全”而努力是值得的 void PrettyMenu::changeBackground (std::istream\u0026amp; imgSrc) { using std:: swap; Lock ml (\u0026amp;mutex) ; std::tr1::shared ptr\u0026lt;PMImpl\u0026gt; pNew (new PMImpl (*pImpl)); pNew-\u0026gt;bgImage.reset (new Image (imgSrc)); ++pNew-\u0026gt;imageChanges; swap (pImpl, pNew); } 当异常被抛出时,带有异常安全性的函数会:\n不泄漏任何资源。 不允许数据败坏。 异常安全函数(Exception-safe functions)提供以下三个保证之一:\n基本承诺:如果异常被抛出,程序内的任何事物仍然保持在有效状态下。 强烈保证:如果异常被抛出,程序状态不改变。 不抛掷( nothrow)保证,承诺绝不抛出异常,因为它们总是能够完成它们原先承诺的功能。 智能指针使用reset，当new Image(imgSrc)成功后，才会删除旧图像。\nclass PrettyMenu{ ... std::tr1::shared_ptr\u0026lt;Image\u0026gt; bgImage; ... }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { Lock m1(\u0026amp;mutex); bgImage.reset(new Image(imgSrc));//用new Image执行结果设定bgImage内部指针 ++imageChanges; } 第二、将所有“隶属对象的数据”从原对象放进另一个对象内,然后赋予原对象一个指针,指向那个所谓的实现对象(implementation object,即副本)。这种手法常被称为pimpl idiom\ncopy-and-swap策略\n当“强烈保证”不切实际时,你就必须提供“基本保证”\n一般而言并不保证函数具有强烈的异常安全性\nvoid PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { using std::swap; Lock ml(smutex); std::tr1::shared ptr\u0026lt;PMImpl\u0026gt; pNew (new PMImpl(*pImpl)); pNew-\u0026gt;bgImage.reset(new Image(imgSrc)); ++pNew-\u0026gt;imageChanges; swap(pImpl, pNew); } 如果函数哪还对另外两个函数进行操作:\nvoid someFunc() { ... f1(); f2(); ... } 假设f1只提供基本保证,那么为了让someFunc提供强烈保证,我们必须写出代码获得调用f1之前的整个程序状态、捕捉f1的所有可能异常、然后恢复原状态。 如果F1和f2都是“强烈异常安全” ,情况并不就此好转。毕竟如果f1圆满结束,程序状态在任何方面都可能有所改变,因此如果f2随后抛出异常,程序状态和someFunc被调用前并不相同,甚至当F2没有改变任何东西时也是如此。 问题出在“连带影响” (side effects) 。如果函数只操作局部性状态(local state,例如somerunc只影响其“调用者对象”的状态),便相对容易地提供强烈保证。但是当函数对“非局部性数据” (non-local data)有连带影响时,提供强烈保证就困难得多。\n本文要点\n异常安全函数(Exception-safe functions)即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证:基本型、强烈型、不抛异常型。 “强烈保证”往往能够以copy-and-swap实现出来,但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。 条款30: 透彻了解inlining的里里外外 过度热衷inlining会造成程序体积太大(对可用空间而言)。即使拥有虚内存, inline造成的代码膨胀亦会导致额外的换页行为(paging) ,降低 指令高速缓存装置的击中率(instruction cache hit rate) ,以及伴随这些而来的效率损失。 inline只是对编译器的一个申请,不是强制命令。这项申请可以隐喻提出,也可以明确提出。隐喻方式是将函数定义于class定义式内。\nclass Person { public: int age() const { //一个隐喻的inline申请: //age被定义于class定义式内。 return theAge; } ... private: int theAge; }; friend函数也可被定义于class内,如果真是那样,它们也是被隐喻声明为inline.\ntemplate\u0026lt;typename T\u0026gt; inline const T\u0026amp; std::max(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b : a; } Template的具现化与inlining无关。如果你写的template没有理由要求它所具现的每一个函数都是inlined,就应该避免将这个template声明为inline (不论显式或隐式) 。\n本文要点\n将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级(binary upgradability)更容易,也可使潜在的代码膨胀问题最小化,使程序的速度提升机会最大化。 不要只因为function templates出现在头文件,就将它们声明为inline. 条款31: 将文件间的编译依存关系降至最低 #include \u0026lt;string\u0026gt; #include \u0026#34;date.h\u0026#34; #include \u0026#34;address.h\u0026#34; 这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系(compilation dependency)。如果这些头文件中有任何一个被改变,或这些头文件所倚赖的其他头文件有任何改变,那么每一个含入Person class的文件就得重新编译,任何使用Person class的文件也必须重新编译。\n接口与实现分离\n这个分离的关键在于以“声明的依存性”替换“定义的依存性”,那正是编译依存性最小化的本质:\n现实中让头文件尽可能自我满足,万一做不到,则让它与其他文件内的声明式(而非定义式)相依。其他每一件事都源自于这个简单的设计策略:\n如果使用object references或object pointers可以完成任务,就不要使用objects。你可以只靠一个类型声明式就定义出指向该类型的references和pointers;但如果定义某类型的objects,就需要用到该类型的定义式。 如果能够,尽量以class声明式替换class定义式。 为声明式和定义式提供不同的头文件。 另一个制作Handle class的办法是,令Person成为一种特殊的abstract base class (抽象基类) ,称为Interface class。\n本文要点\nHandle classes和Interface classes解除了接口和实现之间的耦合关系,从而降低文件间的编译依存性(compilation dependencies) 。 支持“编译依存性最小化”的一般构想是:相依于声明式,不要相依于定义式。 基于此构想的两个手段是Handle classes和Interface classes. 程序库头文件应该以“完全且仅有声明式” (full and declaration-only forms)的 形式存在。这种做法不论是否涉及templates都适用。 virtual函数意味“接口必须被继承” , non-virtual函数意味“接口和实现都必须被继承”。\n条款32: 确定你的public继承塑模出is-a关系 以C+进行面向对象编程,最重要的一个规则是: public inheritance (公开继承)意味\u0026quot;is-a\u0026quot; (是一种)的关系。\nclass Bird { public: virtual void fly(){cout \u0026lt;\u0026lt; \u0026#34;it can fly.\u0026#34; \u0026lt;\u0026lt; endl;} }; class Penguin: public Bird { // fly()被继承过来了，可以覆写一个企鹅的fly()方法，也可以直接用父类的 }; int main() { Penguin p; p.fly(); // 问题是企鹅并不会飞！ } 方法一，在Penguin的fly()方法里面抛出异常，一旦调用了p.fly()，那么就会在运行时捕捉到这个异常。这个方法不怎么好，因为它要在运行时才发现问题。\n方法二，去掉Bird的fly()方法，在中间加上一层FlyingBird类（有fly()方法）与NotFlyingBird类（没有fly()方法），然后让企鹅继承与NotFlyingBird类。这个方法也不好，因为会使注意力分散，继承的层次加深也会使代码难懂和难以维护。\n方法三，保留所有Bird一定会有的共性（比如生蛋和孵化），去掉Bird的fly()方法，只在其他可以飞的鸟的子类里面单独写这个方法。这是一种比较好的选择，因为根本没有定义fly()方法，所以Penguin对象调用fly()会在编译期报错。\n在艰难选择方法三之后，我们回过头来思考，就是在所有public继承的背后，一定要保证父类的所有特性子类都可以满足（父类能飞，子类一定可以飞），抽象起来说，就是在可以使用父类的地方，都一定可以使用子类去替换。\n这正是Liskov替代原则告诉我们的：任何父类可以出现的地方，子类一定可以替代这个父类，只有当替换使软件功能不受影响时，父类才可以真正被复用。通俗地说，是“子类可以扩展父类的功能，但不能改变父类原有的功能”。\n本文要点\n\u0026ldquo;public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于 derived classes身上,因为每一个derived class对象也都是一个base class对象。 条款33: 避免遮掩继承而来的名称 int x; void someFunc () { double x; std::cin \u0026gt;\u0026gt;x; } 这个读取数据的语句指涉的是local变量x,而不是global变量x,因为内层作用域的名称会遮掩(遮蔽)外围作用域的名称。\nclass Base { private: int x; public: virtual void mf1() =0; virtual void mf2(); void mf3 (); }； class Derived: public Base { public: virtual void mf1(); void mf4(); }； #mf4函数实现部分 void Derived::mf4 () { ... mf2(); } 当编译器看到这里使用名称mf2,必须估算它指涉(refer to)什么东西。编译器的做法是查找各作用域,看看有没有某个名为mf2的声明式。\nclass Base { private: int x; public: virtual void mf1() = 0; virtual void mfl(int); virtual void mf2(); void mf3(); void mf3 (double); ... }; #从名称查找观点来看，base::mf1和base::mf3不再被derived继承 Derived d; int x; d.mf1 (); //没问题,调用Derived::mf1 d.mf1 (x); //错误!因为Derived: :mf1遮掩了Base::mf1 d.mf2 (); d.mf3 (); d.mf3 (x); //错误!因为Derived::mf3遮掩了Base::mf3 解决方法1 using声明\n用using声明式来在子类中声明父类的同名函数(重载函数不需要声明多个),此时父类的各重载函数就是子类可见的了。\nclass Derived:public Base { public: using Base::mf1; using Base::mf3; virtual void mf1(); void mf3(); void mf4(); }; 解决方法2 转交函数\n使用转交函数，即在子类函数的声明时进行定义，调用父类的某个具体的重载函数（此时由于在声明时定义，成为inline函数），此举可以只让需要的部分父类重载函数于子类可见。\nclass Base { public: virtual void mf1() = 0; virtual void mf1(int); } class Derived:private Base { public: virtual void mf1() { Base::mfl(); }; Derived d; int x; d.mf1(); //调用Derived::mf1 d.mf1(x); //错误！Base::mf1被遮掩了 本文要点\nderived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日,可使用using声明式或转交函数(forwarding functions) 条款34: 区分接口继承和实现继承 public继承概念由两部分组成:\n函数接口(function interfaces)继承 函数实现(function implementations)继承 这两种继承的差异很像函数声明与函数定义之间的差异。\n成员函数的接口总是会被继承。一如条款32所说, public继承意味is-a (是一 种),所以对base class为真的任何事情一定也对其derived classes为真。 声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。 我们可以为pure virtual函数提供定义。也就是说可以为Shape::draw供应一份实现代码, C++并不会发出怨言,但调用它的唯一途径是“调用时明确指出其class名称” Shape* ps1 = new Rectangle; ps1-\u0026gt;Shape::draw(); //调用Shape::draw 声明简朴的(非纯) impure virtual函数的目的,是让derived classes继承该函数的接口和缺省实现。 “你必须支持一个error函数,但如果你不想自己写一个,可以使用Shape class提供的缺省版本”。\nclass Shape { public: virtual void error(const std::string\u0026amp; msg); }; class Airplane { public: virtual void fly(const Airport\u0026amp; destination) = 0; //pure virtual protected: void defaultFly(const Airport\u0026amp; destination); }; void Airplane::defaultFly(const Airport\u0026amp; destination) { #缺省行为,将飞机飞至指定的目的地。 } #inline函数和virtual函数之间的交互关系 class ModelA:public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { defaultFly(destination); } }; class ModelB:public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { defaultFly(destination); } }; #Airplane 中的pure virtual函数迫使Mode1C必须提供自己的fly版本: class ModelC:public Airplane { public: virtual void fly(const Airport\u0026amp; destination); }; Airplane继承体系如何给pure virtual函数一份定义\nclass Airplane { public: virtual void fly(const Airport\u0026amp; destination) = 0; }； void Airplane::fly(const Airport\u0026amp; destination) { //缺省行为,将飞机飞至指定的目的地 } class ModelA: public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { Airplane::fly(destination); //airplane } }; class ModelB: public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { Airplane::fly(destination); //airplane } } class Modelc: public Airplane { public: virtual void fly(const Airport\u0026amp; destination); }； void ModelC::fly(const Airport\u0026amp; destination) { //将c型飞机飞至指定的目的地 } 如果成员函数是个non-virtual函数,意味是它并不打算在derived classes中有不同的行为。实际上一个non-virtual成员函数所表现的不变性(invariant)凌驾其 特异性(specialization) ,因为它表示不论derived class变得多么特异化,它的行为都不可以改变。\n声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现。 class Shape { public: int objectID() const; } pure virtual函数、simple (impure) virtual函数、non-virtual函数之间的差异,使你得以精确指定你想要derived classes继承的东西:只继承接口,或是继承接口和一份缺省实现,或是继承接口和一份强制实现。\n两个常见的错误\n第一个错误是将所有函数声明为non-virtual。这使得derived classes没有余裕空间进行特化工作。non-virtual析构函数尤其会带来问题(见条款7) 。 另一个常见错误是将所有成员函数声明为virtual 本文要点\n接口继承和实现继承不同。在public继承之下, derived classes总是继承base class的接口。 pure virtual函数只具体指定接口继承。 简朴的(非纯) impure virtual函数具体指定接口继承及缺省实现继承。 non-virtual函数具体指定接口继承以及强制性实现继承。 条款35: 考虑virtual函数以外的其他选择 Non-Virtual Interface手法实现Template Method模式\nclass GameCharacter { public: int healthvalue() const { ... int retVal = doHealthValue (); return retVal; ... } ... private: virtual int doHealthValue() const { ... } }; 这一基本设计,也就是“令客户通过public non-virtual成员函数间接调用private virtual函数”,称为non-virtual interface (NVI)手法。\n藉由Function Pointers实现Strategy模式\nclass GameCharacter; //以下函数是计算健康指数的缺省算法。 int defaultHealthCalc (const GameCharacter\u0026amp; gc); class GameCharacter { public: typedef int (*HealthCalcFunc) (const GameCharacter\u0026amp;); explicit GameCharacter (HealthCalcFunc hcf = defaultHealthCalc) : healthFunc (hcf) {} int healthValue() const { return healthFunc(*this); } private: HealthCalcFunc healthFunc; } 同一人物类型之不同实体可以有不同的健康计算函数。 class EvilBadGuy: public GameCharacter { public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : GameCharacter (hcf) {...} ... }; int loseHealthQuickly(const GameCharacter\u0026amp;); int loseHealthslowly(const GameCharacter\u0026amp;); #相同类型的人物搭配, 不同的健康计算方式 EvilBadGuy ebg1(loseHealthQuickly); EvilBadGuy ebg2(loseHealthslowly); 某已知人物之健康指数计算函数可在运行期变更。 “健康指数计算函数不再是GameCharacter继承体系内的成员函数”这一事实意味,这些计算函数并未特别访问“即将被计算健康指数”的那个对象的 内部成分。\n藉由tr1:function完成Strategy模式 如果我们不再使用函数指针(如前例的healthFunc) ,而是改用一个类型为tr1l:: function的对象,这些约束就全都挥发不见了。\nclass GameCharacter; //如前 int defaultHealthcalc (const GameCharacter\u0026amp; gc); //如前 class GameCharacter { public: //HealthCalcFunc可以是任何“可调用物” (callable entity) , //可被调用并接受任何兼容于GameCharacter之物,返回任何兼容于int的东西。详下。 typedef std::tr1::functio\u0026lt;int (const GameCharacter\u0026amp;)\u0026gt; HealthCalcFunc; explicit GameCharacter (HealthCalcFunc hcf = defaultHealthCalc) : healthFunc (hcf ) {} int healthValue () const { return healthFunc(* this); } ... private: HealthcalcFunc healthFunc; }; std::tr1::function\u0026lt;int (const GameCharacter\u0026amp;)\u0026gt;\n“接受一个reference指向const GameCharacter,并返回int\u0026rdquo;。\n这个trl::function类型(也就是我们所定义的HealthCalcFunc类型)产生的对象可以持有(保存)任何与此签名式兼容的可调用物(callable entity)。\n所谓兼容,意思是这个可调用物的参数可被隐式转换为const GameCharacterk,而其返回类型可被隐式转换为into\nshort calcHealth (const GameCharacter\u0026amp;); struct HealthCalculator { int operator () (const GameCharacter\u0026amp;) const { ..} }; class GameLevel { public: float health (const GameCharacter\u0026amp;) const; ... }； class EvilBadGuy: public GameCharacter { ... }； class EyeCandyCharacter: public GameCharacter { ... }； EvilBadGuy ebg1(calcHealth); EyeCandyCharacter eccl(HealthCalculator()); //使用某个函数对象计算健康指数 GameLevel currentLevel; ... EvilBadGuy ebg2 ( std::tr1::bind(\u0026amp;GaneLevel::health, currentLevel, _1) //使用某个成员函数计算健康指数 ); 古典的Strategy模式 class GameCharacter; class HealthCalcFunc { public: virtual int calc(const GameCharacter\u0026amp; gc) const { ... } }; HealthCalcFunc defaultHealthCalc; class GameCharacter { public: explicit GameCharacter (HealthCalcFunc* phcf = \u0026amp;defaultHealthCalc) : pHealthCalc (phcf) {} int healthValue() const { return pHealthCalc-\u0026gt;calc(*this); } private: HealthcalcFunc* pHealthCalc; }; 本文要点\n使用non-virtual interface (NVI)手法,那是Template Method设计模式的一种 特殊形式。它以public non-virtual成员函数包裹较低访问性(private或protected) 的virtual函数。 将virtual函数替换为“函数指针成员变量” ,这是Strategy设计模式的一种分解表现形式。 以tr1::function成员变量替换virtual函数,因而允许使用任何可调用物 (callable entity)搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式。 将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。 virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。 将机能从成员函数移到class外部函数,带来的一个缺点是,非成员函数无法访 问class的non-public成员。 trl::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式(target signature)兼容”的所有可调用物(callable entities) 条款36: 绝不重新定义继承而来的non-virtual函数 class B { public: void mf(); }; class D: public B{ void mf(); ... }; # D x; B* pB =\u0026amp;x; D* pD =\u0026amp;x; pb-\u0026gt;mf(); //Bmf pd-\u0026gt;mf(); //Dmf 由于pB被声明为一个pointer-to-B,通过pB调用的non-virtual函数永远是B所定义的版本,即使pB指向一个类型为“B派生之class\u0026quot;的对象, virtual函数是动态绑定, 不论是pb,pd都是导致调用Dmf, 因为pB和pD真正指的都是一个类型为D的对象。\n适用于B对象的每一件事,也适用于D对象,因为每个D对象都是一个B对象; B的derived classes一定会继承mf的接口和实现,因为mf是B的一个non-virtual函数。 本文要点\n绝对不要重新定义继承而来的non-virtual函数。 条款37: 绝不重新定义继承而来的缺省参数值 virtual函数系动态绑定(dynamically bound) ,而缺省参数值却是静态绑定(statically bound)\nclass Shape { public: enum ShapeColor { Red, Green, Blue }; /所有形状都必须提供一个函数,用来绘出自己 virtual void draw (ShapeColor color = Red) const =0; }; class Rectangle: public Shape { public: /注意,赋予不同的缺省参数值。这真糟糕! virtual void draw (ShapeColor color = Green) const; }; class Circle: public Shape { public: virtual void draw(ShapeColor color) const; ... }; Shape* ps; Shape* pc = new circle; //静态类型为Shape* Shape* pr = new Rectangle; //静态类型为shape* ps = pc; ps = pr; pc-\u0026gt;draw(Shape::Red); //调用circle::draw(Shape::Red) pr-\u0026gt;draw(Shape::Red) ; //调用Rectangle::draw(Shape::Red) virtual函数是动态绑定,而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时,却使用base class为它所指定的缺省参数值\npr-\u0026gt;draw(); //调用Rectangle::draw (Shape::Red) Rectangle::draw函数的缺省参数值应该是GREEN,但由于pr的静态类型是Shape*,所以此一调用的缺省参数值来自Shape class而非Rectangle class!\nclass Shape public: enum ShapeColor { Red, Green, Blue }; virtual void draw (ShapeColor color =Red) const =0; }; class Rectangle: public Shape { public: virtual void draw (ShapeColor color =Red) const; ... } 代码重复又带着相依性(with dependencies): 如果Shape内的缺省参数值改变了,所有“重复给定缺省参数值”的那些derivedclasses也必须改变,否则它们最终会导致“重复定义一个继承而来的缺省参数值”。\nNVI方法\nclass Shape { public: enum ShapeColor { Red, Green, Blue }; void draw (ShapeColor color =Red) const { doDraw (color); } private: virtual void doDraw(ShapeColor color) const = 0; }; class Rectangle: public Shape { public: ... private: virtual void doDraw (Shapecolor color) const; //注意,不须指定缺省参数值。 ... }; 本文要点\n绝对不要重新定义一个继承而来的缺省参数值,因为缺省参数值都是静态绑定,而virtual函数\u0026ndash;你唯一应该覆写的东西-却是动态绑定。 条款38: 通过复合塑模出has-a或\u0026quot;根据某物实现出\u0026quot; class Address{...}; class PhoneNumber {...}; class Person { public: //... private: std::string name; Address address; PhoneNumber voiceNumber; PhoneNumber faxNumber; }; 条款32曾说, \u0026ldquo;public继承”带有is-a (是一种)的意义。 复合意味has-a(有一个)或is-implemented-in-terms-of(根据某物实现出) 。 当复合发生于应用域内的对象之间,表现出has-a的关系;当它发生于 实现域内则是表现is-implemented-in-terms-of的关系。\n本文要点\n复合(composition)的意义和public继承完全不同。 在应用域(application domain) ,复合意味has-a (有一个) 。在实现域 (implementation domain) ,复合意味is-implemented-in-terms-of (根据某物实现出)。 条款39: 明智而审慎地使用private继承 private继承主要用于“当一个意欲成为derived class者想访问 一个意欲成为base class者的protected成分,或为了重新定义一或多个virtual函数\u0026rdquo; 但这时候两个classes之间的概念关系其实是is-implemented-in-terms-of (根据某物实现出)而非is-a。\n本文要点\nPrivate继承意味is-mplemented-in-terms of (根据某物实现出) 。它通常比复合 (composition)的级别低。但是当derived class需要访问protected base class的成员,或需要重新定义继承而来的virtual函数时,这么设计是合理的。 和复合(composition)不同, private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言,可能很重要。 条款40: 明智而审慎地使用多重继承 多重继承(multiple inheritance; MI) 单一继承(single inheritance; SI) 当MI进入设计景框,程序有可能从一个以上的base classes继承相同名称(如函数、typedef等等)。那会导致较多的歧义(ambiguity)机会。\nclass Borrowableltem { public: void checkout(); }; class ElectronicGadget { private: bool checkOut() const; }； class MP3Player: public Borrowableltem, public ElectronicGadget {..}; MP3Player mp; mp.checkOut(); //调用哪个checkout 为了解决这个歧义,你必须明白指出你要调用哪一个base class内的函数:\nmp.Borrowableltem::checkOut();\n“钻石继承”\nclass File {...}; class Inputfile: virtual public File {...}; class Outputfile: virtual public File {...}; class IOFile: public Inputfile, public OutFile {...}; 使用virtual继承的那些classes所产生的对象往往比使 用non-virtual继承的兄弟们体积大,访问virtual base classes的成员变量时,也比访问non-virtual base classes的成员变量速度慢。种种细节因编译器不同而异,但基本重点很清楚:你得为virtual继承付出代价。\nvirtual base class忠告\n第一,非必 要不使用virtual bases。平常请使用non-virtual继承。 第二,如果你必须使用virtualbase classes,尽可能避免在其中放置数据。 本文要点\n多重继承比单一继承复杂。它可能导致新的歧义性,以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtualbase classes不带任何数据,将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情节涉及\u0026quot;public继承某个Interface class和\u0026quot;private继承某个协助实现的class\u0026quot;的两相组合。 Re:\nhttps://blog.csdn.net/qq_36915078/article/details/104718945\nhttps://harttle.land/tags.html#Effective-C++\n","permalink":"https://vcvvvc.github.io/post/effective_cpp/","tags":["CPP"],"title":"Effective C++ 总结"},{"categories":null,"contents":"条款41:了解隐式接口和编译期多态 template\u0026lt;typename T\u0026gt; void doProcessing (T\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastywidget) { T temp(w); temp.normalize(); temp.swap(w); } } w必须支持哪一种接口,系由template中执行于w身上的操作来决定。 凡涉及w的任何函数调用,例如operator\u0026gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates\u0026quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。 显式接口和隐式接口的差异\n显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。\n其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。 隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。\ntemplate\u0026lt;typename T\u0026gt; void doProcessing( T\u0026amp; w) { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastywidget) { ... } } 它必须提供一个名为size的成员函数,该函数返回一个整数值。 它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T 本文要点\nclasses和templates都支持接口(interfaces)和多态(polymorphism) 。 对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。 对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。 条款42: 了解typename的双重意义 template\u0026lt;class T\u0026gt; class widget; //使用\u0026#34;class\u0026#34; template\u0026lt;typename T\u0026gt; class Widget; //使用\u0026#34;typename\u0026#34; C++并不总是把class和typename视为等价。有时候你一定得使用 typename。 template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { if (container.size() \u0026gt;= 2) { C::const iterator iter(container.begin()); ++iter; int value = *iter; std::cout \u0026lt;\u0026lt; value; } } template内出现的名 称如果相依于某个template参数, 称之为从属名称(dependent names)。如果从属 名称在class内呈嵌套状,我们称它为嵌套从属名称(nested dependent name) 。int是一个不依赖任何template参数的名称，为非从属名称(non-dependent names)。\ntemplate\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { if(container.size() \u0026gt;=2) C::const_iterator iter(container.begin()); //假设为非类型 } 如果解析器在template中遭遇一个嵌套从属名称,它便假设这名称不是个类型,除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。\n#正确版本 template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { //这是合法的CH+代码 if (container.size() \u0026gt;=2) { typename C::const_iterator iter(container.begin()); } } 一般性规则很简单:任何时候当你想要在template中指涉一个嵌套从属类型名称,就必须在紧临它的前一个位置放上关键字typename\n\u0026ldquo;typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是, typename不可以出现在base classes list内的嵌套从属类型名称之前,也不可在 member initialization list (成员初值列)中作为base class修饰符。\ntemplate\u0026lt;typename T\u0026gt; class Derived: public Base\u0026lt;T\u0026gt;::Nested { //不允许 public: explicit Derived(int x) : Base\u0026lt;T\u0026gt;::Nested(x) //不允许 { typename Base\u0026lt;T\u0026gt;::Nested temp; //允许 ... } ... }; 由于std::iterator-traits: :value-type是个嵌套从属类型名 称(value-type被嵌套于iterator-traits之内而IterT是个template参数) ,所以我们必须在它之前放置typename\ntemplate\u0026lt;typename IterT\u0026gt; void workwithiterator(IterT iter) typename std::iterator traits\u0026lt;IterT\u0026gt;::value type temp (*iter); 本文要点\n声明template参数时,前缀关键字class和typename可互换。 请使用关键字typename标识嵌套从属类型名称;但不得在base class lists (基类 列)或member initialization list (成员初值列)内以它作为base class修饰符。 条款43: 学习处理模板化基类内的名称 class MsgInfo { ... }; template\u0026lt;typename Company\u0026gt; class MsgSender { public: void sendClear(const MsgInfo\u0026amp; info) { std::string msg; 这儿,根据info产生信息; Company c; c.sendcleartext (msg); } void sendSecret (const MsgInfo\u0026amp; info) { ... } }; template\u0026lt;typenane Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: void sendClearMsg (const MsgInfo\u0026amp; info) { //将“传送前”的信息写至log; sendClear (info); //调用base class函数;这段码无法通过编译。 //将“传送后”的信息写至1og; } ... }; 上面问题在于,当编译器遭遇class template LoggingMsgSender定义式时,并不知 道它继承什么样的class。当然它继承的是MsgSender,但其中的Company 是个template参数,不到后来(当LoggingMsgSender被具现化)无法确切知道它 是什么。而如果不知道Company是什么,就无法知道class MsgSender看起来像什么\u0026ndash;更明确地说是没办法知道它是否有个sendClear函数。\n解决办法\ntemplate\u0026lt;\u0026gt; class MsgSender\u0026lt;Companyz\u0026gt; { public: ... //删除了sendclear void sendSecret(const MsgInfo\u0026amp; info) { ... } }； 注意class定义式最前头的\u0026quot;template\u0026lt;\u0026ldquo;语法象征这既不是template也不是 标准class,而是个特化版的MsgSender template,在template实参是Companyz时被使用。这是所谓的模板全特化(total template specialization)。\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsqSender\u0026lt;Company\u0026gt; { public: void sendClearMsg (const MsgInfo\u0026amp; info) { //将“传送前”的信息写至log; sendClear(info); //如果company == Companyz,这个函数不存在。将“传送后”的信息写至log; //将“传送后”的信息写至log; } ... }; 它知道base class templates有可能被特化,而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在templatized base classes (模板化基类, 本例的MsgSenderkCompany\u0026gt;)内寻找继承而来的名称(本例的SendClear) 。\n为了重头来过,我们必须有某种办法令C++“不进入templatized base classes观察”的行为失效。 有三个办法,第一是在base class函数调用动作之前加上this-\u0026gt;\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsqSender\u0026lt;Company\u0026gt; { public: void sendClearMsq (const MsgInfo\u0026amp; info) { //将“传送前”的信息写至log;, this-\u0026gt;sendClear(info); //将“传送后”的信息写至log; } ... }; 第二是使用using声明式。\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: using MsgSender\u0026lt;Company\u0026gt;::sendClear; ... void sendClearMsg (const MsgInfo\u0026amp; info) { ... sendClear (info); ... } ... }; 第三个做法是,明白指出被调用的函数位于base class内:\ntemplate\u0026lt;typename Company\u0026gt; class LoggingMsgSender: public MsgSender\u0026lt;Company\u0026gt; { public: void sendClearMsg (const MsgInfo\u0026amp; info) { ... MsgSender\u0026lt;Company\u0026gt;::sendClear(info); ... } ... }; 但这往往是最不让人满意的一个解法,因为如果被调用的是virtual函数,上述的明确资格修饰(explicit qualification)会关闭\u0026quot;virtual绑定行为”。\n从名称可视点(visibility point)的角度出发,上述每一个解法做的事情都相同:对编译器承诺\u0026quot;base class template的任何特化版本都将支持其一般(泛化)版本所提供的接口”。\nLoggingMsgSender\u0026lt;Companyz\u0026gt; zMsgSender; MsgInfo msgData; ... zMsgSender.sendClearMsg(msgData); //错误 因为在那个点上,编译器知道base class是个template特化版本Msgsender,而且它们知道那个 class不提供sendClear函数,而后者却是sendClearMsg尝试调用的函数。\n本文要点\n可在derived class templates内通过\u0026quot;this-\u0026gt;\u0026ldquo;指涉base class templates内的成员名称,或藉由一个明白写出的\u0026quot;base class资格修饰符”完成。 条款44: 将与参数无关的代码抽离templates template\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix { public: ... void invert(); // 求逆矩阵 } SquareMatrix\u0026lt;double,5\u0026gt; sml; ... sm1.invert(); //调用SquareMatrix\u0026lt;double,5\u0026gt;::invert SquareMatrix\u0026lt;double,10\u0026gt; sm2; ... sm2.invert(); 这会具现两份invert。这些函数并非完全相同，但除了常量5和10，其他部分都相同，这是template引出代码膨胀的一个典型例子。\n下面是第一次修改\ntemplate\u0026lt;typename T\u0026gt; //与尺寸无关的base class class SquareMatrixBase{ protected: void invert(std::size_t matrixSize); //以给定的尺寸求逆矩阵 }; template\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SquareMatrixBase\u0026lt;T\u0026gt;{ private: using SquareMatrixBase\u0026lt;T\u0026gt;::invert;//避免遮掩base版的invert public: void invert() {this-\u0026gt;invert(n);} //制造一个inline调用，用this-\u0026gt;为了不被derived classes的函数名称掩盖 }; 带参数的invert位于base class中。和SquareMatrix一样，也是个template，不同的是他只对“矩阵元素对象的类型”参数化，不对矩阵的尺寸参数化。因此对于给定的元素对象类型，所有矩阵共享同一个(也是唯一一个）SquareMatrixBase class。也将因此而共享这唯一一个class内的invert。\n另一个办法是令SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存。而只要它存储了那些东西，也就可能存储矩阵尺寸：\ntemplate\u0026lt;typename T\u0026gt; class SquareMatrixBase{ protected: SquareMatrixBase(std::size_t n, T* pMem) :size(n), pData(pMem){} void setDataPtr(T* ptr){pData = ptr;} private: std::size_t size; T* pData; }; 这允许derived classes决定内存分配方式。某些实现版本也许会将矩阵数据存储在SquareMatrix对象内部：\ntemplate\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SquareMatrixBase\u0026lt;T\u0026gt;{ public: SquareMatrix(): SquareMatrixBase\u0026lt;T\u0026gt;(n, data) {} private: T data[n*n]; } 另一种做法是把每个矩阵的数据放进heap：\ntemplate\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SquareMatrixBase\u0026lt;T\u0026gt;{ public: SquareMatrix() :SquareMatrixBase\u0026lt;T\u0026gt;(n, 0),//base class的数据指针设为null pData(new T[n*n])//为内容分配内存，将指向该内存的指针存储起来 { this-\u0026gt;setDataPtr(pData.get());//将pData的一个副本交给base class } private: boost::scoped_array\u0026lt;T\u0026gt; pData; }; 本文要点\nTemplates生成多个classes和多个函数,所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。 因非类型模板参数(non-type template parameters)而造成的代码膨胀,往往可消除,做法是以函数参数或class成员变量替换template参数。 因类型参数(type parameters)而造成的代码膨胀,往往可降低,做法是让带有 完全相同二进制表述(binary representations)的具现类型(instantiation types)共享实现码。 条款45: 运用成员函数模板接受所有兼容类型 Templates和泛型编程(Generic Programming)\n构造模版, 这样的模板(templates)是所谓member function templates (常简称为member templates) ,其作用是为class生成函数\ntemplate\u0026lt;typename\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; SmartPtr (const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other); }; template\u0026lt;typename\u0026gt; class SmartPtr { public: template\u0026lt;typename U\u0026gt; SmartPtr(const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other) : heldPtr (other.get ()) {..} T* get() const { return heldPtr; } private: T* heldptr; }; 使用成员初值列(member initialization list)来初始化SmartPtr之内类型为T*的成员变量,并以类型为U*的指针(由SmartEtrU\u0026gt;持有)作为初值。这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译,\n成员函数模版也支持赋值操作\ntemplate\u0026lt;class T\u0026gt; class shared_ptr { public: template\u0026lt;class Y\u0026gt; explicit shared_ptr(Y* p); template\u0026lt;class Y\u0026gt; shared_ptr(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); template\u0026lt;class Y\u0026gt; explicit shared_ptr(weak_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); template\u0026lt;class Y\u0026gt; explicit shared_ptr(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator-(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); }; 上述所有构造函数都是explicit,惟有“泛化copy构造函数\u0026quot;除外。那意味从某个sharedptr类型隐式转换至另一个sharedptr类型是被允许的,但从某个内置指针或从其他智能指针类型进行隐式转换则不被认可(如果是显式转换如cast强制转型动作倒是可以)。\nmember templates并不改变语言规则,而语言规则说,如果程序需要一个copy构造函数,你却没有声明它,编译器会为你暗自生成一个。在class内声明泛化copy构造函数(是个member template)并不会阻止编译器生成它们自己的copy构造函数(一个non-template)\n所以如果你想要控制copy构造的方方面面,你必须同时声明泛化copy构造函数和“正常的” copy构造函数。\ntemplate\u0026lt;class T\u0026gt; class shared ptr { public: shared_ptr(shared_ptr const\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr(shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); shared_ptr\u0026amp; operator=(shared_ptr const\u0026amp; r); template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator= (shared_ptr\u0026lt;Y\u0026gt; const\u0026amp; r); }; 本文要点\n请使用member function templates (成员函数模板)生成“可接受所有兼容类型”的函数。 如果你声明member templates用于“泛化copy构造\u0026quot;或“泛化assignment操作\u0026rdquo;,你还是需要声明正常的copy构造函数和copy assignment操作符。 条款46:需要类型转换时请为模板定义非成员函数 条款24的模版化\ntemplate\u0026lt;typename т\u0026gt; class Rational { public: Rational (const T\u0026amp; numerator = 0, const T\u0026amp; denominator = 1); const T numerator() const; const T denominator() const; ... }; template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026amp; 1hs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { ... } Rational\u0026lt;int\u0026gt; oneHalf(1, 2);\nRational\u0026lt;int\u0026gt; result = oneHalf * 2;\n在template实参推导过程中从不将隐式类型转换函数纳入考虑。 方法一: template class内的friend声明式可以指涉某个特定函数。那意味class Rational可以声明operator*是它的一个friend函数。令Rational class声明适当的operator*为其friend函数,可简化整个问题\ntemplate\u0026lt;typename T\u0026gt; class Rational { public: ... friend const Rational operator* (const Rational\u0026amp; 1hs, const Rational\u0026amp; rhs); }; template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator* (const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { ... } 当对象oneHalf被声 明为一个Rational, class Rational于是被具现化出来,而作为过程的 一部分, friend函数operator*(接受Rational参数)也就被自动声明出来。后者身为一个函数而非函数模板(function template) ,因此编译器可在调用它时使用隐式转换函数(例如Rational的non-explicit构造函数)\n混合式代码通过了编译,因为编译器知道我们要调用哪个函数(就是接受一个Rationalkint\u0026gt;以及又一个Rationalkint\u0026gt;的那个operator * ) ,但那个函数只被声明于Rational内,并没有被定义出来。\n方法二: 将operator * 函数本体合并至其声明式内:\ntemplate\u0026lt;typename T\u0026gt; class Rational { public: ... friend const Rational operator*(const Rational\u0026amp; 1hs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()) } }; \u0026ldquo;Rational是个template\u0026quot;这一事实意味上述的辅助函数通常也是个template, 所以定义了Rational的头文件代码,很典型地长这个样子:\ntemplate\u0026lt;typename T\u0026gt; class Rational; //声明Rational template template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; doMultiply(const Rational\u0026lt;T\u0026gt;\u0026amp; 1hs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs); template\u0026lt;typenane T\u0026gt; class Rational ( public: friend const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return doMultiply(lhs, rhs); } }； template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; doMultiply (const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return Rational\u0026lt;T\u0026gt; (lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } 本文要点\n当我们编写一个class template,而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时,请将那些函数定义为\u0026quot;class template内部 的friend函数” 条款47: 请使用traits classes表现类型信息 STL迭代器分类(categories)\ninput选代器 只能向前移动,一次一步,客户只可读取(不能涂写)它们所指的东西,而且只能读取一次。\nOutput迭代器 一切只为输出:它们只向前移动,一次一步,客户只可涂写它们所指的东西,而且只能涂写一次。\nforward迭代器。 这种迭代器可以做前述两种分类所能做的每一件事,而且可以读或写其所指物一次以上。这使得它们可施行于多次性操作算法(multi-pass algorithms) 。\nBidirectional迭代器 比上一个分类威力更大: 它除了可以向前移动,还可以向后移动。\nrandom access选代器 这种迭代器比上一个分类威力更大的地方在于它可以执行“迭代器算术”,也就是它可以在常量时间内向前或向后跳跃任意距离。\n针对这五种分类,C++标准库分别提供专属的\u0026quot;卷标结构\u0026rdquo;(tag struct)加以区分:\nstruct input_iterator_tag{}; struct output_iterator_tag{}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_iterator_tag:public bidirectional_iterator_tag{}; traits允许我们在编译期得到类型的信息。traits并非一个关键字，而是一个编程惯例。\ntraits的另一个需求在于advance对与基本数据类型也能正常工作，比如char*。所以traits不能借助类来实现， 于是我们把traits放到模板中。比如：\ntemplate\u0026lt;typename IterT\u0026gt; // template for information about struct iterator_traits; // iterator types terator_traits\u0026lt; IterT\u0026gt;将会标识IterT的迭代器类别。iterator_traits的实现包括两部分：\n用户定义类型的迭代器 基本数据类型的指针 用户类型的迭代器\n在用户定义的类型中，typedef该类型支持迭代器的Tag\ntemplate\u0026lt; ... \u0026gt; // template params elided class deque { public: class iterator { public: typedef random_access_iterator_tag iterator_category; }: }; 在全局的iterator_traits模板中typedef那个用户类型中的Tag，以提供全局和统一的类型识别。\ntemplate\u0026lt;typename IterT\u0026gt; struct iterator_traits { typedef typename IterT::iterator_category iterator_category; }; 基本数据类型的指针\n为了支持指针迭代器, iterator-traits特别针对指针类型提供一个偏特化版本(partial template specialization) 。\ntemplate\u0026lt;typename IterT\u0026gt; struct iterator traits\u0026lt;IterT*\u0026gt; { typedef random access iterator tag iterator category; ... }; 如何设计并实现一个traits class\n确认若干你希望将来可取得的类型相关信息。例如对迭代器而言,我们希望将 来可取得其分类(category) 。 为该信息选择一个名称(例如iterator_category) 。 提供一个template和一组特化版本(例如稍早说的iterator-traits) ,内含你希望支持的类型相关信息。 advance的实现\ntemplate\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iterator_tag)) ... } 上述实现其实并不完美，至少if语句中的条件在编译时就已经决定，它的判断却推迟到了运行时（显然是低效的）。 在编译时作此判断，需要为不同的iterator提供不同的方法，然后在advance里调用它们。\ntemplate\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { doAdvance( // call the version iter, d, // of doAdvance typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category() ); } // 随机访问迭代器 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::random_access_iterator_tag) { iter += d; } // 双向迭代器 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::bidirectional_iterator_tag) { if (d \u0026gt;= 0) { while (d--) ++iter; } else { while (d++) --iter; } } // 输入迭代器 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::input_iterator_tag) { if (d \u0026lt; 0 ) { throw std::out_of_range(\u0026#34;Negative distance\u0026#34;); // see below } while (d--) ++iter; } 总结如何使用一个traits class\n建立一组重载函数(身份像劳工)或函数模板(例如doAdvance) ,彼此间的差异只在于各自的traits参数。令每个函数实现码与其接受之traits信息相应和。 建立一个控制函数(身份像工头)或函数模板(例如advance) ,它调用上述那些“劳工函数”并传递traits class所提供的信息。 本文要点\nTraits classes使得“类型相关信息”在编译期可用。它们以templates和\u0026quot;templates特化”完成实现。 整合重载技术(overloading)后, traits classes有可能在编译期对类型执行 if.else测试。 条款48: 认识template元编程 Template metaprogramming (TMP,模板元编程)是编写template-based C++程序并执行于编译期的过程。\n**使用TMP有两个好处: **\n第一,它让某些事情更容易。如果没有它,那些事情 将是困难的,甚至不可能的。 第二,由于template metaprograms执行于C++编译期,因此可将工作从运行期转移到编译期。 template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iterator_tag)){ iter += d; } ... } list\u0026lt;int\u0026gt;::iterator it; advance(it, 10); 其实上述代码是不能编译的，设想以下advance\u0026lt;list::iterator, int\u0026gt;中的这条语句：\niter += d; list\u0026lt;int\u0026gt;::iterator是双向迭代器，不支持+=运算。虽然上述语句不会执行，但编译器不知道这一点。 编译时这条语句仍然会抛出类型错误。\nTMP已被证明是个“图灵完全”(Turing-complete)机器\nTMP主要是个“函数式语言” (functional language), TMP的递归甚至不是正常种类,因为TMP循环并不涉及递归函数调用,而是涉及“递归模板具现化”(recursive template instantiation) 。\ntemplate\u0026lt;unsigned n\u0026gt; struct Factorial { enum { value = n * Factorial\u0026lt;n-1\u0026gt;::value }; }; template\u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; { //Factorial\u0026lt;0\u0026gt; 值为1 enum{ value=1 }; }; int main() { std::cout \u0026lt;\u0026lt; Factorial\u0026lt;5\u0026gt;::value; //印出120 std::cout \u0026lt;\u0026lt; Factorial\u0026lt;10\u0026gt;::value; //印出3628800 } 为了更好地理解TMP的重要性，我们来看看TMP能干什么：\n确保量纲正确。在科学计算中，量纲的结合要始终保持正确。比如一定要单位为”m”的变量和单位为”s”的变量相除才能得到一个速度变量（其单位为”m/s”）。 使用TMP时，编译器可以保证这一点。因为不同的量纲在TMP中会被映射为不同的类型。 优化矩阵运算。比如矩阵连乘问题，TMP中有一项表达式模板（expression template）的技术，可以在编译期去除临时变量和合并循环。 可以做到更好的运行时效率。 自定义设计模式的实现。设计模式往往有多种实现方式，而一项叫基于策略设计（policy-based design）的TMP技术可以帮你创建独立的设计策略（design choices），而这些设计策略可以以任意方式组合。生成无数的设计模式实现方式。 本文要点\nTemplate metaprogramming (TMP,模板元编程)可将工作由运行期移往编译期,因而得以实现早期错误侦测和更高的执行效率。 TMP可被用来生成“基于政策选择组合\u0026rdquo; (based on combinations of policychoices)的客户定制代码,也可用来避免生成对某些特殊类型并不适合的代码。 了解C++内存管理例程的行为。这场游戏的两个主角是分配例程和归还例程(allocation and deallocation routines,也就是operator new和operator delete), 配角是new-handler, 这是当operator new无法满足客户的内存需求时所调用的函数。\noperator new和operator delete只适合用来分配单一对 象。Arrays所用的内存由operator new1]分配出来,并由operator delete[]归还(注意两个函数名称中的[])\n条款49: 了解new-handler的行为 new_handler函数运行代码\n当operator new抛出异常以反映一个未获满足的内存需求之前,它会先调用个客户指定的错误处理函数,一个所谓的new-handler。\nnamespace std { typedef void(*new handler) (); new_handler set_new_handler(new_handler p) throw(); } //以下是当operator new无法分配足够内存时, 该被调用的函数\nvoid outOfMem(){ std::cout \u0026lt;\u0026lt; \u0026#34;Unable to alloc memory\u0026#34;; std::abort(); } int main(){ std::set_new_handler(outOfMem); int *p = new int[100000000L]; } 当operator new无法满足内存申请时,它会不断调用new-handler函数,直到找到足够内存。\n一个设计良好的new-handler函数必须做以下事情:\n使更多内存可用； 安装一个新的”new-handler”； 卸载当前”new-handler”，传递null给set_new_handler即可； 抛出bad_alloc（或它的子类）异常； 不返回，可以abort或者exit。 std::set_new_handler设置的是全局的bad_alloc的错误处理函数，C++并未提供类型相关的bad_alloc异常处理机制。 但我们可以重载类的operator new，当创建对象时暂时设置全局的错误处理函数，结束后再恢复全局的错误处理函数。\n比如Widget类，首先需要声明自己的set_new_handler和operator new：\nclass Widget{ public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc); private: static std::new_handler current; }; // 静态成员需要定义在类的外面 std::new_handler Widget::current = 0; std::new_handler Widget::set_new_handler(std::new_handler p) throw(){ std::new_handler old = current; current = p; return old; } 关于abort, exit, terminate的区别：abort会设置程序非正常退出，exit会设置程序正常退出，当存在未处理异常时C++会调用terminate， 它会回调由std::set_terminate设置的处理函数，默认会调用abort。\n最后来实现operator new，该函数的工作分为三个步骤：\n调用std::set_new_handler，把Widget::current设置为全局的错误处理函数； 调用全局的operator new来分配真正的内存； 如果分配内存失败，Widget::current将会抛出异常； 不管成功与否，都卸载Widget::current，并安装调用Widget::operator new之前的全局错误处理函数。 我们通过RAII类来保证原有的全局错误处理函数能够恢复，让异常继续传播。关于RAII可以参见Item 13。 先来编写一个保持错误处理函数的RAII类：\nclass NewHandlerHolder{ public: explicit NewHandlerHolder(std::new_handler nh): handler(nh){} ~NewHandlerHolder(){ std::set_new_handler(handler); } private: std::new_handler handler; NewHandlerHolder(const HandlerHolder\u0026amp;); // 禁用拷贝构造函数 const NewHandlerHolder\u0026amp; operator=(const NewHandlerHolder\u0026amp;); // 禁用赋值运算符 }; Widget::operator new的实现\nvoid * Widget::operator new(std::size_t size) throw(std::bad_alloc){ NewHandlerHolder h(std::set_new_handler(current)); return ::operator new(size); // 调用全局的new，抛出异常或者成功 } // 函数调用结束，原有错误处理函数恢复 客户使用Widget的方式也符合基本数据类型的惯例：\nvoid outOfMem(); Widget::set_new_handler(outOfMem); Widget *p1 = new Widget; // 如果失败，将会调用outOfMem string *ps = new string; // 如果失败，将会调用全局的 new-handling function，当然如果没有的话就没有了 Widget::set_new_handler(0); // 把Widget的异常处理函数设为空 Widget *p2 = new Widget; // 如果失败，立即抛出异常 仔细观察上面的代码，很容易发现自定义”new-handler”的逻辑其实和Widget是无关的。我们可以把这些逻辑抽取出来作为一个模板基类：\ntemplate\u0026lt;typename T\u0026gt; class NewHandlerSupport{ public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc); private: static std::new_handler current; }; template\u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::current = 0; template\u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::set_new_handler(std::new_handler p) throw(){ std::new_handler old = current; current = p; return old; } template\u0026lt;typename T\u0026gt; void * NewHandlerSupport\u0026lt;T\u0026gt;::operator new(std::size_t size) throw(std::bad_alloc){ NewHandlerHolder h(std::set_new_handler(current)); return ::operator new(size); } 有了这个class template,为widget添加set-new-handler支持能力就轻而易举了:\n只要令widget继承自NewHandlerSupport\u0026lt;widget\u0026gt;就好\nclass Widget: public NewHandlerSupport\u0026lt;Widget\u0026gt; { ... //和先前一样但不必声明set_new_handler或operator new }; operator new则应该抛出bad alloc异常\nclass widget{ ....}; widget* pw1 = new widget; //分配失败 抛出bad_alloc if (pw1 == 0) ... //一定失败 widget* pw2 = new (std::nothrow) widget; //分配失败返回0 if (pw2 == 0) ... //可能成功 本文要点\nset-new_handler允许客户指定一个函数,在内存分配无法获得满足时被调用。 Nothrow new是一个颇为局限的工具,因为它只适用于内存分配;后继的构造函数调用还是可能抛出异常。 条款50: 了解new和delete的合理替换时机 替换编译器提供的operator new或operator delete理由:\n检测使用错误。new得到的内存如果没有delete会导致内存泄露，而多次delete又会引发未定义行为。如果自定义operator new来保存动态内存的地址列表，在delete中判断内存是否完整，便可以识别使用错误，避免程序崩溃的同时还可以记录这些错误使用的日志。 提高效率。全局的new和delete被设计为通用目的（general purpose）的使用方式，通过提供自定义的new，我们可以手动维护更适合应用场景的存储策略。 收集使用信息。在继续自定义new之前，你可能需要先自定义一个new来收集地址分配信息，比如动态内存块大小是怎样分布的？分配和回收是先进先出FIFO还是后进先出LIFO？ 实现非常规的行为。比如考虑到安全，operator new把新申请的内存全部初始化为0. 其他原因，比如抵消平台相关的字节对齐，将相关的对象放在一起等等。 定制型operator new\nstatic const int signature = 0xDEADBEEF; // 边界符 typedef unsigned char Byte; void* operator new(std::size_t size) throw(std::bad_alloc) { // 多申请一些内存来存放占位符 size_t realSize = size + 2 * sizeof(int); // 申请内存 void *pMem = malloc(realSize); if (!pMem) throw bad_alloc(); // 写入边界符 *(reinterpret_cast\u0026lt;int*\u0026gt;(static_cast\u0026lt;Byte*\u0026gt;(pMem)+realSize-sizeof(int))) = *(static_cast\u0026lt;int*\u0026gt;(pMem)) = signature; // 返回真正的内存区域 return static_cast\u0026lt;Byte*\u0026gt;(pMem) + sizeof(int); } 这个operator new的缺点主要在于它疏忽了身为这个特殊函数所应该具备的“坚持C++规矩”的态度。\n所有operator news都应该内含一个循环,反复调用某个new-handling函数。\n齐位(alignment)意义重大,因为C++要求所有operator news返回的指针都有适当的对齐(取决于数据类型)。\n本条款的主题是,了解何时可在“全局性的”或\u0026quot;class专属的”基础上合理替换缺省的new和delete:\n为了检测运用错误 为了收集动态分配内存之使用统计信息 为了增加分配和归还的速度。 为了降低缺省内存管理器带来的空间额外开销。 为了弥补缺省分配器中的非最佳齐位(suboptimal alignment)。 为了将相关对象成簇集中。 为了获得非传统的行为。 本文要点\n有许多理由需要写个自定的new和delete,包括改善效能、对heap运用错误进行调试、收集heap使用信息。 条款51: 编写new和delete时需固守常规 实现一致性operator new必得返回正确的值,内存不足时必得调用new-handling函数 ,必须有对付零内存需求的准备,还需避免不慎掩盖正常形式的new。\noperator new的返回值十分单纯。如果它有能力供应客户申请的内存,就返回一个指针指向那块内存。如果没有那个能力,就遵循条款49描述的规则,并抛出一个badalloc异常。然而其实也不是非常单纯,因为operatornew实际上不只一次尝试分配内存,并在每次失败后调用new-handling函数。\n奇怪的是C++规定,即使客户要求0bytes, operator new也得返回一个合法指针。\nnon-member operator new\nvoid* operator new(std::size_t size) throw(std::bad_alloc) { using namespace std; if (size ==0) { size = 1; } while (true) { 尝试分配size bytes; if (分配成功) return (一个指针,指向分配得来的内存); //分配失败;找出目前的new-handling函数(见下) new_handler globalHandler = set_new_handler(0); set_new_handler(globalHandler); if (globalHandler) (*globalHandler)(); else throw std::bad_alloc(); } } size == 0时申请大小为1看起来不太合适，但它非常简单而且能正常工作。况且你不会经常申请大小为0的空间吧？ 两次set_new_handler调用先把全局”new handler”设置为空再设置回来，这是因为无法直接获取”new handler”，多线程环境下这里一定需要锁。 while(true)意味着这可能是一个死循环。所以Item 49提到，”new handler”要么释放更多内存、要么安装一个新的”new handler”，如果你实现了一个无用的”new handler”这里就是死循环了。 谈到operator new内含一个无穷循环,而上述伪码明白表明出这个循环: \u0026ldquo;while (true)\u0026ldquo;就是那个无穷循环。\n退出此循环的唯一办法是:内存被成功分配或new-handling函数做了一件描述于条款49的事情:让更多内存可用、安装 另一个new-hander、卸除new-handler、抛出badalloc异常(或其派生物) ,或是承认失败而直接return。\n重载operator new为成员函数通常是为了对某个特定的类进行动态内存管理的优化，而不是用来给它的子类用的。 因为在实现Base::operator new()时，是基于对象大小为sizeof(Base)来进行内存管理优化的。\n当然，有些情况你写的Base::operator new是通用于整个class及其子类的，这时这一条规则不适用。\nclass Base{ public: static void* operator new(std::size_t size) throw(std::bad_alloc); }; class Derived: public Base{...}; Derived *p = new Derived; //调用了Base::operator new 子类继承Base::operator new()之后，因为当前对象不再是假设的大小，该方法不再适合管理当前对象的内存了。 处理此情势的最佳做法是将“内存申请量错误”的调用行为改采标准operator new\nvoid *Base::operator new(std::size_t size) throw(std::bad_alloc){ if(size != sizeof(Base)) return ::operator new(size); ... } 上面的代码没有检查size == 0！这是C++神奇的地方，大小为0的独立对象会被插入一个char（见Item 39）。 所以sizeof(Base)永远不会是0，所以size == 0的情况交给::operator new(size)去处理了。\n这里提一下operator new[]，它和operator new具有同样的参数和返回值， 要注意的是你不要假设其中有几个对象，以及每个对象的大小是多少，所以不要操作这些还不存在的对象。因为：\n你不知道对象大小是什么。上面也提到了当继承发生时size不一定等于sizeof(Base)。 size实参的值可能大于这些对象的大小之和。因为Item 16中提到，数组的大小可能也需要存储。 operatore delete\nC++保证“删除null指针永远安全”\nvoid operator delete(void *rawMem) throw(){ if(rawMem == 0) return; // 释放内存 } 万一你的class专属的operator new将大小有误的分配行为转交::operator new执行,你也必须将大小有误的删除行为转交::operator delete执行:\nclass Base{ public: static void * operator new(std::size_t size) throw(std::bad_alloc); static void operator delete(void *rawMem, std::size_t size) throw(); }; void Base::operator delete(void *rawMem, std::size_t size) throw(){ if(rawMem == 0) return; // 检查空指针 if(size != sizeof(Base)){ ::operator delete(rawMem); } // 释放内存 } 如果即将被删除的对象派生自某个base class而后者欠缺virtual析 构函数,那么C++传给operatordelete的sizet数值可能不正确。\n本文要点\noperator new应该内含一个无穷循环,并在其中尝试分配内存,如果它无法满足内存需求,就该调用new_handler,它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 条款52: 写了placement new也要写placement delete “placement new”通常是专指指定了位置的new(std::size_t size, void *mem)，用于vector申请capacity剩余的可用内存。 但广义的”placement new”指的是拥有额外参数的operator new。\nnew和delete是要成对的，因为当构造函数抛出异常时用户无法得到对象指针，因而delete的责任在于C++运行时。 运行时需要找到匹配的delete并进行调用。因此当我们编写了”placement new”时，也应当编写对应的”placement delete”， 否则会引起内存泄露。在编写自定义new和delete时，还要避免不小心隐藏它们的正常版本。\nclass widget { public: //非正常形式的new static void* operator new(std::size t size, std: :ostream\u0026amp; logStream) throw (std::bad alloc); //正常的class专属delete static void operator delete (void* pMemory std::size_t size) throw(); }; 如果operatornew接受的参数除了一定会有的那个sizet之外还有其他,这 便是个所谓的placement new。因此,上述的operator new是个placement版本。众多placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”:\nvoid* operator new(std::size_t, void* pMemory) throw(); 那个class将引起微妙的内存泄漏\nwidget* pw = new (std::cerr)widget; 如果内存分配成功,而widget构造函数抛出异常,运行期系统有责任取消operator new的分配并恢复旧观。然而运行期系统无法知道真正被调用的那个operator new如何运作,因此它无法取消分配并恢复旧观,所以上述做法行不通。\n运行期系统寻找“参数个数和类型都与operator new相同”的某个operator delete。如果找到,那就是它的调用对象。\nvoid operator delete(void*, std::ostream\u0026amp;) throw(); 如果一个带额外参数的operator new没有“带相同额外参数”的对应版operator delete,那么当new的内存分配动作需要取消并恢复旧观时就没有任何operator delete会被调用。\nclass widget { public: static void* operator new(std::size t size, std::ostream\u0026amp; logstream) throw (std::bad alloc); static void operator delete (void* pMemory) throw(); static void operator delete (void* pMemory, std::ostream\u0026amp; logstream) throw(); }; placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针(例如上述的pw)施行delete绝不会导致调用 placement delete, 这意味着避免内存泄漏我们需要一个正常的operatordelete(用于构造期间无任何异常被抛出)和一个placement版本(用于构造期间有异常被抛出)。后者的额外参数必须和operator new一样。\n由于成员函数的名称会掩盖其外围作用域中的相同名称(见条款33),你必须小心避免让class专属的news掩盖客户期望的其他news (包括正常版 本) 。\nclass Base { public: static void* operator new(std::size t size, std::ostream\u0026amp; logStream) throw(std::bad alloc); }; Base* pb = new Base; //错误!因为正常形式的operator new被掩盖. Base* pb = new (std::cerr) Base; //正确,调用Base的placement new. 为了避免全局的”new”被隐藏，先来了解一下C++提供的三种全局”new”：\nvoid* operator new(std::size_t) throw(std::bad_alloc); //normal new void* operator new(std::size_t, void*) throw(); //placement new void* operator new(std::size_t, const std::nothrow_t\u0026amp;) throw(); //见Item 49 对于每一个可用的operator new也请确定提供对应的operator delete。如果你希望这些函数有着平常的行为,只要令你的class专属版本调用global版本即可。\nclass StandardNewDeleteForms { public: // normal new/delete static void* operator new(std::size_t size) throw(std::bad_alloc) { return ::operator new(size); } static void operator delete(void *pMemory) throw() { ::operator delete(pMemory); } // placement new/delete static void* operator new(std::size_t size, void *ptr) throw() { return ::operator new(size, ptr); } static void operator delete(void *pMemory, void *ptr) throw() { return ::operator delete(pMemory, ptr); } // nothrow new/delete static void* operator new(std::size_t size, const std::nothrow_t\u0026amp; nt) throw() { return ::operator new(size, nt); } static void operator delete(void *pMemory, const std::nothrow_t\u0026amp;) throw() { ::operator delete(pMemory); } }; 凡是想以自定形式扩充标准形式的客户,可利用继承机制及using声明式, 取得标准形式:\nclass widget: public StandardNewDeleteForms { public: using StandardNewDeleteForms::operator new; using standardNewDeleteForms::operator delete; static void* operator new(std::size t size std: :ostrean\u0026amp; logSt.ream) throw (std::bad alloc); static void operator delete(void* pMemory, std::ostream\u0026amp; logstream) throw(); ... }; 本文要点\n当你写一个placement operator new,请确定也写出了对应的placementoperator delete。如果没有这样做,你的程序可能会发生隐微而时断时续的内存泄漏。 当你声明placement new和placement delete,请确定不要无意识(非故意)地遮掩了它们的正常版本。 条款53: 不要轻忽编译器的警告 编译警告在C++中很重要，因为它可能是个错误啊！ 不要随便忽略那些警告，因为编译器的作者比你更清楚那些代码在干什么。 所以，\n请严肃对待所有warning，要追求最高warning级别的warning-free代码； 但不要依赖于warning，可能换个编译器有些warning就不在了。 一个常见错误\nclass B{ public: virtual void f() const; }; class D:public B{ public: virtual void f(); }; 这里希望以D::f重新定义virtual函数B::,但其中有个错误: B中的f是个const成员函数,而在D中它未被声明为const。我手上的一个编译器于是这样说 话了：\nwarning: D::f() hides virtual B::f() 这个编译器试图告诉你声明于B中的f并未在D中被重新声明, 而是被整个遮掩了。\n本文要点\n严肃对待编译器发出的警告信息。努力在你的编译器的最高(最严苛)警告级别下争取“无任何警告”的荣誉。 不要过度倚赖编译器的报警能力,因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上,你原本倚赖的警告信息有可能消失。 条款54: 让自己熟悉包括TR1在内的标准程序库 本文要点\nC++标准程序库的主要机能由STL, iostreams、 locales组成。并包含C99标准程序库。 TR1添加了智能指针(例如trl::shared ptr)、一般化函数指针(tr1:: function) 、 hash-based容器、正则表达式(regular expressions)以及另外10个组件的支持。 TR1自身只是一份规范。为获得TR1提供的好处,你需要一份实物。一个好的 实物来源是Boost 条款55: 让自己熟悉Boost 本文要点\nBoost是一个社群,也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在CH+标准化过程中扮演深具影响力的角色。 Boost提供许多TR1组件实现品,以及其他许多程序库。 Re:\nhttps://blog.csdn.net/qq_36915078/article/details/104751688\nhttps://harttle.land/tags.html#Effective-C++\n","permalink":"https://vcvvvc.github.io/post/effective_cpp_2/","tags":["cpp"],"title":"Effective C++ 下"},{"categories":null,"contents":"并发和并行 并发\n通过一种算法将 CPU 资源合理地分配给多个任务，当一个任务执行 I/O 操作时，CPU 可以转而执行其它的任务，等到 I/O 操作完成以后，或者新的任务遇到 I/O 操作时，CPU 再回到原来的任务继续执行。\n并行\n多核 CPU 的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。\n并发+并行\n每个核心并发执行两个任务，两个核心并行的话就能执行四个任务。当然也可以一个核心执行一个任务，另一个核心并发执行三个任务，这跟操作系统的分配方式，以及每个任务的工作状态有关系。\n异步跟同步 图为同步/异步\n同步等待上一步执行完成后才会执行下一步。\n异步系统当中的解决方案是开启一个额外的线程进行处理。\n第一个线程获取第一个文件，第二个线程获取第二个文件，第二个线程并不需要等待第一个线程执行完毕再执行。当两个线程都获得到对应的结果之后，再重新同步处理合并结果的操作。\n同步执行\n异步\nsetTimeout(function cbFn(){ console.log(\u0026#39;learnInPro\u0026#39;); }, 1000); console.log(\u0026#39;sync things\u0026#39;); setTimeout就是一个异步任务，当JS引擎顺序执行到setTimeout的时候发现他是个异步任务，则会把这个任务挂起，继续执行后面的代码。直到1000ms后，回调函数cbFn才会执行，这就是异步，在执行到setTimeout的时候，JS并不会傻呵呵的等着1000ms执行cbFn回调函数，而是继续执行了后面的代码。\n异步不会造成阻塞\n异步可以启用额外的线程去执行任务。\n异步并不会缩短任务的时间\npython异步 import asyncio # 定义异步函数 async def print_after(delay, message): # 异步等待 await asyncio.sleep(delay) # 打印消息 print(message) # 获取事件循环 loop = asyncio.get_event_loop() # 创建任务列表 tasks = [ loop.create_task(print_after(1, \u0026#39;Hello\u0026#39;)), loop.create_task(print_after(2, \u0026#39;World\u0026#39;)), ] # 在事件循环中执行任务 loop.run_until_complete(asyncio.wait(tasks)) # 关闭事件循环 loop.close() # 多线程实现 import threading import time # 定义一个函数，这个函数将在一个新的线程中运行 def print_numbers(): for i in range(10): time.sleep(1) print(i) # 定义另一个函数，这个函数也将在一个新的线程中运行 def print_letters(): for letter in \u0026#39;abcdefghij\u0026#39;: time.sleep(1) print(letter) # 创建两个线程 t1 = threading.Thread(target=print_numbers) t2 = threading.Thread(target=print_letters) # 启动线程 t1.start() t2.start() # 等待线程完成 t1.join() t2.join() from concurrent.futures import ThreadPoolExecutor import time def task(n): time.sleep(n) return n # 创建一个线程池 with ThreadPoolExecutor(max_workers=4) as executor: # 提交任务到线程池 futures = [executor.submit(task, n) for n in range(1, 5)] # 获取任务结果 for future in futures: print(future.result()) ## 2 from multiprocessing import Pool def task(n): return n * n # 创建一个进程池 with Pool(processes=4) as pool: # 映射任务到进程池 results = pool.map(task, range(1, 5)) # 输出结果 for result in results: print(result) Re: http://c.biancheng.net/view/9486.html\nhttps://cloud.tencent.com/developer/article/1795692\nhttps://blog.csdn.net/qq_43533974/article/details/110058714\nhttps://www.zhihu.com/question/33515481\nhttps://blog.csdn.net/li123128/article/details/80650256\nhttps://www.cnblogs.com/IT-CPC/p/10898871.html\n","permalink":"https://vcvvvc.github.io/post/async_thread/","tags":["Linux"],"title":"并行、并发、异步、同步"},{"categories":null,"contents":"Cookie HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。\nHTTP Cookie（也叫 Web Cookie 或浏览器 Cookie） 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\nCookie 主要用于以下三个方面：\n会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n个性化设置（如用户自定义设置、主题等）\n浏览器行为跟踪（如跟踪分析用户行为等）\n创建 Cookie 当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\n定义 Cookie 的生命周期 Cookie 的生命周期可以通过两种方式定义：\n会话期: Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。\n持久性: Cookie 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。\nCookie 的作用域 Domain 和 Path 标识定义了 Cookie 的作用域：即允许 Cookie 应该发送给哪些 URL。\nRe: https://developer.mozilla.org/zh-CN/docs/web/http/cookies\n","permalink":"https://vcvvvc.github.io/post/http_cookie/","tags":["Server"],"title":"Http_cookie"},{"categories":null,"contents":"ERC ERC全称“Ethereum Request for Comment\u0026quot;，翻译过来即Ethereum版的意见征求稿，用以记录以太坊上应用级的各种开发标准和协议(application-level standards and conventions)。\nEIP(Ethereum Improvement Proposals以太坊升级提案)是为以太坊潜在新功能或流程提出建议的标准。 EIP 包含提议改进的技术规范，并作为社区的“真相来源”。 在 EIP 的过程中，将会讨论和制定以太坊的网络升级和应用标准。\n以太坊EIP 的标准序列包括 Core（核心改进）、Networking（网络层改进）、Interface（接口改进）、ERC（应用层意见征集）。\nEIP分为三种类型:\n1. 标准轨道EIP(A Standards Track EIP)\n2. 元EIP(A Meta EIP)\n3. 信息EIP(An Informational EIP)\nERC-20 ERC-20 提供了一个同质化代币的标准，换句话说，每个代币与另一个代币（在类型和价值上）完全相同。 例如，一个 ERC-20 代币就像 ETH 一样，意味着一个代币会并永远会与其他代币一样。\n它用于以太坊区块链上的所有智能合约以实现代币，并提供所有基于以太坊的代币必须遵循的规则列表。\n六个基本的编码功能是：\n总供给 余额 津贴 转移 批准 从转移 ERC-721 ERC-721 非同质化代币标准\n非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！\n所有 NFTs 都有一个 uint256 变量，名为 tokenId，所以对于任何 ERC-721 合约，这对值contract address, tokenId 必须是全局唯一的。 也就是说，dApp 可以有一个“转换器”，该转换器使用 tokenId 输入和输出一些非常有趣的事物的图像， 例如武器、技能或非常可爱的猫咪！\nERC-1155 ERC-1155 則是多重代幣標準，全名為 Multi Token Standard。ERC-1155 的用途為再製、包裝或組合一個至多個 Token Type 或 NFT Collection，讓 Token Type 或 NFT Collection 有繼承、多型、封裝等功能。\n其他 什么叫做代币？ 代币可以在以太坊中表示任何东西：\n在线平台中的信誉积分 游戏中一个角色的技能 彩票卷 金融资产类似于公司股份的资产 像美元一样的法定货币 一盎司黄金 \u0026hellip; ICO（是Initial Coin Offering缩写），首次币发行，源自股票市场的首次公开发行（IPO）概念，是区块链项目首次发行代币，募集比特币、以太坊等通用数字货币的行为。 Re： https://zhuanlan.zhihu.com/p/80029720\nhttps://www.yisu.com/zixun/515957.html\nhttps://www.wwsww.cn/ytf/2324.html\nhttps://baike.baidu.com/item/ICO/21498451\nhttps://ethereum.org/zh/developers/docs/standards/\nERC-list https://eips.ethereum.org/erc\nhttps://blog.csdn.net/u010694922/article/details/85761042\nhttps://eips.ethereum.org/EIPS/eip-20\nhttps://ethereum.org/zh/developers/docs/standards/tokens/erc-20/\nhttps://ethereum.org/zh/developers/docs/standards/tokens/erc-721/\nhttps://bshare.io/en/nft/erc20_721_1155/\n","permalink":"https://vcvvvc.github.io/post/about_erc/","tags":["Block_Chain"],"title":"About_ERC"},{"categories":null,"contents":"1. 下载安装geth https://geth.ethereum.org/\n2. 创建私有链 创建创世块配置文件 genesis.json\n{ \u0026#34;config\u0026#34;: { \u0026#34;chainId\u0026#34;: 15, \u0026#34;homesteadBlock\u0026#34;: 0, \u0026#34;eip155Block\u0026#34;: 0, \u0026#34;eip158Block\u0026#34;: 0, \u0026#34;eip150Block\u0026#34;: 0 }, \u0026#34;coinbase\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000\u0026#34;, \u0026#34;difficulty\u0026#34; : \u0026#34;0x40000\u0026#34;, \u0026#34;extraData\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;gasLimit\u0026#34; : \u0026#34;0xffffffff\u0026#34;, \u0026#34;nonce\u0026#34; : \u0026#34;0x0000000000000042\u0026#34;, \u0026#34;mixhash\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;, \u0026#34;parentHash\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;, \u0026#34;timestamp\u0026#34; : \u0026#34;0x00\u0026#34;, \u0026#34;alloc\u0026#34;: { } } 3. 初始化 geth --datadir genesis-block init genesis.json 启动节点\n#1 geth --datadir genesis-block --networkid 1108 console 注册账户 personal.newAccount(\u0026#39;Your Password\u0026#39;) #创建两个 余额查询\nmy=eth.accounts[0] eth.getBalance(my) personal.newAccount(\u0026#39;password\u0026#39;) other=eth.accounts[1] personal.unlockAccount(my) 账户余额查询\neth.getBalance(my) eth.getBalance(other) 挖矿\nminer.start(1) miner.stop() #null 转移资产到另一个号\neth.sendTransaction({from:my, to:other, value:10000}) 测试网络 geth --http --http.api db,eth,net,web3,personal --datadir genesis-block --networkid 1108 console 2\u0026gt;\u0026gt;1out.log Re: https://blog.csdn.net/weixin_40401264/article/details/78095222\nhttps://blog.csdn.net/qq_25870633/article/details/82931782\nhttps://blog.csdn.net/cjm083121/article/details/106319518\nhttps://blog.csdn.net/qq_46526828/article/details/113779366\n","permalink":"https://vcvvvc.github.io/post/geth_use/","tags":["Blockchain","Linux"],"title":"Geth_私链创建并链接钱包"},{"categories":null,"contents":"Non-Fungible Rights, 不可替代权利\nNon-fungible Token, 不可替代代币\n","permalink":"https://vcvvvc.github.io/post/nft_nfr/","tags":["Note"],"title":"NFT_NFR"},{"categories":null,"contents":"https://zhuanlan.zhihu.com/p/143156163\n","permalink":"https://vcvvvc.github.io/post/ubuntu20_install_docker/","tags":["Linux","Docker"],"title":"Ubuntu20_install_docker"},{"categories":null,"contents":"TCP tcp报文首部的前20个字节是固定的，后面有4n字节是需要根据需要增加的选项，因此tcp首部的最小长度是20字节。\n源端口、目标端口： 计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个。\n序号：表示本报文段所发送数据的第一个字节的编号。在TCP连接中所传送的字节流的每一个字节都会按顺序编号。由于序列号由32位表示，所以每2^32个字节，就会出现序列号回绕，再次从 0 开始。\n序号增加到最大值的时候，下一个序号又回到了 0. 也就是说 TCP 协议可对 4GB 的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。 确认号：表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。也就是告诉发送发：我希望你（指发送方）下次发送的数据的第一个字节数据的编号是这个确认号。也就是告诉发送方：我希望你（指发送方）下次发送给我的TCP报文段的序列号字段的值是这个确认号。\n数据偏移: 占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。 但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。\n保留: 占 0.5 个字节 (4 位)。 保留为今后使用，但目前应置为 0。\n控制位: 占 1 个字节 （8位）\nCWR（Congestion Window Reduced） ECE（ECN-Echo） URG（Urgent Flag） 该位为1时，表示包中有需要紧急处理的数据。对于需要紧急处理 的数据，会在后面的紧急指针中再进行解释。 ACK（Acknowledgement Flag） 该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连 接时的SYN包之外该位必须设置为1。 PSH（Push Flag） 该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH 为0时，则不需要立即传而是先进行缓存。 RST（Reset Flag） 该位为1时表示TCP连接中出现异常必须强制断开连接。 SYN（Synchronize Flag） 用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段 进行序列号初始值的设定 FIN（Fin Flag） 该位为1时，表示今后不会再有数据发送，希望断开连接。当通信 结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1 的TCP段。 窗口大小（Window Size）\n该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置 开始能够接收的数据大小（8位字节）。 校验和（Checksum）\n紧急指针（Urgent Pointer）\n该字段长为16位。只有在URG控制位为1时有效。该字段的数值表 示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指 针所指示的位置为止为紧急数据。因此也可以说紧急指针指出了紧急数 据的末尾在报文段中的位置。 选项（Options）\n选项字段用于提高TCP的传输性能。因为根据数据偏移（首部长 度）进行控制，所以其长度最大为40字节。 UDP 源端口号：表示发送端端口号，字段长16位。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候该字段的设置为0。可用于不需要返回的通信中。\n目标端口号：表示接收端端口，字段长度16位。\n包长度：该字段保存了UDP首部的长度跟数据的长度之和。单位为字节。\n校验和：校验和是为了提供可靠的UDP首部和数据而设计的。\nudp的首部开销小，仅仅有8个字节。\nRe: https://blog.csdn.net/weixin_45649763/article/details/104082660\nhttps://zhuanlan.zhihu.com/p/348660544\n","permalink":"https://vcvvvc.github.io/post/tcp_udp%E9%A6%96%E9%83%A8/","tags":["Server","TCP/IP"],"title":"TCP/UDP首部"},{"categories":null,"contents":"IPv4首部 版本：由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4，因此在这个字段上的值也为“4”。\n首部长度(（IHL：Internet Header Length）)：由4比特构成，表明IP首部的大小，单位为4字节（32比特）。对于没有可选项的IP包，首部长度则设置为“5”。也就是说，当没有可选项时，IP首部的长度为20字节（4*5=20）。\n区别服务（TOS：Type Of Service）: 由8比特构成，用来表明服务质量。每一个的具体含义如表所示。\nDSCP（Differential Services Codepoint，差分服务代码点）是TOS（Type Of Services）的一部分。现在统称为DiffSer，用来进行质量控制。 如果3-5位的值为0,0~2位则被称作类别选择代码点。这样就可以向TOS的优先度那样提供8中类型的质量控级别。对于每一种级别所采取的措施则由提供DiffServ的运营管理者制定。为了与TOS保持一致，值越大优先度也越高。如果第五位为1，表示实验或本地使用的意思。\nECN(Ecplicit Congestion Notification，显示拥塞通告)用来报告网络拥塞情况，由两个比特构成。 第6位的ECT 用以通告上传TCP层协议是否处理ECN。当路由器在转发ECN为1的包的过程中，如果出现网络拥塞的情况，就将CE位设置为1。\n总长度（Total Length）： 表示IP首部与数据部分合起来的字节数。该字段长16比特。因此IP包的最大长度为65535=2^16字节。目前还不存在能够传输最大长度为65535字节的IP包的数据链路。不过，由于有IP分片处理，从IP的上一层的角度看，不论底层采用何种数据链路，都可以认为能够以IP的最大包长传输数据。\n标识（ID：Identification）：由16比特构成，用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。通常，每发送一个IP包，它的值也逐渐递增。此外，即使IP相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。\n标志：由3比特构成，标识包被分片的相关信息。每一个的具体含义如图：\n片位移（FO：Fragment Offset）：由13比特构成，用来标识被分片的每一个分段相当于原始数据的位置。第一个分片对应的值为0.由于FO域占13位，因此最多可以表示8192（=2^13）个相对位置。单位为8字节，因此最大可表示原始数据8*8192=65536字节的位置。\n生存时间（TTL：Time To Live）：由8比特构成，它最初的意思是以秒为单位记录当前包在网络上应该生存的期限。然而，在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减1，直到变成0则丢弃该包。\n协议（Protocol）：由8比特构成，表示IP首部的下一个首部隶属于哪个协议。目前使用的协议部分如图：\n首部校验和（Header Checksum）：由16比特（2个字节）构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。校验和的计算过程，首先要将校验和的所有位置设置为0，然后以16比特为单位划分IP首部，并用1补数计算所有16位字的和。最后将所得到这个和的1补数赋给首部校验和字段。\n源地址（Source Address）：由32比特构成，表示发送端IP地址。\n目标地址（Destination Address）：由32比特构成，表示接收端IP地址。\n可选项（Options）：长度可变，通常只在进行实验或诊断时使用。该字段包含如下几点信息：安全级别，源路径，路径记录，时间戳\n填充（Padding）：也称作填充物。在有可选项的情况下，首部长度可能不是32比特的整数倍。为此，通过向字段填充0，调整为32比特的整数倍。\n数据：存入数据。将IP上层协议的首部也作为数据进行处理。\nIPv6首部 IPv6为了减轻路由器的负担，省略了首部校验和字段。因此路由器不再需要计算校验和，从而提高了包的转发效率。\n此外，分片处理所用的识别码成为可选项。为了让64位CPU的计算机处理起来更方便，IPv6的首部及可选项都由8字节构成。\n版本：和IPv4 一样，由4比特构成。IPv6其版本号为6，因此在这个字段上的值为“6”。\n通信量类（Traffic Class）：相当于IPv4的TOS（Type Of Service）字段，也由8比特构成。有TOS在IPv4中几乎没有什么建树，未能成为卓有成效的技术，本来计划在IPv6中删掉这个字段，不过出于今后研究的考虑还是保留了该字段。\n流标号（Flow Label）：由20比特构成，准备用于服务质量（Qos：Quality Of Service）控制。使用这个字段提供怎样的服务已经成为未来研究的课题。不适用Qos时每一位可以全部设置为0。 在进行服务质量控制的时，将流标号设置为一个随机数，然后利用一种可以设置流的协议RSVP（Resource Reservation Protocol ）在路由器上进行Qos设置。当某个包在发送途中需要Qos时，需要附上RSVP预想的流标号。路由器接收到这样的IP包后现先将流标号作为查找关键字，迅速从服务质量控制信息中查找并做相应处理。此外，只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流。\n有效荷载长度（Payload Length）：有效荷载长度是指包的数据部分。IPv4的TL(Total Length)是指包含首部在内的所有长度。然而IPv6中的这个Playload Length不包括首部，只表示数据部分的长度。由于IPv6的可选项是指连接IPv6首部的数据，只有当有可选项时，此处包含可选项数据的所有长度就是Playload Length。\n下一个首部（Next Header）：相当于IPv4中的协议字段。由8比特构成。通常表示IP的上一层协议是TCP或UDP。不过在有IPv6扩展首部的情况下，该字段表示后面第一个扩展首部的协议类。\n跳数限制（Hop Limit）：由8比特构成。与IPv4中的TTL意思相同。为了强调“可通过路由器个数”这个概念，才将名字改为“Hop Limit”。数据每经过一次路由器就减1，减到0则丢弃数据。\n源地址（Source Address）：由128比特构成，表示发送端IP地址。\n目标地址（Destination Address）：由128比特构成，表示接收端IP地址。\nIPv6扩展首部：IPv6的首部长度对固定，无法将可选项将入其中，取而代之的是通过扩展首部对功能进行了有效扩展。 扩展首部通常介于IPv6首部与TCP/UDP首部中间。在IPv4中可选项长度固定为40字节，但是在IPv6中没有这样的限制。也就是说，IPv6的扩展首部可以是任意长度。扩展首部当中还可以包含扩展首部协议以及下一个扩展首部字段。\nRe: https://www.cnblogs.com/alway-july/p/9090137.html\nhttps://www.cnblogs.com/alway-july/p/9090255.html\nhttps://blog.csdn.net/richenyunqi/article/details/83660244\nhttps://www.cnblogs.com/lakeone/p/3487173.html\n","permalink":"https://vcvvvc.github.io/post/ip%E9%A6%96%E9%83%A8/","tags":["Server","TCP/IP"],"title":"IPv4/v6首部"},{"categories":null,"contents":"什么是协程 进程-\u0026gt;线程-\u0026gt;协程\nRe:\nhttps://baike.baidu.com/item/协程/8652240\nhttps://cloud.tencent.com/developer/article/1916705\nhttps://zhuanlan.zhihu.com/p/172471249\nhttps://www.zhihu.com/question/32218874/answers/updated\nhttps://zhuanlan.zhihu.com/p/70256971\nhttps://docs.python.org/zh-cn/3/library/asyncio-task.html\nUnity: https://developer.unity.cn/projects/61c80ba3edbc2a244ffbcf25\nhttps://www.nowcoder.com/discuss/821457\nhttp://c.biancheng.net/view/5214.html\nhttps://zhuanlan.zhihu.com/p/59178345\nhttps://zhuanlan.zhihu.com/p/337946103\n","permalink":"https://vcvvvc.github.io/post/%E4%BD%95%E4%B8%BA%E5%8D%8F%E7%A8%8B/","tags":["Linux","CPP","Python"],"title":"何为协程"},{"categories":null,"contents":"#https://blog.csdn.net/dosthing/article/details/80383817 std::string ip = \u0026#34;www.baidu.com\u0026#34;; struct hostent stHostent; struct hostent *pstHostent = nullptr; char **pptr = nullptr; char buf[2048] = \u0026#34;\\0\u0026#34;; sprintf(buf,\u0026#34;%s\u0026#34;, \u0026#34;ip\u0026#34;); int iError; if((pstHostent = gethostbyname(buf)) == NULL || pstHostent-\u0026gt;h_addr_list == NULL || pstHostent-\u0026gt;h_addr_list[0] == NULL) { std::cout \u0026lt;\u0026lt; \u0026#34;can\u0026#39;t parse the domain\u0026#34; \u0026lt;\u0026lt; std::endl; exit(0); } else { std::cout \u0026lt;\u0026lt; \u0026#34;official hostname: \u0026#34; \u0026lt;\u0026lt; pstHostent-\u0026gt;h_name \u0026lt;\u0026lt; std::endl; for(pptr = pstHostent-\u0026gt;h_aliases; *pptr != NULL; pptr++) std::cout \u0026lt;\u0026lt; \u0026#34;alias: \u0026#34; \u0026lt;\u0026lt; *pptr \u0026lt;\u0026lt; std::endl; switch(pstHostent-\u0026gt;h_addrtype) { case AF_INET: case AF_INET6: pptr = pstHostent-\u0026gt;h_addr_list; for(; *pptr!=NULL; pptr++) printf(\u0026#34;address:%s\\n\u0026#34;,inet_ntop(pstHostent-\u0026gt;h_addrtype, *pptr, buf,64)); printf(\u0026#34;first address: %s\\n\u0026#34;,inet_ntop(pstHostent-\u0026gt;h_addrtype, pstHostent-\u0026gt;h_addr,buf,64)); break; default: printf(\u0026#34;Unkown address type\\n\u0026#34;); } } ","permalink":"https://vcvvvc.github.io/post/get_domain_ip_cpp/","tags":["Linux","Server","CPP"],"title":"C++获取域名IP"},{"categories":null,"contents":"区块链的确是个很好的想法。\n区块链（Blockchain） 网上有说是账本，有说数据库的，我先不下定义。\n起源是2008年中本聪比特币白皮书提出。区块链有望令诸多行业收益，不过目前让机构拿来玩起了资本游戏。\n比特币白皮书: https://bitcoin.org/bitcoin.pdf\n中文版本: https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf\n#维基百科 区块链是借由密码学串接并保护内容的串连文字记录（又称区块）。 每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易资料（通常用默克尔树（Merkle tree）算法计算的散列值表示）， 这样的设计使得区块内容具有难以篡改的特性。用区块链技术所串接的分布式账本能让两方有效记录交易，且可永久查验此交易。 运作 集中化： | 去中心化： | 分布式：\n\u0026ndash;\n区块链是一种记录保存系统，在将条目添加到数据链之前会有多个源来验证该条目。数据一旦添加，便无法更改，记录随之分布到网络中的多个位置。向区块链序列添加新记录（称为区块）需要由连接到区块链网络的多个成员进行验证。这些数据区块相互链接而形成链。区块链中的全部交易对其中的所有人公开，但所有个人身份都是隐藏的。\n区块链技术使用算法为每个区块分配加密哈希（包含字母和数字的唯一字符串，有时也称为“数字指纹”）。除哈希以外，每个区块还包含带时间戳的先前交易的记录集，以及前一个区块的哈希。正是这种机制确保了在链中的连续区块之间建立起不可变的链接。\n加密术和时间戳的组合确保了区块链技术能自动验证这个增长的哈希序列永远不会更改。这种操作机制能够防止不按顺序插入新区块，从而防止交易数据事后被更改或伪造。\n区块链由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条：\n优势 比较突出的就这几点 我直接复制过来\n去中心化 点对点 防篡改 通过共识同步化 消除了对第三方验证机构的需求 特定区块链中的全部交易对涉及的各方都可见 透明性：所有参与者都可以查看区块链中的信息，但不能修改信息。这有助于减少风险和欺诈，同时建立信任。 安全性：得益于其分布式和加密的特性，区块链很难受到非法攻击。因此，该技术能够保障业务和物联网的安全性。 消除中间商：区块链是真正意义上的点对点网络，将减少企业对某些第三方中间商的依赖。这有助于提高流程效率，减少数据输入错误几率和交易费用。 可追溯性：由于区块链数据不可篡改，因此非常适合复杂供应链中的物品跟踪和追踪或溯源。 提高效率和投资回报率：分布式账本将帮助企业打造更精简、更高效且更具盈利能力的流程，让他们快速获得投资回报。 加快流程速度：区块链可以加快多方交易场景中的流程执行速度，不受办公时间的限制，加快交易处理。 自动化：区块链具有可编程的特点。通过编程，在满足条件的情况下，区块链技术可以自动触发行动、事件和付款。 数据隐私：虽然信息在添加到区块链之前需要通过共识流程进行验证，但数据本身通过哈希代码被转换成了一系列字母和数字。网络中的参与者无法在没有密钥的情况下破译这些信息。 四种类型 公共区块链： 比特币和以太坊 (Ethereum) 是最早和最典型的区块链网络，也是公共网络。所有人都能读取公共区块链，向公共区块链发送交易，或者参与公共区块链的共识流程。公共区块链无需许可，每笔交易都是公开的，而且用户可以保持匿名状态。 半私有区块链： 半私有区块链由单一企业运行，该企业为所有满足预设标准的用户提供访问权限。尽管并未真正去中心化，但在 B2B 用例和政府应用领域，这类许可区块链仍然极具吸引力。 私有区块链： 私有区块链也是由单一企业控制，该企业决定谁可以读取区块链、向区块链发送交易和参与共识流程。但是，这种区块链完全中心化，因此只适合用作沙箱环境，无法用于实际生产。 共同体区块链： -目前，在建立区块链网络的四种方法中，共同体区块链最受欢迎。在共同体区块链中，共识流程由预先选定的团体（如企业团体）控制。可能每个人都可以读取区块链和向区块链提交交易，也可能仅限于参与者。共同体区块链被认为是“许可区块链”，最适合用于商业领域。 智能合约 智能合约是以区块链技术为基础，能够自我执行的条约；一旦满足条件，就可以自动触发行为或付款。不久的将来，智能合约将能利用资产 GPS 数据等实时信息触发事件，比如转移所有权和资金。\n以太坊带来的重大创新是智能合约的出现。通常，主流商业世界中的合同在两个独立的实体之间进行管理，有时还有其他实体协助监督过程。智能合约是那些在区块链上自我管理的合约。它们由诸如过期日期或特定价格目标实现之类的事件触发；作为回应，智能合约自行管理，根据需要进行调整，无需外部实体的输入。\nBAAS Blockchain as a Service，简称BaaS-区块链即服务\nBaaS是一种帮助用户创建、管理和维护企业级区块链网络及应用的服务平台。它具 有降低开发及使用成本，兼顾快速部署、方便易用、高安全可靠等特性，是为区块链应用 开发者提供区块链服务能力的平台。BaaS通过把计算资源、通讯资源、存储资源，以及 上层的区块链记账能力、区块链应用开发能力、区块链配套设施能力转化为可编程接口， 让应用开发过程和应用部署过程简单而高效，同时通过标准化的能力建设，保障区块链应 用的安全可靠，对区块链业务的运营提供支撑，解决弹性、安全性、性能等运营难题，让 开发者专注开发。 一些术语 加密技术：安全的信息和通信技术，在区块链中用于发送和/或存储数据，确保只有目标接收人才能访问数据。 哈希：一种加密技术，在区块链中是由字母和数字编码的字符串，对链接序列中的每个区块是永久唯一的，有时也称为“数字指纹”。 区块：一种封装的数据块，其中包含 1) 自身的标识区块哈希，2) 来自链序列前一个区块的哈希，以及 3) 带时间戳的交易记录集。 区块链交易：经成员验证过的数据记录，为业务交易（例如财务或合约）提供几乎不可变的真实性证明。 Reference https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE\nhttps://www.liaoxuefeng.com/wiki/1207298049439968\nhttps://www.amd.com/zh-hans/technologies/blockchain-explained\nhttps://www.sap.cn/insights/what-is-blockchain.html\nhttps://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/BCS/BCS__2.0.pdf\nhttp://www.caict.ac.cn/kxyj/qwfb/bps/201901/P020190218567777098715.pdf\n学习： https://cubic-leaf-731.notion.site/web3-202208-09-1623ccd15c2148a1ae00ed8794d153b1\n区块链的侧链/跨链，硬分叉链/软分叉链，主链/子链 https://learnblockchain.cn/2018/08/26/0cf08430c38e\n","permalink":"https://vcvvvc.github.io/post/blockchain/","tags":["Stock","Blockchain"],"title":"区块链｜Blockchain"},{"categories":null,"contents":"前言 谈到ETH就需要先了解区块链跟BTC，单独写了一篇：\nBlockchain \u0026amp; BTC\n\u0026ndash;yi-\nETH https://ethereum.org/\n以太坊（Ethereum）是一个去中心化的开源的有智能合约功能的公共区块链平台。 以太币（ETH 或 Ξ）是以太坊的原生加密货币。截止 2021 年 12 月，以太币是市值第二高的加密货币，仅次于比特币。以太坊是使用最多的区块链。 以太坊的特点包括下列：\n智能合约（smart contract）：存储在区块链上的程序，由各节点执行，需要执行程序的人支付手续费给节点的矿工或权益人。[6] 分布式应用程序：以太坊上的分布式应用程序不会停机，也不能被关掉。 代币（tokens）：智能合约可以创造代币供分布式应用程序使用。分布式应用程序的代币化让用户、投资者以及管理者的利益一致。代币也可以用来进行首次代币发行。 叔块（uncle block）：将因为速度较慢而未及时被收入母链的较短区块链并入，以提升交易量。使用的是有向无环图的相关技术。[6] 权益证明（proof-of-stake）：相较于工作量证明更有效率，可节省大量在挖矿时浪费的电脑资源，并避免特殊应用集成电路造成网络中心化。平行运作中，预计2022年与主链合并。 燃料（gas）：由交易手续费的概念扩展，在执行各种运算（computation）时需计算燃料消耗量，并缴交燃料费，包括发送以太币或者其他代币也被视为一种运算动作。 分片（sharding）：减少每个节点所需纪录的资料量，并透过平行运算提升效率。预计于2022年实现。 以太坊白皮书原版：https://ethereum.org/zh/whitepaper/#further-reading\n以太坊白皮书中英对照：https://zhuanlan.zhihu.com/p/33779523\n以太坊白皮书简体中文：https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6\n以太币 以太坊区块链上的代币称为以太币（Ether），代码为ETH，可在许多加密货币的外汇市场上交易，它也是以太坊上用来支付交易手续费和运算服务的介质\n工作量证明 (POW, Proof of work)\n工作量证明是一个为矿工设置挖矿难度和规则的基础性算法。 挖矿就是“工作”本身。 挖矿是向区块链中添加有效区块。 权益证明机制(POS, Proof of stake)\n权益证明是一种区块链网络达成共识的共识机制。(彩票) 其他\n权威证明(POA, Proof of authority)\n由投票机制的“许可区块链共识” DEFI 去中心化金融 (DEcentralized FInance）。\nCeFi = Centralized Finance 中心化金融（传统金融）\nDEFI - The Future Of Finance Explained: https://www.youtube.com/watch?v=H-O3r2YMWJ4\u0026amp;t=2s\nWhat is DEFI? Decentralized Finance Explained: https://www.youtube.com/watch?v=k9HYC0EJU6E\nDEBI是一种基于区块链的金融，它不依赖券商、交易所或银行等金融机构提供金融工具，而是利用区块链上的智能合约（例如以太坊）进行金融活动。DeFi平台允许人们向他人借出或借入资金，交易加密货币，并在类似储蓄的账户中获得利息\n去中心化金融（又名“DeFi”或“开放金融”）是指构建开放金融基础设施的许多去中心化协议。这些协议很有价值，因为它们正在创建必要的管道，使世界上任何拥有互联网连接的人都能够访问自主主权、抗审查的金融服务。 DeFi 如何运作？\nDeFi 使用加密货币和智能合约来提供不需要中介的服务。 在现代金融体系下，金融机构充当交易的担保人。 因为您的资产通过这些机构流通，从而为这些机构赋予了巨大能量。 世界上还有数十亿人甚至无法使用银行帐户。 在 DeFi，智能合约取代了交易中的金融机构。 智能合约是一种以太坊帐户，可以持有资金，并可以根据某些条件发送/退还资金。 当智能合约上线时，没有人可以改变其有效期，它会始终按程序运行。 一份旨在发放补贴或零用钱的合同可以被编程为：每周五从 A 帐户向 B 帐户汇款。 只有帐户 A 拥有所需资金，它才会这样做。 没有人可以改变智能合约并将帐户 C 添加为收款人以窃取资金。 合约也是公开的，任何人都可以检查和审计。 这意味着不良合约往往会很快受到社会监督。 这确实意味着，目前需要信任以太坊社区中能够读取代码的技术员。 基于开源的社区有助于控制开发者，但是随着时间的推移，这种需求将逐渐减少，因为智能合约变得更易于阅读。并且开发了其他方法来证明代码的可信赖性。 Defi项目目前分成四大类： 第一类：无中介借贷(Decentralized Loan)\nUniswap-去中心化交易所\nCompound-去中心化借贷\n第二类：无托管交易(Decentralized Exchange)\n第三类：可编程的标准化金融衍生品(Decentralized Derivatives)\n第四类：金融流程自动化(FINANCIAL PROCESS AUTOMATION)\nETH2.0 Eth2是一系列相关的升级，目标是使得以太坊更加可扩展、更安全以及更节能。这些更新由以太坊生态下的多个团队共同开发。\n信标链\n信标链将处理或协调分片和质押者的扩展网络。 但它与今天的以太坊主网不同。 它无法处理帐户或智能合约。\n信标链的角色将随着时间的推移而改变，但它是我们正在努力实现的安全、可持续和可扩展的以太坊的基础组件。\n分片\n分片可以提高以太坊的性能\n权益证明机制(POS)\n权益证明是一种区块链网络达成共识的共识机制。\n这将要求用户抵押他们的以太币从而成为网络中合法的验证者。 验证者有着与矿工在 工作量证明（pow）中相同的职责：将交易排序和创建新的区块，以便让所有的节点就网路状态达成一致。\n权益证明、权益质押和验证者\n权益证明是一种用于激励验证者接受更多质押的基本机制。 就以太币而言，用户需要质押 32ETH 来获得作为验证者的资格。 验证者被随机选择去创建区块，并且负责检查和确认那些不是由他们创造的区块。 一个用户的权益也被用于激励良好的验证者行为的一种方式。 例如，用户可能会因为离线（验证失败）而损失一部分权益， 或因故意勾结而损失他们的全部权益。\n智能合约 智能合约（Smart Contract）。\n以太坊提供了一个EVM（Ethereum Virtual Machine）虚拟机来执行智能合约的字节码 智能合约只是一个运行在以太坊链上的一个程序。 它是位于以太坊区块链上一个特定地址的一系列代码（函数）和数据（状态）。\n合约不能主动执行，它只能被外部账户发起调用。如果一个合约要定期执行，那只能由线下服务器定期发起合约调用。\nCODE IS LAW? Smart Contracts Explained (Ethereum, DeFi): https://www.youtube.com/watch?v=pWGLtjG-F5c 智能合约的一个简单比喻是自动售货机，其工作方式与智能合约有些相似——特定的输入保证预定的输出。\n您选择一个产品 自动售货机退回购买产品所需的金额 您输入正确的金额 自动售货机验证您输入的金额是否正确 自动售货机分发选择的产品 只有在满足所有要求后，自动售货机才会分发您想要的产品。如果您没有选择产品或投入足够的钱，自动售货机不会发出您的产品。\nNFT(Non-Fungible Tokens) 非同质化代币 (NFT)\nNFT 是我们用以代表独特物品所有权的代币。 NFT 让我们把诸如艺术品、收藏品、甚至房地产等物品代币化。 他们一次只有一个正式主人，并且受到以太坊区块链的保护 - 没有人可以修改所有权记录或者根据现有的 NFT 复制粘贴一份新的。\nNFT 代表非同质化代币。 非同质化是一个经济术语，您可以用它来描述家具、歌曲文件或您的电脑等物品。 这些东西不能与其他物品互换，因为它们具有独特属性。\n另一方面，同质化物品可以互换，这取决于它们的价值而非独特属性。 例如，ETH 或美元具有同质化属性，因为 1 ETH/1 USD 可以兑换成另外的 1 ETH/1 USD。\nWhat Are NFTs and How Can They Be Used in Decentralized Finance? DEFI Explained: https://www.youtube.com/watch?v=Xdkkux6OxfM 在数字化潮流之下，NFT以及国内的数字藏品改变了一些事情，一些人。\n这种形式使得艺术品离人们距离变得不再遥远，同时通过互联网让更多的人可以参与到这次的潮流之中，每个人都可以获得属于自己独一无二的数字藏品。\n目前应用比较单一，但是未来可以看得到太多美好。 NFT复制/粘贴问题 有些傻的问题。\n是你的程序会帮你验证，为你证明，不是你的复制再多也没用。\n99%的NFT都会归于普通，投资人应该用明亮的双眼去寻找那1% punk 在曼哈顿的公交车候车亭上展示的 CryptoPunk NFT © Dia Dipasupil/Getty 以太坊帐户 一个以太坊帐户是一个具有以太币 (ETH) 余额的实体，可以在以太坊上发送交易。 帐户可以由用户控制，也可以作为智能合约部署。\n以太坊有两种账户，如下图所示：\n外部账户（externally owned accounts），由密钥控制。\n合约账户（contract accounts），由智能合约的代码控制。\n主要区别:\n外部持有\n创建帐户是免费的\n可以发起交易\n外部所有的帐户之间只能进行 ETH 和代币交易\n合约\n创建合约存在成本，因为需要使用网络存储空间\n只能在收到交易时发送交易\n从外部帐户向合约帐户发起的交易能触发可执行多种操作的代码，例如转移代币甚至创建新合约\n外部账户：有账户余额；无代码；能触发交易（转账或执行智能合约）；由私钥控制。\n合约账户：有账户余额；有代码；能被触发执行智能合约代码；在智能合约创建后自动运行。\n外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后按预先编写的智能合约代码执行。\n外部账户 以太坊帐户有四个字段：\nnonce – 显示从帐户发送的交易数量的计数器。 这将确保交易只处理一次。 在合约帐户中，这个数字代表该帐户创建的合约数量\nbalance – 这个地址拥有的 Wei 数量。 Wei 是以太币的计数单位，每个 ETH 有 1e+18 Wei。\ncodeHash - 该哈希表示以太坊虚拟机 (EVM) 上的帐户代码。 合约帐户具有编程的代码片段，可以执行不同的操作。 如果帐户收到消息调用，则执行此 EVM 代码。 与其他帐户字段不同，不能更改。 所有代码片段都被保存在状态数据库的相应哈希下，供后续检索。 此哈希值称为 codeHash。 对于外部所有的帐户，codeHash 字段是空字符串的哈希。\nstorageRoot – 有时被称为存储哈希。 Merkle Patricia trie 根节点的 256 位哈希已编码了帐户的存储内容（256 位整数值映射），并编码为 Trie，作为来自 256 的 Keccak 256 位哈希的映射位整数键，用于 RLP 编码的 256 位整数值。 此 Trie 对此帐户存储内容的哈希进行编码，默认情况下为空。\n外部持有的帐户和密钥对\n帐户由公钥和私钥加密对组成。 它们有助于证明交易实际上是由发送者签名的，并防止伪造。 您的私钥是您用来签名交易的密钥，所以它保障您对与您帐户相关的资金进行管理。 您从未真正持有加密货币，您持有私钥 – 资金总是在以太坊的账本上。\n这将防止恶意参与者广播虚假交易，因为您总是可以验证交易的发送者。\n合约账户 合约账户（contract accounts），由智能合约的代码控制。只有合约账户才有代码，其中存储的是 codeHash（这个账户的以太坊虚拟机代码的哈希值）。这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。\n合约账户可以设置多重签名（multisign），比如一个简单示例是：现有一个合约账户，它要求一个转账由发起转账的人（Alice）和另一个人（Charles）签名均可。因此，当 Alice 通过这个合约向 Bob 转账 20 个 ETH 时，合约会通知 Charles 签名，在他签名后，Bob 才可以收到这 20 个 ETH（见图2）。\nRe:\nnews: https://www.ft.com/content/e003ee52-024c-42f5-8743-d69a7390d5ba\nnews: https://www.ft.com/content/e95f5ac2-0476-41f4-abd4-8a99faa7737d\nhttps://zh.wikipedia.org/wiki/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E9%87%91%E8%9E%8D\nhttps://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E5%9D%8A\nhttps://docs.ethhub.io/built-on-ethereum/open-finance/what-is-open-finance/\nhttps://zhuanlan.zhihu.com/p/361370235\nhttp://iqartis.cn/artwork/artwork_oil001.html\nhttp://iqartis.cn/artwork/artwork_oil351.html\nhttps://crowdin.com/translate/ethereum-org/2810/en-zhcn?filter=basic\u0026amp;value=2\nhttps://ethereum.org/zh/developers/docs/consensus-mechanisms/pow/\nhttps://academy.binance.com/zh/articles/proof-of-work-explained\nhttps://ethereum.org/zh/developers/docs/consensus-mechanisms/pos/\nhttps://ethos.dev/beacon-chain/\nhttps://www.zhihu.com/question/401620531\nhttps://ethereum.org/zh/eth2/beacon-chain/\nhttps://ethereum.org/zh/eth2/shard-chains/#what-is-sharding\nhttp://c.biancheng.net/view/1935.html\nhttps://ethereum.org/zh/developers/docs/accounts/\nhttps://eth.tokenview.com/cn/learn/eth-address\nhttps://academy.binance.com/zh/start-here#blockchain\nhttps://www.youtube.com/watch?v=ojxfbN78WFQ\nhttps://gachain.readthedocs.io/zh/latest/concepts/consensus.html\nhttps://academy.binance.com/en/articles/what-is-a-blockchain-consensus-algorithm\nhttps://academy.binance.com/en/articles/byzantine-fault-tolerance-explained\nhttps://luz-ethhomestead.readthedocs.io/zh_CN/master/contracts-and-transactions/account-types-gas-and-transactions.html\nhttps://www.zhihu.com/question/413930344\n","permalink":"https://vcvvvc.github.io/post/eth/","tags":["Stock","Blockchain"],"title":"了解以太坊_Ethereum"},{"categories":null,"contents":"2021留下的坑 今天看到这篇预测想起来了， 来回填一下。\nhttps://cn.investing.com/news/stock-market-news/article-2072927\n云计算 2006年3月，亚马逊推出弹性计算云服务。\n云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。 云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。 因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒钟）完成对数以万计的数据的处理，从而达到强大的网络服务。\n现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。\n混合云 混合云是云计算的一种类型，它将本地基础结构（或私有云）与公有云结合在一起。使用混合云，可以在两种环境之间移动数据和应用。\n云服务 软件即服务（SaaS）：消费者使用应用程序，但并不掌控操作系统、硬件或运作的网络基础架构。是一种服务观念的基础，软件服务供应商，以租赁的概念提供客户服务，而非购买，比较常见的模式是提供一组账号密码。例如：Adobe Creative Cloud，Microsoft CRM与Salesforce.com。\n平台即服务（PaaS）：消费者使用主机操作应用程序。消费者掌控运作应用程序的环境（也拥有主机部分掌控权），但并不掌控操作系统、硬件或运作的网络基础架构。平台通常是应用程序基础架构。例如：Google App Engine。\n基础设施即服务（IaaS）：消费者使用“基础计算资源”，如处理能力、存储空间、网络组件或中间件。消费者能掌控操作系统、存储空间、已部署的应用程序及网络组件（如防火墙、负载平衡器等），但并不掌控云基础架构。例如：Amazon AWS、Rackspace。\n提起SaaS，PaaS避不开Salesforce(赛富时)。\n赛富时公司于1999年2月在特拉华州注册成立。公司是全球领先的客户关系管理（CRM）技术，将公司和客户联系在一起。公司成立于1999年，通过现有和新兴技术（包括云、移动、社交、区块链、语音和人工智能（“AI”）等），公司使各种规模和行业的公司能够以新的方式与客户联系，从而实现业务转型。\n贝尼奥夫长期推广SaaS（Software As A Service，软件即服务）的观念，后来更开创新的里程碑，提出PaaS（Platform As A Service，平台即服务），并和Parker Harris, Dave Moellenhoff, Frank Dominguez等人创立Salesforce.com公司来提供PaaS服务，他将Salesforce.com的市场定位为“软件终结者”。\n云游戏 斗鱼云游戏、虎牙云游戏、腾讯START都体验了。 网速足够与真机无异。\n云安全 安全服务边缘 (SSE)\n云数据 边缘计算 单点登录 okta, workos\n术语缩写: IaaS (Infrastructure as a Service：基础设施即服务） PaaS (Platform as a Service：平台即服务） SaaS (Software as a Service：软件即服务) BaaS（Backend as a Service：后台即服务） DaaS（Date as a Server：数据即服务） CaaS (Communications as a Service：基础设施即服务） MaaS（M2M（Machine to Machine) As A Service：物联网服务） TaaS （everyThing as a Service：泛在服务) Reference: https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97\nhttps://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353\nhttps://www.intel.cn/content/www/cn/zh/cloud-computing/as-a-service.html\nhttps://www.zhihu.com/question/20387284\nhttps://www.alibabacloud.com/zh/knowledge/what-is-hybrid-cloud\nhttps://azure.microsoft.com/zh-cn/overview/what-are-private-public-hybrid-clouds/#overview\n","permalink":"https://vcvvvc.github.io/post/cloud/","tags":["Stock","Cloud","Blockchain"],"title":"云服务"},{"categories":null,"contents":"未填的坑3\n基本分析 财务报表 企业护城河 影响因素 企业估值 市盈率 投资策略 价值投资 成长投资 事件驱动投资 技术分析 限时限额加码止盈投资法 基本面分析 https://zh.wikipedia.org/wiki/Category:%E5%9F%BA%E6%9C%AC%E9%9D%A2%E5%88%86%E6%9E%90\n基本面分析是一种证券或股票估价的方法，利用财务分析和经济学上的研究来评估企业价值或预测证券（如股票或债券等）价值的走势。这些被分析的基本资料可以包含一家公司的财务报表和非财务上的信息，如商品需求增长性的预测、企业比较、新制度的影响分析或人口的改变。它通常和所谓的技术分析相对，技术分析在研究证券价值的趋势时，并不使用到市场本身以外的因素来做预测。\n投资者使用基本分析来检验一家公司的财务状况、其内部运作和其产业市场，用以来了解这家公司的稳定性和增长潜力。被检验的项目可能包括有发放股息、公司管理资金方法、公司的负债值和公司收支增长。一个利用基本分析的人会看基本分析的结果来决定要操作多头或空头。\n基本面分析的目标可能有：\n对公司股票进行估值，并预测未来价格趋势。 预测公司未来表现。 评价公司管理体系，为内部商业决策做支持。 计算违约风险。 企业估值 资产估值: 维基百科\nReference:\nhttp://abcexchange.io/terms/b/business-valuation.asp\n聊聊“市盈率”那点事\n东财-股民学校\nMBA智库百科\n投资策略\n","permalink":"https://vcvvvc.github.io/post/business-valuation/","tags":["Stock","Note"],"title":"企业估值"},{"categories":null,"contents":"未填的坑2\n市盈率 ＝ ∑(收盘价×发行数量)/∑(每股收益×发行数量) ","permalink":"https://vcvvvc.github.io/post/per/","tags":["Stock","Note"],"title":"市盈率"},{"categories":null,"contents":"安装mysql8.0 apt-get update apt-get install mysql-server 设置远程访问 #远程 vim /etc/mysql/mysql.conf.d/mysqld.cnf bind-address改为0.0.0.0 #重启 /etc/init.d/mysql restart #设置权限与密码 use mysql; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;密码\u0026#39;; #使用mysql_native_password修改加密规则 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39; PASSWORD EXPIRE NEVER; #更新一下用户的密码 UPDATE user SET host = \u0026#39;%\u0026#39; WHERE user = \u0026#39;root\u0026#39;; #允许远程访问 #刷新cache中配置 刷新权限 flush privileges; quit; 初始化 #初始化 mysql_secure_installation 1. NO 2. 输入密码 3. 其余全部默认 # 检查 systemctl status mysql.service 状态 #开启 service mysql start # 关闭 service mysql stop # 重启 service mysql restart # 状态 systemctl status mysql.service 其他 缺少mysql.h头文件\napt-get install libmysqlclient-dev 修改root密码8.0\nuse mysql; update user set authentication_string=\u0026#39;\u0026#39; where user=\u0026#39;root\u0026#39;;--将字段置为空 ALTER user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;root\u0026#39;;--修改密码为root Re:\nhttps://blog.csdn.net/u010520724/article/details/107444032\nhttps://blog.csdn.net/weixin_38924500/article/details/106261971\nhttps://blog.csdn.net/wolf131721/article/details/93004013\nhttps://blog.csdn.net/qq_40039731/article/details/124675476\n","permalink":"https://vcvvvc.github.io/post/ubuntu_install_mysql/","tags":["Mysql","Ubuntu"],"title":"Ubuntu20_install_mysql"},{"categories":null,"contents":"时间一长，模版跟继承还多容易忘，这样比看代码更效率些。\ntemplate\u0026lt;typename T\u0026gt; TC_LockT\u0026lt;T\u0026gt;::TC_LockT(const T \u0026amp;mutex) { std::cout \u0026lt;\u0026lt; \u0026#34;1class name = \u0026#34; \u0026lt;\u0026lt; typeid(mutex).name() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;2class name = \u0026#34; \u0026lt;\u0026lt; typeid(*this).name() \u0026lt;\u0026lt; std::endl; } ","permalink":"https://vcvvvc.github.io/post/typeid_get_class_name/","tags":["CPP"],"title":"通过typeid()获取类名"},{"categories":null,"contents":"2021-12-08: 氦气短缺的背后\n百科 百度百科：https://baike.baidu.com/item/氦气/8572782\n氦气，是一种稀有气体，英文名为Helium，元素符号为He，原子序数2。 [1] 为无色无味的惰性气体，化学性质不活泼，一般状态下很难和其它物质发生反应。 德国林德 氦寡头垄断企业\n百度百科：https://baike.baidu.com/item/林德集团/2174084\n林德（Linde）是全球领先的工业气体和工程公司之一，是工业气体、工艺与特种气体的全球领先供应商。2020年销售额为270亿美元（240亿欧元）。其所触及的终端市场涵盖众多行业，包括化工与精炼、食品与饮料、电子、医疗健康、制造业以及初级金属等。而林德所生产的工业气体则应用于各种领域——从医院用氧到用于电子行业的高纯及特种气体，再到用于清洁能源的氢气等。 简单分析 1、氦气作为稀缺战略资源，可广泛用于各行各业，以下行业氦气用量还在持续增长。\n航空航天\n汽车及运输设备\n电子\n医疗保健\n焊接及金属加工\n2、天然气分离法是目前唯一工业化获取氦气途径, 且成本高，不易存储。\n3、中国氦气主要依赖进口, 并且价格在持续的增长\n4、 当前环境氦气资源紧张，可能探索早已展开，不过进展不大。\n5、中国开展氦气相关资源探索、储备。\n又近一步！我国启动首座大型氦气厂(2020年07月28日) Re: http://www.cigia.org.cn/?m=home\u0026amp;c=View\u0026amp;a=index\u0026amp;aid=4227\nhttps://xueqiu.com/4065438410/176599996\nhttps://max.book118.com/html/2021/0602/8107126070003105.shtm\nhttps://bg.qianzhan.com/report/detail/300/200327-592d351b.html\n","permalink":"https://vcvvvc.github.io/post/%E6%B0%A6%E6%B0%94%E6%A6%82%E5%BF%B5/","tags":["Note","Stock"],"title":"氦气概念"},{"categories":null,"contents":"20.10有点下问题，得简单配置下\n添加到bashrc 或zshrc cd ~ mkdir vscode alias code=\u0026#39;code --user-data-dir $HOME/vscode\u0026#39; root运行 vim /usr/bin/code # 跟谷歌浏览器一样 添加 --no-sandbox ","permalink":"https://vcvvvc.github.io/post/ubuntu2010_install_vscode/","tags":["Ubuntu","Linux"],"title":"Ubuntu20.10 install vscode"},{"categories":null,"contents":"编译安装 make时间比较长。\n#直接存sh里 wget https://mirrors.ustc.edu.cn/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.gz tar -zxvf gcc-11.2.0.tar.gz cd gcc-11.2.0 ./contrib/download_prerequisites mkdir build cd build ../configure configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-11.2 --enable-checking=release --enable-languages=c,c++ --disable-multilib --program-suffix=-11.2 make -j4 make install 设置默认gcc ln -s /usr/local/gcc-11.2/bin/g++-11.2 /usr/bin/g++-11.2 ln -s /usr/local/gcc-11.2/bin/gcc-11.2 /usr/bin/gcc-11.2 update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11.2 100 update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11.2 100 #选择版本 就一个选项的不会提供选择 update-alternatives --config gcc update-alternatives --config g++ gcc -v g++ -v Re: https://blog.csdn.net/wbvalid/article/details/119945557\nhttps://blog.csdn.net/EternallyAccompany/article/details/108865331\n","permalink":"https://vcvvvc.github.io/post/ubuntu20_install_gcc11/","tags":["Linux","GCC"],"title":"Ubuntu20.4 install gcc11.2.0"},{"categories":null,"contents":"2021-12-01： 写在市场Wi-Fi6概念未爆发前。\n以下非科普，只做了一些整理\n发展历程 WI-FI 6 维基百科：https://zh.wikipedia.org/wiki/IEEE_802.11ax\n百度百科：https://baike.baidu.com/item/Wi-Fi6\n**Wi-Fi 6（原称：IEEE 802.11.ax）即第六代无线网络技术，是Wi-Fi标准的名称。是Wi-Fi联盟创建于IEEE 802.11标准的无线局域网技术。Wi-Fi 6将允许与多达8个设备通信，最高速率可达9.6Gbps。**o\n主要先进功能:\n速度更快、延时更低、容量更大、更安全、更省电\n向下兼容11a/b/g/n/ac\n正交频分多址（OFDMA）：在要求严格的环境中，同时面向上行链路和下行链路有效共享信道，以提高网络效率并降低延迟。\n多用户多输入多输出（MU-MIMO）：允许一次传送更多下行链路数据，使接入点能够同时将数据传送到更多的设备。\n160MHz信道：增大带宽，从而能够以低延迟提供更高性能。\n1024正交幅度调制模式（1024-QAM）：通过在同样数量的频谱中编码更多数据，提高Wi-Fi设备的吞吐量。\n目标唤醒时间（TWT）：显著延长Wi-Fi设备的电池寿命，例如物联网（IoT）设备。\n发送波束成形：在给定范围内支持更高的数据速率，从而提供更大的网络容量。\n4倍OFDM符号时间（symbol duration）\n自适应的空闲信道评估（Adaptive CCA）\n安全标准升级为WPA3\nWI-FI 6E Wi-Fi 6 Extension\n6GHz频段是一个全球统一的连续频谱块，范围从5925MHz扩展到7125MHz，共计1200MHz频谱，意味着额外提供了提供7个160MHz信道，或14个80MHz信道，或29个40MHz信道或59个20MHz信道。\n新增6GHz频段\n容量提升\n速率新突破\n时延更低\nRe: https://www.zhihu.com/question/370062627/answer/1983878262\nhttps://www.zhihu.com/question/370062627/answer/1983827527\n视频: https://www.zhihu.com/question/370062627/answer/1286497626\nhttps://info.support.huawei.com/info-finder/encyclopedia/zh/WiFi+6.html\nhttps://info.support.huawei.com/info-finder/encyclopedia/zh/WiFi+6E.html\nhttps://zhuanlan.zhihu.com/p/270389108\n","permalink":"https://vcvvvc.github.io/post/wifi6_6e/","tags":["Stock","Note"],"title":"Wifi6与Wifi6e"},{"categories":null,"contents":"国债 百度百科-国债：https://baike.baidu.com/item/国债/801020\n国债（national debt; government loan），又称国家公债，是国家以其信用为基础，按照债的一般原则，通过向社会筹集资金所形成的债权债务关系。国债是由国家发行的债券，是中央政府为筹集财政资金而发行的一种政府债券，是中央政府向投资者出具的、承诺在一定时期支付利息和到期偿还本金的债权债务凭证，由于国债的发行主体是国家，所以它具有最高的信用，被公认为是最安全的投资工具。\n简单说就是,政府借老百姓钱, 写张欠条,欠债要还钱，国债一到期, 政府就得连本带息还给老百姓。 利率 百度百科-利率：https://baike.baidu.com/item/利率\n利率是指一定时期内利息额与借贷资金额（本金）的比率。利率是决定企业资金成本高低的主要因素，同时也是企业筹资、投资的决定性因素，对金融环境的研究必须注意利率现状及其变动趋势。\n利率是指借款、存入或借入金额（称为本金总额）中每个期间到期的利息金额与票面价值的比率。借出或借入金额的总利息取决于本金总额、利率、复利频率、借出、存入或借入的时间长度。利率是借款人需向其所借金钱所支付的代价，亦是放款人延迟其消费，借给借款人所获得的回报。利率通常以一年期利息与本金的百分比计算。\n央行基准利率 百度百科-央行基准利率: https://baike.baidu.com/item/央行基准利率\n基准利率是人民银行公布的商业银行存款、贷款、贴现等业务的指导性利率，各金融机构的存款利率可以在基准利率基础上下浮10%，贷款利率可以在基准利率基础上下浮20%。\n基准利率是金融市场上具有普遍参照作用的利率，其他利率水平或金融资产价格均可根据这一基准利率水平来确定。基准利率是利率市场化的重要前提之一，在利率市场化条件下，融资者衡量融资成本，投资者计算投资收益，客观上都要求有一个普遍公认的利率水平作参考。所以，基准利率是利率市场化机制形成的核心。\n加息 百度百科-加息：https://baike.baidu.com/item/加息\n加息是一个国家或地区的中央银行提高利息的行为，从而使商业银行对中央银行的借贷成本提高，进而迫使市场的利息也进行增加。加息的目的包括减少货币供应、压抑消费、压抑通货膨胀、鼓励存款、减缓市场投机等等。加息也可作为提升本国或本地区货币对其它货币的币值（汇率）的间接手段。\n国债是追逐低风险投资者的首选，国债投资除了吃利息之外，收益还取决于国债价格浮动。国债价格受全球交易市场决定，其价格和收益率成反比（比如10年期100元面额的国债的固定收益是2元每年，你的年化收益率大概1.84%，而如果国债价格上涨至110元，你的年化收益大概1.69%）。\n国债跟利率是相反走势，利率下降，国债价格上涨，利率上升，国债价格下跌。\n例如国债票面利率是 5%，而银行利率变成 10%，如果保持原票面利率，计算国债应该的价格，假设为X X * （1 + 10%） = 100 * （1 + 5%） 意思是说虽然银行利率变化了，但你还是按国债票面利率获得最终收益，最后还是拿到 105。 计算 X 约等于 95.45，这就是国债的理论价格。 相反，当银行利率下降时，为了保持固定的票面利率，国债价格会上升，还是保证你最后拿到 105。 看了三个文章简单理解\n由美国十年国债的曲线图可以看出 国债与股市成反比，国债大幅度下跌，股价上升。\n国债上涨，代表未来预期变好，资金撤离，国债利率大于股市股息更没必要投资股市了, 同时预期变好可能伴随着之后政策的收紧。\nRe: https://www.zhihu.com/question/438523362/answer/1668529153\nhttps://zhuanlan.zhihu.com/p/21471980\nhttps://zhuanlan.zhihu.com/p/353299450\n","permalink":"https://vcvvvc.github.io/post/%E5%A4%AE%E8%A1%8C%E5%88%A9%E7%8E%87_%E5%9B%BD%E5%80%BA%E5%85%B3%E7%B3%BB/","tags":["Stock"],"title":"利率、国债、股市"},{"categories":null,"contents":"readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）。\n#include \u0026lt;sys/uio.h\u0026gt; ssize_t readv(int filedes, const struct iovec *iov, int iovcnt); #散布读 ssize_t writev(int filedes, const struct iovec *iov, int iovcnt); #聚集写 其中的iovec\n#include \u0026lt;sys/uio.h\u0026gt; struct iovec { ptr_t iov_base; /* Starting address */ size_t iov_len; /* Length in bytes */ }; 代码：https://github.com/vcvvvc/CPP_Test/tree/master/test/writev\nRe: https://www.cnblogs.com/nufangrensheng/p/3559304.html\nhttps://www.cnblogs.com/youngerchina/p/5624567.html\n","permalink":"https://vcvvvc.github.io/post/readv_writev/","tags":["Linux","CPP"],"title":"readv_writev"},{"categories":null,"contents":"主机字节序（大端） 和 网络字节序（小端)\n大端: 0x12 | 0x32 | 0x56\n小端: 0x56 | 0x34 | 0x12\nHost to Network long/short\nNetwork to Host long/short\nuint32_t htonl(uint32_t hostlong); //将主机的无符号长整型数转换成网络字节序 uint16_t htons(uint16_t hostshort); //将主机的无符号短整形数转换成网络字节序 uint32_t ntohl(uint32_t netlong); //将一个无符号长整型数从网络字节序转换为主机字节序 uint16_t ntohs(uint16_t netshort); //将一个无符号短整形数从网络字节序转换为主机字节序 https://github.com/vcvvvc/CPP_Test/tree/master/test/hostto\n#把ip地址转化为用于网络传输的二进制数值(32位) in_addr_t inet_addr(const char *cp); #少用了 int inet_aton(const char * cp, struct in_addr *inp); #将网络传输的二进制数值转化为成点分十进制的ip地址 char* inet_ntoa(struct in_addr in); #这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。 地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。 int inet_pton(int family, const char *strptr, void *addrptr); const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len); Re: https://www.cnblogs.com/little-white/p/3236548.html\n下面这个大端小端出错，但是代码正确\nhttps://blog.csdn.net/msdnwolaile/article/details/50727653\nhttps://blog.csdn.net/zyy617532750/article/details/58595700\n","permalink":"https://vcvvvc.github.io/post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/","tags":["Linux","CPP","Socket","Server"],"title":"ip转换函数"},{"categories":null,"contents":"可转债之后第二篇,何为种子轮、天使轮、PreA轮、A轮、B轮、C轮\n种子轮 https://baike.baidu.com/item/种子轮/22415260 种子轮即种子融资，是指最早阶段进行的融资方式。虽然大多数初创企业都依靠创始人自己的或其直系亲属和朋友的资金，一些企业还是会寻求第三方的“种子融资”，这是一种最早期阶段进行的融资方式。 其特点是创业者已经有了创业的方向、思路，但是还没有成形的核心团队、没有产品原型。\n此时主要是依靠自身或者经典F4（Founders/其他创始人、Family/家人、Friends/朋友、Fools/傻子）\n天使轮 https://baike.baidu.com/item/天使轮/22415261 天使轮，即天使投资（Angel Investment），是指个人出资协助具有专门技术或独特概念而缺少自有资金的创业家进行创业，并承担创业中的高风险和享受创业成功后的高收益，或者说是自由投资者或非正式风险投资机构对原创项目构思或小型初创企业进行的一次性的前期投资。天使投资是风险投资的一种特殊形式。 特点是核心创业团队已经成形，有了产品原型或者基本商业模式，但是产品还没有研发完成、商业模式还没有验证。\n天使轮的投资人多是专业的早期投资机构和天使投资人，投资金额通常在几百万元，但是对于少部分领域和团队比较特殊的项目，天使轮的融资金额就可能突破千万元。\nPre-A轮 A轮前的加油续航\nPreA轮是一个夹层轮，融资人可以根据自身项目的成熟度，再决定是否需要融资，倘诺项目前期整体数据已经具有一定规模，只是还未占据市场前列，那么就可以进行PreA轮融资。 特点是产品/商业尚未初具规模但是钱却没了\nPre-A轮的投资人通常是现有的天使轮投资人和部分新引进的投资人。Pre-A轮的估值通常会比天使轮略高，但又不会达到A轮可以给出的有实质性不同的估值。\n以及后面还可能有A+(Pre-B)\nA轮 https://wiki.mbalib.com/wiki/A轮融资 A轮融资指创业企业成立开始运营之后的第一次对外融资。 特点是较完善的产品已经上线，公司业务顺利运营，拥有一定数量的核心用户，有一定的数据支撑。证明这是一个有未来的、切实可行的项目。\nA轮开始，投资人通常会是专业的创业投资机构，天使投资人会变得很少见\nA轮融资的成功将会给企业带来一个翻天覆地的变化, 同时也对企业内外部起若重要作用。\nB轮 B轮融资阶段 是A轮融资阶段的延续， 团队、产品、商业模式、资金、运营 等方面都是在A轮融资基础上做进一步的推进和发展以谋求企业的终极目标。. 在B轮阶段，企业的商业模式及盈利模式需要进一步完善，开始盈利的企业需要持续发力，获取更大的盈利；处于亏损的企业需要寻找新的盈利点。. 在B轮阶段多数企业开始拓展产品线，拓展新的业务领域，以获取更大的利益。 产品/商业模式得到了充足的验证，需要进一步扩大规模, 抢占市场。\n此时投资人更看重商业模式的应用场景及覆盖人群。\nC轮 恭喜，公司成熟，你也成为了行业翘楚。准备完成敲钟的理想。 特点产品/商业模式成熟，盈利强劲且稳定增长，业内具有一定影响力。\nC轮以后的投资者更多的是大的投资机构、互联网巨头、上市公司、战略投资人等，他们对于项目的上市预期更明确。因此，对赌、回购这些在A轮、B轮项目中还可有可无的条款，在C轮以后的投资协议中会成为标配，并且往往非常严格。\n以及之后的D, E, F，Pre-IPO都是为了上市做准备\nRe: https://zhuanlan.zhihu.com/p/40306174\nhttps://zhuanlan.zhihu.com/p/54320363\nhttps://zhuanlan.zhihu.com/p/352456135\n","permalink":"https://vcvvvc.github.io/post/%E5%8C%BA%E5%88%86%E8%9E%8D%E8%B5%84%E8%BD%AE/","tags":["Stock"],"title":"股权投资之区分融资轮"},{"categories":null,"contents":"Re: 收集 总结的真不错\nhttps://www.cnblogs.com/findumars/p/5929831.html\n","permalink":"https://vcvvvc.github.io/post/cpp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","tags":["CPP"],"title":"Cpp内存管理"},{"categories":null,"contents":"元宇宙 | Metaverse We are at the beginning of the next chapter for the internet.\n趋势明显，顺势而为。\nAugmented reality 个人练手小项目:\nwave(波)基于arkit制作: https://www.bilibili.com/video/BV1n44y147pY\nunity+easyar简单用例演示: https://www.bilibili.com/video/BV1wu411f7yH\nunity+easyar识别指定图片或物品播放音乐: https://www.bilibili.com/video/BV1X3411C7EW\n练手项目arkit制作的小地球: https://www.bilibili.com/video/BV1DR4y1J7xM\n练手项目arkit制作的小地球2: https://www.bilibili.com/video/BV1xq4y1G76k\n讯息 2021-10-29：Facebook将公司名称更改为“META”，公司股票代码将从12月1日起变更为“MVRS”。 ","permalink":"https://vcvvvc.github.io/post/metaverse/","tags":["Metaverse"],"title":"Metaverse"},{"categories":null,"contents":"随笔 原文链接: https://github.com/shengcaishizhan/kkndme_tianya\n本文章只是对此贴进行一份备份\n导航（持续更新中\u0026hellip;） 天涯神贴「2010年的房地产调控，我们收获了什么？写在房价暴涨前」脱水版，内容时间顺序和原贴一致，原贴中的优质非楼主写的内容，添加了引用格式便于区分。\n希望调控可以降房价，希望终有一天房价下跌是人们的一厢情愿 1、人人都有居住权。房子是用来住的，不是用来炒的。 2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。 3、房价上涨造成物价上涨，人民生活变得困难 房地产调控的真正目的：防范金融风险 \u0026amp; 通过垄断实现gj利益最大化 官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真 税收从来都是向下游转嫁的 \u0026amp; 房产税迟迟不出台的真正原因 房地产的现状 房价持续上涨的本质是稀缺性让好房子成为资金最好的去处 关于垄断 1、垄断的好处是没有风险 2、垄断可以解决社会稳定 3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难 为什么政府没有那么在意民生问题？ 房产税的制定原则 维稳的本质是人民能吃饱饭 公租房是为体制内服务的 房产税一定会转嫁给租房人 巨大的税收消耗也决定了GDP必须快速增长 调控的好处是让zf利益最大化\u0026amp;防范金融风险 垄断可以控制价格，维持稳定 体制内的住房问题有国家保驾护航 依靠但又不能完全依靠开发商建公租房 体制内的住房问题不难解决 解决体制外的住房问题：国家垄断，细水长流收租 普通人买得起「优质商品房」就尽早买把 商品房和公租房的区别 提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢） 调控带来的影响 农产品的价格关系到影响稳定的吃饭问题 农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管 资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力 资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢 资金流向规律决定了洼地不会一直是洼地 大城市对近距离的小城市有虹吸效应 决定房价的因素有很多，具体情况具体分析 房价暴涨是相对于钱而言的，不是相对于实际购买力而言的 土地不稀缺，优质土地稀缺 集中发展大城市是导致优质土地稀缺的原因 为人民服务是说给人民听的 历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙 zf限制政策房的利润，那kfs就一定会偷工减料 屁股决定脑袋，人民不知厉害关系选房子，政府选农产品 各个阶层的住房问题都安排的妥妥的 顶层的岁月静好来自于底层的负重前行 底层指的是体制外底薪白领 资金终会流向具有稀缺性的资产 土地的稀缺决定了大多数人永远买不起想买的房子 不同阶层的人对收入高低有不同的理解 一二线买房只会越来越难，最终租房会成为主流 人需要一个安身之所，能买早买比晚买好 股市 如果房价不涨，那其他产品会怎么涨 zf如何利用公租房控制租房市场 城中村不会长期存在 三四线城市的未来 房租价格涨不上去，本质是买房还看起来有希望 稀缺房的价格永远涨 粮食和房子的不同是，房子无法和土地剥离 购买房价基数低的省会城市，怎么都不会亏的 房地产是资本市场还是实体经济？ 什么是傻空 什么是真买不起房 具体情况具体分析，如果看不懂，一定是没有抓住问题本质 桂林 vs 南宁 公租房的量级不会冲击到商品房的市场 贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体 重庆：高层和别墅怎么选？ 货币贬值 为什么美国人工高于中国，大多数商品的物价却低于中国 穷人赶紧买房 武汉：城市发展空间的大小，往往和房价的升值空间成正比 权利让革族成为苗族的一支 房价是否会跌，如果会，会怎么跌 通货膨胀是减缓灭亡最好的良药 货币供应不足是明朝的真正原因 经济问题是导致清朝灭亡 房产投资的几点建议 人民币对外升值，对内贬值 南宁买房建议 经济适用房都是内部分配的 普通人怎么办：尽早买房，努力挣钱抵御通胀 房价会出现很多上下波动 买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到） 收入分配改革跟体制外的人没关系 体制外的人要早早考虑养老问题 永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你 当个农民也要懂政策，要顺政策而为 存钱不如存资产，钱会贬值，资产会升值 房子越早买越好，zf想钱想疯了 利益才是zf行为的指挥棒 建议一定是建立在严肃考察的基础上 石家庄 投资最重要的是稀缺性，买房首选公务员小区 远离垃圾人 高房价或许有天会崩盘，但你等不到那一天 房子不仅要早买，而且有能力的话不要怕压力，争取一步到位 金融杠杆是炒房赚钱的放大器 要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松 性格决定命运 2012年不取消调控，还有房价维稳顺利换届考虑 洼地最终都会被填平，多数城市是早买胜于晚买 西部 短期波动属于正常现象，需要关注的是长期趋势 领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运 对于具备投资属性的商品，供求关系是指货币与商品之间的关系 早买的风险小于晚买 小开发商的房子能不能买？ 大兴土木搞建设的城市，房价都底不了 北京老式砖混板楼的最终命运？ 把房买在政府边，差不了 天子脚下：二手老房买得好，拆迁补偿少不了 3万入手北京四环，你也是幸运的 君为贵，商人、技工次之，农民为轻，打工人为底 10年的调控和08年调控的区别、带来的影响、机会 历史总是惊人的相似 关于房贷 买卖商品房会逐渐变成富人的游戏 政府还是更在意农民问题 治国需要用贪官、反贪官 二线城市典型代表 关于商铺和住宅投资 关于房产调控 关于房产税 老公房的拆迁问题 投资新房还是老公房 高端盘有房价带动作用 买房和没买房的差距 房产交易历史 契税的历史 廉租房的历史 历史上买房最好的朝代 未来房地产市场的发展 房产到期 买学区房问题 历史的结局 人口普查 昆山房价分析与买房 为什么现在租售比这么低 \u0026amp; 同小区买一套大还是两套小 买房难之回不去的乡 \u0026amp; 拉美人过得比你想象的好 租房的苦 北京西三旗 买房争取一步到位 收入稳定的家庭如何买房 北京回龙观 贷款还是全款 00后的买房需求从何而来 意大利的住房模式 中国的学术 北京远洋山水 精英的资产 北京三环塔楼 普通人买房的未来 北京房价超香港 中国的新闻不可信，精英的有钱是你想象不到的 40年的商住房没有70年的住宅有投资价值 限贷对精英没用 外汇管制决定了大部分有钱人只能在国内投资 外国国籍在中国生活是更好的选择 分期付款买房，如果房价上涨，很容易毁约 \u0026amp; 自住要选大品牌开发商 通货膨胀和房价的关系 南京买房分析 \u0026amp; 买房要做好调查分析工作 北京华清嘉园 中国的朝代更替 中国可以无限印钞吗 读史读的不是故事，还是找历史规律，以古鉴今 毛太阳的往事 北京大兴 贵阳 富人越富、穷人越穷 通货膨胀的形成原因 深圳 \u0026amp; 昆明仇书记 \u0026amp; 通货膨胀体制内高枕无忧、体制外自求多福 长春 佛山 首付提高的逻辑 四线城市 苏州工业园 住房公积金利率 济南 \u0026amp; 大规律拆迁的城市房价不会下降 公务员小区牛逼 房屋朝向只要不是纯北西就行 \u0026amp; 买房首选市中心、公园地产 政府搬迁 俄罗斯 珠海 \u0026amp; 唯一自住房不只是投资 \u0026amp; 调控是最佳的选房时机 经济崩溃，最后接盘的是老百姓 命运之矛 除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘 kkndme聊北宋、唐朝 宋代房奴 ZG民主 王安石的青苗法之国家出政策的动机 什么是社会公平 还是有很多有钱人 双轨制之体制内的福利 开发商思维 农民政权的缺点 郑州有前景 公园地产是稀缺资源 张献忠屠川 洪秀全、黄巢、李自成 朱元璋 曹参治国 晁错 民营小企业的老板和打工者 郭解 2010年的中国房地产 房奴算不上不幸，相当当不了才算 精英人群的平均收入决定房价 内地不是香港、海南 历史是一面镜子 买房一次性到位比较好 外汇管制 一线和二线 吕后篡权 小产权房 商铺和住宅 体制内外 2010年的上海 买房：物业与房贷 收紧住房贷款 买房：物业与房贷 奸臣蔡京 体制内的28原则 贾谊 kkndme 推荐的历史书 年轻人要早买房 不要低估通货膨胀 二三线城市与重庆 城区和郊区 守着金碗要饭吃 人制的社会，人就是制度 准公务员的好处 小城市房价会因为人民币贬值涨价，但依然难变现 一线杭州 二三线城市的发展靠拆迁 转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫” 拆迁补偿 城市底层 垄断企业 农村自来水 袁盎 二三线城市，选新城还是老城 在中国，普通人手上闲钱不多的人被剥削 三分天注定七分靠打拼 人的前程有的时候不掌握在自己手里 河南郑州与洛阳 杭州 西安与重庆 谢国中「空置率」 打工不如有一技之长的小老板 一线、二线的生活 讲故事含沙射影ZG之房子不属于市场经济 什么是好的政策 李商隐「渣男」祖师爷 西五环内的别墅，是相当稀缺的资源 正文 希望调控可以降房价，希望终有一天房价下跌是人们的一厢情愿 2010年的房地产调控，让很多人看到了希望：让房价降得再猛烈些吧。还有人更是幸灾乐祸似的呼喊：让房地产赶紧崩盘吧。让没房子的好好看看有房子的笑话，是人生的一大快事。\n但是我们是不是要仔细想想，为什么调控？调控期望得到什么样的效果？\n是如千千万万想买房子的人期望的那样，让人人买的起房吗？ 是如千千万万的流氓无产者期望的那样，让房地产崩盘，开发商上吊，dfzf不再靠卖地实现gdp吗？ 2010年房价下跌已经变成了人民最急切的期望，已经高过了解决超贫困家庭的温饱问题，已经超过了子女教育，医疗和养老。并且为房地产必须下降提出了若干义正言辞理由，总结下来无外乎三条：\n人人都有居住权。房子是用来住的，不是用来炒的。 房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。 房价上涨造成物价上涨，人民生活变得困难。 的确，当经济过热，房价过高，会对经济运行和社会安定带来较高的风险。这也是国家所担忧的。防范金融风险，一切维稳才是zy考虑的重中之中。\n而民间所总结的三条，应该和调控的原因和目的基本不沾边。让我们一条一条的分析一下：\n1、人人都有居住权。房子是用来住的，不是用来炒的 其实这是一个伪命题。房子包括房屋及房屋所属的土地两个部分。房屋本身只有居住价值；而土地所具备稀缺性，决定了土地的投资价值。房地产贵的不是房屋，而是房屋下面那块地皮。所以商品房具备了投资与自住双重属性。\n任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。\nliougehooa：\n\u0026ldquo;任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。\u0026rdquo; 任志强这句话绝对没说炒房价，房子在他眼里还是住的。 难道你用byt是你老er比较稀缺才买？那也没看见byt暴涨到5W一个。 ”而土地所具备稀缺性？“任志强也说了，拿出全国耕地的1%也够老百姓住了！现在是啥科技了，舍掉1%耕地对农作物有什么影响？\nkkndme：\n华北平原从河北到山东有大片的盐碱地，你都可以用于盖房，而且会非常便宜，也没有人跟你竞价。但是你在那里盖了房子并不能保证你天天按时在北京城区上班。\n2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘 这个问题比较大。房价是不是太贵了？有没有泡沫？\n我们首先从国民的收入结构来分析\n一个遵从“丛林法则”的精英社会决定了国民收入的金字塔结构。\n既然是金字塔，底端的中低收入者占据了金子塔的最大比例，但是大家要知道金字塔的顶端既使只有10%人口，那也将是一个1亿多的绝对庞大的数字，远远超过了绝大多数西方国家的人口总和。\n而北上广深以及三十多个省会，这些个靠掠夺全国或者一省资源，以牺牲大多数人口的利益为代价发展壮大起来的超大型及大型城市，需要容纳全国1亿多的精英人群，是否能得出房地产严重泡沫，空置率过高的结论？\n当低收入者们努力挥洒汗水期望着自己年薪能够超过5万，8万，10万。。。的时候，他们可能做梦也想不出精英阶层手中究竟拥有多少财富。\n精英们会象流氓无产者们一厢情愿认为的那样：因为一个区区房产税而恐慌性抛弃手中的大量房产吗？\nliougehooa：\n”因为一个区区房产税而恐慌性抛弃手中的大量房产吗？“ 现在不说哪个富豪不是靠偷税漏税爆发的，我就举个例子，一套房不收税，二套房也不收税，三套房收300%税，你龟儿子还敢买三套房？\nkkndme：\n你说的事情在历史上已有发生，大明律明令禁止超标准建房，如果违禁，不仅仅是收税的问题，而是打板子下大狱，没收充公的，比房产税可要狠多了。但是终究没能执行下去，原因在于官员太腐败，不符合官员地主阶层的利益，最后名存实亡了。光是梗着脖子叫唤是没有用的，利益驱动着社会的发展，违背统治阶层利益的事情即使出台也难以执行，最后的下场都是不了了之。\n答案显然是否定的。\n可以确认的是，房价不是由统计局的平均收入决定的。而是精英的平均收入决定的。\n为了便于分析，我们剥离掉商品房（注意：只是商品房，而不是房屋）的社会属性，先把它看做商品。是商品就有他的内在规律。\n什么决定商品的价格，价值？对不起，我只能说你上学上傻了。\n是供求关系，只有供求关系。\n我们判断一个核心城市市区内的商品房是具备足够稀缺性的。\n如果你在北京海淀区上班，即使你在山海关拥有1000平方米的住宅也不能替代你住在北京市近郊区以内的愿望。而无论你是租房，分房还是买房，只要你还在海淀区上班，你就必须住在北京市近郊区以内。\n假设你挣得钱不足够多，你需要租一套房子解决你的上班问题，上班距离的远近及居住的质量，取决于你愿意支付的租金。\n假设你的钱够买房子，我相信你更愿意买房，因为你可以拥有房屋的产权和房产增值的收益。而买房子的大小，品质，离你上班的远近，取决于你手中的资金和你对未来收入的预期。\n买房问题很象是中国的上学问题，而且简直是异曲同工。\n假设你家附近有个重点中学，教学质量很好，考大学几率很高，而其他的学校你觉得不理想，你肯定希望无论如何自家小孩也要上这个重点中学。\n上重点中学凭什么？我们简单的剥离掉其他社会因素的影响，可以认为想上重点中学就要凭好成绩，小孩努力考到前多少名，就可以上重点中学。这与努力赚钱买房是一个道理，有钱的出高价就能买到好位置好环境的房子。\n我们再加入社会因素的影响，比如某大人物看到这个中学很抢手，很可以赚一笔，于是就设计了加分项，谁给自己送的钱多，就给谁加分，于是小孩要上重点中学不但要考高分，还要送钱加分。\n同理，当好位置的商品房成为稀缺资源，各类炒房客的出现是必然的。\n如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？\nliougehooa：\n”如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？“ 你拿一个错误的现象，说这个现象是正确的来证明你错误的房价观念是正确的，可笑！\nkkndme：\n事情不能简单用正确还是错误来评价，一件事物发生一定有发生的原因。你说皇帝统治老百姓，想杀谁杀谁是正确还是错误？如果是错的，但是却在中国延续了几千年。\n尽管炒房和公立幼儿园加价成为普遍的社会现象是令人痛心的，但它们不以刚需人群的意志为转移的存在着，且与泡沫无关。\n最被提及与泡沫有关的是以下两点：\n第一，中国的房价甚至高于某些发达国家的房价。\n其实，众所周知的是：不光房价高于某些发达国家，石油，高速，教育，医疗，税收等费用都远远高于某些发达国家。\n而且中国的精英人群尽管所占比例不大，但是绝对数量足够大，而且精英平均收入甚至远远高于某些发达国家的收入水平。\n第二：租售比问题\n这个问题不用过多解释，使租售比更合理的方法不是只有降低房价一种，还有一种更靠谱的：房租大幅度上涨。而且已经在行动中。房租长期保持低价就像1990年以前的和田玉长期保持低价一样不可能。\n3、房价上涨造成物价上涨，人民生活变得困难 这个问题其实也不用多解释，懂经济学的该明白自然会明白，不会轻易被忽悠，不懂的解释半天也不会明白。\n简单的可以这样说，物价上涨是经济过热，钞票印多了的后果。而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。\nliougehooa：\n”而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。“\n房价高涨，你要发的钞票必须要多，不然怎么去买房子？你发的钞票越多，钞票不是你发下来去买房子就死掉了不流通了，它只要流到人的口袋或者银行的口袋，这钱立马回出现流动，能不造成通货膨胀吗？除非这笔钱收到后限制房东使用。 为了支持高房价，国家必须发大量货币，这也是去年房价高涨的原因。\nkkndme：\n请先了解一下中国的货币发行制度，人可以无知，但不可以乱说。让人笑话。\n其实如果房地产交易量下降，不再具有吸金功能，那么农产品等生活必须品以及房屋租金等等就会大幅上涨。这是因为多出来的大量钞票总要有个流向，如果不被房地产吸收，就会被大蒜，绿豆，姜，及全部生活必须品的上涨来吸收\n事实也证明确实如此。2010年房产调控后，物价上涨的势头非常迅猛。\n房地产调控的真正目的：防范金融风险 \u0026amp; 通过垄断实现gj利益最大化 那麽是不是房地产就没有泡沫呢？\n这个问题谁也不知道，因为到现在zf拿不出一份权威的数据来说明房地产到底有无泡沫。\n但是房价高了就有风险，zf从感性上还是有清楚认识的。\n注意，我们前面啰嗦了很多，现在才开始接近这次调控的真实意图。\n防范金融风险？不错，你说的很对，但是没这么简单。\n辨别利益是看透一切事物真相的武器。\n高房价谁是受益者？\n房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售\ndfzf卖地之后，剩余的风险和收益都归银行和开发商\ndfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。\ndfzf只负责卖地，是无风险的买卖。\n只要房价不断上涨，加杠杆的炒房客就会赚到盆满钵满\n这么分析下来，最受益的地方政府、开发商、炒房客。\n独独缺了zy。\n这时你是否猜到zy为什么要调控？如果还猜不到没关系，听我道来。\n纵观古今，上位者最不能容忍的是别人受益，自己被黑锅。\n大kfs，小kfs，大炒房客，小炒房客，dfzf都是收益者，但是风险却由zy来抗。这是一笔很不划算的买卖。\n而房地产混战的局面，造成了国家队央企成员只有凭财大气粗高价拿地的份，钱花的最多，风险却抗的最大。\nzy深深的感觉到要想国家队受益，要想控制风险只有做到两个字：垄断。\n提高资金门槛，让小kfs，小炒房客，有点钱的小老百姓推出这个游戏。房地产很好玩，但不是小人物应该玩的。\n先让市场冷静，彻底整顿，踢出那些个跳梁小丑，然后国家队出马，绝对垄断的市场，才能够统一定价，才能够控制风险，才能够利润最大化。\n既然油价高于美国是合理的，那麽房价高于美国一定也是合理的，关键在于垄断。\n不仅仅是房价的垄断，因为过高的垄断定价将会使交易量下降，国家队也需要资金周转。\n真正厉害的，还是房租的垄断。公租房的推出是房租垄断进程的里程碑。\n至于苦等廉租房的同志，不要抱太大的希望。城市要建设，地铁，广场，政府大楼都要上马，钱从哪里来？不会无缘无故凭空出来。\n想想小学就近上学，但是重点小学真的就近就能上吗？小学名额可以寻租，经适房，廉租房也是一个道理。\ntjOOSAN：\n真扯啊~~~ 油价跟房价去比？？\n这位kkndme ，你就别忽悠了！~~\n汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。\n大哥！房子是必须品。ok？那么既然你也认为政府的钱大多从地产来。\n那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？\n招你的法子说，炒楼才是中国的前途？\nkkndme：\n这位兄弟，您比那些希望钱钱去炒大米的还不靠谱。\n石油影响的不仅仅是开车的人花费多了。疯狂上涨的运输成本会导致民不聊生的。\n假设一斤蔬菜从广西的农民地里收购是0.5元一斤，但是由于油价的像你说的上百倍的涨，运到北京，这斤蔬菜要卖300块一斤。\n社会就瘫痪了\ntjOOSAN：\n那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？\nkkndme：\n实体经济的发展不是简单的钱不去投资房产，就会去投资实体经济，实体经济就发展起来了。估计媒体洗脑洗的比较厉害，你中毒了。\n资本是趋利的。无论是哪个国家，哪个社会，只要存在市场经济，这个道理就一定不会错。\n为什么资金进入房地产及其他资本市场而逃离实体经济？是因为实体经济环境不好，不赚钱。\n一是税赋太高，二是各种需要打点孝敬的部门、管理人员、工作人员太多，比税赋还高，不能承受之重。三是国家队在各个重要领域的垄断，使国企变成了变相税务局的职能，垄断企业的暴利定价，又是压在本应该蓬勃发展的实体经济上的又一座大山。\n现在央企基本是不垄断的行业不做，把产能过剩，充分竞争的产业交给民间资本，并且还要给这些资本压上高昂的负担.\n有可能垄断的行业包括房地产都会收到国家队手里，以后更是将发展成为一个高度垄断的社会。\n资本不是傻子，一定会趋利，所以资本放弃了操心受累不挣钱的实体经济，转而投向房地产。房地产的调控，让资本又进入了黄金、农产品领域参与爆炒，反正就是不进实体经济。因为国家不给实体经济的环境做任何的改善。\n如果实体经济有一个好的环境，有一个好的获利空间，大量的资金就不会撤出实体经济，没有资金潮涌般的投入房地产市场，中国的房地产将会是一个平稳的上涨趋势。\n但是体制决定了资金的去向，不以人的意志为转移。\n高税赋、暗箱成本及垄断不但造成巨大的贫富差距，而且将会导致生活成本的大幅提高，生活负担日益沉重。\n一方面百姓生活负担的加重，导致一些非生活必须品严重产能过剩，将会出现大量亏损倒闭的内需企业。\n另一方面精英阶层快速聚集大量财富，使奢侈品供不应求。古董，字画，玉器，豪车，顶级服装的消费比重也将越来越大。\n但是能够容纳大量资金的只有两个领域：农产品领域（满足老百姓的肚子）和商品房领域（居住权要满足老百姓的需求，产权要满足精英阶层的需求）。\n资金的流向只能疏导不能强堵，zf很明白这个道理。两者危害取其轻，你认为zf会选择哪个领域？\ntjOOSAN：\n真扯啊~~~ 油价跟房价去比？？\n这位kkndme ，你就别忽悠了！~~\n汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。\nvavan2010：\n这种人肯定最后就是蠢死的。你没车，不用汽油，你可知道生活中有多少东西是需要用汽油的？无知才最可悲！\nkkndme：\n我们为确实买不起房的低收入群体，只能感到无奈\n但有些本来能买房却嫌这嫌那而不买房的傻空通知，我们只能说你买不起房，完全是自己的原因，连油价上涨意味着什么都搞不懂，贫穷真的不能怨别人。\n官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真 说到房产泡沫的问题，就不得说说官方的统计数据。\n官方的统计数据从来是可以很雷，但不可以很真。\n我们的统计原则基本就是：村骗乡，乡骗县，一骗骗到国务院。\n不知道有人去市、县、乡、村进行过社会调查没有？\n社会调查是怎么一回事？\n我来告诉你，所有的关于人口、收入、田地、贫困户的数据都是官方统一编写，统一口径，如果胆敢有哪个小民对调查人员乱说，那是吃不了兜着走的。\n你问了数据编来编去的意义在哪里呢？\n意义很大，起码跟向上申请拨款是关系非常密切的。数据不假，钱从哪来？\n统计数据无所谓是否真实并不重要，重要的是它是获取利益的重要手段。\n假设官方想证明房地产不存在泡沫，那么一定拿的出不存在泡沫的统计数据作证。\n反之，也一样。\n好比,CCAV为了证明高空置率的结论，派出记者专门找偏远且刚刚完工的楼盘，进行了一次纯粹为了证明内部已事先得出结论的毫无科学依据的调研。\n而dfzf，为了证明刚需多么强劲，也立刻拿出了选择性失明的统计数据来进行回击。\n无论是左还是右，同样都是不科学，都是现有结论，再有证据。\n我们到底应该信谁\ncdw1：\n商品房本来名字中就有商品二字不准投资岂不是笑话？真正不准投资的那叫公房，这才是保证老百姓有房住的关键，商品房诞生的时候就很明确是改善居民居住条件的，现在政府怪商品房价格过高造成老百姓没房住本来就是颠倒黑白，政府不造保障老百姓居住的公房，而让老百姓去购买改善居住条件的商品房来解决本该政府解决的居住问题，政府不作为才是造成老百姓出现居住问题的罪魁祸首。我不期望人人有房，我只希望每一个在城市里找到工作的人通过努力工作勤俭持家能在生活城市里有希望拥有一套安稳的房子来容身，不管这房子的性质是商品房、经适房、廉租房或者其他什么房子。\nkkndme：\n你说的正是根源所在啊，zf的职责应该向无房者提供的保障房，建成经适房、两限房，被权贵占有牟利，而非要把商品房赋予稳定社会的职能。zf不是不知道问题的根源，而是不愿意放弃巨大的利益。\n税收从来都是向下游转嫁的 \u0026amp; 房产税迟迟不出台的真正原因 闲扯了一下统计数据\n还是回到这次调控中来\n房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售\ndfzf卖地之后，剩余的风险和收益都归银行和开发商\ndfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。\ndfzf只负责卖地，是无风险的买卖。当然还有人企图利用流氓无产者和无知群众的群情激奋来进一步收取房产税来提高dfzf收入。\n税收从来都是向下游转嫁的，zf多收出来的钱一定是通过最下游的房租来体现。\n当然，也有很多明白人士大声疾呼反对房产税。\n自古而今，即使最辉煌的朝代，最被广大群众津津乐道的太平盛世，普通群众也仅仅只是解决了温饱而已，包括贞观、文景、康乾。\n国家的富庶都是以老百姓勒紧裤腰带为代价的。\n所以，zf是不会理会部分明白人反对房产税的呼声的。\n真正对房产税的顾及来自于dfzf对土地出卖前途的担忧，真是鱼与熊掌不可兼得。\n尽管流氓无产者和无知群众的呼声很高，然而房产税征收一旦实际操作起来，就会变的不得人心，征收难度非常之大，实际效果难以预知。也就是说zf没有底。而如果房产税征收效果不佳，dfzf卖地收入再受到巨大影响，那就真正是得不偿失了。\n就会变成赔了夫人又折兵。\n这样的买卖，zf是不会轻易做的\n房地产的现状 房地产的现状是，商品房二级市场是由各种类型的开发商自由竞争的，一手房开发商之间的竞争，二手房投资客之间的的竞争。\n房价持续上涨的本质是稀缺性让好房子成为资金最好的去处 房价为什麽在一个自由竞争的市场上能够持续上涨？因为稀缺性。不是房屋的稀缺性，而是房屋所必须占用的土地的稀缺性。\n有些群情激奋的群众立刻以6500万套房子空置的事情提出质疑，还有ccav的报道，那是要多煽情又多煽情。\n我们无需说6500万套的真实性（明白人都知道非常离谱）和空置我心的科学性。为什么不说，因为这种稀缺性跟空置率就完全没有关系。商品房的稀缺性是相对人民币而言的。人民币印多了，资金没地方去，商品房就涨价了。\n关于垄断 1、垄断的好处是没有风险 垄断的市场是没有风险的，土地是完全垄断的，所以dfzf完全没有风险。\n而商品房是自由竞争的市场，是具备风险属性的，尽管由于大量印钞造成了商品房的飞涨，但随着房价的高涨，风险也在积聚。\ndfzf土地垄断没有风险，完全可以置身事外。\n可是银行呢？属于国家的银行。\n银行正在承担自由竞争市场房价高涨积聚的风险。\n这是zy不允许看到的，dfzf受益，而风险全部甩给zy。\n既然垄断的市场是没有风险的，那还是让房屋和土地一起垄断好了。\n2、垄断可以解决社会稳定 垄断还可以解决一个问题：社会稳定。\n常被媒体和群情激奋群众所提及的一个重要问题就是：房价收入比。\n大量印刷的人民币促成了房价高企（因为商品房实在是具备了大资金需要的所有投资品属性），可是那些个巨额的资金普通老百姓并没有见到。\n路人甲：我们一个月就挣2000多块钱，干一辈子买不起房啊。\n路人乙：我一个月上万都买不起房。\n媒体：一个家庭不吃不喝22年买一套房\n大量的疯狂印刷的人民币在哪里呢？\n在精英手里。\n我们在回顾一下开篇，我们奉行的是精英社会，丛林法则，金字塔式收入结构。\n人民币再多，也不可能流到金字塔的底端。\ndfzf垄断卖地也就让百姓们发发牢骚。\n而炒房客，kfs赚的盆满钵满就让生活在中下层的老百姓眼红和不能容忍。\n不患寡而患不均啊。\n垄断，国家队的垄断，可以解决眼红问题，也就是社会稳定问题。\n3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难 还有一个最重要的问题：银行和民营开发商之间，是官与民之间的问题。\n而银行和国家队央企，是左兜和右兜的问题。\n土地是垄断的\n然而房屋垄断并不是一件容易的事情。\n因为民间百姓手里是存在大量二手房的，当然这也是为什么调控的板子只打在二套房、投资客、炒房客身上的原因。\n同样，房租的垄断也并不是一件容易的事情，因为民间百姓手中的大量二手房都具备出租的特性。\n俗话说，问渠哪得清如许，唯有源头活水来。\n要垄断，必须抓住源头。\n源头在哪里？\n在一级市场，而不是二级市场。\n房地产的垄断就是要国家队从一级市场做起，从一级市场开发着手完成对商品房开发的垄断。\n一级市场，那是一个高高的门槛，民间资金，就让他该干嘛干嘛吧，房地产不是你玩的。\n一级市场包括的内容是一般开发商无法参与的：\n城市规划，城中村改造，旧房拆迁，城市综合体开发。\n可以说从规划、改造拆迁、开发、到二级市场销售，一条龙服务。\n一级市场开发的最大特点就是可以创造需求：你不是有房子吗？我拆掉你的房子，看你有没有刚需。\n国家垄断控制风险的意义还在于：需求可以拆出来。\n以后的路，民营开发商的日子将变得越发艰难。\n土地是dfzf的，商品房开发是央企和国企的。\n处于金字塔下层的40%家庭，如果还没有一套自己的房子，那么买一套自己的房子就越发的变得不可能。\n商品房将逐渐往金字塔的上层积聚。\n处于金字塔下层40%的无房家庭将只能以租房来解决居住问题。\n租金的快速上涨期即将到来，zf已经盯上了房租这块巨大的蛋糕。因为房租的收益比房产税更靠谱，更具有操作性。\n公租房，呼之欲出\n为什么政府没有那么在意民生问题？ sunxinmfc：\n政府无需考虑民生问题么，本次号称史上最严厉的打压政策再起不到一点效果，ZF威信力将进一步下降，需要仔细考量\nkkndme：\n自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。\n因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。\n农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。\n而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。\nsunxinmfc：\n秀才造反，三年不成，自古已然。\n但我们还没有谈到所谓“造反”的地步，只是说房价如你所述，暴涨，中国的中产和以上人士将进一步携款合法外流（在房价暴涨的09年，中国外流人口达到历史峰值）。这一部分人利益如何保证？您觉得zf不需要考虑对么？\nkkndme：\n现在社会跟几百年前最大的不同是，世界是开放的，这得益于地理大发现和世界经济一体化，即使缅甸朝鲜这样封闭的国家也免不了受到来自世界范围的影响。大一统的集权社会融入了西方民主的思想，同时互联网的出现也让人们对过去的思维进行了再思考。\n尽管底层百姓出国还是一个梦想，但对于精英人群，基本上是在世界范围自由流动的。\n中国自古以来，商人都是没有地位的，商人的财产可以随时被官员没收，自古如此，至今如此，即使是今天也并没有出现私人财产神圣不可侵犯的宣言。即使出现了，也没有任何可以操作的可能。\n明朝以后大量的商人移居海外成了华侨，现今的商人为了安全移居海外也不是什么新鲜事，不过是步明朝华侨的后尘罢了，zf会真的放在心上吗？朱元璋没有放在心上，朱棣没有放在心上，现在同样也不会放在心上。\n真正可怕的是官员一方面谋取私利一方面把亲属和存款送到国外，这其实是一种国家背叛。在国内榨干老百姓的血汗，得到的金钱却在国外挥霍。什么叫卖国，不过如此。\nconnstr：\n假如商人可以移居海外，官员自然也可以。官商能分家吗？\nkkndme：\n商人还是要分的吧：红顶商人就是官商，统治阶级，那是上位者。\n普通商人，比如开个袜子厂赚个辛苦钱，最后袜子厂不挣钱了，官员还天天找他，让他孝敬，他就只好移民了。\n普通商人在中国也是海量的，有点钱，但是没一点地位。\n中国自古以来都不是人人都能有属于自己的房子，大量的丫鬟、仆妇、管家、小厮寄养在权贵人家，身体都是不自由的，何谈拥有自己的房子。\n自古以来，最多的就是失去土地的农民，住在地主家做长工，又何谈属于自己的房子。\n只要是有贫富差距的社会，只要存在阶级，只要存在统治和被统治，这个社会就会不以人的意志为转移的出现大量的底层居民，没有这些底层居民。权贵就不能很好的生活。\n为了权贵生活的更好，就要维持大量的底层群众。\n权贵必须保证大量底层群众的基本生活，才能够让自己过得更舒服，仅此而已。这就是民生\nsunxinmfc：\n删掉了一大段，不得不说，你说的很对。\n（呻吟一下）。君不见，天涯上多少盼着被美军解放的铁杆准汉奸，政府楼被炸七成网民不是替死者默哀，而是一片欢呼。为什么会有这样的民意，参考前苏联，ZF确实应三思\nkkndme：\n爱国是与中华的历史分不开的，自秦统一以来，中国由封建时代转变为帝国时代，只有在项羽焚烧咸阳后，对诸侯进行了一次分封，但时间非常短暂，刘邦重新统一了天下，帝国时代经历了漫长的汉、唐、宋、元、明、清。天下一统的爱国情结是根深蒂固的。\n而在秦以前，与中世纪的欧洲是极为相似的，齐国人可以到秦国做宰相，赵国人可以到燕国做将军。中世纪法国的诺曼底公爵可以到英格兰继承王位，瑞典的贵族可以到基普做大公，封建时代的国家概念并不是明显。欧洲经历了漫长的封建时代，国家观念很淡薄，能够抛弃国家货币成立欧盟就是明证。这对于漫长帝国时代，天下一统的国家是很难想象的。\n爱国只跟历史文化传统有关。\n1978年越南入侵红色高棉，当时的红色高棉对内实行红色恐怖，以gongchanzhuyi的名义对全国700万人口进行奴役和屠杀，总共屠杀了100万人。当越南军入侵时，受到了广大柬埔寨群众的热烈欢迎，称越南军解放柬埔寨是解放人类的战争。\n红色高棉失去了民心，必然败亡。\n那时，为了支援红色高棉，中越战争打响。有我国的强力支持，红色高棉仍然走向败亡。\n房产税的制定原则 中年不惑吗：\n不过从政府要分租房市场的蛋糕而言，我有不同的看法\n政府的公租房要想租出好价格，有两种方式\n1）减少市场可出租房源（北京就这样干了，拆迁廉价城中村）\n2）提高竞争房源的成本。（所以我认为推出房产税是大概率的事情，因为政府的公租房是不需要交房产税的）\n于是竞争房源的房租暴涨，政府的公租房也就可以羞羞答答的打个9则来\n安抚一些底层了，反正所有的黑锅都有竞争房源的房东背了\nkkndme：\n房产税的问题我觉得zf还是慎重的\n1、如果采用不公平法则：\n公务员，垄断企业，事业单位的福利房不上税，权贵与利益集团购买囤积的大量商品房不上税，只有普通百姓上税，会加剧社会矛盾，而房产税会大幅提升租金，在公租房没有大量建起来之前，对稳定不利，维稳才是第一要务。\n2、如果实行公平法则\n小产权房，福利房，权贵囤积房都要上税，执行难度太大，可操作性不强，阻力几乎难以逾越。\n如果真的收房产税，采用不公平法则的可能性最大，普通的无房百姓生活将变得非常艰难。\n维稳的本质是人民能吃饱饭 维稳问题其实最终还是吃饭问题。\n房价上涨可以不买，如果房租价格不能控制，农产品价格不能控制。一旦大批群众吃饭出现了问题，维稳就无从谈起了。这个底线，还是要严守的\n公租房是为体制内服务的 说到公租房问题\n首先还是要提到我们实行的双轨制\n从某一方面可以简单的理解为统治阶级内和统治阶级外。\u2028也就是我们常说的体制内，体制外。\n体制内：公务员、垄断企业及医院高校科研院所等事业单位。\n体制外：外资、私企打工者，个体工商户，农民，这里面也应当包括高层的老板和最底层的长期无业人员。\n我们感受最深的就是涨工资的问题，一旦政府涨工资，那就一定是体制内涨工资，跟体制外完全没有关系。在金融危机的08年，大批企业关门，减薪，裁员，美国欧洲因为钱紧不得不降低公务员薪水。而这时，我们神奇的国家在干一件事：公务员普遍加薪，是为了全国百姓着想—刺激消费。\n还有保障房问题，这个也是我们感受最深的：保障房=公务员及垄断企业住房；解决住房问题变成了如何让领导干部住更多更大的房子，如何让体制内员工拥有足够舒适住房的问题。\n体制外的群众，那是别想得到一点好处的。谁让你是被统治阶级呢。\n公租房的推出，也要解决两个问题：\n1、体制内的最下层（最下层也是统治阶级，也就是是古代官吏中的吏）员工的基本住房问题\n2、向体制外被统治的小民稳定收钱的问题。\n房产税一定会转嫁给租房人 中年不惑吗：\n对公租房的问题受教了\n不过当前从来不存在什么公平正义\n税收向来是穷人多交，富人不交或少交\n不过我很感兴趣的是假如推出了房产税\n政府采取何种方式收\n难道是如同鬼子进村了，挨家挨户的收？\n但鬼子本身就是房产税的征收对象（不然也当不了鬼子）\n他们自己都抵制，难道还指望他们向屁民收\n遇到那种要钱没有，要命有一条的主\n难道政府还开拖拉机来收？\n5年前就叫嚣对房租收个人所得税\n到现在也没有个影了\n操作性实在太差\n房产税无论是持有环节征收，还是交易环节征收都是要向最终租房人转嫁的。\n好比鸡饲料上涨没有可能鸡肉不涨价，但是养鸡的并没有赚更多钱。\n巨大的税收消耗也决定了GDP必须快速增长 \u0026amp; 公务员越精减越多 降低百姓租房困难的唯一国际通行办法就是减税。但是减税，在我国是很难行的通的。一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，gdp保8实际上是必须的也是迫不得已的。维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有gdp快速的增长怎么可能呢。\nfeiying：\n这种看法很有道理，但保8毕竟会有个尽头，一旦走到头了那怎么去做呢\nkkndme：\n对于小富即安的我等小老百姓来说，希望此生不要见到这一天的到来。\n对于流氓无产者来说，盼望着这一天的到来。届时新的英雄将从流氓无产者中产生。如同威武的 同志。\n艾馨999：\n我也觉得应精减公务员，也许减掉三分之二房价就见效了，呵呵。中国确实存在很多不应有的机构。\nkkndme：\n千万不能精减，越精减越多。 一般裁减公务员都是专门裁那些没背景，没关系，不会拍马屁，傻干活的。而留下的就是有背景有关系，会拍马而不干活的。 当傻干活的公务员被裁掉以后，剩下的不干活的公务员照样不干活。 于是政府发现没人干活了，人不够用了，再大批量招人，所以越精简人越多。 这就叫精减膨胀\n特别是把熟悉业务的熟手减下来后，不得不招3个新手才能顶的住。等新手熟练了，人又富裕出来了。 精减膨胀这是不可更改的。 千万别精减，谁提出精减跟谁急，到时人民更没活路了。\n跳坑的青蛙：\n楼主关于精简膨胀的见解很精辟~ 很多事情看起来、听起来很美，也仅仅是看起来、听起来而已， 有丰富生活经验的人仔细思考一下、观察一下就不是那么回事了~\nkkndme：\n是啊，很多空空们扯着脖子呼喊这个政策那个政策，殊不知执行下来，最倒霉的还是自己。管老爷利用空空们鸡冻的心情趁机敛财，赚个盆满钵满。等空空们明白过来，也没办法了。 好比许多人最欢迎的费改税，结果税增加了，费却一点没见少。\n调控的好处是让zf利益最大化\u0026amp;防范金融风险 骑自行车买别墅：\n就说政府为什么要调控？\n难道就为了给你说的P民面子？？\n如果房价一直暴涨，不更符合食利阶层的利益？房价低价一起彪～\nkkndme：\n真不知道你仔细看了没有。我通篇也没下过调控是为了给P民面子的结论。\n调控的根本原因还是zy在房地产的游戏中没有得到好处。调控是为了让zy的国家队参与进来，成为主体。\n垄断可以控制价格，维持稳定 垄断的目的还在于能够控制价格，为了维稳，zy是不希望暴涨的，但也不希望不涨。\n体制内的住房问题有国家保驾护航 回头还说公租房\n在私企打过工的都知道，毫无归属感可言，老板脑袋一发热，随时让员工卷铺盖卷走人。那是要多没保障有多没保障。原因是社会关系，关键客户，都掌握在老板一个人手里，员工就是打个下手，一不爽了，就换人呗。\n统治者可知道不能这么用人的。一个庞大的国家机器要想正常运转，必须得让手下的和自己的利益一致。如果自己吃肉，手下的连汤都没得喝，这个机器就转不动了。\n因此，在房价高涨的时代，保障房才成为zy默认的公务员房、垄断企业房。\u2028公租房首要解决的就是手下里面最底层人士的住房问题。\u2028我认为针对于体制内来说，无论是公务员，事业单位，还是国有企业的初级员工，都可以通过所在单位申请公租房，公租房的租金会略低于市场，主要是单位一定会提供补贴。\u2028体制外对公租房的申请就没有那么幸运了。\n依靠但又不能完全依靠开发商建公租房 钱的问题，dfzf也想到了解决的办法。\n在卖地时就要求开发商配套建设一定比例的经适房、廉租房或公租房。\u2028然而，羊毛出在羊身上，开发商不可能做赔本的买卖。经适房好说，反正是卖个住户，大不了利润很低，顶多挣得少点。而廉租房和公租房就纯粹是只见投入不见产出的（开发商可没资金没耐心收租子）。廉租房和公租房的建设成本必须加到所建的商品房身上，这肯定会抬高房价。 关键是拿地成本逐年上涨，孝敬的资金也在逐年上涨，在加上多出来的廉租房和公租房建设成本，房价不可能无限抬高的。开发商也需要资金回笼周转。房价越高风险越大只是无论zf，开发商，炒房客和买房群众都有的共识。只是房价多高才是高，不同的人理解是不同的。\n显然，把大量廉租房和公租房的建设寄托在开发商配套身上是完全行不通的，不仅不能解决住房问题，还让本来就高企的房价更加雪上加霜。\n体制内的住房问题不难解决 体制内公务员、垄断企业和事业单位的员工住房问题是不难解决的，因为有zf行为的强制意志在里面。\n1、df划拨土地，征集开发商建经适房、公租房\n2、dfzf强制要求开发商建配套经适房、公租房，建设成本就转嫁给购买商品房的冤大头吧。\n3、体制内单位自有土地，集资建房。\n多管齐下，体制内人员的住房不难解决，甚至体制内人员每人住好房子大房子多套房子的问题都不难解决。处于金字塔的中上层，他们俯瞰着芸芸众生。\n解决体制外的住房问题：国家垄断，细水长流收租 处于金字塔下层的体制外的广大群众怎么办？\n体制内员工的住房舒适性和投资获利是首要保证的，不然光让干活不给好处，怎么能让手下听话呢？\n体制外广大群众的住房问题也要解决，这关系到社会稳定。\n能不能拿出一个办法，即解决了群众住房问题，又可以从群众手里长期获取收益？\n细水长流收租子的事情开发商做不了，但zf可以做。\n公租房，如果解决了钱的问题，面向广大群众的公租房的推出，将会取得双赢的局面。\n既然房地产开发最肥的肉留给了国家队，国家队也应该投身到公租房的建设中来。\n国家队全面进场之前，大鱼小鱼虾米泥鳅，皆可得利。\n不把小鱼虾米泥鳅赶出池塘，市场无法控制，风险无法控制，公租房建设也无从谈起。\n二套房首付提高到50%，第三套房停止贷款，小开发商的清理整顿，民营企业在招拍挂中无论价高价低都无法取得土地，等等一系列重拳直击小鱼虾米。\n土地将回到国家队手中，这个世界将变得清爽。\n让时光倒流到80、90年代，我们的dfzf守着蕴藏着巨大财富的金矿、锡矿、铜矿却过着贫穷的日子。没有资金，矿山是没有办法变成财富的。于是招商引资，为了gdp,为了解决就业问题，出台了各种优惠政策，于是外商堂而皇之的走进来了。成为了这些矿山的主人。5年，7年或者10年，外商享受的免税期满的时候，外商卷着巨额财富走了，留下了一个个废弃的充满危险的大坑。这是血琳琳的教训，zf没有理由不吸取。外资、私企、小业主总有一天会让他们清场，尽管这一天晚来了十几年。\n在土地日益稀缺的今天，房租难道不是可持续产出的金矿？让炒房客、投资客、民企开发商见鬼去吧。\nkkndme：\n在土地日益稀缺的今天，房租难道不是可持续产出的金矿？\n百无一用一书生：\n如果人们宁愿住桥洞呢，如果人们决定离开呢，如果房租收入不断下降呢\nkkndme：\n宁愿住桥洞的早晚要当盲流处理的\n逃离城市基本是一部分人被淘汰掉，选择，离开，而又有更多的人冲击去。\n房租收入下降基本是做梦才会出现的事情，国家队的进场就是不让房租下降\n普通人买得起「优质商品房」就尽早买把 懒兔爱散漫：\n楼主的意思是今后体制外的人（除最高层)外，是无缘商品房，只能住公租房了？\nkkndme：\n如果你现在还买的起商品房，那你就尽早买吧\n商品房和公租房的区别 中年不惑吗：\n有个疑问\n商品房和公租房相比，优势在什么地方？\n那些楼裂裂的商品房估计质量还不如公租房吧\n楼主应该加一句，买质量好的商品房\nkkndme：\n商品房和公租房的区别实际就是土地性质的不同，一个是出让，一个是划拨\n出让那必须是招拍挂，那必须是天价。\n划拨就基本算是白给，收钱就是象征性的意思意思。\n是商品房还是公租房，土地的性质说了算，dfzf说了算。跟房屋质量没有关系。\n一套房子假设20000一平，房子的价值也就占30%，剩余的都是土地的价值\n提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢） 今天看到搜狐上一篇文章说道要通过征税来调节贫富差距，提出这个方案的人不知是无知还是故意，如果zf听了这种无耻参谋的建议，不知道多少老百姓会活的更惨。\n假设出台又一个新税种，无乱它叫什么，我们暂定为财产税。既然有了新税种，就要定任务，那好了为了这个税种制定了年上缴多少多少的任务。\n实操的时候，执行的工作人员发现一旦轮到权贵脑袋上的事就没办法执行，你执行，他先让你下课。\n但是任务必须完成，那还是从普通老百姓身上打主意吧。于是政策就完全走样了，非但起不了劫富济贫的目的，反而加重了穷人的负担。\n往近里说，个人所得税，挣的是谁的税？权贵没看见交，月薪3000块的工薪层可一个都跑不了。3000块月薪上缴的个人所得税你看着不多，可对于养孩子糊口的老百姓来说，哪怕10块钱都是重要的。他们可没有资本象月薪上万的小资一样动不动花500块钱泡个吧。\n个人所得税是有任务的，工作人员必须完成任务，税别管是局级干部交的，还是连孩子幼儿园都上不起的穷光蛋交的，总之完成任务就是好样的。既然局长的税收不上来，就要从穷光蛋身上加倍收上来。\n往远里说，王安石变法是怎么失败的，以史为鉴可以知得失。王安石的初衷难道不是好的吗，可结果怎么样呢？只有一个——民不聊生。\n书生误国啊。\n调控带来的影响 许多兄弟关心房价什么时候会涨\n那么先看看这次调控后都出现了什么样的现象。\n全国房产成交量大幅下降 一线城市房价略有下跌，但并不持续，到现在基本跌不动了 多数二三线城市房价不跌反涨，成交量逐渐回升 大多数二线以上城市租金持续上涨 农产品价格有上涨迹象，大蒜、姜等小品种农产品遭遇爆炒。 变化莫测的政策导致精英阶层出现移民潮 还有什么，欢迎大家补充\n农产品的价格关系到影响稳定的吃饭问题 农产品价格的上涨是很值得警惕的。想买房子但嫌房子贵的都市白领对农产品的价格很不敏感，但是金字塔最底层的最大多数群众是很敏感的。领导们也很敏感。这牵扯到相当大比例人口的吃饭问题，稳定压倒一切。\n农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管 农产品价格的抬头将会导致物价全面上涨，在不引起质变的前提下，房价作为商品也不例外。这个引起质变的前提是出现饥荒的极端情况，这样的几率在现在社会很少。尽管干旱和洪涝使农产品大幅度减产，但是农产品还可以进口，国家还有粮食储备，保证全国人民填饱肚子还是不存在问题的。\n资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力 一线城市仍然沉默，国家队在积极运动。二三线城市的房价上涨的成交量的回升却给了市场一个明确的信号。这是资金运动的规律。国家队对一线城市的布局，迫使资金流向二三线城市。二三线城市相对（与一线城市相比）不高的价位给出了较大上升空间的预期。\n全国富人买北京上海，全省富人买省会，房价的合理性已经不能用简单的本地平均收入来衡量。精英阶层的购买力才是关键。\n资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢 明年物价进入持续上涨期是一个不容回避的问题。\n在资金总量不变的前提下，巨量资金推动农产品价格上涨或者推动房价上涨是一个必须的选择。\n今年zf用行政手段严厉打击蒜和绿豆价格的暴炒，基本上没有起到作用，资金有自己的运作规律，光靠拿张悟本出气也不能解决问题。\n资金流向规律决定了洼地不会一直是洼地 二三线城市的房价的上涨使与一线城市的差价缩小，为一线城市的发力提供了动能。\n无论你喜欢还是不喜欢，都不是以人的意志为转移的\n大城市对近距离的小城市有虹吸效应 许多人心怀房价肯定会跌回2004年的美好愿望，刻舟求剑似的思维错过了一次次购房的机会。在患得患失中，在牛刀的号角声中，在任志强的大炮声中，迷失了自我。\n任何事物都是有其规律性的。关键是否有一双慧眼能够穿透重重的迷雾。\n假设你是个投资客，你非要去石家庄和长沙买房子，结果发现不怎么升值，怨天怨地：\n石家庄作为一个二线省会怎么会不涨？长沙的房价怎么那么低？\n我们知道，北京的房子是全国有钱人买的，省会的房子是全省的有钱人买的。但是当省会城市距离一线大城市在6个小时高速以内，省里的有钱人的资金就会流向一线大城市，而不是省会。河北的富人一定会选择在北京投资房产，湖南的富人一定会选择广州深圳投资房产。\n假设你是一个投资客，你去昆明旅行，发现昆明的房价甚至高过重庆，很不理解。你很疑惑昆明这么小的西部边陲城市投资价值在哪里？\n昆明是云南省内唯一的大城市，且相邻的二线以上城市离云南省都比较远。云南地州资源丰富，虽然穷人占的比例大，富人的数量却也不少。昆明南有滇池，北有长虫山，作为一个700万人口的城市，土地资源非常稀缺。所以贵，一定有贵的原因。便宜一定有便宜的道理。\n决定房价的因素有很多，具体情况具体分析 zzz4697：\n楼主针对南昌的房价做个分析吗？从刚公布的100个城市房子均价看，南昌5k每平左右，是高了还是低了？\nkkndme：\n对于不了解的城市不敢妄下断言。没到现场调查就没有发言权啊。\n房价会不会涨还要看dfzf的规划。 比如广州拥有大量的城中村，其周边有较多的大城市，广州的房价就比北京和上海低。如果广州的城中村一旦大规模拆迁，房价将会大幅上涨。\n比如南宁东盟贸易自由港的概念使南宁的房价涨幅惊人。\n南昌的地理位置，zf规划，发展前景，江西富裕人口的多少，都是决定房价的因素\n房价暴涨是相对于钱而言的，不是相对于实际购买力而言的 tjOOSAN：\n。。。。。。暴涨之后。。。。。。\n我们不就是第二个日本吗？\n供求关系？供求关系，现在是谁在决定？国家！\n国家的经济结构决定的。制造业的资金都进入房地产了。能不涨吗？普通人有几个可以够炒房资格的？\n日本 当初也是供求关系！~~ 供求关系的根本也不应脱离，国家的经济实力！！\n还暴涨？怎么涨？再涨都够去美国买房了！！ 你这不扯淡么\nkkndme：\n中国和日本最大的不同在于日本的货币是开放的，中国的不是，是不能自由兑换的。\n暴涨是相对于钱而言的，不是相对于实际购买力而言的。\n80年代工资200多块钱一个月的时候，是不能想象90年代末北京城区5000每平米的房价的。那时候万元户已经是富人的代表了。\n90年代末工资1000块钱的时候是不能想象现在30000一平米的房价的。90年代的100万绝对是富裕群体。可现在连个中产都算不上。\n货币的持续贬值你没有考虑\n土地不稀缺，优质土地稀缺 tjOOSAN：\n在反驳楼主一句！！\n在中国的土地，可不稀缺！~~ 只是没开发罢了！！~~\n中国与世界不同！ok？13亿人！！用十三亿的居住权作为市场竞争的资本。\n那太可怕了！真的！！！如果可能，中国绝对可以产出世界第一贵的地价！\n为什么？这么多人需要房子。能不涨吗？\n呵呵！多少有点扯淡！！别再提供求关系了！~~ 供求根本是平衡的！！\nkkndme：\n中国有13亿人口，960万平方公里土地，土地一点不稀缺。\n但假设你在北京西城上班，让你去塔特拉马干买房子，你愿意去吗？\n全国有点钱的都要在一线城市和省会城市买房子，所以才会稀缺。\n大兴安岭有大量的土地，哪个有钱愿意跑去置业呢？\n集中发展大城市是导致优质土地稀缺的原因 中国经济发展不平衡，牺牲全国大多数城市和乡村，来保证北上广深及大部分省会城市的繁荣才是造成土地稀缺的愿意。\n土地有的是，房子有的是，但好位置的土地和房子并不多。\n一方面大量的小县城和乡镇、村庄人口锐减，因为缺乏谋生手段不得不背景离乡外出打工，另一方面超大型城市越来越拥挤，土地资源越来越稀缺。\n这就是中国集中发展极少数标杆城市所造成的呀，也是因为如此，才造成了中国金子塔式的收入结构，贫富差距越来越悬殊。\n为人民服务是说给人民听的 很多人很疑惑，贪官越来越多，根本不把老百姓的利益放在心里，这些贪官即使被曝光了，还能继续当官。这是为什么呢？\n首先理解一下老百姓，也就是民到底是什么？\n民就是牛养，古代的时候，官员管理百姓叫做牧。官员管理百姓就是替君主放牧，只要保证牛羊不逃跑，不骚乱，那么就是合格的官员。\n秦始皇暴政，百姓揭竿而起，可是陈胜起事后基本视民众如草芥，项羽屠杀平民比始皇更残暴。\n萧何是一个很贤德的人，对百姓很好，赢得了很高的名声。刘邦在广武山和项羽对峙，得知了萧何在关中深受百姓爱戴，就疑心萧何要造反。一个君主爱民如子是为了百姓的支持，江山永固，一个臣子对老百姓好是不是要造反呢？于是派人去调查萧何。\n萧何是个聪明人，感觉到刘邦已经不信任他了。于是赶紧改变工作作风，开始霸占百姓的田产，上大街欺负漂亮的妇女同志，并且派自己的子女上前线给刘邦做人质。\n刘邦看到了萧何的行为非常高兴，知道萧何不会造反就放心了。\n百姓不是牛羊是什么？\n在红色高棉统治下的柬埔寨人，民连牛羊都不如呀。\n波尔布特同志坚持gongchanzhuyi的按需分配，取消了货币。于是市场经济完全没有了。群众完全变成了按阶级分配了。\n阶级只分为两种，波尔布特老板及其打手是绝对的统治阶级，其他人为被统治阶级，也可以称为奴隶阶级。统治阶级对奴隶阶级不爽可以直接拿ak47突突。柬全国700万人口被波老板突突死了100万，当然不光是突突，还有活埋。\n以至于越南派了10万军队侵略柬埔寨，受到了柬埔寨人民的夹道欢迎，称为解放人类的战争。\n公道自在人心\n历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙 博古才能通今，不了解历史无法治理国家，不了解历史也无法对事务有一个清楚的认识。\n我们的今天本来就是历史的延续，前人经验和智慧的总结，不是一句话就可以抹杀的。\n因为秦以后漫长帝国时代的大一统，才会把中央集权延续到现在。\n而西方封建时代延续到地理大发现，诸侯割据王国、公国、侯国林立为现代的西方提供了民主制度的可能。\n在制度上完全的不可比性，使向国际接轨成为了笑话。\n我们看到的结果就是，物价上涨与西方接轨，甚至堂而皇之的超过西方，体制外的工资则与非洲结果，也算是国际化了。\nzf限制政策房的利润，那kfs就一定会偷工减料 mellyzhang：\n大家听过那个西三旗的有名的限价房——旗胜家园吧~！外表看起来那么光鲜，地段也不是特别偏，紧邻城铁，当然是被人疯抢都抢不到的两限房呀~！还不是质量问题一大堆。\nZF安排的政策房也是要KFS建的，哪个KFS没肉吃还能保证把房子盖好？？！！所谓检测都TMD是虚的~。\nkkndme：\n这是肯定的，开发商都追求利润最大化。\nzf建设两限房限制开发商利润，开发商必然偷工减料，zf都知道怎么回事，必须争一只眼闭一只眼，否则这个政策就执行不下去了\n屁股决定脑袋，人民不知厉害关系选房子，政府选农产品 对于渴望拥有一套产权住房的都市小白领对希望房价狂降已经到了歇斯底里的程度，他们赞成农产品价格放开，让资金炒作农产品，而离开房地产市场。理由很简单，一套房子一涨就是几十万甚至上百万，而大米小麦，一斤就算涨到10块，也根本不能影响到自己的生活质量。\n如果我国农产品价格是开放的，资金流向大米、小麦、猪肉，并且允许囤积，房地产一定会下跌的，这是毫无疑问的。\n但是，我们看到的绝不是10块钱一斤的大米、小麦，而是500块钱、1000块钱一斤的大米、小麦。\n我国将会出现大面积的饥荒，几千万甚至上亿的底层人士饿死街头，社会将出现大的动荡。\n而产权房屋价格的上涨牺牲的主体只是体制外部分都市白领的利益，换来的不过是网络上没完没了的牢骚和咒骂。\n巨量资金必须有地方去，如今面临的房地产和农产品之间的选择，你认为zf会怎么做？\n各个阶层的住房问题都安排的妥妥的 体制内中层、高层可以分到多套福利房，低层至少能够分到一套保障房，即使最不重要部门的底层员工，搞到由单位补贴的公租房是没有问题的。\n体制外的高层、中层，以他们的资金实力买多套房子都是不成问题的。\n农民，分配有宅基地。国家要稳定，首先就是要农民稳定，因此我国只有农民能够分到土地自己盖房子。\n军人，会享受到比公务员更好的福利，让军人享受更高标准的福利待遇，国家有深刻的认识。\n那么只有体制外的都市中下层群众才是高房价的受害者，可是这个群体的地位真的很微不足道。\n顶层的岁月静好来自于底层的负重前行 这些既无稳定工作（低层都市白领失业的概率还是蛮大的）又无自己的房产的都市小白领是金子塔底层被压榨的对象，甚至远远不如交通便利地区的农民。\n没有这个群体的存在，金字塔上层的权贵是无法享受舒适的生活的。\n社会需要底层群体用巨大的付出和极少的收获为金字塔上层群体服务。\n当然，在巨大的付出后，有少数人会从低层脱颖而出，爬到金子塔的中层、甚至上层。\u2028这些少数人带给了底层群体奋斗的希望。\n拥有一套属于自己产权的房子，就只有一套路：从金字塔的底层往上爬。这条路很艰辛，并且会越来越艰辛，但总有希望。\n底层指的是体制外底薪白领 天地间间：\n楼主有一点没说透彻，那就是白领的工资普遍较高，他们有能力买房子，但是受到几千年以来的小农经济思想的约束，他们普遍认为买房子不划算，占便宜心里普遍严重，别看他们外表光鲜，其实还都是一帮农民\nkkndme：\n我说的是买不起房的低收入小白领\n高薪白领不买房的不多吧，都是网上吹的吧。\n高薪白领一般还是有自住房的，只是有人不愿意投资房产。每个人想法不同而已。\n资金终会流向具有稀缺性的资产 天地间间：\n请问楼主所说的低薪白领一个月赚多少钱算底薪？\n就拿我说吧，我06年买的房子，当时月薪3000元，这在当时算不算低薪？\n但是我买房了，还是一个人买的，当然老爸赞助了点。每个月还完月供兜里就剩几十元，硬扛下来了。\n目前年薪12万，我老婆年薪6万？这算不算高新？\n如果我当时没买房子，以我们2个人的收入当下也买的起，只不过生活负担重一些。\n所以请楼主明示，什么是低薪？\nkkndme：\n兄弟，你所描述的是另外一个问题。先说说你所说的这个问题，再谈谈什么叫低薪\n先说06年你月薪3000买房子的问题。\n我们打一个比方：\n假设80年代，咱们两个月薪都是100块。你喜欢清朝的瓷盘子，咬咬牙，一年用好不容易攒下的100块钱买了清朝瓷盘子。我喜欢缝纫机，用一年好不容易攒的钱买了一个缝纫机。\n市场有价值发现功能。显然，80年代清代瓷盘子的价值没有得到发现。\n进入90年代，随着社会的发展，社会财富的增加，钞票也大幅度增加。清代瓷盘子的市场价值发现出来了，瓷盘子价格开始大幅上涨，你的瓷盘子由100块涨到1000块。而我买的缝纫机已经淘汰了\n瓷盘子具备投资品的一切属性，能够吸收社会的富裕资金，而缝纫机没有这个功能。我很眼红，我虽然买的起这个瓷盘子（因为90年代我的工资由100涨到了800），但是我觉得价格太高了，没有买。而你的瓷盘子在90年代为你挣了900元钱。\n时光又到21世纪，社会资金越来越多，钞票越印越多，可瓷盘子在市场上越来越少（都被收藏了），于是瓷盘子涨到了1千万一个，我即使想买瓷盘子再也买不起了，而不是嫌价格高的问题。而你已经成为了千万富翁。那个瓷盘子也并没有因为1千万的价格实在太高而暴跌，相反价格仍以每年20%的速度增长。\n06年你在房价价值发现的初期买了房子，就像90年代你用1000块买清代瓷盘子。\n如果你的工资不变，或者变化不足够大，现在你将没不起房子，就像你在21世纪不可能买的起瓷盘子。\n天地间间：\n楼主啊，你有一个概念错误：清代的瓷盘子是收藏品是古董，其价值是由拥有瓷盘子的收藏家决定的，而房子是商品（我指的是商品房，不是公租房之类的保障房），其价值远没有古董增值速度快，所以说收藏品和商品是有区别的。\nkkndme：\n呵呵，商品房当然和清代磁盘是不同的，升值空间不同，投资对象也不同，但价值发现的道理是一样的。投资品的基本属性：稀缺性是共有的，当然稀缺的程度不同。\n我所讲的是投资品的价值发现，而不是商品房=清代瓷盘\n土地的稀缺决定了大多数人永远买不起想买的房子 天地间间：\n此外，您还没有正面回答我什么是低薪\n我今年30多岁，如果我刚毕业肯定是拿底薪的，往最坏了想，我毕业几年到今年混的不好，今年只赚3000元一个月，我就买不起房么？\n如果你觉得是，那么你错了，我仍然可以买的起，我会到比较偏远的地段去买房子，比如密云，延庆等买套小户型二手房，那里的房价我仍然可以支付月供，当然我还是要像老爸要点钱付首付的。\n可是如果我不这么想，觉得去哪里不划算，在四环里买房子多好啊！那么我可能就买不起了，因为在四环里买房已经超出了我的能力\n那么请问我买不起四环里的房子是房价的问题呢还是我的问题呢？是不是说我买不起四环里的房子就是我买不起房？\n综上所述，每个人都有自己的能力极限，不同能力的人去不同的地段买房子，一味的强求自己做能力不及的事情，反而还怨天尤人的，这就是小农意识。\nkkndme：\n如果我们买首套房，不是为了投资。我们买房总有个基本的要求：\n有一个自己的家，并且上班相对方便\n如果你在长城饭店上班，你跑去密云买个房子。首先你上班就成问题。\n如果我月薪3000块，我甚至不能在密云买房子（因为也上万了），但我可以在山西的某个县城买套房子。问题是我买这套房子干什么？\n先天下之友：\n请问楼主，在密云延庆买房子就不能去长城饭店上班吗？貌似密云延庆的城轨马上就要开通了，一个小时就可以到三元桥的，如果你仍然觉得不可能，那么我就很同情生活在东京纽约的白领了，他们买房子都在离工作单位50-100公里的地方，他们大部分人也靠城铁上下班的，所以说东京和纽约的白领生活在水深火热中啊\n此外，密云和延庆的二手房子10000元一平？用不用我贴个卖房帖子啊？密云和延庆县城里的二手房子均价6000一平，一居室50平吧，总价 约30万，首付12万，月供1200元左右，这个对于月薪3000元的人来说是不成问题的，当然去密云延庆买别墅确实是10000元一平。\nkkndme：\n这种抬杠没什么意义，如果密云的轻轨修通了，1小时到三元桥，密云就由远郊区变为了近郊区，房价也不会维持现有水平，一定会水涨传高。\n我没看过密云的规划，如果真有这个规划，且密云房子还没有大涨的时候，还时值得购买的。\n密云的房价我倒真没去看过，不过以前有个住密云的同学说密云的新盘1万多了，老房子价格我并不知道。\n我们只不过打的一个比方，假设密云到城里上班没有问题，普通小白领又买得起，那么不买的可以称为傻空。\n但是确实有真正买不起的，连密云也买不起的，月收入3000，但要供养老人和孩子的，即使能在河北某个县城买，可是房子不能上班就完全没有意义了。\n天地间间：\n我的中心思想是：北京的白领普遍买的起房子，但是有一部分不买，其原因是想花最少的钱去获得最好的地段，最好的楼层，最好的朝向的房子，这是划算不划算的问题，不是买得起买不起的问题\n当然有的人会说：买房了，得病了怎么办？失业了怎么办？一大堆怎么办！那么请问：既然你知道早晚要见马克思，为什么现在还活着啊？一刀了断了算了，呵呵\nkkndme：\n你说的这类人其实是因为贪婪和恐惧，幸运不会垂青即贪婪又恐惧的人。用天涯的语言来说：就是传说中的傻空\n不同阶层的人对收入高低有不同的理解 再说说收入高低，不同城市，不同消费水平，对收入高低有着不同的理解。 我们举北京为例。\n反映真实居住成本的是房屋租金，而不是房价。\n在北京生活，一家三口的通常情况\n一个位置能够满足上班条件的两居室租金大约3000元，小孩花费没有3000块是下不来的，再加上夫妻俩2000元的基本生活花费，也就是说8000月收入的家庭，刚好能达到收支平衡。\n如果是体制外的都市白领，这个收入是很可怜的，因为还要考虑到失业问题，并且应付万一发生的意外支出。所以每月能有2000元的结余是必须的，那么10000元是在北京生活的基本水平。\n而购买商品房所支付的金钱是要远高于租金成本的，因为你买的不是房屋居住权，而是房屋的产权，一定会出现溢价。\n如果你现在的家庭收入能够再买得起一套房子，那么你的收入水平应该至少是小康，甚至达到中产\n天地间间：\n楼主，一对有工作经验的年轻的北京白领夫妻月收入只有8000元？这是怎么统计的？\n您的统计结果不准啊，我的结论是10000-12000元/月是北京标准的白领夫妻的月收入，那么这笔钱能不能买房子？\n能，能不能付首付？可能不能，首付款怎么来的？一部分是父母赞助的。\n作为父母就要把自己的孩子扶上马，再送一程，这和啃老没关系\nkkndme：\n呵呵，这个也不好这么说，不同行业间的薪水差距实在太大了。\n比如一个有6、7年职业学校的教师或者一个有5，6年电脑分销经验的产品经理（都是大学毕业），他们辛辛苦苦干一年多点的也就7、8万块。他们都不晓得招商银行随便一个客户经理轻轻松松年薪几十万。\n同是大学毕业，同是5、6年工作经验，北京几十万年薪收入的人不少，但一个月只挣3、4000块的数量更庞大。\n先天下之友：\n楼主，我说的是北京白领夫妻的标准工资，什么是标准工资？就是这个城市的可提供工作岗位加权平均工资，也就是说，你在北京混，正常的情况下，北京的白领夫妻在成为这个公司的主力员工以后就可以拿到的工资，什么是主力？就是在你的单位里能够独立挑起一滩活。\n此外，在北京的白领，月薪3000元在大多数公司都是起薪价，工作几年后工资翻一番的比例很大，我在北京混了很久了，我相信在北京的绝大多数老板是给员工出路的，楼主你说是么？\nkkndme：\n我倒是觉得平均工资真没有什么意义。\n你在中石化工作，各种收入加一起一年低于20万的还真没有。\n你做基金经理年薪低于100万的还真不好找。\n你在电力系统，有点职务的，一年搞个上百万都是轻轻松松的。\n你要是公务员有点级别，好的一年收入上千万，不好的一年收入也就十来万。\n但你要是在某个私营或者股份公司做个人事，行政，一年弄好了也就几万块钱\n你要是做销售，好的销售年薪几十万，上百万，不好的销售一年也就挣2、3万。\n我真不知道平均工资意义在哪里？\n一个年收入千万的总经理跟100个失业的白领平均，人人都是年收入10万\n先天下之友：\n我还是要强调白领的平均工资，这个很重要，也是很多北漂留下来的重要理由，不同行业收入不同，但是主流行业的收入差距是不大的，至于你说的中石油和其他的高薪公司这个一般人进的去么？\n至于失业问题，这个和国家的政策密切相关，属于不可抗力，一味的强调这一点没意思\nkkndme：\n如果仅指北漂而言，一般大学毕业的普通北漂白领有个几年经验的月薪大概是8000-15000不等吧。北漂几年的普通家庭月收入在15000-20000.\n这个收入，即使在现在，在北京五环以外买房还是没问题的。\n低于这个收入，真的考虑回家吧\n一二线买房只会越来越难，最终租房会成为主流 在北京一个年薪15万的普通家庭仍然买的起房，在五环外，只是你愿不愿意买。\n但以后一个年薪15-20万的普通家庭买房子，即使是五环外的，也只能是梦想了。\n租房将成为今后小白领主流的生活方式。\n人需要一个安身之所，能买早买比晚买好 房价是由土地决定的，而土地是咱们这个国家的根本，当年不就因为要改变土地的属性，才有了我们的党。\n凡房屋也都是只有土地的使用权，土地属于国家，说收回的话不管你有无房证更不会和住房者商量，如（拆迁），这个性质决不变，想下，对有房者如此，会为了没有房子的而制定均衡均分的土地政策下降房价吗？\n现在贫富分化越来越严重，真买的起房的考虑的重点不会是贷款，买不起的，房价跌去三分之一也还是买不起，不要看政府如何了，如果能少贷款或不贷款买处房的话就买吧，人早晚得有个安身之所，不要贪大求全，战争或地震来了房子不值钱，但万一战争或地震不来呢？\nkkndme\n没错，就是这个意思，如果战争来临，你手中的钱也变成废纸\n股市 新智战者：\n楼主对楼市的分析让人佩服！能否谈谈股市？现在的股市不管涨跌，我只是看到ZF在疯狂的发行新股大盘股，压大盘是肯定的了，看样子又是下一盘很大的棋！\nkkndme：\n你要注意2010年的股市与以往是不同的。因为股指期货的出现。\n要时刻关注股指期货投入的资金量。\n当股指期货资金量足够大的时候（什么叫足够大就要看个人的判断了），期指将指导沪深300指数。大盘会跟着固执期货走\n如果房价不涨，那其他产品会怎么涨 lfastro：\n“上帝欲使其灭亡，必先使其疯狂！”\n很想看看“报复性上涨”是个什么样子。\nkkndme：\n你可以这样理解（只是为了理解方便做个示意）：\n假设房价从2004年的4000一平，涨到2010年的20000一平\n猪肉从2004年的6块一斤，涨到2010年的10块一斤。\n但是如果房价2004年4000一平，到了2010年还是4000一平\n那么，猪肉从2004年的6块一斤，将在2010年涨到30块一斤，不仅猪肉，还有大米，小麦，大蒜、葱、姜、房租都会翻几倍的价格。\nzf如何利用公租房控制租房市场 中年不惑吗：\n政府要垄断房租市场？市场上已有的和不断要产生的出租房源政府怎么让它们消失呢？\n还是说政府要造足够多的公租房来占据市场主体 那就更难了 要花多少钱呀 公租房的地段好不了的\nkkndme：\n公租房将为房租市场树立一个标杆。有了这个标杆，私人出租房将会对比公租房做一个参照。\n公租房是有限的，是需要申请的，而私人出租房会在相同位置将自己的房租定价高于公租房。\n这样就保证了公租房的价格低于市场。\n公租房不是廉租房，zf要持续赚钱，他的定价不会低，私人房就会定得更高，这将导致市场上的房租整体上涨。\n公租房的吸引力在哪里？\n对体制内会有单位补贴 对体制外人员可以提供一个较长的稳定租期。 zf定价的标杆作用，无论怎么定价，公租房都会低于周边市场价格. 城中村不会长期存在 中年不惑吗：\n城中村可是提供廉价房源的地方 这个公租房的竞争对手肯定要被政府干掉 所以城中村的拆迁改造那是一定的\nkkndme：\n城中村一定会消失的，不消灭城中村，哪来的GDP\n三四线城市的未来 alice_xg：\n写得非常好\n楼主能否分析下未来三四线小城市的发展，是否会空心化\n另外，请分析下海南的城市有没有投资价值\nkkndme：\n四线城市房价也会缓步上涨，但比较慢，主要还是因人工成本，原材料价格上涨造成的建筑成本上涨。\n城市的空心化可能性不大，人口仍然会缓慢增长。但偏远乡镇却存在空心化的可能。\n海南具备得天独厚的海岸线资源，这是全国任何一个其他海滨城市无法比拟的（其他的海滨确实比较差，毫无美感）。但关键还是zf如何开发，急功近利的开发，和毫无节制的圈海岸线可能会大幅降价海南的旅游与投资价值。\n取决于政策，有较高风险\n房租价格涨不上去，本质是买房还看起来有希望 今天下午才出门，上午闲来无事，跑来再说两句。\n一是再说说房租问题，房租的发展趋势：\n现在房租低的一个重要原因是因为，大多数都市小白领还希望能够买一套属于自己的产权房，至少他们觉得即使现在钱钱不够，但是努力一把，跳个脚还能够得着。所以他们省吃俭用拼命的存钱。一个月薪10000块的小白领租一套月租金3000元的还算舒适的两居室是没有问题的，但是他为了攒钱买房宁可几个人合租一室，仅仅愿意在居住上花费少得可怜的500元钱。\n随着国家队的进入，民营资本的退出，房地产开发和房地产投资的门槛都会大幅度提高，投资房产以后就成为富人的专属。\n小白领的生活将变得“轻松”，因为除非能够上位，否则一般人跳脚是够不到属于自己的那套房子的。对于拥有房产失去希望，将使他不得不搬出合租房而转而租住一套还算舒适的两居室。\n高昂的商品房价把大量的小白领从合租房中解放出来，转而去租住两居室或者三居室。\n房租的价格一定会通过市场发现功能，找到他的位置。\n想住清合吗：\n看了那么久，突然间觉得，楼主会不会过于武断了？\n尽管我也看好房价和房租都上涨，但是，买房应该不会只是富人的专属。例如在日本，有许多的普通白领买的起房，难道在中国，白领就买不起吗？\nkkndme：\n白领是分层次的，有技术，有能力，有背景，肯吃苦的白领将通过努力获得更多的收入，获取更高的职位，走进金字塔的中层，买房子肯定没有问题。但进入金字塔中层的绝不会占大多数比例。\n低级白领，公司办公室普通职员，一无技术，二无资 没有特殊的技能或本领，又没有什么关系和背景，对机会的把握能力也不是很强，如果家里也不富裕，这样的同志今后买房子就比较困难了。金字塔的底层人数比例是最大的。\n日本的国情确实跟中国有很大不同，另外日本东京的房子也不是普通白领买的起的。我认识个NEC的部长（相当于中国企业的总监），也算大企业的中层干部，他也在东京买不起房子，家在离东京很远的郊区。\n中年不惑吗：\n日本的城市化已完成 不过东京市中心的房子小白领是买不起的 他们买的是东京卫星小城市的房子 如同你在上海工作 去扬州买房子还是能承受的 人家的地铁一个小时能跑200公里 你说生活半径能扩大多少呢 再说日本是有选票的\nkkndme：\n没错，就是这个道理。天涯里有些人说年薪30万买不起房，年薪70万买不起房。原因还是期望太高了，以为自己年薪70万了，就是人上人了，就必须住市中心的大房子。\n但事实上市中心的大房子是绝对稀缺的，人上有人，天外有天。\n买房子还是量力而行。有1000万资产的人是买不起价值2000万的翡翠的。有1个亿资产的人也不能买下故宫的居住权。\n稀缺房的价格永远涨 sunxishila：\n我认为房价不可能跌的（至少5年内） ，尤其北上广，因为\n地球资源就那么点，美国人不可能允许所有的人都过上他们那样的高消耗生活，所以美国人就尽可能地创造无产阶级国家来为其当奴隶进行打工，中国的现状也一样，利益集团以及国家政府为了其利益以及维稳庞大的执政集团必须要通过工具将更多的人丧失生产资料以便当其奴隶。试想如果人人都有房住，人人都有闲钱可以自由的选择生活方式，我们以出口为主的血汗工厂还能招得到工人吗？北上广还能存在这么多外资企业吗？外资企业没的话，没这么多就业机会，所有的外地人回家了，上海的办公楼，出租房不全完蛋了 ，那么势必减少了各种税收，那么北上广正常的维持城市运行的资金必将断裂\u0026hellip;怎么可能呢。 适度宽松的货币政策（也就是过量发行的货币）必将导致通货膨胀，在中国货币多了必将走进房地产，因为在中国基本没有别的更靠谱的投资渠道。长期看来，货币一直是贬值的 ，世界上几乎所有的国家货币一直都在贬值，这是货币的固有属性，就是剥削。除非取消货币，可能吗？ 房价下跌或者价格合理当然是有可能的，可是这取决于政治，除非取消一党执政，除非土地似有话，原因相信大家都清楚，你们认为近期可能吗？ 粮食和房子的不同是，房子无法和土地剥离 二是再说说粮食问题\n中国的粮食实行储备制度，国家每年从农民手里收购一定数量粮食以及进口一定数量的粮食用于储备。\n中国的稻米主要出自东北和广西，东北米好吃但产量小价格高，广西米难吃但产量达价格低，都市人都愿意花高点的价格购买东北米。\n各地储粮通行的做法是以储粮为名收购的东北米加价在市场上出售牟取利润，再低价收购难吃的广西米用于粮食储备。\n米在市场上的价格差别还是很大的，好的东北米可以卖到5块钱一市斤，一般的东北米卖到3块钱左右一斤，差点的东北米卖到2块钱一斤。而广西米基本在2块钱以下，而且除非比较穷的，一般人都不愿意吃。\n大家可以看到在市场上交易的大米跟其他商品并没有什么不同，好的稀缺的就贵，差的产量大的就便宜。\u2028但是米和房子不同，一方面米是当年的好吃，放到第二年陈了就不值钱了，第二年土地上新的稻子又长出来，会有新的米下市。但是房子不会，一栋楼今年卖掉了，明年这块已经卖掉了的土地并不能长出另外一栋楼。另一方面，中国实行的储备粮制度将会在粮食减产的时候平易粮食价格的上涨（尽管储粮和市场上销售的粮食完全不是一个品质），而且国家对口粮的问题会高度重视。\u2028粮食作为商品本身是与土地剥离的，而房屋作为商品却无法从土地剥离出来。这是粮食与房子的根本不同。\n商人在粮食稀缺时期进行囤积会枪毙，在粮食丰收时期囤积粮食只能亏损（第二年的米就没人吃了。\n商品房作为商品在市场上交易，而保障房是为了保障低收入群体的最基本居住，这与粮食分为储备粮和商品粮又多少有些相似。\n但是商品房土地和房屋无法剥离，产权和居住权却是剥离的，这就使既保障人民的基本居住权，又通过产权的升值牟取巨大的利益成为可能。zf实在是再明白不过了。\n购买房价基数低的省会城市，怎么都不会亏的 Razerwu：\n我也年纪小，07年才毕业，学经济的，人文历史基础有一点，关注房价有两年了。看了楼主帖子，更是开朗了。\n升斗小民一定要跟形式跑，千万别一厢情愿，也别被媒体的话语误导了。\n以后，征服会逐渐保证居者有其屋，但是不是每个家庭住的房子有自己产权。中国社会阶层分化很严重。主要分体制内和体制外两个群体。体制内的即使明摆着的收入一般，但是福利好。体制外的，有高薪的，但是低收入的更多。我们公司一般在年收入到手5-6W左右。这个应该是这个城市的平均水平了。我相信50%的人都在这个数。这个收入租个房子，除去其他生活开支，一年还能余个1,2W，如果是两个人一起生活，也能养小孩的，只是，你永远买不起自己的房子。\n但是我也知道，更多的小白领，在空调房里工作，一个月就领1000来块的薪水，而那里房价也不低，8000-10000了。你还是买不起。\n所以，未来你可以选择在房价高的地方生活，然后租房。你也可以选择回到三四线城市。但是很可能，到时候那里的房子价格也不低，如果你能力够，还是有希望买到商品房。\n非常有钱的人很多，我不知道他们会怎样投资。\n我想给一些跟我一样收入层次的人一些建议。\n物价必涨，这是趋势，如今农村的农民都不怎么种地了，征服在搞平整，以后都会自动流转，每个村的徒弟承包给一个人，别的农民给他打工。有资金的农村出来的，可以考虑往农业方向发展。\n我薪水收入一般，但是有外快，跟女友一块存钱，年收入超过20W，\n楼主在帖子里提到长沙和石家庄的例子，我认为，二三线城市也要具体分析，像我老家长沙，房产升值空间还是有的，只要每年涨20%，我就满足了。一线城市的房子更稀缺，但是，城市化的进程，不可能继续像上一个10年那样，大家都往一线城市跑了。所以，房地产暴涨的时代我不相信还有。我还相信二线城市和一线的房价差距会慢慢拉近。\n所以，我用09年的结余，在今年上半年长沙贷款买了一套，我准备下半年再买一套。我不是炒房，我是略有结余的工薪阶层，我选择保值，总比放在银行要好。事实证明我是对的上半年买的现在已经涨了10%了。\n一线和省会城市的商品房，未来一定会成为更加稀缺的资源。\nkkndme：\n长沙的房子一定会涨，只不过涨得会比其他城市慢。\n低价买涨幅滞后的房子有一个好处，一旦长沙放出“大量拆迁”等利好因素，你就赚大了。购买房价基数低的省会城市，怎么都不会亏的\n房地产是资本市场还是实体经济？ 还有一个关于实体经济的问题，房地产是资本市场还是实体经济？\n我们回顾一下，房地产的居住属性和产权属性是剥离的。\n依照房地产的居住属性，房地产绝对属于实体经济。\n从下游来说，不搬新家重新购买一套家具、一套家电、做一次大的装修的可能性都不大。在没有改善住房的前提下，去换家具家电，搞装修的应该是一个很小的比例。\n从上游来说，钢铁、水泥、机械等行业无一不受到到房地产的影响。\n房地产影响到钢铁、水泥、机械、家电、家具、建筑建材等多种领域，影响真的不小。\n依照房地产的产权属性，房地产又是资本市场。\n资金推动了商品房价格的快速上涨。\n房地产为政府积聚了大量的财富（卖地），这些财富用来建造地铁、公园、广场、办公大楼、公款招待、潇洒挥霍，又推动了实体经济的增长。\n什么是傻空 关于买房量力而行的事，还是有必要再说得清楚些的。\n还是打个比方\n假设某人家庭月收入15000块（都市小白领的通常收入），工作6年，手里有50万存款，我可以在北京北五环外（比如西三旗或者回龙观）买一套价值150万的房子（2万每平米，70几平米）。首付50万，贷款100万，月供7000多，是完全买的起的，而且因为轻轨的开通，即使在市中心工作，上班时间肯定可以在2个小时之内（作为北京这个城市来说是可以接受的）。\n但是这个人心比较高，非要在北四环内，买一套100平的住宅，二手房3万一平米，100平米就是300万。首付按30%算，也就是90万，还要贷210万，已经完全超过了他的收入水平及收入预期。于是这个人成天怨天尤人，成天喊自己买不起房，抱怨zf，憎恨炒房客和开发商。天天叫唤社会不公平。\n过了1年，国家队布局完毕，西三旗、回龙观房价涨到30000一平米了，买个70平的还要210万。首付30%，要60多万，贷款150万，月供12000左右。这时，他买西三旗70多平米的房子已经很费劲了。\n这种行为叫什么？这就叫傻空。\n什么是真买不起房 再比如说\n某人家庭月收入比较低，8000块，在北京上班，西三旗和回龙观的房也要150万的总价，是买不起的。他的收入水平只能在密云或者河北买房子，但是即使在密云或者河北买了房也没办法上班。这个人就叫做真的买不起房。\n如果他对未来的收入预期也不是很高的话，房价未来的上涨将使他进一步对买方绝望，他将彻底放弃攒钱买房，带着老婆孩子搬出跟人合租的城中村，每月花费2500块钱在回龙观租一间两室一厅的住宅。\n日子就这么过下去了。\n量变将引起质变，8000块钱的家庭月收入，是真买不起房的家庭，而15000月收入的家庭买不起房就叫傻空。\n具体情况具体分析，如果看不懂，一定是没有抓住问题本质 小时候看春秋战国之类的书籍，总弄不明白一个问题：\na国家跟c国家打，他的邻国b就会很害怕，害怕a国家灭了c国家实力更强大，对自己不利。\ne国家跟g国家打，他的邻国f就会很高兴，高兴e国家与g国家两败俱伤，自己可以获取利益。\n后来我终于弄懂了。\n当a国家跟c国家打仗时，如果a的国力明显强过c,他的邻国b就会很害怕，因为a国家很轻易就会灭掉c国家变得更强大。\n当a国家跟c国家打仗时，如果a的国力跟c差不多,他的邻国b就会很高兴，因为a国家跟c国家会拼得两败俱伤。\n分析问题，一定要深入的研究啊\n桂林 vs 南宁 leeyq88：\n楼主的观点高明，因为把房价与整个经济及政治层面的东西联系起来了。请教一个问题，桂林属于5线城市了吧，现在均价近5000，请楼主分析一下桂林这种级别城市房价的趋势。\nkkndme：\n缓慢上涨，有钱买南宁吧，东盟贸易提供了巨大的空间\n公租房的量级不会冲击到商品房的市场 vavan2010：\n楼主说得好，根据你所描述的，关于房租的这一块，我看到的前景是，由于国家队的加入和垄断，以后开发商只有可能是财雄势大集团的地产商和国家队这两种了。\n而大量的建筑公屋，也是要分租赁市场的一杯之羹，又有公租房又有廉租房，再加上物业税的出台，这样愿意持有普通住宅多套的收租客会不会减少？\n因为没钱买的会去租公租或廉租，有钱租的也去租高端好房，就象香港一样，有钱的买商品房，一般的买普通限价房，经济实用房，没钱的住公屋或廉租。反而持有普通住宅多套的会不会逐渐减少？\nkkndme：\n公租房只能是有一定量，不会是大量，首先解决的也是体制内的住房问题。持有多套住宅的有自己的市场空间\n醉生梦思1：\n这个问题很好解答，香港公租房占5成比例，私人租房市场委缩了吗？没有，这是市场上不同档次的产品，对应不同的需求。\n就像有人看盘，绿化不好，没有游泳池的房子坚决不要是一样的道理。\n贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体 旅行的第一站，是贵阳。\n一座低收入高消费的西部边远城市。\n当地人说贵阳的消费太黑人，太畸形了。大多数当地人的收入相当于中部城市的县城水平，生活必需品的消费却超过了北京。\n越偏远的地方越黑暗，越偏远的地方越不存在公平，越偏远的地方贫穷群众的比例越大，越偏远的地方权贵生活的越腐败、越奢华。\n越是资源匮乏的地区，权贵阶层越富裕，这是以绝大多数人的贫穷为代价的。\n资源的稀缺，导致权贵易于对资源形成垄断，通过以低收入高物价的方式，对底层群体进行赤裸裸的掠夺。\n于是权贵们鲜衣怒马，下层群众褴褛衣衫。\n贵州难道不是中国的缩影吗？\n在欧洲的商业区，我国权贵们一掷万金，引来欧洲群众围观，瞠目结舌。以至于全世界都没法相信我国不是超级发达国家。\n贵阳的近郊房价已经9000一平米，远郊的金阳房价已经接近了6000一平。\n但是我们能就此判断贵阳的房价存在巨大泡沫吗？\n贵阳到处是山，地少人多，物产极不丰富。\n因此，贵阳的商品房就像贵阳的餐厅一样，和普通群众是完全没有关系的。而对于权贵与精英来说，即使再翻几倍的价格也一样买得起。（腐败啊）\n看看贵阳，想想中国。\n资源的匮乏将形成高度的垄断，导致贫富分化进一步加剧，生活成本大幅度提高，中国正走向低收入高消费的畸形社会结构，群众生活越艰难，权贵的生活就会越富足。\u2028生活必需品和房价都会变得比西方国家更贵。\nfzh_0931：\n鉴定完毕，聪明的房托！ 通篇围绕通货膨胀核心立论，既然商品房是商品，那就不具备投资品的一些属性，（帖子里关于清代磁盘子的案例很不错）为什么还要在这里忽悠呢？抵御通货膨胀的手段，除了买房以外还有很多不错的选择，为毛还在这里大谈特谈房价暴涨呢？既然在上世纪90年代是商品房价值发现初期阶段没有买进，那么到了现在这个所谓的价值发现中期或者后期阶段还有什么理由买进呢？（当然，没有自住房的例外，对于投资者来说，眼下投资房产恐怕不是最好的选择）我相信，随着通货膨胀的加剧，我们手里的钞票不断贬值，房子肯定还是会上涨，只不过不是暴涨和普遍上涨，会是局部的，具有某些概念的，那么试问，我们作为普通百姓，怎么才能未卜先知到底是哪一部分的房子会上涨？那一种概念的房子会上涨？恐怕也只有那些个具有神通的精英阶层才能知道，所以作为一个普通小民来说，俺是不会淌这趟浑水滴，俺自己够住就行，真要有天，时来运转，中了六合彩或者虾米大奖之类的，俺实在是不知道那钱做什么用时才会考虑在海南？还是杭州？抑或是南京买所蜗居来等待升值，否则俺只能望房兴叹。。。\nkkndme：\n从2005年开始\n傻空眼里 凡是认为房价不会降的都是房托 凡是买房子的就认为49年加入国民党的。\n装成傻空专骗真傻空的人，一面天天喊着房价暴跌，一面抄了一套又一套\n真傻空除了骂街恨社会，什么也没得到\n重庆：高层和别墅怎么选？ yourrainbow：\nLz还在吗？咨询下重庆房价的走势呀！\n投资别墅与高层的比较！\nkkndme：\n我个人很不喜欢重庆这个城市，但是我不得不说重庆的发展空间很大，无论是经济还是房价。\n别墅，如果有钱投资，一定是别墅，只要不是太偏远的。\nhollybible2018：\n我给你解释为什么楼主推荐别墅了。看问题不是看短时间内，而是要看长远。\n第一，中国富裕阶层追捧什么房型？别墅。要想富，先学会用富人的思维方式思考问题。\n第二，随着中国经济越来越强，人均住房面积会进一步增加，人们选择的房型会由公寓逐渐转移到别墅。\n第三，如果你有在欧美，日本这些发达国家的生活经验，你会知道，公寓是给穷人住的地方，而稍微收入可以的住的都是别墅型的房子。我国按照这样的发展趋势，是能达到这些发达国家的水平。我国曾经现在将来发生的事情都是那些发达国家曾经现在发生的事情。\n货币贬值 刚从青岩古镇玩回来，饭前说说货币贬值。\n货币贬值，来自于大量的印钞\n可不可以少发点钞票。\n对不起，不行。\n这是我国的官有经济体制决定的。\n为什么美国人工高于中国，大多数商品的物价却低于中国 凡是去过美国的朋友，会惊奇一个现象\u2028除了人工服务行业，几乎大多数产品的绝对价格都低于国内。\n从数码产品，到奢饰品，从矿泉水，鸡蛋到汽车，统统比国内的绝对价格（把美金换成人民币，再拿人民币进行比较）便宜。（美国的餐馆比较贵是因为包含了人工服务成本）\n不仅仅是美国货比在中国卖的便宜，几乎所有made in china的商品在美国卖的绝对价格都低于国内售价（一件国内生产出口的服装在美国售价150人民币左右，但在国内售价竟然达到800-1000人民币）\n贫穷的发展中国家——我们的物价却远远高于美国，这是什么样的原因呢？\n我想主要还是我们的体制决定的：\n1、高昂的行政成本\n中国庞大的公务员队伍对货币的消耗达到惊人的程度。任何一种商品的销售都要分摊政府高昂的行政开支。不大量印钞票是无法维持正常运转的\n2、过渡依靠政府投资。\u2028大家都知道，中国的经济发展，是依靠政府投资为主导的，全世界都知道，政府投资的效率是最底下的，1个亿的投资往好了说只能产生3000万的效益，剩余7000万损耗掉了。因此政府不得不持续增加货币发行量\u20283、惊人的fb成本\n一集中箱货物运到美国的成本甚至低于从北京运到深圳的国内运费。这是令人惊讶的事情，又是确凿的事实。中国高昂的高速费用使物流贵得吓人，从农民手中2分钱收购的蔬菜，运到了目的地，成本就变成了1元钱。\n这中间不仅仅是高速费，当公路及铁路运输变得紧张的时候，你不得不花费比高速费更贵的支出用于打点关系。\n关系的成本已经远远贵过商品本身。惊人的fb成本是物价上涨的重要原因，因为权贵贪心也是逐年增加的，fb成本越来越高。fb成本的每年高速增长，迫使印钞需求高速增长。\n4、低附加值产品出口创汇\n低附加值产品出口创汇是我国经济发展的主要支柱。\n可以这样理解，我们的商品卖到了国外，换回的是外汇。国内的商品少了，就变贵了。换回的外汇，国家就会按照外汇的总金额依据汇率全都印成人民币，投放到社会。社会上不但商品变少了，每年还会多印出一大堆钞票，这就是通货膨胀。货币的购买力在持续贬值，国家通过货币持续贬值来收割普通劳动者的羊毛。\n所以说我国高通胀，货币持续贬值，是官有经济体制所决定的。\n是不可能改变的。\n持有闲置现金的风险，比持有任何一种可保存的商品的风险都大。\n穷人赶紧买房 奉劝那些盼着zf政策出打击房产直到崩盘，以此得到高潮的同志们，真的不要等了，除非出现明末的极端事件，否则一辈子等不到高潮。\n也奉劝希望房价能降个30%-50%好买套自己的房子的善良百姓，还是看有什么机会多挣点钱吧，等房价大降真的不现实。\n百姓们希望领导们能给自己做个主，可是几千年以来，中国的上位者们从来都只考虑一个问题：“卧榻之上，岂容他人安睡。”真的没有时间管你们的那些小事儿。\n中年不惑吗：\n大家应该知道所谓的康乾盛世，开元盛世都是什么样子了\n上层阶级的盛世而已\n底层老百姓在史书上连“某人甲，某人乙”都留不下\ndantez13：\n康乾确实是虚假的所谓“盛世”开元还是不错的\n看历史不光纵向看 也要横向看\nkkndme：\n开元盛世留下巨大的隐患才导致玄宗悲惨的人生，不应简单的认为是杨玉环和安史之乱的原因。\n首先是大量的土地兼并，大量的农民同志逃跑，社会的不安定为安史之乱埋下了隐患。还有就是节度使的权力太大，以全国之力供养节度使的军备，而内地养了一群废兵。\n相当于老大把精兵干将派去边远山区收保护费，结果自己身边连个像样的保镖都没有。有个收保护费的领班突然不爽，自己想当老大，带着打手跑回去揍老大，准备上位。这时老大就光杆司令一个，看着自己的手下叛变之能干瞪眼\ndantez13：\n我说的看历史纵向横向的意思是指\n康乾时期 纵向来看 还算是个稳定时期 但是17 18世纪 欧洲正轰轰烈烈的搞工业革命\n乾隆却几下江南 还搞什么骑射乃满洲之本\n而开元时期 ，虽然的确有很多隐患 但是大唐还是当之无愧的世界老大\n唐朝也是那个时候达到的巅峰\nkkndme：\n呵呵，大唐当世界老大也不知道是好事还是坏事\n欧洲经历了漫长的中世纪黑暗时代，结果由诸侯割据的封建社会直接进入了资本主义社会，并向国家社会主义过渡。\n中国早在秦就结束了诸侯国林立的封建时代，进入了大一统高度集权的帝国时代，到现在也没完全结束。\n武汉：城市发展空间的大小，往往和房价的升值空间成正比 dantez13：\n挨楼主好近 呵呵\n请教一下楼主对武汉这个城市的看法 房价 以及将来发展的空间\n今年刚在武汉出手两套房\nkkndme：\n对武汉的房价真没研究过，不敢妄言。但很看好武汉这个城市的发展。城市发展空间的大小，往往和房价的升值空间成正比，虽然不是绝对\n权利让革族成为苗族的一支 刚从大山深处（枫香）出来，做了6个小时车，到榕江现城，居然赶上全程停水，狂晕。\n枫香是革家聚居区，名族识别的时候本来应该定为革族，结果苗王（也是贵州shengzhang)一句话就把完全不同祖先的革族变成苗族的一支啊。这就是权利的力量。\n房价是否会跌，如果会，会怎么跌 几天没有上来，发现来了很多比较鸡冻的同志。心情可予以理解。\n但是鸡冻并不能让日子过的更好。\n油价大涨小跌，我们鸡冻了，但是事实并没有改变。\n高速费早就收回成本，可是依然雷打不动的收着，我们鸡冻了，可是事实也没有任何改变。\n房价就能真如很多人所愿，使劲跌到人人买的起吗？今后的现实将告诉我们答案。\n房价会不会跌？\n我说在较远的将来一定会跌，但下跌的方式是完全不同的。不可能象大家所期望的由2010年的30000一平跌到2004年的6000一平。\n下跌一定是另一种方式：当农产品价格以几年翻10倍甚至几十倍的速度上涨的时候，房产却相对滞涨。这是最有可能的下跌方式。\n通货膨胀是减缓灭亡最好的良药 最善良的意愿并不能阻止事务向邪恶的方向发展。\n我们大家都很清楚却都没关注的一个常识，当我们满怀热情无偿献血的时候，有哪个贫穷的患者在需要输血时，能够因为广大群众的无偿献血而得到医院的优惠吗？\n不能，无论你是穷是富，只要你是平头百姓，你都不得不因为需要输血而支付昂贵的医药费。\n同样，zf并不会因为拆迁给你补偿的太低，而强迫开发商降低房价卖给群众。压低建设成本，抬高售价，中间的利润由商人和权贵进行分配，这是官商结合的通行做法。自古以来，能够赚大钱的都是红顶商人，而不是普通个体户。\n对于很多鸡冻的群众，指着鼻子问我：国家会不管吗？疯狂难道不是导致灭亡吗？\n我告诉你，通货膨胀就是减缓灭亡时间的最好良药\n被忽悠的群众：\n请楼主解释一下\n通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利，怎是良药？？？\nkkndme：\n通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利————没错，通货膨胀就是剪老百姓的羊毛，让权贵的财富更集中，中下层群众更贫穷。\n但是，从国家的统治与巩固来讲，的确是良药啊（当然有一定限度）。\n当大多数资源掌握在少数人手中的时候，占有绝大多数的金字塔下层的群众能够分配到的资源就越少，资源的价格就会越高，少数的金字塔中上层的既得利益者就会越富有。\n大家知道，有些资源会变成富人间的游戏（比如现在的古董，字画），完全失去群众基础；而如果与生活密切相关的资源过度集中，一定会爆发极端冲突事件，造成社会动荡。\nzf通过不断稀释货币的实际购买能力，并且对粮食等生活必需品实行平准制度，一方面保证了绝大多数人民的基本吃饭问题，另一方面让中下层群众手中的余钱基本消耗在特定的商品上，以至于不得不马不停蹄的劳作，这才能保证社会的稳定和向前发展。而上层精英就可以坐享其成。\n让我们回顾一下过去\n80年代，那时的人们靠省吃俭用积攒出节余，被消耗在自行车、手表、缝纫机上。通过不断的劳动，才能吃饱饭，才能攒点钱买三大件取媳妇。\n80年代末，90年代初，人们的工资提高了，手里的结余增加了，彩电、冰箱的大规模普及又消灭了老百姓手中的流动性。\n紧接着电话、空调又接过了彩电、冰箱的大旗。那时安装个电话可要5000大元啊。\n随着工业化水平大幅度提高，经济高速增长，货币发行量也迅速增加，彩电、冰箱等工业化大规模产品已经不具备稀缺资源的特性，也无法吸收百姓手中庞大的结余资金。\n汽车和商品房的发展成为消灭老百姓手中的流动性的最好工具。\n在经济发展的大潮中，一旦对资源的支配权可以换取利益，贫富两极分化是发展的必然。随着贫富分化开始加剧，财富集中在少部分人手中，集中了大量财富的少部分人已经不满足于购买普通的消费品（汽车是工业化的产物，不具备稀缺性），对投资品的追捧造就了2005年房地产的崛起。\n房地产具备了投资品和生活必须品的双重属性，即可以让金字塔中上层的精英群体依靠房地产保值增值，又可吸收掉中下层群众的未来若干年的结余资金。\n大量印刷的货币还是有一定数量留到勤劳肯干的白领手中的，而这些货币又因为通货膨胀因素消耗在不断上涨的生活必需品上，必需品中商品房占了大头。\n于是拥有大量房产的金字塔中上层精英可以坐享其成，享受房产升值带来的收益，而中下层群众不得不为房子打工。\n发行大量货币满足经济发展的需要，同时通过通货膨胀来消灭广大群众手中的流动性，是zf稳定社会，发展经济的法宝，适度的通货膨胀当然是缓解社会矛盾的良药\ntjOOSAN：\n楼主！这段话，我不是很明白。\n好像世界上，每个国家都是如此把？谁会不买东西？谁会不买生活必须品？\n别忘了，中国发展到现在，百姓也没有能力购买一切生活必须品！当然，随着社会的发展，人民在一点一点的去完善基本生活。\n这你却说成。。。精英和国家的阴谋。。。我。。。很难理解。\n稳定粮食价格，这对每个国家而言，都是必须的啊！？？这最最基本了吧？\n房子为什么涨价？？？国家决策！懂吗？间接取消了经济适用房政策。市场上百分之九十都是商品房！！你告诉我，房价能不涨吗？\n房价涨了，受益人是谁？？？是政府！！不是你嘴里所谓的精英，他们只是傀儡罢了！\nkkndme：\n不是阴谋，我没提过一句阴谋，是国策\n好比美国，以中产阶级利益为代表的美国，一个币值相对稳定的国家，主导借钱消费，这就是国策。\n当08年的金融危机，多数中产却尝到了惨痛的教训。而在美国的华人，因为热爱储蓄的原因（这跟美国币值相对稳定、华人储蓄习惯都有关系），生活并没有受到太大影响。\n货币供应不足是明朝的真正原因 明朝末年，可怜的崇祯皇帝面临的最可怕的问题貌似两个:一是努尔哈赤的入侵；一是大饥荒下，到处闹蚁贼。光是努尔哈赤的入侵，明末的关宁铁骑完全可以将满人挡在山海关外；光是蚁贼肆虐，凭洪承畴、孙传庭等名将镇压一群乌合之众还是易如反掌的；内忧外患才导致了明朝的灭亡。这是通行的说法。\n明朝灭亡的真正原因，是经济原因。\n当然，这也是句废话，无论是社会的稳定，还是国家的动乱，或者邻国间的战争，都是经济原因导致的。\n明朝真正灭亡的原因是：货币供给不足。\n不要说百姓的经济行为受到很大制约，即使是军队也发不出饷银。以至于除了关宁铁骑以外，明朝就找不出一支有战斗力的军队，甚至洪承畴、孙传庭打高迎祥、李自成、张献忠，居然靠农民军的馈赠过日子。\n货币供给不足，明朝的经济崩溃了。\n经济问题是导致清朝灭亡 再谈谈鸦片战争和那个满脑子浆糊的林则徐。\n鸦片战争的原因，在于大清国与欧洲诸国之间存在的巨大贸易顺差。\n大清虽然闭关锁国，丝绸、茶叶、瓷器通过民间和官员私下大量出口欧洲换取白银，却没有任何的进口需求。以至于英、法国家不得不世界范围开采银矿，但依然不能满足采购中国商品的需求。\n英法诸国必须要与中国通商贸易，才能解决贸易顺差这个根本的问题。英国人实在不知道拿什么商品来进行贸易(貌似中国什么都不需要），于是不法商人想出了鸦片撬开中英贸易缺口的馊主意——这并没有得到英国官方的支持。\n但是林则徐同志既不懂得经济，又不懂得外交，对欧洲人的认识也就停留在：我不给你茶叶，你的腿都站不直。\u2028不管洋人打算干什么，总之洋人就是邪恶的，就该抓起来打板子。于是，自然而然的一顿开打，结果可想而知。\u2028于是清朝官员施展出了村骗乡，乡骗县，一骗骗到guowuyuan，的传统技能，咸丰同志在故宫几乎自始至终听到的都是捷报频传。\n清末，一会儿闹拳匪，一会儿闹白莲教，一会儿闹太平天国。然而，靠鸡冻的群众杀几个洋毛子并不能使中国变得强大。林则徐如果能够有点知识，不妄自尊大，能够说动咸丰开放正常通商贸易、拒绝鸦片，联军入侵圆明园的事大致可以避免。\n经济问题才是导致社会动荡，战争爆发的根源。\n挑个刺 第一次鸦片战争清的皇帝是道光不是咸丰 白莲教不是清末的而是清中叶嘉庆年间的\nkkndme：\n确实是道光不是咸丰，笔误，特此道歉。\n白莲教始于宋，最早可以追朔到南北朝时期，最早的名字叫“白莲社”。白莲教其实就是摩尼教，也就是倚天屠龙记里的明教，朱元璋靠白莲教得了天下，所以明代对白莲教的镇压异常残酷。清代的白莲教出现了许多分支，如八卦教、天地门教，先天教等等，总之白莲教从元代开始一直到清末都是闹得很凶的。\n房产投资的几点建议 感谢大家的支持，不少朋友还提了一些关于房产投资的问题。\n我觉得无论做什么样的投资，自己一定要做足功课。就房产来说，对于区域经济发展，要有深刻的理解，否则就不要轻易出手。\n关于房产，我只是从大方向上说了一下自己的判断，并没有对区域的房产升值做过研究，所以没法给大家提供建议，请大家谅解。\n不过，关于房产投资的方向，也有几点心得：供大家参考：\u2028一、坚决不能投资自己不熟悉的城市 二、坚决不投资中小城市，一般省会及计划单列以上城市问题都不大，但中小城市即使房价上涨也存在变现困难问题。 三、坚决不投资距离大城市较偏远的旅游城市，比如山东乳山之类的，几乎无法变现。 四、慎重投资大城市的郊区，除非价格绝对低。如果外来人口比较多，zf又有发展规划，且价格与城区相比有较大的价差，才可以考虑\n人民币对外升值，对内贬值 楼主，据sz的统计公布09年底的商品房存量4~5万套，33%左右的自由率，10年新建成面积在300万平米左右，应该不算泡沫吧？目前美元走强，人民币贬值会导致国外热钱以及权贵的钱逃走么？对房地产影响怎么看？\nkkndme：\n人民币对外是升值，对内贬值\n南宁买房建议 showforme：\nLZ帮忙分析南宁的楼市情况，这边的房价均价是6000多，最近中央说要投资1.5万亿给广西发展北部湾经济，也许对南宁楼市有一定的刺激作用，我想近期买一套房自住+投资，现在入手合适还是等到年底合适？\nkkndme：\n自住+投资？\n自住房首要考虑的还是生活方便，不要太多考虑涨跌，没有意义，如果手里有钱就可以买。\n南宁的房价我不清楚。但南宁是一个经济高速发展的城市是毋庸置疑的。\n相对于昆明，南宁在面向东南亚贸易方面，有着更得天独厚的优势——港口。\n经济适用房都是内部分配的 yjfsam：\n看新闻说,在经济适用房里提供一定数量的廉租房,而不是大量廉租房,经济适用房是可以购买的,而且是建在市中心附近,如果是我,我当然是想买经济适用房,而廉租房又不多,这会不会跟楼主的意思有点不一样?\n另外经济适用房在高价房附近推出,可以打压附近房价?\nkkndme：\n你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？\n经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。\ntjOOSAN：\n大哥！！我真服你了。。。。。。\n你知道 定向分配吗？？？就是只有拆迁户才有资格买的房子。不存在收入的问题！！\n你纯粹是胡诌啊！我发现\nkkndme：\n兄弟，你一直比较鸡栋，呵呵\n拆迁户的定向房属于另外的问题，作为有产阶级的拆迁户来说，部分是城市扩大化的受益者，而部分又是受害者，不能一概而论。时机不同，城市不同，境遇也不同。\n但是有一点可以肯定，拆迁的目的，不是为了拆迁户过得更好更舒服。开发商愿意支付高额的拆迁费（只限于超大型文明的城市，许多城市拆迁户的补偿是很可怜的）而是有更大的利润可图。\nzf为主导建设的市中心经济适用房也不仅仅为了拆迁户回迁，拆迁户回迁比例最多占小区总放量的30%，而其余的基本上是权贵房\ntjOOSAN：\n我可不激动！就是闲的没事，来找事吧！还算是正事！\n你说的什么给权贵房，固然存在。但是比例太太少了！！你说的话，根本没有依据！\n现在买限价房的和经济适用房的人，都要在报纸上公布姓名和住址。\n而且只要不是太穷的，基本都希望拆迁！因为第一，给的钱多。 第二 可以有定向分配。而且还是好地段的房子！！\nkkndme：\n兄弟你还是去了解一下体制内分福利房的真相吧。\n福利房占用的都是经济适用房的指标啊\n真正向社会公示的保障房才有多少呢？相对于数量庞大的福利房，可以说凤毛麟角。\n不了解真相就没有发言权啊\n特别是在二三线城市，房源比一线相对略为宽松，一个有点级别的公务员，通常都是分两三套房，这些房子占用的都是保障房的指标，都是要统计入保障房数据的。\n不信你可以问问身边的公务员、银行员工、垄断企业员工。\ntjOOSAN：\n奥！你说的是，传说中的 国企员工啊！！\n可你一开始却说得是 经济适用房！是你搞错了把？\n国企员工分配房子的，也要够一定工龄！一定级别！不是谁都有的。好伐？\n而且 现在中国地产，很大一部分就是国企投资的。\n所以叫内部分配么！！国企分房，在中国的体制内是正常的！\nkkndme：\n传说中的上海人？\n我没有搞错，体制内员工分配的福利房就是经济适用房。\n我举个例子，昆明武警干部的福利房叫恒安新邻居，它的官方名称叫什么？\n我告诉你，叫做“武警经济适用房小区”\n你看到的内部分房，占用的都是经济适用房的指标，也就是占用的是：我们所说的为了解决民生问题的保障房的指标。\ntjOOSAN：\nkkndme\n你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？\n经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。\n这可是您自己的原话啊？？对吧？？\n市中心的经适，就是叫做定向分配。就是 在这附近拆迁的人，住的！！\n你非要说，有人谋私，我也不反对！但绝对不会多。\nkkndme：\n我估计是你理解错了，谋私和牟取暴利是两回事。\n假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。\n这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系\ntjOOSAN：\n我觉得楼主拿经济适用房 做例子。很愚笨。\n中国房价高起的根本原因，不就是国企，制造业资金进入地产么。\n经济适用，现阶段就是为拆迁户盖得。\nkkndme：\n晕，也许你们上海是吧，放眼全国肯定不是\njellyoak：\n上海今年以前根本没有过经济适用房，恰恰相反，上海是商品房最彻底的城市\n给动迁户的叫动迁安置房，绝对都是建在最偏僻的地方的，最近5年基本上没有原拆原回的安置。\n那位激动的同志有点多动症的嫌疑，忽略算了。\ntjOOSAN：\nkkndme：\n我估计是你理解错了，谋私和牟取暴利是两回事。\n假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。\n这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系\n你。。我不知道你说这个是什么意思？\n贪污腐败是少数。这是肯定存在的现象。但我现在讨论的是大众现象！\n而且内部分房的们都要够一定级别！就算他们一人分三套，那根本对楼市没有影响的\nkkndme：\n我说的是房产双轨制，是一种制度，不是说个人的以权谋私。\n房屋问题实际上是土地问题，当一少部分人群能够以很低的代价占有更多的土地，市场上的土地就会变得稀缺，价格就会上升。\njellyoak：\n可以说上海是最彻底的商品房市场化的城市。\n没有小产权，没有福利分配，完全的市场化。\n唯一的例外就是动迁户能分配到动迁安置房，虽然都是地处偏远但现在也都价值高昂。\nlz说的那种公务员分配的安置房在很多城市是很普遍的。\n情况绝非那位偏执狂TX所理解的\n事实是庞大臃肿的公务员机构都有机会给这些公务员分配到一套住房，总数量很是惊人。\n如果严控贷款的话，现在上海的房价是得不到长久支撑的。\n看长期政策如何了。\n现在没人相信贷款可以一直这样卡下去。\n普通人怎么办：尽早买房，努力挣钱抵御通胀 被忽悠的群众：\n楼主：我们P民怎么办呢？只有买房保住自己的社会地位！？\nkkndme：\n问题是房子将会是普通人越来越难以参与的游戏，门槛越来越高。\n只有努力工作赚钱才是唯一能抵抗通胀的办法，这也是zf最希望看到的。\n当然体制内员工，工资制度本身就可以抵御通胀。这些多发出来的钱是需要体制外广大群众创造出来的，因为体制内员工本身并不直接创造价值。\n而体制外的广大群众要想抵御通胀，就必须努力工作，创造更大的价值来提高收入水平。\n这也就是国家能够维持运转的根源所在啊\n房价会出现很多上下波动 fengyu1218：\n楼主，你所分析问题透彻明晰，很受启发\n但是立足于将任何问题都用P民跟精英阶层对立的观点，我觉得有点绝对\n社会阶层的复杂性，以及相互之间的博弈会在特定的阶段\n有特定的表现形式，比如，当房价太高，P民阶层抗议不断的时候\n会有所谓的调控出来，尽管成效不大\n统治阶层也不会任由社会矛盾积累到最大程度而不作为\n所以房价的表现形式会出现很多的上下波动\nkkndme：\n你说的对，房价趋势是上涨，但一定会有短期的波动\ntjOOSAN：\n而且对于你所标榜的“暴涨” 你自己后来也改了，是在波动中上涨！\n那还是暴涨吗？你都违背了自己的标题。\nkkndme：\n呵呵，短期的调控并不能改变长期上涨的趋势，\n当资金的运作规律收到外力的压制，短暂低头的房价就会迎来暴涨。这是规律。\n买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到） 很多朋友都关心买房时机问题\n对于自住需求者和投资需求者是要区别对待的\n对于一线城市与二三线城市也是要区别对待的\n对于自住需求者（仅指普通群众）来说，只要你还有钱能够买的起房，那你就买吧。\n不要赌博和赌气，因为真的赌不起。\n人人都可以买得起商品房，只是一个美丽的童话。\n当然如果你赶上了国家调控的好时机，那你就要认真选房，做足功课，迅速出手。因为买到一套户型、位置、楼层都让你满意的房子，在商品房热销期，是很难的事情，根本没有给你挑选的机会，而在调控期，或许房价没怎么下降，但绝对给了你挑选的余地。\n对于投资来说，问题就比较复杂，要考虑的问题就会更多，不同条件的人就有不同的需求。\n总的来说在严厉调控期，需要关注以下几点：\n一、当新盘的价格低于周边二手房的价格。 二、当看房的人不断增加 三、当kas拿地热情大减，以至于多处土地流拍\n以上三点是提示你准备出手的信号。\n对于一线城市，一定会有一段时期小幅下跌，及跌后滞涨。\n对于二三线城市，多数城市会缓步持续上涨。但遇到大规模拆迁的城市，那房价就会忽视调控，选择快速上涨。近期，在二三线城市，无论自住还是投资，都是早买好于晚买。\n收入分配改革跟体制外的人没关系 feifeilongdi：\n请问楼主国家的收入分配改革调整的是哪一部分人的收入？\n我们底层p民如果真的连公租房都只能勉强供得起，那以后子女的抚养费用，夫妻以后的养老资金如何解决\nkkndme：\n工资收入分配改革应该只是个说法，对公有制经济是很有实惠的。但非公有制员工的工资是阳光雨露都撒不到的。\n以前说涨工资基本都是公务员，收入分配改革后可能对事业单位及国企工资收入有明显改善。\n至于体制外，无论打工仔和个体户都是自生自灭的\n体制外的人要早早考虑养老问题 体制外人员养老确实是个问题\n做生意的赚钱养老\n聪明的下手早的以房养老\n最惨的是没有混上去，且又没有特殊技能的私企打工仔。养老实在是个大问题。\n所以东部地区才有宁挣老板1000元，不赚打工5000块的说法。\n双轨制下，低层群众想翻身确实比较难。\n永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你 鸡冻先生\n能够有资格跟你辩论的一定只有两种人\n一种是智商极高，世间罕见的\n一种是智商比较低的。\n其他人跟你辩论那是自找苦吃\n当个农民也要懂政策，要顺政策而为 刚从深山老林钻出来，终于找到地方洗澡了，我激动啊。\n洗完澡轻松，讲一个刚从支书那里听来的故事。\n大家普遍感觉很穷的贵州省榕江县栽麻乡宰荡村，在解放前却是有名的富裕村，他们靠勤劳开垦荒地，良田多到种不过来，直到土改后，zf将宰荡的良田分给了加所、林所等周围几个土地较少的村子的村民（这些村子土地少的原因主要还是周围几个村子的村民比较懒惰，宁肯受穷也不愿意开垦荒地），宰荡才穷下来。\n因为宰荡村过去比较富裕，拨给的富农指标就比较多。有一户人家很富裕，按理应该划为富农，但这户人家很了解政策，知道评上富农就会挨整，于是走关系，成分改成了中农。\n而其他大多数依靠勤劳致富的人家非常老实，也不懂评为富农有什么不好，认为什么成分都无所谓，还不是老老实实干活。结果可想而知。当上了富农接下来就是没完没了的批斗。\n这个故事告诉我们，哪怕当个农民也必须了解zf的意图。\n存钱不如存资产，钱会贬值，资产会升值 去年在宰荡做了一段时间的田野调查，今年这次来算是回访。时过一年，发现去年村子附近的大多数农田，今年都变成了房子。\n现在农民政策还是可以的，即使贫困如贵州山区，农民除了能够完全自给自足外，多余的粮食蔬菜也能换来一定的经济收入，随着家境变好了，对更大的房子的需求也就产生了，农民愿意把闲钱都用来盖成更大的房子，宁肯牺牲掉自有耕地。这其实是一件可怕的事情。\n这次同样对村民做了入户调查，发现了一件有意思的事情。\n村民最感到遗憾的事情就是早在2000年初，那时村里还没有电，村民为了想让全村通电，卖掉了所有山上的古树。电通了，当时的村民很高兴，而且认为古树卖了一个高价格（当时总共卖了6万块钱），换来了全村的生活方便。\n大约在三年后，其他村寨，zf都给免费通了电。如果那些古树不卖掉，现在随便一颗的价格都超过了6万。现在那些古树至少值几百万。\n村民们用最朴实无华的思想总结了一个道理：存钱不如存房子、存木头、存树\n房子越早买越好，zf想钱想疯了 全国人民都知道有个以雷厉风行著称的球书记\n球书记曾说过一段著名的话，大意是：昆明的开发商拿地价格很低，卖的价格却很高，腐败才是高房价根源。\n当时昆明的很多无房户都很鸡冻，以为这下可好了，找到问题根源了，昆明房价要降了。\n可是我听到的意思却是：zf卖地卖得太低了，应该大幅提高土地价格。\n果然不久就出台了54321政策，以前拿地没走招拍挂程序的，一律按照54321补交土地款，否则开发商不发放任何证件，以至于升级到已买了房的业主也拿不到房产证。\n于是昆明的新盘由于手续问题都无法开盘，已经卖掉很久的老盘，开发商还要求业主补交房款，否则退房。\n结果可想而知，昆明的房价以一环与二环之间为例，由去年下半年的6000多涨到现在的均价过万。\n如果从民生着想，会做出这样荒唐的事来吗。\n帖子里有朋友问昆明的买房时机，我只能说越早买越好，因为dfzf想钱已经想疯了\n利益才是zf行为的指挥棒 北大朱晓阳用了十多年时间跟踪昆明城中村，对刚刚建好5年的宏仁村就要因为商业利益而拆迁已经出离了愤怒，结果这事捅到CCAV曝光了，拆迁的事只好暂停。\n利益才是zf行为的指挥棒\n建议一定是建立在严肃考察的基础上 爱情就像跳恰恰：\n这两天全部看完了，深受触动，楼主是个睿智的人，赞一个~\n想说下自己的情况，楼主帮我参谋一下，我在上海，女性，前几年由于一些特殊个人原因，导致一直没有自己的房子，这两年专注于事业，今年发展不错，进帐了260万左右，但是，通过几次看房，我发现 300万以内，已经找不到理想的房源！\n我现在是租住的市中心高档住房，每月租金 8500块，100个平米左右，这样的房子大概售价 500万左右，所以，现在的情况是 我想住的房子买不起，买的起的我也不想住~\n我本人对买房和租房没有太大感觉，从某种意义上说 我倒更喜欢租房，可以每两年换个区 换套新房住住 比较有新鲜感~但是，我手上也不想持有现金，由于物价上涨，通货膨胀，我觉得持有现金的风险也不小！\n不知道楼主对扬州的房产怎么看，我想放弃上海，到扬州购入房产，处于保值或者以后升值空间大后再售出，比如在市中心购入两三套高档小户型，用于出租！扬州由于地理优势，一两年后可能开通上海高铁，这样考虑在扬州安个家也不错，再置入一套生活便利的大点房子，以后可以考虑自住~\nkkndme：\n你的想法显然是经过深思熟虑的，在扬州买房子自住，花更少的钱过更舒适的生活很好啊，当然前提是你自己喜扬州这个城市。\n说到投资，其实没人能够取代你自己的判断。我也没法给你提供究竟有多大升值空间的建议，因为建议一定是建立在严肃考察的基础上的。\n我只能说东部地区的城市房产保值还是没问题的，但在哪个城市投资更好，确实需要认真实地考察。\n如果从全国范围看，仅对投资而言，我比较看涨西安和重庆。但我个人不会在这两个城市买房子，因为本人不喜欢重庆的酷热和西安的气氛。\n石家庄 楼主，请评价下石家庄的楼市，是暂时的价值洼地还是长期？\nkkndme：\n石家庄的地理和经济上的位置都比较尴尬。山西和天津都比石家庄有更好的优势\n投资最重要的是稀缺性，买房首选公务员小区 说到买房子，无论投资还是自住，最重要的还是稀缺性，首选还是学区房。\n自住最好买政府公务员小区，无论是商业配套，教育配套以及休闲娱乐配套都是商品房所无法比拟的。特别是商品房经过十几二十年，房子旧了，电梯很容易出故障，如果物业有问题或者小区里有人不交物业费，那么这个小区就很难住了。公务员小区则完全不用考虑房子老旧的问题，那都是zf包干到底的。\nusstcai：\n怎么找这种房源呢？\nkkndme：\n每个城市的情况不一样，北京基本上是单位的老公房，老计委的房，中石化的房都有上市交易的，但新房很难找。\n至于二三线城市，现在还存在大量的公务员、垄断企业的新小区，并且很多房源都在市场上交易。比如昆明，存在大量的权贵小区，比如金江小区是省政府公务员小区，月牙塘小区是市政府公务员小区。\n远离垃圾人 关于流氓无产者，在宰荡村子里还听了个故事\n说很久以前的事情。\n宰荡村民都很勤劳很淳朴。但是意外的出了一个叫罗老黑的人。\n这个人好吃懒做无所事事，看见人家地里庄稼蔬菜长的好就跑去抢，为此挨过几次打。有一天罗老黑路上遇到个大兵，骗了大兵的枪，于是开始在村子里耀武扬威，不但抢人家辛辛苦苦种的菜，遇到单身的姑娘还动手动脚。\n罗老黑在村里到处宣传他的逻辑：村里的庄稼、蔬菜、猪牛应该见者有份。\n村里一些年轻人受了罗老黑的感染，开始变得好吃懒做，谁家种的东西都跑去拿。于是，村里人都不愿意劳动了，宰荡村开始变穷。\n村里有个人很憎恨罗老黑的行为，但不敢明着跟王老黑作对，就在晚上在王老黑家放了一把火。侗族人住的房子都是杉木的，一旦一家着火，很可能全村遭殃，那把火烧了整个宰荡寨子，连青石板都烧裂了。\n罗老黑，这个典型的流氓无产者，他的光荣事迹被当作反面教材激励着世世代代的宰荡村民。\n高房价或许有天会崩盘，但你等不到那一天 zhuce010022：\n不合理的制度不会永远的存在下去的。。。正如国父当年说的一句“天下大势浩浩荡荡，顺之者昌，逆之者亡”。。。\n现在的高房价是目前中国的政治、经济结构失序造成的。\n楼主上面分析了那么多，确实是，在目前这种局面下可能一直冲到崩是唯一的选择，但是，你怎么知道这种失序的大局面会一直持续下去呢？\nkkndme：\n一个朝代从鼎盛到衰亡至少维持个一两百年。所谓天下大势分久必合，合久必分，由合到分，总还是有个时间跨度的。\n侥幸能在有生之年平平安安就是最大的福气，身死之后，哪管洪水滔天\n房子不仅要早买，而且有能力的话不要怕压力，争取一步到位 傻子也疯狂：\n楼主\n你好\n跟你的帖子已经两晚上了，还是没看完\n不过已经到第六页了，我会继续跟下去\n感觉你分析很有道理，也很深奥 以前在一个炒房人的终极预测也看到过类似的帖子 慢慢的也有所感悟 现在想请教你个问题，也是我自己面临的问题\n人在深圳，想趁今年调控在武汉买套房子，因为有回武汉发展的想法 我毕业三年，收入不高，目前可能首付都不够（40万总价我想付10\u0026ndash;15万，别笑我无能）总是在想是等我存够了首付再回去看房子还是现在就订下来，订下来吧钱不够，可能要问朋友借点，既要还债又要月供怕压力大，如果先不买等存够钱我怕那时候房价又上去了，所以想你帮我参考参考，给点建议，谢谢，诚信请教\n另外，我和我女朋友月总收入8000左右，你觉得买总价40万的压力大吗 准备两年后结婚，再次感谢。\nkkndme：\n40万首付15万，贷款25万，月供1000多，你和女朋友月收入8000，你觉得有压力吗？\n二三线城市往往早买好于晚买，特别是你是自住。\n40万的房子要不然是比较小的，要不然就是郊区了，如果你们有8000的月收入供60万的房子是不成问题的，建议不要图便宜，首选还是位置，宁可买贵点买离城中心近的房子，因为将来能够买得起改善性住房的会越来越少，有能力的话还是尽量买到位。要特别考虑今后小孩上学的配套问题。\n傻子也疯狂：\n楼主可能还不明白我的意思\n我的首付目前也就10万\n如果买大了首付要三成，按你说的卖60万的好是好\n可首付至少要18万\n我没有这么多怎么办呢\n如果借钱，还债又月供，还要考虑两年后结婚。。。。。。。。\n你觉得怎么办好，或者你有更好的建议\n谢谢\nkkndme：\n如果只差8万，家里支持一些，亲戚朋友借一些，一挺就过去了。很多刚开始买房的年轻人都是要咬牙买的，换来以后的轻松。甚至很多人因为今后收入的提高，几年就把贷款还完了。\n当然，如果真的凑不上，还是量力而行，但买房还是买位置，首选离城中心近的，宁可买小一点。住在远郊区的大房子里花1个多小时的时间上班才是受罪\n金融杠杆是炒房赚钱的放大器 错误角色：\n其实个人觉得普通炒房者不一定就能获多少利，比如他买一套新房是三千每平，等新房价到六千时出手，他能卖到五千每平。看上去他每平赚了二千…但是，他要继续炒的话，就要再加每平一千的本金进去买新房…看上去他们是资产翻翻了，但是他们的二次投资也是翻翻的…也就是说他以前三十万买了一百平，现在卖出去是五十万，看上去赚了二十万，但是，他想再买个一百平的却需要六十万…他还得从老本掏十万买同样大小的房子…这样算我也不知道对不对…要是对的话，就说明炒房的人不是抬高房价的最根本原因和最关键因素……\nkkndme：\n你没考虑金融杠杆的作用，真正的投机炒房是贷款炒房，而投资客更愿意一次性付清。一个炒房客用20万可以买100万的房子，等到200万卖掉，投入20多万，赚了170多万。然后用变现的钱又可以贷款买多套，这就是投机炒房比股市更吸引人的地方，但是一旦资金链断掉就会比较惨。\n这种赌徒心态的投机炒客还是比较遭人恨的，这次调控提高首付比例，对这类投机炒家打击不小。小资金的纯粹投机客数量控制在一个比较小的范围内，房产市场才会健康发展，这个国家是有共识的。所以二套房首付比例提高后，有可能变成常态\ntjOOSAN：\n这话。。。让我肝颤！~~ 投入20万？赚170？？还贷了80万呢\n还有利息呢！~~\nkkndme：\n09年初20万首付买的100万的房子，2010年初涨到200万卖掉，你认为1年能还多少利息。难道炒房客一套房子拿满20年再卖？\n要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松 要用发展的眼光看问题，只要你还年轻，即使你现在给老板打工只能赚4000块，并不意味着以后多少年都只赚4000块，随着经验和阅历的增长，薪水是会提高的，当然前提是肯学习，肯吃苦，提高能力和才干。\n性格决定命运 错误角色：\n我只买得起4000元内100平的房子！哪怕住小点，住旧点…我也不愿意背着几十年的债度过我最美好的青年和中年时代、我更不愿意每天睁开眼就开始为了还房贷而奋斗。我不想短短的一辈子只是为了一堆只有七十年产权的砖瓦而奋斗。我只是一个平凡普通的人，我只想和老婆有一个快乐安逸的小家…但是“家”这个商品已经成了现在对我来说最昂贵的奢侈品。哈哈！\nkkndme：\n有一句话叫做怎么样付出就会怎么样的收获，看到许多人买房获利，另一些人坐不住了，心态变得鸡冻了，但是，当初人家咬牙买房的时候，另一些人还在追求所谓的生活品质。性格决定了命运\n2012年不取消调控，还有房价维稳顺利换届考虑 zf希望房价维稳，为2012年换届后上涨留出空间，所以调控政策不会轻易取消，但是在高通胀预期的背景下，能不能稳住房价是很考验zf智慧的。\n换届后的老板不可能去接一个烂摊子，这是关键的地方\n洼地最终都会被填平，多数城市是早买胜于晚买 目前传言与辟谣越来越频繁，如何透过重重的迷雾看到事情背后的真相。\n这次调控zy盯的主要还是一线城市，从提高首付比例，直到监管预售款的准备推出，都是为了提高房地产进入门槛，踢出大量小资金投资客，让小开发商民营开发商知难而退，为国家队入场铺路，zy需要稳定一线城市房价，使2012年能够顺利换届，为换届后的上涨留足空间。有了国家队的后盾，zy无需因为调控导致部分小开发商资金链断掉而担心，相反这是zy希望看到的。\n当然在政策和市场的博弈中，是否能够达到zy的预期，zy的心理也不一定完全有底，因为资金有他自己内在的规律。在打压房地产的同时，会带来农产品等生活必须品的价格全面上涨，这就需要xy做出一个权衡。因为填饱肚子的问题比房价的问题更重要。\n多数二三线城市会在一线城市滞涨期间进行补涨，补足09年行情中远低于一线城市的涨幅。\n作为二三线城市的刚需买房者，多数城市的情况都是早买胜于晚买\n西部 mstsc_XP：\n楼主对成都的房子咋看？\nkkndme：\n在西部地区，重庆、西安、成都、昆明投资房产都不会有问题。西部的其他城市就要谨慎，不是因为房价不会涨，而是因为变现比较困难。\n四川、重庆经济的高速发展是不容置疑的，但存在最大的隐忧就是三峡大坝对生态和环境的破坏根本无法预测。\n短期波动属于正常现象，需要关注的是长期趋势 mobster6789\n楼主的一番讲解真如拨云见日！\n但是本人认为，在目前基本面疲软的情况下，成交会进一步萎缩，房价在短期内也还有小规模下调的趋势，请楼主评议。\nkkndme\n短期的波动是再正常不过的事情，把握政策可以把握趋势，但很难做到准确的逃顶与抄底\n领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运 领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运。\n精英社会相对于法制社会存在更多的不稳定性，更崇尚个人能力、才干与职业精神，如果刘备只懂得眼泪是不可能得到三分天下的。\n精英社会的根本就是以人治国，就是要承认人与人之间的差别。\n百年战争，法国拥有全世界最强大的重骑士军团，可是由于统帅的无能，被英国长弓兵打得落花流水。\n而耶路撒冷王国的鲍德温四世，一个年轻的麻风病人，率领几百个骑士打得萨拉丁三万马木流克骑兵溃不成军，几乎全军覆没。\n一个人很可能决定一个国家的命运。\n也许任何一个国家，甚至中国历史上任何一个朝代都没有象现在那样金权至上。\n无论中国的儒家思想还是西方的骑士精神，都告诉人们，人总是要有所追求的，不能仅仅盯着钱。\n秦时，有个老头叫郦食其，70多岁了还跑到刘邦大营参与革命，当然最后下场比较凄惨，被齐王煮了。郦老头本事很大，只身到齐国说服齐王归降了汉王刘邦。韩信害怕郦老头功劳太高，超过自己，于是很不仗义，在郦老头人还在齐国的时候，带兵攻打了齐国。齐王很愤怒，后果很严重，把郦老头放在锅里煮了。郦老头的才能出众，本想做一番事业，可惜没有算到人类本性丑恶的一面。\n当然韩信也没有好下场，这个军事上的天才，政治上的白痴，本来做了齐王，汉、楚、齐三足鼎立，结果向刘邦缴了枪，直接兔死狗烹了。\n另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。\n姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物\n另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。\n姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物\n打工不易：\n我个人认为：个人的智慧来自对大方向的把握，否则再有才干也难有作为。\n单位司机，工厂工人即便技术再好，工资也高不到哪去。\nkkndme：\n聪明智慧决定了人的眼界，有远见的人一定会未雨绸缪。刘邦身为区区亭长可以得天下，朱元璋一个穷和尚驱除鞑虏重建朝廷，一个司机未尝不能当富商，一个小姐也可能当局长\n对于具备投资属性的商品，供求关系是指货币与商品之间的关系 关于供求关系还是有必要解释一下的\n一提起供求关系，马上口水就来了，什么空置率啦，闲置率啦，空置我心啦，电表显示6000万套房没人住啦。\n实际上供求关系跟空置率和闲置率完全没有关系。\n对于具备投资属性的商品，供求关系是指货币与商品之间的关系。当货币量大于商品供应量时，商品价格就会上涨，即使人为打压也是短期行为，这是铁律。\n早买的风险小于晚买 fantabulouski：\n楼主给点意见吧，想在上海市内环内买套二手房，现在出手合适嘛？\n等等的话可能跌点么？有没有什么风险吗？\n多谢！ 因为首套房可以贷款七成，多谢！！\nkkndme：\n如果手头有钱，又是自住，到不一定非要考虑抄在最底部。\n因为钱要贬值是毋庸置疑的，房价在一段较长时期上涨的趋势也是毋庸置疑的。\n但短期，波段性的抄底和逃顶是很难把握的，尤其是自住，考虑太多实在没有意义。\n持币要冒房价持续上涨的风险，买房可能会面临短暂小幅下跌，哪个风险更大，需要自己认真考虑。\n一线城市如上海一定会有短期的滞涨甚至小幅的下跌，当新房的价格低于周边二手房价，并且成交量开始逐渐攀升就是买房的时机。\u2028我反复强调，这次调控期却是二三线城市的补涨期，对于一线城市正好可以仔细的挑选好房，这种机会在房价上升期是难以遇到的。\nfantabulouski：\n楼主再问一个问题，看看这一两天调控的信息满天飞，上海房产税的消息也到处都是，银行在不断的紧缩，感觉这次调控可是不同以往，是外松内紧啊，至少到年底前看不到放松的迹象，还什么情况下才可能会放松呢？难道要等到KQ 接班不成？\nkkndme：\n可以肯定的是首付款的比例是不会轻易放松的。房产税的推出就没那么容易了。\n上海和北京城区的二手房价有点幅度的下跌几乎不可能，很长一段时间都会滞涨或者维持小幅度的上涨。\n手里资金多的人全款买房的比例大幅提高，精英阶层的购买力基本能够维持一线城市的正常的成交量（09年下半年的高成交量zy认为是反常的，已经影响了金融秩序，是zy不愿意看到的。）\n现在的状况是，zy对调控后一线城市的房价增幅及成交量基本是满意的。\n小开发商的房子能不能买？ mstsc_XP：\n楼主的分析让我明白了很多之前误解的东西，所以自己错过了买房时机也是有一定道理的O(∩_∩)O哈哈~\n比如空置率、供求关系、当地房价和当地平均收入关系等的解释，非常感谢\n想再请教一下，zy要挤出小开发商的话，到2012年，这些小开发商修的房子会不会烂尾?因为被挤出了，也不好好修了，或者干脆跑了\u0026hellip;..因为我买的房子不是华润、中海这些有实力的开发商的楼\u0026hellip;.\nkkndme：\n如果不是经济危机，基本不会出现这种情况，当然排除个别不诚信的开发商\n大兴土木搞建设的城市，房价都底不了 黛眉轻：\nLZ厉害，分析得很透彻。请教LZ，对于目前的合肥房价怎么看呢？做为皖江城市带的中心城市，合肥的房价目前中心城区已经到了7000，也有了超过万元的所谓豪宅。和武汉长沙比起来，经济上感觉合肥还是差的，可是房价却已经不差了。\nkkndme：\n凡是大兴土木积极拆迁的城市，房价都低不了，城市发展规划的资金都要得益于dfzf卖地。这是zf主导投资经济模式的必然结果。这也是二三线城市在这次调控中补涨的根本原因\n北京老式砖混板楼的最终命运？ 汝爱之罪：\n楼主我想请教一下：就是北京二三环甚至四环有不计其数的老式砖混板楼，年代分布从六七十年代到八十年代初的都有，这些房子都是北京城市发展的产物，也是北京留给土著们的天然福利，但是现在有个问题是它们的房龄已经超过30年奔着40,50去了，这些房子的命运如何呢？拆迁吗？在原址上盖回迁房或者重新规划把里面的居民赶到周围郊区？\n因为随着政策的收紧，这类房子越来越不容易流通了，银行不给贷款，升值空间也逐渐放缓，但是地段都非常好。是不是随着房龄的增加，这类房子只剩下保值功能而最终无法流通了呢？\n这批房子最终会大规模寿终正寝，不知道dfzf会怎么处置？很想听听你的看法。\nkkndme：\n这个情况比较复杂，因为大多数老房子是各大部委的单位房。原则还是谁的孩子谁包干，谁的孩子谁认领。所以说买房子买到公务员小区最保险，即使房子旧了也不会没人管，也不会存在物业跑路、小区沦为贫民窟的问题，即使老房子拆了单位盖了高楼，保证会在原址上还你一套。\n至于说单位不行了或者单位不存在了的老公房也是有的，早晚会走拆迁的路子，那就没有原址回迁那么幸运了，肯定是搬到远郊区县，但补偿条件肯定不差，离开城中心到郊区就成了富翁。\n位置决定了价值。北京郊区农民房拆迁补偿两万一平就算高的，但是城中心房屋拆迁，补偿款那都是10万一平起步的。愿意一掷千金全款买城中心老房子的人只会多不会少，说白了就是：哥买的不是房子，是位置。\nwelldayzwb：\n现在貌似 还没有听说10万的，反而是听说政府给你的补偿比市价二手房价格还低不少，如果没有拼死斗争的话\n前段看新闻说是北京要控制拆迁成本，估计就是为了这一步压缩成本来着\n把房买在政府边，差不了 yy45678：\n楼主您好，想请教下，最近想买房，三线城市老住宅区（我们那里最早的商品房90年建的）附近一幢私房，上下二层半，120平一层,带地皮93年的房子，所有证件齐全，不好的是建在一个山坡上不能进车子。售价一起30W，另是城市新区，新市政府边，小区房。现在还很荒，什么都不方便,但环境很好。请问是买哪一个房子好？我们那里平均楼价2000左右。\nkkndme：\n2000一平的地方，好像算不上三线城市，大概应该是地级市或者县级市的房价。\n一般来说房子买在市政府边上怎么也不会有问题，只要确定新市政府已经搬到你说的那个地方，该地的升值空间肯定是有的。但是如果仅仅是zf规划就要谨慎了，因为规划并不等于真的搬迁。\n天子脚下：二手老房买得好，拆迁补偿少不了 旅行中，上个网是很不容易的事情。\n关于拆迁补偿的事，巨大的利益驱使，那真是鲜血淋淋的。所以二手老房买在哪里很重要。银行的房、zf的房、各大部位的房，有上市交易的，买下来肯定不会吃亏。\n存在风险的就是弱势群体聚居区。但是北京，毕竟天子脚下，不能搞得太僵，最终该补的还是会补到位，至于外省就很不好说了\n3万入手北京四环，你也是幸运的 汝爱之罪：\n北京七八十年代的砖混老房有体制内的，也有体制外的。现在公房上市流通，好多央产房也易主了，也许过个十年二十年的这批房子的产权证上早已换了一波又一波人。除非像楼主所说的昆明那种大型的省市公务员小区，房子新，户型好，环境和地理位置都不错，一般公务员没个20年轻易不会卖。\n北京的这些老楼，不管谁是房主，肯定值钱，房子不值钱，位置还值钱呢。\n至于这些房子使用寿命到了以后怎么处置，谁也说不清，能不能回迁，要看dfzf和规划局的利益。比如眼下金融街西侧月坛的老房子就要被集体拆除，连中学都要搬迁，这些西城人很有可能被撵到昌平回龙观西去，那边已经在建大批安置房了。\n所以说，这些老房子不管是体制内的还是体制外的，命运如何不在自己手里。即使体制内的比较不错的老小区（比如三里河的建设部小区），如果牵涉到地方的利益，肯定也是毫不犹豫全部拆除，除非那里面住着实权人物当官的不让拆。这个时候就要看这些被拆迁户的谈判能力了，谈判能力强的，当个钉子户，当然是要得越多越好。\n我以前买房的时候，也想了这些，不过最后还是买了新楼。现在因为地皮的价值，北京新老楼的房价差距不大，这个在别的城市是不可思议的。\n很感谢楼主发这么一个帖子，版主还给了个绿脸，要不然可能就错过拜读的机会了\n其实有些问题平时自己也在思考，比如GDP为什么保八，房价和滥发纸币等等，但是关于炒房和房租这一块，思考的并不多，而楼主的帖子比较有条理和逻辑的分析了这些方面，真的是很感谢，我甚至不用自己写分析，只要把楼主的帖子稍微整理，就是一篇很不错的分析资料了。\n关于zf收紧口子，抬高小老百姓炒房门槛这一块，天涯房观有几个高人和楼主的看法一致。我细细想了一下，这个提高首付到50%的政策，确实会成为长期政策保持下去，而其实即使没有这个政策，稳健型的小老百姓也会掂量自己的钱袋买房。没有谁想断供，因为刚需需要房子。\n至于以后十年甚至更长时间，房价仍然会涨。因为城市的发展离不开勤劳的人民，zf在不断的修建地铁画大饼，就是为了土地能卖个好价钱，只有不断的卖地搞铁公鸡，才会有gdp，才会有政绩。统治阶级带着他的各种利益集团一起玩，而老百姓以后可玩之物会越来越少，只能老老实实的干活挣钱。\n由于家人的优柔寡断和缺乏对北京房地产现实的认识，我直到今年初才在四环买了第一套房，3w多的均价，让家里背负了100多w的债务。我错过了07年1w的机会，和09年1w+的机会。世上没有后悔药，历史也不会重演，那些07年买房和09年买房的人是幸运的。我现在努力攒钱挣钱的同时，最希望看到的事情居然是房价尽快远离我的成本区，我知道没有买房的同学一定会抨击我这种想法，但是现实就是这样可笑，一方面希望房价能降，这样可以把老人接到身边，另一方面又希望房价涨，这样自己在还贷的时候心里稍微能好受点。呵呵，不知道自己这样是不是活得太累。\n不管怎么说，希望大家都能住上自己称心如意的房子，这几年来，zf真把我们这些人折腾的够呛。我和家人都是传说中的体制内，体制内确实有福利，可惜要想自己的财富不缩水，还得靠自己。\n君为贵，商人、技工次之，农民为轻，打工人为底 傻子也疯狂：\n今天看到新闻 什么房产市场回暖啊 温州炒房团又出江湖了 成交均价上涨啊\n请问这个是真的吗，房价会在短时间涨上去吗 如果是真的，那中央调控有什么用，在没有下降的基础上再涨10% 不是自己打自己嘴巴吗\n很想听听楼主怎么看待这个事情。\nkkndme：\n维持在正常成交量，保持一个缓步上涨的趋势，是zy最愿意看到的。因为zy很清楚，除非体制上有大动作，否则让房价下跌只是唱给人听的口号。体制是不能动摇的根本，是国家稳定的基础，高房价是体制造成的必然结果。zy很清楚，最好的方式就是以一个平缓的速度增长。但是决策者是不是有此能力控制房价缓慢上涨，这是值得仔细研究的。\n任何一个朝代，即使是我们在电影里常看到的奸佞当权，往往政策的初衷都是好的，但是执行效果却常常适得其反，领袖的智慧与执政能力对国家的命运起着至关重要的作用。\n明朝朱厚照时期有个太监刘瑾，权势一手遮天，是个典型的奸佞。但他其实是很想做点事情的。\n明朝开国时，朱元璋搞了个戍边屯田，相当于现在的军垦，因为军队自给自足，给国家省了大笔的银子。但是到了后来，军官们都变成了大地主，霸占了士兵的土地，把士兵当作佃农，依靠盘剥士兵来实现让一部分人先富起来的号召。这是与杀良冒功、贪吃空饷并列齐名的第三大快速发家致富手段。\n我们说了刘瑾是个有雄心壮志，很想做点事业的高责任心人士。对于军官霸占士兵田产导致士气低下这件事很看不惯，很不满意。决定坚决打击这种行为。于是下令地方zf\n清理军官霸占田产的问题。\n军官霸占的田产不仅仅是士兵的，更多的是当地老百姓的。\n按理说，这应该是个老百姓叫好的政策，而事实上这是老百姓头上的噩梦。\n执行人是谁？地方官。\n地方官执行的时候就实在为难了，军官老爷手里都是握着重兵的，你上门还没开口，兵大爷的刀已经架在脖子上了。可是刘瑾刘老板下达命令的同时，还是要下达任务指标的，没收的田产有任务指标，以前军官老爷占有的田都不交税，既然清理田产就要交税，交税也有任务指标。\n有些地方官比较聪明，不敢找军官大爷收，就摊派给了老百姓，结果老百姓又交田又交税，自然是连活路都没了。有些地方官脑子不清醒，真的跑去找军官老爷要田要税，结果造成军官勾结宁王造了反，最后刘瑾自己的脑袋也保不住了。\n历朝历代，统治者代表的都是地主阶级的利益。历朝历代的改革都只是为了缓和底层群众与地主阶级的矛盾，防止因为过激发生极端群体性事件。\n调控也是为了缓和矛盾，要温水煮青蛙，而不要一把火把青蛙烧死。\n关于自己打自己嘴巴的事，那是太多了，自古以来，统治者也从来不怕自己打自己嘴巴。古人就总结过，只准州官放火，不准百姓点灯。\n以前的科举制度与现在的公务员考试制度基本目的都是相同的，让全天下的优秀的和不优秀但有出身的知识分子依附于官，这样就有了绝对的话语权。无法进入体制内的知识分子，有商业头脑和技术专长的人员，就相当于过去的商人、小作坊主，尽管也许还算富裕，但是没有任何地位，任人支配。要是没有一技之长，又不能经商，就基本上在社会的最底层很难翻身，相当于过去城市里的贩夫走卒，甚至无片瓦立锥，糊口都是困难，地位和稳定性反而远远不如自给自足，拥有宅基地的农民\n中年不惑吗：\n说到底空空太幼稚了 当年拖拉机之夜太学生怎么也想不到机关枪和拖拉机真的会招呼到自己身上 这和他们从小接受到的教育不一样 呀 主流宣传中party妈妈都是慈祥的温柔的全心全意为p民服务的\n有皇帝大力支持的王安石变法到了地方法令也大变味 如今虎温的威权要远远小于当年的宋神宗和王安石 而且统治阶层从上到下的改革从来是为了巩固统治地位 至于p民收益那从来都是附属作用\nkkndme：\n这就是中西方的不同，西方的拖拉机是对外的，中国的拖拉机从来对的都是p民，对外基本比较忪。所以才有元和清，明明是外族入侵灭了国，还要把蒙古人和女真人一起拉进来统一叫中华民族，居然认为中华民族很强大，元朝时一直打到亚得里亚海。也不管蒙古人跟中华的两河文明有关系没有。\n10年的调控和08年调控的区别、带来的影响、机会 这次调控与08年调控后的结果是有所区别的。08年调控的结果是一线城市的暴涨；而2010年调控的结果是房价以二三线城市为主的全面上涨。不但是二三线城市，高房价甚至已经传到至四线及以下城市。\n在二三线以下城市，无房户的需求其实并不大，真正的刚需来自改善性住房。城市升级使人们开始不满足过去老旧式住房的居住环境，开始追求大盘大开放商的品质住宅。房价也由此迎来全面上涨。这种全面上涨，不能理解为全面泡沫，而是有基础存在的。不能理解为全国炒房。特别是四线及以下城市尽管新盘价格高涨，老旧住宅却乏人问津，县级市二手房变现也比较困难。在2010年的调控的大背景下，却神奇的出现了二三线以下城市的刚需大量释放现象，不得不令人叹为观止。这神秘的幕后推手其实就是资金的规律。\n对于在2010年初布局二三线城市的房开商和有远见的投资者，在这次调控中，无疑是受益者。\n一线城市，这次调控给刚需买房者一个最好的入市良机，但是能够抓得住的只是少数。\n历史总是惊人的相似 汝爱之罪：\n其实，几千年来，唱的都是同样的戏，只不过台上的演员变换而已。\nkkndme：\n赞赏这一句，呵呵，历史规律是不变的，变化的只是时间、地点、人物、事件。\n城头变换大王旗。\ntjOOSAN：\n历史规律是不变！但他妈世界变了！~~ 中国采用资本主义制度了\n还只参考中国历史？\nkkndme：\n你知道什么叫资本主义制度吗？\n首先基础是三权分立。\n早在1748年，孟德斯鸠男爵发表了伟大的划时代的巨著“论法的精神”明确提出了三权分立。奠定了资本主义制度的基础。三权分立制度就是国家的立法、行政、司法三权分别由三个机关独立行使，并相互制衡的制度。讲的是法律精神，讲得是私人财产神圣不可侵犯。\n而作为一个人治而非法制国家，怎么能说是资本主义呢？\n建议个别（tjOOSAN）不读书，不研究，不了解中西方历史，不懂经济，对社会制度基本的理解基本是个白痴的同志，就不要乱发表议论了，惹人笑话。\n无论是中国还是西方历史对现在都是很有借鉴意义的。这就使毛说过的“古为今用，洋为中用”，毛建的武装斗争及建国思想其实很大程度来自于朱元璋。\n古代君主统治国家征服世界靠战争武器，现在则靠金融武器。\n西方，我们所熟悉的具备最纯正贵族血统的哈布斯堡家族，曾经的德意志王国和神圣罗马帝国的统治者，家族成员曾经统治过欧洲诸国：包括波希米亚王国 、匈牙利王国 、克罗地亚及斯洛文尼亚王国、伦巴第及威尼斯王国 、奥地利皇室领地 、萨尔茨堡公国 、塞尔维亚及塔米斯-巴纳特公国等等无数欧洲国家。\n而现在，哈布斯堡家族控制着华尔街，继而通过华尔街控制着全球的经济。\n历史是在继承的前提下发展的，特别是在西方，现在几乎每一个显赫的家族都能追根溯源。因为尽管西方也发生大革命，但是象文革一样彻底否定历史是完全不可思议的。\n我们有点英雄情结的人听到最多的西方中世纪十字军三大骑士团：圣殿骑士团、条顿骑士图案、医院骑士团；直到现在仍有两大骑士团存在。条顿骑士团总部现在还在德国，专门从事慈善事业。医院骑士团后来改名为马耳他骑士团，也就是现在的马耳他，世博会还来上海参展。只有圣殿骑士团灰飞烟灭，但现在仍有大量的修士组织自称为圣殿骑士团的继承人。\n完全不懂历史，就等于完全不懂得社会。\n关于房贷 四环四环：\n同意LZ。 刚刚父母帮忙首付、自己还贷，在北五环边买了个小房。 判断依据非常简单：一个是国家政策和我等屁民生活是两岔儿的，既然移民无望，就赶快站队；一个是力所能及、负担得起。\n07年底和09年底都错过了机会，也是当时条件不允许，一次是自己嫌弃燕郊太远；一次是嫌弃通县太远。完后工作逐渐稳定，一狠心安了家，剩下的就是往体制外金字塔中层挤吧。\nLZ所说，正是我说不清楚、但能判断大概的那些事儿。 哈哈。\n请教LZ：\n眼下商业贷款贷款46万。 分20年还，月供3066 分30年还，月供2562\n朋友劝我贷款时间越长月供越少越好。 直觉判断我觉得也是这样。 有科学依据么？\nkkndme：\n你的朋友考虑是有道理的。 如果不考虑通货膨胀，当然是利息越少越好，20年还的利息要少于30年还的利息。 但是因为通货膨胀的因素，我国是高增长高通胀的国家，每年的通胀率远远大于实际公布的数字，更远远高于贷款利息，所以贷款时间越长越好。 至于月供是否越少越好，完全取决于个人的承受能力，有条件当然买大房子，宁肯月供多一点。但是条件不够就买小的，量力而行。\n四环四环：\n谢谢楼主指点。\n假设通胀率有一个固定值（当然实际这是没有的，它也是个取决于经济规律和国家意志的不确定因素）、贷款利息有一个值。 完后不同的贷款年限。 就能估算出两个值此消彼长。\n需要选择判断的是，通胀率这个值的数字。 但通过对国际意志不确定因素极端情况的估算，预计这个值。\n完后把这变成一个数学题。\n是这意思么？\n那不用算了，按常识，知道该怎么选了。\nkkndme：\n银行贷款的年限越高，利息支出越高，但不会高过通胀。你能贷30年就贷30年，这是你年轻的优势。年纪大点的就只能贷25年，甚至20年了。\n所以说40岁买房的人很不靠谱，首先40岁的人不一定有钱，反而错过了最敢买房的黄金年龄。其次是40岁贷款年限就短了好多，相当于月供压力更大了。\n买卖商品房会逐渐变成富人的游戏 以后，商品房本来就变成了富人间的游戏，普通人将不能卖进参与的门槛。\n到多数人真的买不起房时也就安心了，也不用关心房价的涨跌了。\n但是现在，房价还没有到那个高度，很多人还觉得有希望，所以对房价的涨跌才会特别关注。这个时期应该就是普通人最后买房的机会。错过了，将不会再有。\n政府还是更在意农民问题 肖肖19850706：\n楼主虽然有很多观点写的很有道理，但是对于历史这块，并不太正确\n引用一段楼主的话： —————— 自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。 因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。 农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。 而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。 ——————\n其实在当今政权建立之前，还有一个政权，叫做中华民国 这个政权是由民主革命带来的 他们所举的旗帜是资产阶级革命，所建立的政权是资本主义社会 为什么会失败？ 这是一个值得思考的问题 让一个经历了5000年封建社会的国家经过一次革命就达到资本主义社会的境界 没有工业革命的基础 没有原始的积累 有的只是借鉴西方 想先变制度再进行调整，结果固然是失败 于是“农民起义”卷土重来，我想大家肯定明白“农民”所指的是什么 于是又了现在的这个政权 由工人阶级和资产阶级去推翻帝制 再由农民阶级把土地抢回来，最终回到封建政权来压迫资产阶级 他们最怕的还是农民么？ 显然不再是了 他们最怕的正是资产阶级 其次就是你说的那些 “关心自己能否拥有一套产权房，除了呻吟一下意外，几乎是没有什么有效反抗的可能的都市白领” 攻占巴士底狱的不是农民 正是这些“几乎没有什么有效反抗可能的都市白领” 是工人阶级结束了地球上长达上千年的封建统治 而改革开放，市场经济的发展，给了这一切充足的物质基础 社会的转化过程有两种 一种是和平演变 一种就是革命\n现在所存在的问题，不是他们更怕谁 而是他们选择面对哪种演变方式\nkkndme：\n最可怕的不是农民而是失去土地的农民。 为什么说新民主主义革命是工人阶级领导的？ 那时的工人阶级是什么？就是失去土地的农民和破产的手工业者，除了体力一无所有，所以他们才具备脑袋掖在裤腰带上，为了抢土地而玩命的动力。解放战争时期，我军的宣传就是：“同志们，国民党要把分给你们的土地抢走，你们说怎么办？”于是广大失去土地的农民兄弟不干了，玩命了。 工农红军一四方面军胜利会师，在选择南下和北上发生了分歧，真的为了北上抗日吗？1935年抗日战争还没有打响，日本人在东北而不是西北。北上抗日的说法实在有些牵强。 我想真正的原因还是群众基础。 近几年多次在西南地区的乡村进行田野调查，发现一个问题：解放前，即使如贵州山区的偏僻乡村，农民自给自足吃饱肚子是完全没有问题的，更别说富庶的四川平原。 那时参加红军要有不要脑袋的玩命精神，对于多数能够填饱肚子的农民来说，主动参加革命显然是不现实的。红军在西南地区完全没有群众基础，战斗中的减员得不到有效的补充，所以人才会越打越少。 而西北地区完全不同，自然条件恶劣，农村耕地很少，存在大量食不果腹，无地可种的农民。李自成起义也是从陕西发起的，可以说具备了随时发动武装暴动的群众基础。所以毛选择了北上的正确路线。而张同志南下凄惨的下场印证了毛的正确判断。 北上延安的另一个重要原因是获得苏联的支持，没有强大的后援是无法取得决定性胜利的。\n一旦农民失去了土地，而又没有去处，那是相当可怕的，所以农民工就业问题是zy最为关注的。甚至提出如何让农民工在城镇买房子置业，处理好农民问题，是社会稳定的重中之重。\n将来，有地可耕的农民将会成为都市中的底层群众羡慕的对象，农民有地有住宅有粮食。进可以在城市打工，有聪明的甚至通过经商迈进富人阶层，退可以回乡种田，虽然现钱不多，但是吃穿住行都是没有问题的。\n而真正一无所有的将是大量在都市中沦为贫困的人群。在打拼挣扎的打工仔，如果没有能力购置房产，也没有得到向上爬的机会，在都市立足将变得困难，而又毫无退路。\n治国需要用贪官、反贪官 讲个故事，可能这个故事很多人都看过，并且曾经多次被转帖：\n宇文泰是北周开国的奠基者。当他模仿曹操，作北魏的丞相而“挟天子令诸侯”之时，遇到了可与诸葛亮和王猛齐名的苏绰。宇文泰向苏绰讨教治国之道，二人密谈 三日三夜。\n宇文泰问：“国何以立？”\n苏绰答：“具官。”\n宇文泰问：“如何具官？”\n苏绰答：“用贪官，反贪官。 ”\n宇文泰不解的问：“为什么要用贪官？”\n苏绰答：“你要想叫别人为你卖命，就必须给人家好处。而你又没有那么多钱给他们，那就给他权，叫他用手中的权去搜刮民脂民膏，他不就得到好处了吗？”\n宇文泰问：“贪官用我给的权得到了好处，又会给我带来什么好处？”\n苏绰答：“因为他能得到好处是因为你给的权，所以，他为了保住自己的好处就必须维护你的权。那么，你的统治不就牢固了吗。你要知道皇帝人人想坐，如果没有贪官维护你的政权，那么你还怎么巩固统治？”\n宇文泰恍然大悟，接着不解的问道：“既然用了贪官，为什么还要反呢？”\n苏绰答：“这就是权术的精髓所在。要用贪官，就必须反贪官。只有这样才能欺骗民众，才能巩固政权。”宇文泰闻听此语大惑，兴奋不已的说：“爱卿快说说其中的奥秘。”\n苏绰答：“这有两个好处：其一、天下哪有不贪的官？官不怕贪，怕的是不听你的话。以反贪官为名，消除不听你话的贪官，保留听你话的贪官。这样既可以消除异己，巩固你的权力，又可以得到人民对你的拥戴。其二、官吏只要贪墨，他的把柄就在你的手中。他敢背叛你，你就以贪墨为借口灭了他。贪官怕你灭了他，就只有乖乖听你的话。所以，‘反贪官 ’是你用来驾御贪官的法宝。如果你不用贪官，你就失去了‘反贪官’这个法宝，那么你还怎么驾御官吏？如果人人皆是清官，深得人民拥戴，他不听话，你没有借口除掉他；即使硬去除掉，也会引来民情骚动。所以必须用贪官，你才可以清理官僚队伍，使其成为清一色的拥护你的人。”\n他又对宇文泰说：“还有呢？”\n宇文泰瞪圆了眼问： “还有什么？”\n苏绰答：“如果你用贪官而招惹民怨怎么办？”宇文泰一惊，这却没有想到，便问：“ 有何妙计可除此患？”\n苏绰答：“祭起反贪大旗，加大宣传力度，证明你心系黎民。让民众误认为你是好的，而不好的是那些官吏，把责任都推到这些他们的身上，千万不要让民众认为你是任用贪官的元凶。你必须叫民众认为，你是好的。社会出现这么多问题，不是你不想搞好，而是下面的官吏不好好执行\n二线城市典型代表 klid：\nLZ 成都属于您口中的二三线城市么？ 那么这次属于补涨阶段？\nkkndme：\n成都、重庆、西安、昆明、武汉都是二三线城市的典型代表。\n关于商铺和住宅投资 马甲马甲_马马甲：\n请教楼主：\n因为种种原因， 错过了很多买房的好时期，现在租房住，（ 享受到了朋友提供的体制内的好处， 远低于市场价格租了一套房子）。\n手上200万左右的现金， 在上海，想买房子保值增值，\n1，有套著名大学附近的二手房子，57平米， 130万左右，估计租金大约是2.5万-3万 之间， 2，在市中心成熟的商业区有个店铺， 124万， 年租金现在是6.4万一年。\n2个选择，个人倾向于投资店铺， 因为在上海店铺的涨价远远低于住宅的涨幅，况且店铺的资金回报率也达到了 5% ，不知道楼主是否有更好的建议？\nkkndme：\n很多人不愿意投资商铺还是在于风险大，好位置熟铺是很少有人愿意拿出来卖的，谁愿意放弃生蛋的母鸡呢？而新开发的商铺要不然位置比较偏，不知道能不能做的起来，要不然就溢价太高，超出了大多数人的承受。好的商铺是市面上很难买到的。\n如果经过考察确认商铺没有问题，还是首选商铺，但是一定要经过认真的考察。\n而住宅的风险就相对小多了，而且投资不需要很多的经验，更适合一般投资者。\n关于房产调控 tianxiaobing11：\n请问楼主，房价会在年底重新确立上涨趋势吗？如果再不涨，政府的地卖不上好价钱，地方财政就回吃紧，地方政府还会像去年那样出各种政策救市吗\n九五二七八：\n全国各地 一线二线三线 情况都有不同 楼主预测时点 怕不好预测啊\nkkndme：\n不但是不同城市情况有区别，同一城市的不同区位情况也有区别。就拿北京来说，过渡爆炒的通州房山等远郊区县，房价一定会有所回调，但是城市中心，特别是学区房是没有下降可能的。\n而对于多数二三线城市，均价下降的原因主要还是远郊区的房源投放量增加，城区内的房子不但不降，而且涨得还很厉害。\n房产投资最重要的还是位置，当远郊区县的房价远低于城中心的时候，一定会有补涨的要求，但当远郊区县的房价向城中心接近的时候，一定会出现城中心的补涨，当然在调控期也会体现为远郊区县房价的回调。\nkkndme：\n仔细看一下各地的房价，不要被公布的所谓均价迷惑，只有少部分城市价格下降或者持平，多数城市都在上涨，只不过幅度不大而已。现在成交量属于正常水平，不存在dfzf吃紧的问题，当然不可能象09年那样的疯狂，09年底甚至银行出现无款可贷，太高的成交量会被zy视为危险的信号，是达到危害金融安全的高度的。\n关于房产税 tianxiaobing11：\n还有一问题请教楼主，目前我一共有三套房，一套自己住，一套父母住，一套是投资房，在大连最繁华的地方，租金回报是百分之六点五，请问房产税会很快推出吗？我的那套投资房是卖掉还是持有呢？卖的话能赚白分之五十\nkkndme：\n在卖掉之前，你要先问问自己，拿这笔钱打算干什么？如果没的可做，干等着贬值，那你为什么要卖呢？ 如果你有更好的投资或者创业渠道，那当然立刻卖掉，不用犹豫。 至于房产税，第一：近两年一定不会征收，因为条件还不成熟。第二：房产税只是一项苛捐杂税，目的是补充财政收入，并没有降低房价和租金的功能，并且只能导致租金的上涨。怕房产税的应该是租客，而不是房东。\n任何税种最终都要转嫁到社会最底层群众身上。丛林法则实际就是大鱼吃小鱼，小鱼吃虾米。\n上层人士的享受是靠底层群众勒紧裤腰带过日子换来的。\n老公房的拆迁问题 wofuleyumin1：\n从头至尾，一口气看完了。。赞同之极。。。\n也向楼主问些问题。。。\n是否老公房都会拆迁？ 在成都，一环，二环内还有非常多的老公房，总量比商品房还多，这么多的房子都会拆迁吗？ 我在想是否先买套老公房。。因为价格也便宜。新的商品房一般八九千。。老公房才5千多。买了后灯拆迁。\n但这么多老公房都会拆迁吗？我觉得可能很多房子是不会拆迁的吧？否则只要现在买这些房子，以后都发财了。\n是否拆迁的只是很少部分？\nkkndme：\n将来多数房都会拆迁，这是中国体制和经济发展模式决定的。在城市拆迁改造升级过程中，大量的老房拆毁，大量的新房拔地而起。而随着拆迁改造的成本的上升，房子也越来越贵。 现在拆迁改造集中建设70-90的小户型，将来会沦为新的城中村，通过二手置换，这类房子会变成新的贫民窟，而将来的拆迁改造建设的一定是追求环境品质的大户型。 因为zf官员任期的限制，决定了官员的短视，决定了城市规划的短视。 但是市中心的房子，即使在将来人口下降的过程中，仍然是稀缺的，房价高不可攀的。如果手有余钱首选的是市中心的大户型。 关于市中心老旧二手房的购买，还是有一定学问的，一定要选择位置好，低密度的矮层住宅楼，因为密度低，便于拆迁。而密度高的塔楼拆迁非常困难，拆迁成本太高，开发商很难有利可图。现在住在市中心高层旧式塔楼的富裕人口，将来一定会二次置业，这些旧式塔楼逐渐会沦为新一代年轻中产阶层的过渡性住房。\n投资新房还是老公房 wofuleyumin1：\n楼主。。谢谢你的答复\n我接着问\n你说现在投资是投资一套新房好，，还是找个老公房投资？\n新房，，一切都好，但价格贵。。\n老公房，一切都不好，但价格便宜。。主要是等拆迁。。但可能要等七八年。。（从我近2年的观察，一般都要这么久。。除非有内部消息）\nkkndme：\n有钱当然是新房舒服。\n老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。\n关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。\nwofuleyumin1：\n有钱当然是新房舒服。 老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。 。。。。。。。。。。。。。。。。。。。\n楼主的意思是。。还是投资新房比较好？\nkkndme：\n还是量力而行，买老公房也比不买强，有条件当然买新房。\n高端盘有房价带动作用 wofuleyumin1：\n楼主。。。又有一个问题\n我附近的普通房子大概9000 旁边有个02年的别墅现在13000 现在又有一个新的楼盘开盘了。。是电梯 容积3 十多层的 是中海的高端项目，装修过的 居然卖将近2万。。。离谱吗？旁边容积0.8的老别墅才13000啊\n请问中海这个项目是否价格过高？ 另外，这个项目对我这附近的房价能拉动多少？\nkkndme：\n高端房产，开发商都是不急着卖的，而且也从来不乏有钱人慷慨解囊。你说的情况跟昆明的空间俊园完全相同。在市中心徘徊在万元关口的时候，空间俊园直接开出了19000的均价，之后市中心的二手房紧随攀升到15000.而一环二环间的房价在万元关口徘徊。\n大盘高端盘对房价的带动作用是显而易见的。\n自调控刚刚推出的时候，与一个朋友闲聊，说起调控将是二三线城市大涨的机会，还聊了聊昆明的发展，结果那个朋友头顶调控的大棒，去昆明投了n套房产，当时价格7000多点，时过几个月，现在看房价已经涨到9000.而且他买的位置周边先后有高端大盘推出，预计开盘价格在12000-15000，一旦高端大盘开盘将让他买的房子直接迈上万元的台阶。\n买房和没买房的差距 汝爱之罪：\n新穷三代。。。ORZ 我可不想做穷一代。。。。\n房子真的让人抓狂，当跟你同样起点的人早你三年买房的时候，这种感觉尤为明显。\n我老公是77年的，他一个女同学2007年底在清河新城买了一套房，一百多平100多万吧，找家里东拼西凑的全款。其实当时我老公也能拿出100w不用借钱的，可是他偏不听我的话，认为清河在五环外，那种地方还要100多万不可思议。结果北京经历了09年的疯狂以后他同学那套房子已经翻倍，借的钱也已经还清。\n而我们呢，在犹豫和老公的优柔寡断中错过了时机，终于在2010年3月最疯狂的时候入手了，这时候即使首付160多万，还要背负100多万的贷款，生活质量比他的女同学差的不是一点半点。\n这是真实发生的事情，犹豫和无知真的能让人付出很大的代价。\nkkndme：\n清河新城好像是50年产权吧。反正我对50年产权的都不感冒。 我一朋友06年买的水木天成，买时5000多，现在25000，调控都不带降价的。\n汝爱之罪：\n清河新城盘子还是很大的，分好几期，有70年也有50年，他们买的是70年的。07年底刚开第一期，相当于股市里的打新股了，基本上没什么风险。\n房产交易历史 最早的房产交易，出现在一个名字叫“盉”的西周青铜器上。在公元前919年农历三月份，一个叫矩伯的人分两次把一千三百亩土地抵押给一个叫裘卫的人，换来了价值一百串贝壳的几件奢侈品，包括两块玉，一件鹿皮披肩，一条带花的围裙。\n周厉王三十二年又发生了一宗土地买卖。这宗土地买卖的交易过程也被刻在青铜器上。\n这次记录的是周厉王买地的事，周厉王为扩建王宫，买下一个叫鬲从的人的地，没有立即给钱。鬲从担心周厉王赖账，周厉王派人对鬲从说：“你别怕，我一定会照价付款的，如果我赖账，就让上天罚我被流放好了。”这是个很毒的誓。\n周厉王买地花了多少钱，铭文上没写。不过李开周说，有人买地，有人卖地，说明当时除了有土地抵押，还存在土地买卖，房地产市场已经有了雏形。\n隋唐时，有个叫窦乂的人，他生在陕西，很小的时候就死了爹娘，无依无靠，跟着舅舅一块儿生活。\n他舅舅是个公务员，住在长安城。窦乂先通过卖鞋、卖树等生意赚了一些钱，后来有了80万钱的身家，于是开始向房地产行业进军。\n当时长安西市有一个废弃的化粪池，面积不小，有十几亩，闲置七八年了，一直没人买。窦乂把它买了下来，雇人填平，在上面盖了20间店铺，租给波斯胡人做生意，平均每天都收上来几千钱的房租。\n再后来，窦乂听说当朝太尉李晟喜欢打马球，于是斥资70万钱买下一块地，又花30万钱把这块地建成一片马球场，送给了李晟。\n李晟很高兴，从此跟窦乂结成死党，有求必应。有这种靠山保驾护航，窦乂发得更快了，不到40岁就成了长安首富，人称“窦半城”。\n除了像窦乂这样的开发商，古代的业余开发商还有一些是公务员、退休干部等，甚至官府自己就是开发商。\n比如在北宋，中央政府下面就有个专门搞开发的机构，叫做“修完京城所”。这个机构本来只能是修筑城墙和宫殿，后来城墙修得差不多了，宫殿也盖得够豪华了，这个机构就开始转型，开始给中央财政搞创收。\n怎么搞创收呢？修完京城所向朝廷请示，划拨给他们大片地皮，他们在上面盖住宅盖店铺，盖好了，有的卖给老百姓，有的赁给老百姓，给国库做了很大贡献。\n古代是没有专业的开发商的。做开发商最需要的是钱。买地、买建材、雇人、摆平关系，哪个环节都得花钱。尤其买地，流动资金不能少，钱不够，就得找同行拆借，或者找银行贷款。\n古代没有银行，但有钱庄，可是钱庄规模一般很小，即使有一些大型的全国连锁的钱庄，他们也不做开发商的生意，都把钱借给别的老板了。\n史料上有这样两个办理房地产抵押贷款的例子，一个是南北朝时候的梁朝郡王萧宏，让人家拿着房契去贷款，一张房契最多只贷给几千钱；还有一个是明朝嘉庆年间山阴县的一个富户，名叫求仲，最多的一次才贷给15000文。这点儿钱别说搞开发，吃一顿大餐都不够。 直到民国时期，外国银行纷纷到中国开展业务，开发商们才能贷到大笔的贷款。所以中国的职业开发商直到民国才出现。\n古代开发商如果大量囤地得挨板子\n以唐朝为例。唐玄宗在位时，土地政策里有这么一条：“应给园宅地者，良口三口以下给一亩，每三口加一亩，贱口五口给一亩，每五口加一亩，……诸买地者不得过本制。”意思就是说，政府给老百姓划拨宅基地，划拨的宅基地大小取决于家庭等级和家庭人口，如果是平民家庭，每三口人给一亩宅基；如果是贱民家庭，每五口人给一亩宅基。另外老百姓也可以购买宅基，但是购买的面积有限，不能超过政府规定的指标。\n政府规定的指标是多少呢？平民家庭买地，每三口人，最多只能买一亩宅基；如果是贱民家庭买地，每五口人，才能买一亩宅基。\n在唐朝，商人也属于贱民，再有钱的商人也是贱民，贱民老板去买地，即使是上百口人的大家庭，最多也只能购买20亩地，用这20亩地搞开发，一两年就倒腾光了。而如果超标大量买地会怎么样呢？\n唐朝法律规定：“诸占田过限者，一亩笞十。”意思是买地超过指标的，得挨板子，每超出一亩指标，挨10大板。\n虽然古代开发商没有现如今的开发商这么“牛”，环境和政策对他们都不太有利，但是在拆迁问题上，始终还是开发商们占优势。就比如窦乂，他就知道要搞房地产，首先得朝上有人，于是傍上了当朝太尉。\n古代拆迁过程更为暴力，因为普天之下，莫非王土，国家要用哪里就用哪里。\n当然，在古代，也不乏一些民主的君主。例如北宋元丰六年(1083年)，开封外城向外拓展，规划中的新修城墙要占用120户居民的住宅，宋神宗让开封府制定拆迁补偿计划，开封府写报告说，总共需要补偿款两万零六百贯，平均每户至少能拿到补偿款171贯。\n契税的历史 关于契税、物业税或者房产税，其实也不是现在的创造或者纯粹的拿来主义。\n早在东晋时期，就开始收契税，当时叫“散估”，这也是中国第一个有据可查的契税。其后，几乎所有朝代都有契税。\n唐初魏征等人写出了房产税的实质：“其实利在剥削也”——当时“剥削”没有现今这么贬义，与“增加财政收入”是一个意思。\n从税率上看，东晋税率为4%，隋唐税率是5%，宋代4%，元明清三朝基本是3%。我们现在的契税大户型也是3%。\n万历三十三年，利玛窦在北京宣武门附近买了处房子，他在意大利、葡萄牙、印度都呆过，那些地方并没有“契税”这一说，所以他也没有去有关部门办理手续。\n《大明律》规定：“凡典买田宅不税契者，笞五十，仍追田宅一半价钱入官。”好在利玛窦同志上面有人，托了户部官吏，最后交了一笔可观的滞纳金了事。\n相比之下，“物业税”这税种兴起较晚，而且断断续续。公元783年，唐德宗向长安城内拥有房产的市民开征物业税，叫作“间架税”，乃是按照房屋的等级和间架计税，上等房屋每年每间缴纳两千文，中等房屋一千，下等房屋五百。\n结果民怨载道，当年深秋五万军兵哗变，口号就是“不税汝间架”。迫于压力，784年唐德宗废止了这个税种，也就是说，中国第一个正规的物业税仅仅活跃了半年就夭折了。\n到了五代十国，梁唐晋汉周的每一代帝王都曾征收物业税，不过鉴于“间架税”惹过乱子，改叫“屋税”。\n北宋物业税不是常设税种。南宋由于军费困难，每年两次向城乡居民征收屋税。元代，不叫间架税或屋税了，改叫“产钱”，按地基面积征稻米若干或折成钱若干。明朝，物业税不常设，江浙地区小范围征收过一段，叫“房廊钱”。清代，物业税也不常设，往往临时征收，比如1676年由于对吴三桂用兵，朝廷财政紧张，康熙下诏“税天下市房”，规定“不论内房多寡，惟计门面间架，每间税银二钱，一年即止。”算下来，是只对门面房征税，二钱税额相当于两斗大米或七斤白糖的价钱，不多。\n总而言之，无论是间架税、屋税、地基钱、产钱、房捐，都是不折不扣的物业税。只不过，它们与国际上通行的物业税是不同的——不是为了调节需求，而是单纯地敛财。\n然而物业税在中国并不能成为常设税种，因为这个税是纯粹的苛捐杂税，税又比较重，很容易激化矛盾，直接结果是百姓吃不起饭，太容易导致大规模的农民运动，所以很难持续征收。\n廉租房的历史 言及公房和廉租房系统，最是宋朝搞得好。\n宋朝原则上不分房，京官无论大小，一律租房居住，宰相那样的高干都是如此。偶尔有“赐第”，只照顾部级领导和有军功的将军。算起来大家的住房自有率不高。\n南宋初年，大量流亡人口涌进杭州，三十平方公里的杭州城一度住了一百万人口，人口密度接近上海浦西。\n因人多地少房价高，居民普遍租住公房。除了大规模公房出租，宋朝还有住房救济体制，一是灾年对租住公房的市民减免房租；二是政府建房（福田院、居养院）免费安置流民和赤贫民众；三是修建比公房条件要差的简易房，但是租金更低，堪称“廉租房”。此外，宋朝还有安济坊——慈善医疗，还有漏泽园——安葬无人认领的尸身，比较有人性。\n如果是公务员的话，生在元代也还不错。建国开始，就给半数京官和所有地方官分了房，叫“系官房舍”。一般分不到的市民以自主建房为主导，但是盖房不用买地，政府批给一块官地，然后每月交一次租金，时称“地基钱。”\n满人刚进北京那会儿，也给领导们分房子。一品官二十间，二品官十五间，三品官十二间，四品官十间，五品官七间，六、七品官四间，八品官三间，不入流小军官每人两间。按照每间十五平方米估算，从一品官的三百平方米、到小军官的三十平方米不等。\n廉租房主要由寺观经营。土地由政府划拨，建房资金由民众捐献，房产维护可以从香火钱里冲销，僧尼道士理论上讲不以盈利为目的，再加上信仰需要，正适合执掌这项半慈善业务。大都市的庙宇常有上千间客房，供应试的学生、出门的商旅和遭了天灾的百姓临时居住。\n《西厢记》里张生和崔莺莺在山西停留一整月，在那永济县普救寺里，莺莺住西厢，张生住东厢，该故事充分说明：在廉租房里也可能发生爱情。\n到了明清两代，又多出个廉租房的来源，便是会馆。在这异乡人建立的聚会场所里，客房租金相当便宜。顺治十八年建于北京的漳州会馆，福建人来租住，只象征性地收取租金：每月三文钱！\n历史上买房最好的朝代 历朝历代，哪朝买房最容易呢？\n南北朝最不靠谱，贫富相差极为悬殊，普通居民收入只有几千，房价则是几百万。谢灵运那样的大财阀“左江右湖，南北二山”，房价都被他们给炒上去了。\n唐朝不用说啊，我们都知道“居长安，大不易”，而且士大夫时兴攀比，为了写诗题名好看，非得有个别墅不行。比如王维有辋川别业，岑参有南溪别业，杜牧有樊川别业，就是白居易本人，后来也在洛阳买了十七亩地，修了个“履道园”。\n宋朝文人叶梦得说：“人未有无产而致富者也。有好便田产，可买则买之……勿计厚值。”这话一再被地主老财们重复。有点闲钱，买房子置地，不惜一切代价。\n明代买房也不是件容易事。《金瓶梅》第五十六回，西门庆的结义兄弟要买房，朋友帮他算了算帐，“一间门面，一间客座，一间床房，一间厨灶——四间房子是少不得的。论着价银，也得三四千多银子”。小户型房子，要三四千两银子。而清河县县令，从七品国家公务员，每年薪水不过三百五十两。就是说，就算县长去买房，如果不贪污的话，需要十年不吃不喝才能攒够房钱。明代楼市虚火上延，与攀比之风分不开。尽管明太祖规定，任何人不得超越等级建房，例如居民门窗不得使用朱红油漆；庶民住房不得超过三间；功臣宅邸两边可以保留五丈空地；军民房屋不许建成五间或九间；寺观庵院不得使用斗拱。但如小说里所说，庶民西门庆“现住着门面五间到底七进的房子”，超标超大发了。\n嘉靖年间，大家纷纷打肿脸充胖子，浙江人的房子必须带客厅了，江西人的房子必须带兽头了，江苏人的房子里必须摆上时尚家具和精美古玩了。明朝中叶，北京的地皮已经涨到每亩纹银两千两，就是折成人民币也有好几十万。\n未来房地产市场的发展 中年不惑吗：\n楼主旅行结束呢？\n将来房租市场会如何演化？\n房租涨的太多，如果大多数租客的收入承担不起该如何？\n例如租客的平均工资4000元/月，你让他和别人合租一个小两室要6000元 他们承担不起恐怕就只能离开这个城市了\nkkndme：\n公租房具有平准作用，zf要敛财，不能定价太低，但也不会高的离谱。有了这个参照物，个人普通房出租应该保持在比公租房稍高水平，当然位置好的高端房精装房也可能租出天价。\n中国的房价在未来将成为多数群众遥不可及的梦想，也可以说大多数人都不再关心商品房的房价涨跌。\n未来，租房将成为常态，所以房子的位置环境装修的档次不同，房租的差距将会非常明显。但好房子一定只有中等收入以上家庭才租得起。\n而买房子是富人阶层的事，中等收入家庭想都不敢想。\n中年不惑吗：\n呵呵，将来，只要中等收入的家庭2个月的收入能买1平米，他们也会买房子的\n难道将来的房价要涨到中等收入家庭半年甚至更长的时间才能买1平米？\nkkndme：\n除了房价高，贷款也没那么容易。而且除了房子，各方面的花销都会涨得离谱，这是太平盛世后期的普遍规律。\n关键还在于体制外的中产，都是逆水行舟，一旦不能前进，就可能沦为赤贫。\n房产到期 不明真相的草民：\n向LZ请教\n商品房的土地证年限有多重要？\n现在一个二线城市的开发区，中心地段很多小区房子倒是新盖的，但地是90年代初拿的，有40年、50年的，还有30年20年的，大部分房子的土地证从现在算起只有10几年20几年，有的房子土地证已经到期了，但由于位置较好所以房价一点不便宜。按KFS的说法，土地证到期将来再续就是了，没有大的影响。\nLZ给分析一下，这样房子将来的风险在哪？如果买来自住又如何？\n谢谢！\nkkndme：\n其实有无土地证都无所谓，无论有没有土地证，最大的风险都在dfzf，人治社会法律文件其实就是一张纸，关键还是zf做得不要太过份。\n即使你证件齐全zf想拆一定会拆，即使没有土地证拆的时候也会同样补偿。\n这个东西实在没多大意义。\n不明真相的草民：\n感谢LZ答复。都是新建的高层，应该不会轻易拆迁，这么说自住还好。但如果将来要出手是否就存在困难？？\n期望LZ继续指明。\nLz似乎没有看到这个问题，再次感谢Lz，望答复。\nkkndme：\n出手不存在困难。二手房交易国家不会对土地证进行严格限制，关键还是房产证。\n买学区房问题 开洋木瓜：\n楼主，有个问题想咨询一下。\n家在南京，郊区有一套自住房，130平，市值大概150万左右。市中心有一套小公房，居住权，目前空置（刚分到的，还没有装修，而且单位也禁止对外出租）。现在宝宝一岁，想给宝宝买个学区房，很多名校都要求提前三年落户，所以必须要在2年内买房。一线的学区房单价在2万2-2万6之间。一线小学的分校学区房在1万5-2万之间。我想买的是一个名小的分校，近几年的小升初成绩都非常不错，可以进入南京前三名。\n我想买的一个房子位于这个小学的学区，是拆迁安置房，97年的房子，小区环境比较杂乱，没有物管，停车也不方便。但是周围配套都非常齐全，菜场超市医院都很近，上学也不用过马路。今年年初，2月份的时候我本来在这个小区买了一套，但因为房价上涨房主违约。当时买的房价是12500，现在看中一套，房主要17000，挂了很久没卖掉，我出15000，可能有机会成交。\n这个隔壁有个新小区，物管环境都很好，但价格也上到2万一平了，如果要在这个新小区买房，我们家里的钱就不够了，如果要卖掉现有的房子去买，老公也不愿意。\n还有个问题是，房主要求净得价，12月的时候满五年，就不用付营业税。如果现在交易过户也可以，但要多付几万块。如果算上这几万的税，房价就差不多一万七一平了，我也不愿意现在过户多付这个钱。如果现在签约等12月再交易过户会不会有风险？另外现在是否是出手时机？请楼主赐教。\nkkndme：\n学区房即使在调控最严厉的时期也几乎不可能下跌。但是在上涨期就很难买到，因为房东会跳价。\n12月过户有一定风险，如果到12月时，房价上涨比较厉害，房东有可能违约。\n制约房东违约的方法就是签较高的违约金。\n历史的结局 Peter_Takeshi：\nLZ写的不错，有些意见不敢苟同。 LZ既然熟读历史，又在安抚众人去接受被统治的命运，那能否告知最后的结局呢？ 是否跟前几十个朝代一样？呵呵~ 人性几千年从未根本改变，所以即使过程不同，结局仍旧是一样。 谁上台都改变不了这一切。\nkkndme：\n历史上的结局三条路： 和平演变——在中国好像没发生过，今后也不可能，没有土壤 大革命——哪次也少不了 外来入侵——这个也比较靠谱\nfacetowall：\n对lz的深厚的历史功底十分佩服。lz说改朝换代的方式有三种：1.和平演变；2.农民qiyi；3.外族入侵。我觉得前苏联的解体看似像是和平演变吧，第2、3条好像不符合。lz说zhongguo无和平演变的土壤，但是前苏联好像也没有啊。这该如何解释呢？\nkkndme：\n苏联的文化背景与中国完全不同。我国是自秦以来进入帝国时代，是一个上千年大一统的国家。 而苏联是在近代革命后才出现的。俄罗斯的主要人种是斯拉夫人，在日耳曼民族眼中是奴隶的意思，人种低劣。中世纪叫做罗斯地区，由基辅公国、莫斯科公国、立陶宛公国等多个公国割据，在元代一直附属于拔都建立的金帐汗国。罗斯诸国在西方中世纪非常弱小，直到波兰立陶宛联军大破德意志的条顿骑士团后，才逐渐强大。俄罗斯于1721年彼得大帝时期才开始崛起，19世纪末才成为帝国主义国家，根本就没有大一统的土壤存在，这也就是苏联能够和平演变，而中国不行的原因。\n人口普查 平静的房奴：\n看来楼主今天比较空闲，一口气发了这么多帖子。\n有个问题想青椒哈楼主，我在武汉，最近武汉在全免清理个人和家庭住房信息，晚上调查人员还上门登记、记录，请问这是何意？是否在为出台房产税做准备。\nkkndme：\n人口普查。不但武汉，连穷山沟里也在忙这个，穷乡僻壤的支书天天忙得不亦乐乎。这是第六次人口普查，前面查过五次了\n昆山房价分析与买房 買房難：\n樓主﹐麻煩你分析一下昆山的房價吧﹐先謝謝﹗﹗\n昆山是一個縣級市﹐原先是屬于蘇州的﹐離上海很近﹐動車只要20分鐘﹐現在高鐵也開通了﹐原先房價還算便宜的﹐現在連鎮上也貴到五千多六千了﹐市中心最便宜的也要七千多八千﹐09年10月的時候一下子漲了很多﹐原先我看好的一套二手房32萬﹐現在要50多萬﹐太奇怪了\nkkndme：\n昆山不能理解为县级市，要理解为上海的卫星城。相当于北京的燕郊。所以房子八千多一点也不奇怪。\n買房難：\n謝謝樓主回復﹗昆山市中心的房子大一點的開發商開發的如世茂在一萬左右一平﹐這個價位算不算高啊﹖\n買房子要在市中心好點呢﹐還是城東靠近上海方向好些﹖\n昆山很小的﹐就那么几個鎮﹐現在火車站﹐汽車站﹐高鐵﹐人才市場都在城南﹐另外除市中心的玉山鎮外﹐其它的都是工廠很多﹐污染還是多。\nkkndme：\n买在哪里合适，你要看zf规划，跟着zf规划走。比如房山，zf打造的是长阳而不是老的镇中心，所以买房就应当买在长阳。道理是一样的。\n为什么现在租售比这么低 \u0026amp; 同小区买一套大还是两套小 我爱的飞飞：\n对待房子，我的看法是这样的，50-60年代的人，兄弟姐妹至少5-10个，2004-2020年之间正50、60、70、80、90年代共存的时代，人口达到了爆发阶段，现在好多小年轻70、80代人因为买不起房结不起婚，甚至晚婚索性不育，等50.60后在未来20-30年离世之后，将会有大量的房子空出来。而80后的子女2000后，人口根本不足以养活上一辈。\n我在成都，我的父母是体制内的，我是体制外的80后，刚结婚，老公是体制内的。原家里有一套单位的集资建房，只有小产权，在二线城市的一环内，98年的房子，因为担心迟早有一天拆迁以后没有房子住，小产权也不会赔多好的地段或者得到较好的补偿，再加上以房养房的心理作祟，以及我参加工作以后想从家里独立出来，于是父母在08年底四川地震以后全国大降价赶上好时光在三环外买了一套140的房子，那会儿才买成2900，今年交房以后装修到一半，就有人以双倍价格想买入，父母不卖，留着养老。一年不到翻了一番起来，我结婚以后，也和老公一起在一环附近购入一套小户，8千多。老公家在外省某市有2套，这样算下来，我门要是生一个孩子，以后这孩子手里就有我父母在成都的2套加上老家的1套，我和我老公的1套，孩子爷爷奶奶的2套，一共6套，您说等我父母和老公父母都去世以后，房子嗖的一下就空出来了不少。所以我觉得80后到了四十岁左右肯定都能住上房子，那个时候房子也不再值钱，不过话又说回来，其实我的父母也是年轻的时候住在单位的公房，三十五近四十岁才有了第一套集资建房，而他们的第二套和第三套相对比较快了。所以我现在觉得年轻人还是应该多奋斗吧。但是我真的不清楚，到了房子不缺的时候，那个时候又会炒什么。\n虽然我是土著，也不缺房子，但是压力也不小，特别是还贷，连车也没敢买。有时候我跟LG也想，为啥我们买的房子首付了二十几万，装修十万，我们每个月还还着2500的按揭款，租房客2000就租走了，那不是我们垫着钱给别人提供福利么？向楼主求解。\nkkndme：\n打个比方，假设你打算在某地开个游乐园，竞拍一块地，经过计算当时的门票定价10元一张，根据人流测算，你认为出500万投标这块地，5年可以回本，于是你出了500万，但是别人出到了1000万，你认为1000万要10年回本，风险太大了，于是你放弃了。你冷笑着认为那个傻子一定会赔钱。\n结果过了2年，票价涨到100元一张了，人流量一点也没减小。人家5年就回本了，以后赚的盆满钵满。可是这个生意你却因为太能算计没有做成。\n为什么房价租售比低？\n其中原因之一是现在的房价预期了以后的租金。\n另一个也是最重要的原因就是：现在的房价不够高，说明了很大一部分普通家庭都有希望买得起房，所以宁肯省吃俭用住合租房，为了攒首付。但当房价高到普通家庭不敢问津的时候，这部分中等收入的合租家庭就会放弃买房转而追求租住有一定舒适度的房屋，房屋租金就会上涨到合理的程度。\nwelldayzwb：\n楼主在线啊，真好，这个道理大概也明白，不过现在出于\u0026quot;活雷锋\u0026quot;阶段，心里还是很不舒服 去年底在北五环投资的一套大一居，首付加税款超过60％，贷了30年的公积金，现在房租还是不顶月供，而且空租期很长 很怀疑自己的投资决策，好象不是一个很明智的选择，纠结中\nkkndme：\n当房价快速脱离你的成本区，你的心理就好受了。\nwelldayzwb：\n再多问一句，有机会一步到位买个满意的大房好(也是老房，得房率高，三居)，还是买两套小房，一套凑合着住，一套放租好？\n当然两套小房的总额比一套还是要多不少，帮忙分析一下，短期和长期来看的情况？谢谢！\nkkndme：\n其实买两套同一小区的房子是最好的，投资自住兼顾，可进可退。如果家里有老人，和老人分别居住，又在同一小区，照顾起来很方便。\n买房难之回不去的乡 \u0026amp; 拉美人过得比你想象的好 九五二七八：\n楼主说的以后大部分人买不了房的论题 中美在这个方面的差距 怎么这么大呢 现在产业转移 一部分人就业就有回乡的趋势 今后再有一波转移 会不会再离故乡近一些 这样 分散置业 购买难度会不会下降\nkkndme：\n中美体制不同、文化不同、人口不同。一辆在美国2万美金的汽车，国内要卖几十万人民币。一件made in china的服装美国卖20美金，国内卖900人民币。\n不管一线城市、三三线城市都是人满为患的，从一线城市逃离的也会驻扎在二三线城市，绝没有可能大中型城市向小城市回流。\n返乡潮指的是家有自留地的农民工，如果工资待遇差不多，与其到沿海地区漂泊不如回乡打工或者种地。比如贵州镇远的油漆工一天工资是150，而在珠三角打工一天工资还不到150，这也是大量农民工返乡的原因。\n九五二七八：\n最难的怕是现在三四流的大学生和跟着打工父母生活在城里的二代 失去了农村生活本领 在城里也无法立足 楼主 难道拉美化真的不远了\nkkndme：\n很多人都丑化拉美，但是拉美的生活水平要高过我国。不说远超中国的巴西，即使是法属及荷属圭亚那(苏里南）这样的小国，人民的生活也很富足。\n前几年有个援助项目去苏里南等拉美国家，去之前所有的人给我灌输的都是拉美国家如何贫困。但事实上，这些国家与中国完全不同，国穷民富，藏富于民，与中国正好是相反的，只要勤快点的家庭都还比较富裕。当然不排除也有很多穷人（美国也有很多穷人），穷人一般以当地的黑人为主，好吃懒做，整日无所事事。\n这些国家的人民不如中国人勤奋，从不攒钱，只图眼前享受，我想主要原因还是由于币值不稳定，通货膨胀比较严重，所以没有人愿意攒钱。在拉美国家是无法炒房地产的，比如苏里南平均25平方公里有一口人，真的是地广人稀。所以才保留了世界上最高的森林覆盖率。\n拉美人的懒惰会让中国人瞠目结舌，当地的蔬菜价格昂贵，尽管有大片肥沃的土地，当地却没有人愿意耕种，很多去苏里南种植蔬菜的中国人为此发了大财。\n而相反中国人可以说是全世界最勤劳的民族，但是大量勤劳的中国人却过着低水准的生活。这与中国的国富民穷，藏富于国，与民争利的政策是分不开的。\n拉美国家尽管有这样那样的问题，但是确实是法制国家与民主国家，私人财产神圣不可侵犯，这是与中国完全没有可比性的。\n九五二七八：\n一般对“拉美化”的定义是这个吧：贫富悬殊扩大、腐败严重、国有企业效率低下、社会治安恶化、城市人口过多、地下经济泛滥、对外资依赖性强、金融危机频繁和政局不稳定，等等\n没去过拉美 不知道真实的拉美\nkkndme：\n看来拉美妖魔化后，深入人心了。好比在越南旅游，越南人自己说越南官僚太腐败，我笑了，能有中国腐败？\n拉美的官僚机构，国企、医院、警察我都见识过。\n说到官员的官僚，相比中国我真的觉得那里的官员很亲切。我曾经以一个游客的身份和苏里南的司法部长一起在街边小店喝咖啡。以一个陌生的外国游客身份在财政部长家里做客，逗他家的几个黑小孩玩。\n说到治安，我在街边咖啡店坐了一下午，每二十分钟一辆巡逻车从我身边经过。里约热内卢的治安绝对不会差过广州。\n国有企业效率低下恐怕是全世界的通病，况且拉美根本没有可能赚钱的行业全部由国企垄断。\n政局不稳要看怎么理解，拉美国家是相对民主的国家，国家元首倒是常常因为民众的不满而换届（排除少数经常政变的军政国家）。但人民并没有感觉到不幸福。\n拉美国家的经济基本被美国所控制，所以才会对外资依赖严重和金融危机频繁。作为一个主权国家我们看到的是国家财政贫困，但是作为拉美地区的中下层人民群众，生活水平和幸福感是要高于国内的中下层群众的。\n租房的苦 说到租房举个活生生的例子。\n我有朋友是个房产的死空头，一直租住着北京一套两居室的老公房，租金不高1000多点，所以没什么负担，对买方族恨不能理解。结果今年他租住的那片老公房要拆迁，限期20天内搬家走人，结果终于理解了找房子的辛苦，而且随便租一套两居室也找不到2500以下的了。\n真是心态决定命运。\n北京西三旗 bjwxw：\n楼主在线啊，今天几乎花了大半天的时间从头至尾的看了楼主的帖子，分析和解释的真的很实在到位，也许我了解的不是很多，但是确实觉得现实好多都是这样的，麻烦我现在有个问题，我住在西三旗，我租住的这个小区去年的这个时候价格是60-70左右，我失去了机会，可是今年这些房子基本都是120-140万之间了，我现在是在忍不住，也憋不住了，因为我是刚需，虽然心里是万分的懊丧和后悔，但是事情还的做，房子还是的买，可是我很担忧，我花140万买只隔一年就升值一倍多的房子，后果会是什么，我真的怕等了好久，可是等我出手了，房子真的跌了，尽管不会跌很多，但是把我的首付跌光那也是件很可怕的事，毕竟辛苦的攒了这么多年的钱，我是实实在在像楼主说的那样的底层奋斗着的接近中年的刚需外地人，挣钱太辛苦了，所以很害怕，楼主，我现在也很急，老婆看好了一套140万的房子，要我去买，我也知道她也很无奈了，可是我心里这关好难过啊，想听听你的指点，急盼回音\nkkndme：\n西三旗的房子与不远的立水桥相比，涨速是相当慢的，尽管离市区更近当房价跟回龙观相仿，并没有拉开差距。随着8号线的即将开通，8号线地铁站中央部位保障房项目的启动，西三旗房价上升空间还不小。\n西三旗附近最值得购买的小区是枫丹丽舍，因为低密度将来必定稀缺，但是目前价格也高过其他几个楼盘，甚至高过新盘富力桃园。配套最成熟的小区当属育新小区。象硅谷先锋、森林大第也都比较好住。西三旗这片地区属于难得的价值洼地，值得购买。\nbjwxw：\n多谢楼主，看来您真的对西三旗了解的太透彻了，我真的很幸运，我就直接跟您说了吧，我说的房子是龙乡小区，您肯定也很了解，这个是个老小区，房子已经超过了10年，优点就是交通好，周边医院，学校，购物都极其的方便，因为钱有限的原因，只能买这里的，情况就这样，您能给我多说几句吗？多谢\n一着急字都打错了，不好意思\nkkndme：\n龙乡小区的房价在西三旗片区相对较低，因为房子是90年代的，但是周围配套相当齐全，去超市购物也很方便。如果你在上地上班也算比较近，唯一的遗憾就是房子旧了点，户型与2000年后的次新小区相比，有点不尽如人意。\nbjwxw：\n确实是这样，今天通过从头看到尾您的帖子，基本心中已经有了概念，买吧，尽管我从这个小区的70万的房子如今花140万去买这个心理关很难过去，但是还是过吧，既然已经这样了，认命吧，不害羞的问一句，房子价格已经16000了，您说这个地段在将来是会升些，还是会跌一些，呵呵，实在不好意思，添麻烦了\nkkndme：\n这个地区的房价，两年内是可以看到25000的。\n喜欢8号线：\n楼主看好西三旗地区房价，本人深有同感。 西三旗地区的焦点不在京藏高速路口，也不在林翠路路口，而在西三旗东路。也就是地铁8号线西三旗站附近。 现在这附近已经有宾馆、饭店、百汇商品市场、中小学、3甲医院、银行。 到2012年，8号线开通，百汇市场新增电影院，龙旗广场新增写字楼2座和3星级酒店一座， 随着北新建材厂的搬迁，原厂区还会有更多的新楼拔地而起，西三旗东路将南延、拓宽至永泰。整个地区的房价将随着新楼盘的不断推出而节节高升。\nkkndme：\n西三旗地区一直相对滞涨主要还是缺乏大品牌开发商入住，没有高端楼盘的带动，涨幅偏低。但也正因如此，才形成了一块价值洼地，以后才有更大的上涨空间。\n跳坑的青蛙：\n没想到楼主对西三旗地区如此熟悉~ 想问问楼主对于上地附近二手房的看法，如当代城市家园这样的地方，有没有升值潜力？ 觉得这边交通还是有很大问题~\nkkndme：\n上地区域的房产在2008年之前，涨幅较快。但在2008年以后由于上地区域的产业以民营iT为主，属于充分竞争，利润下滑较快的产业，区域经济的发展前景远不如望京，所以上涨空间受限，涨幅趋缓。 区域发展是房价升值的动力，个人不太看好上地区域。\n汝爱之罪：\n对上地一点也不了解，不过今后北京的私企郊区化应该是趋势，好多公司因为成本问题已经开始向密云等地搬家。上地的价格若被炒太高，也难逃此运。\n也许zf会注意到这个发展趋势，引导郊区，现在大力发展郊区地铁就是为今后的卫星城铺路吧。不过能不能成功，是另一回事。里面牵涉利益太多，比如海淀，主导还是高科技产业，如果全都搬家，地区zf就头大了。上地区域，可是海淀政府大力度发展的重点区域。\nkkndme：\n你说的很有道理，现在海淀的it产业基本就是以处于链条底端的制造业，毫无科技科研，急需产业升级，才能得到持续的发展。象联想这样的it公司完全沦为了90年代家电厂商的境遇，毫无未来。\n买房争取一步到位 hohowell：\n楼主，诚心请教下，从开贴开始就一直在潜水关注，终于坚定了买房的决心\n现在在犹豫，一是买个80平米的小户型，开发商一般，房型尚可，这样贷款比较少，基本不影响供车，旅游和以后小孩的开销，不过考虑5到8年左右，这个房子就不能满足居住要求了，回头换，又是一大笔钱，而且城区内的好小区也会越来越小，另外一个就是保利的大户型，开发商物业都靠得住，基本上短期可以不用换，不过贷款至少贷100多万，短期内还会要小孩，压力会比较大，基本手里每个月都没有闲钱了，很容易回到赤贫线，一直犹豫不决，诚心请教楼主解惑，我在南京，一个一线以下二线以上的鬼地方，两处房子都靠地铁，周边商业中心配套齐全，谢谢！\nkkndme：\n买房子如果有能力还是要争取一步到位。将来改善，除非个人有较大的发展，否则将很难很难。而且买楼首选好位置，大开发商，大盘，升值空间才大。\nwelldayzwb：\n看来楼主分析说购房应该一步到位，我就犯了一个错误，用投资的眼光来选择自住房，后来买的两居室比同小区的三居室性价比高很多，但是居住环境不好，临一条小街，所以现在住起来不是很爽，现在调控着价格先不说了，光是现在限制换房的一些条条框框感觉再置换就很麻烦 另外一套买的外面一点，小区环境非常棒，不过当时是被环境给迷惑了，放租的房子管那么多环境做什么，感觉两套房子操作反了 纠结中啊纠结中，现在唯一能安慰自己的就是，买上房子总比没买强，如果去年年底再犹豫一下或是赌气的话，那就真是悲剧了，一个好三居得活活等成质量差些的两居了\n收入稳定的家庭如何买房 黑眼圈钱：\n请教楼主，买房子的事情，比较纠结。\n1）夫妻两人均在西部某高校任职，一个教师，一个行政人员，年龄都不小了，37和35，两人每月总收入在8000-10000，1年算10万收入，应该会多一点。\n一个女儿，才两个多月。 3）每年给双方父母1万，双方父母均已60出头，一方父母城里的有退休金及医保。另一方父母农村的，得为他们准备点钱。\n4）目前租住单位两室一厅房，就在学校住宅小区内，除了小点，别的都好，房租100。\n5）公积金两人很少，约1000元每月，未来1-2年内会有购福利房机会，估计90多平方的旧三室一厅（约需 10万元），可能有120平米的房子，但需要排队看单位建房情况（2000每平米）。\n6）两人都有单位医疗保险。\n7）孩子可以上学校的幼儿园和小学、初中，就在150米范围内。\n8）对于车没有什么想法，每天步行上班用不到车代步。不过会买辆10万左右的。\n9）现在没有任何投资和理财。银行存款1-2年期定期存款50万，这个傻了，已经存2年了，平时光顾着干活。\n有没有必要买个商品房呢，周围的房价从08年的4500涨到现在8500，容积率还非常高，并且楼间距等等不理想，那种房子我不想住的。\n其实在附近买套120平米的房子，首付后也供得起，买房子放那等涨价或者出租？ 不想放弃单位的房子，每天睡到自然醒再去上班还是挺惬意的，送孩子上幼儿园上学也方便。\n买了房子后经济会紧张些，不像现在自由。财务自由也算一种幸福吧，我太太对于房子没什么要求，所以也不给我什么压力。\nkkndme：\n对于工作稳定，收入不错的体制内家庭，基本上的情况就是有闲钱就买房。主要还是由于收入稳定不用担心失业，钱放着只有贬值，不如置业。投资型住房与自住型住房在选择方向上有很大不同。\n举个例子，昆明打造了个螺丝湾，几乎半个昆明做生意的人都聚集在哪里。如果自住没有人愿意选择在那里买房，实在是不好住。但是投资确是最好的选择，因为可以获取较高的租金的收益，将来升值空间也不会小。\n假如在昆明一环附近买一套两居室，月租金一般在1500-1800，而房价在万元左右。而在螺蛳湾附近买一套两居室，月租金都在2000多，而房价在7000多。\n北京回龙观 baiyang11112010：\nLZ,你好，我2010年3月在回龙观买一复试房子120平米，户型不是很好，全部下来，161万，我尽量提前还贷，控制在3-5年以内，所以，这房加利息定能控制在170万以内，我想问的是，3-5年我想出手，会不会亏？\nkkndme：\n你的问题太短了，虽然问了几遍，居然没看见。 回龙观地区的配套设施齐全，积水潭医院入住将提升该地区的物业价值。随着中关村高新区北延规划的利好，回龙观地区的房价在未来两年内有50%左右的上涨空间。\nbaiyang11112010：\n我觉得LZ你的分析思路不错，但是这种涨幅应该不会再有了吧？虽然我今年4月投资了一套，但是，我能回本就行，没敢过分估计，你这样有煽动别人之心啊\nkkndme：\n首先投资房产不是炒股，不能有炒股的心态。目前说起投资房产是最安全的品种，指的是长线投资，而不是短线投机炒房。短线投机炒房还是因政策的不稳定有较高风险的，一旦资金链断掉，将万劫不复。\n对于4月份，在山雨欲来风满楼的特殊时期，投资一线城市郊区房地产肯定是欠考虑的。\n对于房地产调控，主要针对一线城市，且一线城市在09年行情涨幅过大，郊区楼盘一定会受到调控影响，而资金的运作规律告诉我们，调控抑制住了一线城市的投资资金，一定有相当部分转向二三线房价相对不高的城市，大开发商对二三线城市的入住，将加速城市升级。所以调控征兆的开始，正是布局二三线城市的时机，而不是一线城市。：\n值得安慰的是，回龙观地区并没有遭遇疯狂炒作，表现比较抗跌，即使被套损失也不会大。从未来两三年看，回龙观的区位一定会有50%左右的涨幅，这是不用担心的。\n贷款还是全款 jhjdream：\n楼主，请教一下，\n也正是8月初看来楼主的帖子，坚定了我此时买房的决心\n我在3月份卖了一套小房子，8月底买了套大点的，也是学区房，学校在建\n现在考虑一个问题，是全款付清好还是贷款比较好 全款付清，欠亲戚10多万，没有还钱压力，年底可还清，但是手头没有余钱 贷款的话，手头会有20多万余钱，可以装修，或者等年底再攒点钱，投资其他的 所在省会城市房价8000多，偏一点的6000左右。\n装修好出租2500左右，贷款月利息2000左右 也就是说我全款还清，一年相当于收益2.4万的利息及3万的租金，房款70万左右， 是否值得？还是贷款35万比较合适？\n因为考虑到通货膨胀时期，应该是负债比较划算～～ 谢谢！\nkkndme：\n肯定是贷款划算，这是毋庸置疑的。当然如果你的余钱实在找不到其他投资渠道，也可以一次性付清。如有可能也可以贷款买两套，而不是买一套。 70万的总房款月租金达到2500，租售比还是很高的，贷款35万，租金抵月供完全没有问题，说明你所在地区的房价具备较大的上涨空间。\n00后的买房需求从何而来 和风中的树叶：\n看了那么多 有点意思\n不过在下有一事想不明白：\n因中国的计划生育政策 往近了说 人口红利会在这几年消失 往远了说 80后基本都是独生子女 父辈在城市里都是有房子的 这些房子作为遗产 按理说 在未来应该使00后没有买房的需求。 LZ如何解释在这种情况下在未来房子仍然看涨？\nkkndme：\n前面已经说过了，你往前翻。\n和风中的树叶：\nLZ能不能再贴一次？或者说明一下在第几页？谢谢哈~\nkkndme：\n回去找了一下，居然被删了。 大意基本是讲中国经济未来的发展模式，城市升级与拆迁改造的关系，没想到这样也不允许说。实在懒得再长篇大论说一遍。 关键的意思就是一方面是富裕阶层对更高端产品，更大面积的追求，一方面是城市升级带来的大规模拆迁改造。下层群众将被挤出城市核心区。许多住房都会被拆迁置换。\n意大利的住房模式 我本人对意大利的住房模式还是比较赞同的。 有去过米兰的朋友可能很清楚，米兰城区的房屋居住的大多数是富豪显贵，一旦出了城区，则是大片大片鳞次栉比的公租房供普通工薪族居住。 以后的中国有可能学习这个模式，原市中心的居民被拆迁安置到郊区，城区居住的都是达官贵人。郊区将形成拆迁安置房、中产阶级商品房、公租房、廉租房混居的模式。\n中国的学术 97年我大学毕业的第一任老板就是在龙乡小区买的房，我还到他家送礼。那时从城里骑车到西三旗，花了我将近两个小时。一晃就十几年过去了，真是有很多感慨。\n汝爱之罪：\n感觉您是学者型的啊，看您去做田野调查什么的。大学毕业送礼给老板。。。。\n看您点评回龙观的那一段，估计很多人要捶胸顿足的后悔了。回龙观真是个奇迹，从2600涨到15000，让所有人大跌眼镜。\nkkndme：\n送礼也算学者型？晕\n九五二七八：\n他是说本以为你是学者型的 不需要送礼 现在看到你说送礼 觉得自己判断失误了 呵呵 现在这个时代 学者也需要送礼啊\n汝爱之罪：\n差不多这个意思，呵呵。我一直以为楼主是搞学术的。\n其实吧，虽然大多数学者砖家都成了贬义词，但我觉得在北京这个大环境里，还是有土壤培养一些目光敏锐犀利的人，BBS的P民也需要这样有前瞻性的引导者，因为毕竟不是每个人都强大到能把这些东西娓娓道来，没有积淀，根本悟不出。\nkkndme：\n中国的学者是很难拿出点时间好好搞搞学问的，功利性太强。\n以前跟一伙民族学者到元阳考察，这帮人没呆满两个星期就跑回去了，说是又要评职称了，人不能不在单位。而日本学者已经在元阳与当地人同吃同住了3年，还没有一次回日本。真不知道这帮民族学者研究了两个星期的东西能发表什么样的惊世论文出来。\n北京远洋山水 tianxiaobing11：\n不知楼主了解远洋山水吗？在西四环外，我舅舅想在那买房，去年一万七没买，今年最高到过三万，现在两万六左右，能买吗？还有升值空间吗？诚心请教。\nkkndme：\n别提了，08年的那次调控，开盘才1万1，这是个让人悔得肠子都青了的楼盘。 北京的楼市前景，在未来的两三年，北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事，南面可能相对低一点。远洋山水的位置2万6不能算便宜，但将来只有更贵。\n精英的资产 5万一平的房子对于中国的精英阶层真算不上什么。500、600万一套的房子一次性付清的人群在北京大把的存在着。这是很多工薪阶层一辈子都觉得不可能挣到的财富，但对于另外一些人却可以轻而易举的拿出来。平均工资的概念在中国是完全没有用处的。\n北京三环塔楼 bluesyang2010：\n请问楼主，北京三环内的塔楼，80年代末的房子，以后会有什么走向，现在能出手吗？谢谢\nkkndme：\n三环内都是老公房，干嘛不买个板楼呢。这种房子老到不好住了，迟早还是要换。板楼还可以拆迁，塔楼拆迁就比较困难了。不过今后的北京可能存在一个相当奇怪的现象，一部分高端富裕人群居住在市中心老旧的小区，而令广大住在远郊的中产阶层羡慕不已。\n普通人买房的未来 baiyang11112010：\n直白说，我刚毕业一年，完全靠着父母资助，要完全靠自己根本买不起房，我一些同学在北京两人的话年薪也就15万左右吧，现在好歹还能惦念着买房，要是像您所说，“北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事”，那他们根本就没有盼头了，这是很可怕的事啊\nkkndme：\n将来年薪20万的中产阶层一定连北京6环内的房子都买不起。这一天，不会很远。\n北京房价超香港 tianxiaobing11：\n金岩石说未来五年房价还得翻一翻，北京核心区域得到二十万一平，真会那样吗？请楼主说说\nkkndme：\n北京北四环，东三环，西三环，南二环内区域的房子，价格一定会超过香港。\ntianxiaobing11：\n香港怎么也得几十万一平吧，还是得早买房，早买早心安\nkkndme：\n香港都是按尺算的。富翁住的千尺豪宅相当于我们的大约100平米。现在香港的房价换算成平米大概是十五、六万一平吧。\n中国的新闻不可信，精英的有钱是你想象不到的 bluesyang2010：\n搂主分析一下,现在的新闻都说房屋成交量的上升是因为kfs打折才上升的,但这个很不成立,为什么新闻这么懵老百姓.是不是政策上还有可能收得更紧?\nkkndme：\n中国的新闻最不可信，为了抓眼球不惜胡编乱造，不惜前后自相矛盾。我倒觉得这个成交量放大的背后的意义更值得深入研究。\n在二套房首付50%，三套房首付更是严格控制的前提下，成交量大幅提升，中国的货币到底泛滥到何种程度，中国的精英阶层的绝对数量多么庞大，手里多么有钱。中国的贫富差距很可能已经达到了一般人不敢想象的程度。\n这是一个坏的预兆。\n40年的商住房没有70年的住宅有投资价值 klid：\nLZ 请教一下，市中心没有天然气的房子能买么？自住兼投资\nkkndme：\n商改住，40年产权？ 不影响出租，但是变现可能不那么容易。\nklid：\n是70年产权住宅，但是不通天然气！ LZ请教一下啦，可以自住兼投资么\nklid：\n自住只要你觉得不用天然气也很方便，当然没问题。\n投资首先是出租不存在问题，另外市中心的位置可以填补任何房屋设计方面的不足，70年产权具备投资价值。购买这样的房产还是可以的。\n限贷对精英没用 tianxiaobing11：\n楼主，我也是不明白，现在成交量确实上来了，按说现在贷款控制的这么严，第三套房都贷不到款，是谁在买房，难道都是第一套房的刚需吗\nkkndme：\n民币发行泛滥，有钱人绝对数量庞大。在北京上海等城市，手中拥有千万现金的人不在少数，都是全国的精英阶层啊。精英阶层的财富积累已经逐步完成，提高首付，严控贷款只能抑制小白领保值的需求，但对于精英阶层是没有任何作用的。\n如果将来推出房产税就更好笑了。精英阶层谈笑风声，小白领神情紧张，最终结果是全部转嫁租房客。\nbluesyang2010：\n我认为,这个跟kfs和政府之间的博弈有很大关系,投资人前段时间一直在观望或者投入到农产品等领域,我不记得是7月还是8月,突然听到热钱大量涌入国内房地产市场的传闻,之后成交量就上来了,这些信息之间有很大的关系,但我捋不清. 请楼主评评\nkkndme:：\n你说的很有道理，当资金泛滥无处可去，一定会找到一个出口。资金如洪水在于疏而不在于堵，资金一旦冲破调控所筑的堤坝，将一发不可收拾。所以屡次调控屡次暴涨。如果不能有效开渠，将注定调控政策的失败。\ntianxiaobing11:：\n我现在就被抑制住了，现在是认房不认贷，我也不能贷款了，可现在动不动就得百万以上才能买房，真是力不从心啊，房贷新政看来是堵塞了中低收入的房产投资渠道了，对精英阶层反而是利好，这调控就搞笑了\nbluesyang2010:：\nzf倒是想调控精英层呢,但zf本身就是精英的组成部分,所以zf只能借砍掉投机者之名,开拓自身,抢占市场,特别是楼主说的租赁这个大市场,所以特别佩服楼主之前说的:zf找到了吃租赁这块蛋糕的最好时机,明着是抑制房价,其果却是让很大部分老百姓租着zf的房,zf的钱就更多了,到时候想拆哪儿拆哪儿,精英更精英,百姓更百姓\u0026hellip;.可悲呀\nkkndme:：\n估计给政府出这主意的幕僚熟读过宋史，宋代官府就是靠出租房给群众敛财的。\n外汇管制决定了大部分有钱人只能在国内投资 tianxiaobing11：\n还有一个问题始终不明白，请教楼主，现在五六百万的房子都有人全款买，这些人为什么不买国外的别墅呢？难道就因为中国的房子升值快吗？要我有那么多钱早移民了\nkkndme：\n我国实行的是外汇管制，人民币不能自由兑换，不可能大批人口通过地下钱庄转移资产。只有官员和少部分有背景的高端人士才能做到人民币资产顺利兑换转移。\n一旦发现较多资金量的人民币兑换美元出境，国家将采取强制管制措施。\n现在国家对外汇外流已经非常重视，携带价值50美元以上的商品入境都要交税，实际上国家给出了一个不希望人民币兑换成外币外流的一个强烈信号。\n外国国籍在中国生活是更好的选择 理财的猫咪：\n我有段动过移民的念头，但现在基本放弃了。不知自己的选择正确与否，想听听楼主高见。\nkkndme：\n移民不见得能够适应，毕竟文化差异太大，但是如果拥有一个外国国籍，在中国生活，是一个比较好的选择，至少，你的财产是受到保护的。\n分期付款买房，如果房价上涨，很容易毁约 \u0026amp; 自住要选大品牌开发商 showcar:：\n楼主说的正确啊，除非世界经济再次崩溃或者朝内变天，否则的房价要跌，太难！\n到处听说是纸币不受截至的发行，有点现金留在手上都发抖啊，是因为“贬值”发抖！\n所以，出手了，淘一套保值去吧！！总价150万左右。\n楼主请教付款方式： 1：分期付款，30%首付，6个月内付30%， 12个月内付30%，10%交房前付清（约24个月）； 2：商业银行贷款，需要50%首付，50%余款贷款，首付3个月后按揭，110%的贷款利息。 商业贷款的话，计划交房后就付清。\n不知道哪个更合算？期待楼主解惑。。。。\nkkndme:：\n分期付款是你和房东的约定？这个比较不靠谱，如果是付清后过户，一旦房价上涨，很可能出现毁约。\nshowcar:：\n楼主，忘记说了，是期房，我们这里是房子盖到一层高就预售了。房子结顶是按揭。结顶后1年半左右交付。\nkkndme:：\n貌似你们那里的房产商很不规范。我还是觉得投资自住都要选择大开发商、大体量楼盘，不仅配套好，升值空间也大，这样的楼盘几乎没有风险。\n通货膨胀和房价的关系 要解释通膨和房价的关系，我来建个简单的模型，跟大家说说\n假设5年前，某个国家一共有10个一篮子生活必须品（包括吃，穿，住，行的所有的必需品），这个国家发行了100万货币，一共有10个人。那么这个国家的毎个篮子生活必须品价值10万。\n假设这10个人每人得到了10万元收入，则每个人刚好分配了一个篮子。\n实际情况是，这10个人中，有人得到了10万元，有人得到了8万元，有人得到12万元。那么这10个篮子通过在品质上的差别有所区分，卖给这10个人，刚好1人1份，只不过有的品质略好些，有的品质略差些。 时间过了5年，这个国家增加到20个一篮子生活必须品，人口还是10个人，但是发行了1000万的货币，那么这个国家的毎个篮子生活必须品价值50万。价格翻了5倍。如果每个人平均是100万，则每个人可以得到2篮子生活必需品，生活提高了。但实际上是，这10个人中，4个穷人每人还是10万，3个普通人每人是20万，剩下3个富人每人300万。\n这3个富人共900万可以买掉18个一篮子生活必需品。剩下7个人只能分配到2个一篮子生活必需品。这样势必有人会饿死。而且无论是穷人还是普通人都买不起任何一个一篮子生活必需品。社会不可能只有富人才配生存，没有穷人，富人就不会存在。\n因此必须有一项物品能够从一篮子生活必须品中剥离出来，吸收掉富人庞大的资金，同时也要让穷人和普通人能够买的起一篮子生活必需品中能够维持生命的最基本的生活品。\n于是就要把一篮子生活必须品进行拆分。找到一项物品，不拥有不会饿死，但拥有能够让人过的舒服，具备高的使用价值，能够保存，具备稀缺性。\n这个东西就是具备产权房屋（注意不是使用权），而一篮子生活必须品中其他的东西都不具备这个条件。 吃的不能保存，\n衣服不具备稀缺性，\n土地和房屋，是生产，居住，商业贸易的必需品，可以保存，具备稀缺性，富人拥有房屋土地的所有权可以租给普通人和穷人进行生产和居住。土地和房屋超过租金部分的溢价就变成了富人中吸收资金，炫耀财富的特殊品。\n所以请注意，真正吸收大量发行的被富人拥有的货币的，是土地和房屋超过租金部分的溢价，所以房屋的租售比很低是货币大量发行造成的。房屋土地租金成为了新的一篮子货币中的必需品，而房屋土地所有权被剥离出来变成了富人之间货币再分配的游戏。 这样一篮子生活必须品进行了重新定义，本来包括的房屋，变成了房屋租金，而房屋所有权被从一篮子生活必须品中剥离出来，变成了吸收富人多出来的货币的奢嗜品。而一篮子生活品分成两大类，即最基本的和品质高的。\n最基本的又变成了10万一个，保证这个国家的4个穷人可以每人得到一份。\n品质高的，20万一个,3个普通人和3个富人每人得到一份就可以得到较好品质的生活。\n多出来的840万，就是房屋的所有权，供3个富人拥有。房屋所有权的价格远高于租金，这是因为房屋所有权已经变成了富人炫耀的资本，身份的象征。 因此说，高房价的根本原因是由于货币发行泛滥和收入分配不公。这个根本问题不解决房价不可能下降。\n而且单纯的依靠行政手段让房价下跌不但不能抑制通货膨胀，多出来的流动泛滥的货币得不到有效吸收，会推动生活必需品上涨，使穷人的生活更加艰难。 当然，有人的说，这多出来的840万为什么不投入到创新领域带动需求，增加一篮子生活必须品的品质。\n这显然是不现实的，900万的财富集中在3个人手里，剩余7个人总共只分到100万，而平均一篮子生活必需品的价格是50万，7个人应该有350才能满足生活需要。购买力的不足一定会使远离生活必须品的任何东西都没有市场。\n高房价，低租金是货币泛滥发行和分配不公的必然结果，而不是推动通货膨胀的，阻碍实体经济发展的原因。\n货币泛滥和分配不公才是实体经济发展困难，房价高企的根本原因\nfataltomato：\n有钱人的投资渠道一般都不是房子\n房子最多是资产配置中的一项\n开始投房收租，说明财富控制能力的下滑，往往意味着人生下坡路的开始\n所以诸君，还是努力赚钱改变人生为第一要务\n评来论去，于事无补\n别人说到了，你不一定明白，你明白了，不一定有体会\n你有体会，不一定能做到，你做到了，不一定能做好\n你做好了，还不一定有机会呢，呵呵\nwelldayzwb：\n对于不善理财的人来说，买房收租未尝不是一个选择，到没必要上纲上线，当然为了收租而买房，目前看起来不是很理想的一个选择\n南京买房分析 \u0026amp; 买房要做好调查分析工作 闲坐庭前也：\n楼主，一直跟帖， 觉得你的认识颇有见解 请教一下 最近看了南京奥体附近的仁恒楼盘 2万2左右每平方 不是自住，用做投资的话现在出手是否合适呢？ 一直在犹豫中 望不吝赐教\nkkndme：\n尽管南京去过多次，但对于那里的楼盘并不熟悉，所以不敢妄言。如果能够提供更详细的信息，或许可以试着为你分析。但以你目前提供的信息，真的不好评判\n闲坐庭前也：\n恩， 详细的话就是南京河西奥体那块推出了仁恒G53精装公寓 简称高汤，90平方复式上下两层的，180万左右 我对南京不太了解 有人说2014青奥会召开， 有点升值空间 我不准备贷款 因为平时也不怎么会理财 全付可以95折 楼主，请问我能买进吗？ 汗一个先，我买房好像总买在高点呢 泪奔 不知道这次怎么样 楼主不吝赐教哦！！！\nkkndme：\n房产毕竟是一笔相当大的投资，对于一个不了解的城市，就轻易购买，显得过于轻率。青奥会是噱头但不是利好，对于房产的长期升值没有任何促进作用，充其量也不过有些资金参与短线炒作。 经济的发展才是一个城市房价上升的驱动力。 建议在你购买之前，认真去南京进行考察。不但要考察周边楼盘，还要考察你所购买地区的经济发展状况、交通状况、商业和学校的分布。最好能够了解当地政府的规划。\n北京华清嘉园 dog19972009：\n请教楼主点评华清嘉园的房子以及上地一带的房子，谢谢楼主！\nkkndme：\n学区房，房价坚挺，配套齐全，环境也还凑活，紧邻轻轨，唯一的遗憾就是交通比较拥堵。如果有钱是可以考虑的。但是绝大多数人只能对华清嘉园的高房价兴叹了。我预计两到三年内，华清嘉园就将冲击5万关口。 上地可参加前两页的评述。\ndog19972009：\n谢谢楼主，但如果是上地的低密度低板房格局朝向及位置都较好的小3居可以考虑吗？另外知春路一带的九十年代的塔楼还有板房可以考虑吗？\nkkndme：\n北四环周围有许多不错的小区，都值得考虑，无论自住还是投资都还是比较合适的。比如志新村、塔院、牡丹园小区等等，配套齐全，居住舒适，特别是志新村还是学区房，这一片区位肯定是好过上地的。缺点就是户型较老，物业等于没有。\n中国的朝代更替 中国与西方最大的不同，是历次革命都要推倒重来，革命总是伴随着血琳琳的屠杀和破坏，无论是财富还是文化。每次建朝人民都要从一穷二白做起，所以才说中国人民苦难深重，几千年的历史，居然没有什么积累，有的只是统治者根深蒂固的帝王思想世代传承。 从项羽焚烧阿房宫到近代的破四旧，革命的都非常彻底，人民洗脑也非常彻底。所以帝国时代才能够一直延续。西方人贪婪对财富是占有和继承，东方人重义轻利所以破坏焚烧和屠杀。\n西方的大革命产生了资产阶级新贵阶层，然而当时却不为普通群众接受，尽管他们有钱有势，但是却得不到群众的尊敬，直到资产阶级新贵们捐钱捐物，为群众做了大量的善事之后，才得到人民的认可。 而我们这个时代产生的新贵却太多的为富不仁。\n而中国古代的乡村，通常族长就是村子里的大地主，族长是非常重视名胜的，一个族长必须有足够的威望，象修桥补路，借无米下锅的族人粮食，都是族长份内的事。去徽州旅游的人都知道，道路、桥梁等公益设施无不是富商修建。古人不但讲个人声望，还讲积阴功。假设你去贵州的深山中旅游，发现山径上常常有个亭子，不但有坐的地方，还有水井或者用水管从山上引来的泉水供路人休息。这都是周围的村里人为积阴功修建的，绝非政府投资。 时值社会主义的今天，反而一切行善积德的事都不讲了，全民金钱至上。没有文化建设的民族是悲哀的。\n中国可以无限印钞吗 tianxiaobing11:：\n中国可以无限印钞票吗？有没有个限度呢？我是请教楼主，肉食者会怎么思考呢？他们的幕僚能从历史中找到答案吗？楼主的历史资料库中有这方面的吗？\nkkndme:：\n如果你收集过铜钱，你会发现有一种大钱叫一当十五。这就是中国古代的铸钱方式。当铜不够了，zf用铸造2枚铜钱的铜铸造一枚大钱当作十五个大钱用。那时还没有纸币，所以采取了这种方法。 到了解放战争时期，物品紧缺，国军大量印制金圆券，今天用一捆钱没一斤米，明天用同样一捆钱却只能买一两米。当然这种金圆券无限制满天飞也和我军大量投放伪币有关。 当物质紧缺时，必然会通过发行纸币来缓和矛盾。小时候我常去买2毛钱的肉馅包一顿饺子，现在2毛钱仍在大街上也没人捡。肉馅从2毛钱涨到4块钱，货币贬值了20倍。为什么我们认可肉馅从2毛钱涨到4块钱的既定事实，但是却不能想象现在的物价会在未来的10年再涨20倍呢。 如果你收集过邮票，会发现50年代的老有票的票面价格都是500元一张，1000元一张，我们建国后的货币也并不是一开始就是圆角分的。50年代圆是最基本的货币单位，随便买个最小的东西，都是1000元起步的，很象现在的越南盾。 我们国家的印钞制度，主要跟外汇挂钩，在帖子里已经做过了描述，你可以在帖子里找一找。正是由于国内商品的内需不足，完全依靠低附加值商品出口创汇，才造成了人民币的外升内贬。\n读史读的不是故事，还是找历史规律，以古鉴今 读史读的不是故事，还是找历史规律，以古鉴今，毛就是这方面的天才。 读史难在古人常常作假，事件往往扑朔迷离，必须象破案一样，从重重的迷雾中寻找真相，这也是读史的乐趣所在啊。 好比喜欢三国的度魏延，总认为此人天生反骨。事实上，魏延作为仅次于关张马黄（没有赵云，赵云的才能和级别都不能和魏延相比）的第五员上将，在关张马黄死后，成为了西蜀的军方顶梁柱，不但有极高的军事天赋，而且忠心耿耿，不足的是政治头脑不大灵光，结果诸葛亮刚死，就被小人杨仪给黑了，不但掉了脑袋，还被按上了背主的罪名。\n汝爱之罪：\n《三国演义》里这一段完全是黑魏延来着。 我心里还想，其实魏延还是比较大度的，马谡刚愎自用的时候，诸葛亮很不爽，但是魏延还一个劲的替马谡说好话，我就觉得魏延一直忠心耿耿，怎么可能晚节不保呢？\n唉，看来正史和演义，还是有很大区别啊\nkkndme：\n正史里很多信息都是极其可疑的，就更别说演义了，呵呵。 每次听评书赤壁大战一段，诸葛亮给关张布置任务就觉得好笑，赤壁大战时诸葛亮官拜军师中郎将，官职远不如关张，关张不可能直接听诸葛亮的将令。当时，诸葛亮顶多给刘备出出主意，调兵遣将还应该是刘备的事。演义一夸张诸葛亮，，就没刘备什么事了。\n毛太阳的往事 当年毛太阳发动文ge的原因是因为政府被刘奇和邓平的政经系所把持\n当年要是老毛召开人大来决定谁去谁留，老毛肯定被PK掉\n如此不发动底层，通过正常的程序夺不回权利\n什么防止腐败，打到走资派都是借口\n毛太阳比任何人都要腐败\n死的时候存款有1亿多（不是工资积攒的，都是稿费，垄断市场的稿费）\n70几年的时候，1亿多，确实恐怖\n但是后来被邓平给没收了，讽刺呀，以这是全党的财富为由\n北京大兴 VVVMMMABC：\n楼主,现在大兴的房子新楼盘较多,某楼盘推出两次均卖光光.地理位置占尽优势,因为紧挨着将要建好的地铁.现在能出手买吗?首套,没有立马买房结婚的压力,但三四年内总得买吧.首付提高后也就刚刚好付首付.要是利率也真的不打折,真不知道如何是好.\nkkndme：\n通州、房山、大兴都是前期炒作比较厉害的区域，在楼市调控期要慎重购买，如果遇到明显低于周边二手房的楼盘可以立即下手购买，否则观望。\nVVVMMMABC：\n楼主圣明,楼主说得明显低于周边二手房的话是指大于多少一平的时候呢?现在的二手房和新房都互相盯着呢,都差不多\nkkndme：\n一般来说调控期内，郊区新盘比调控前的周边二手房大约低10-20%%之间，且成交放量，说明底部已见。\n贵阳 努力看透：\n楼主，谢谢你对贵州的关注！ 我是贵阳的，想听听你对贵阳的看法，我07年在小河区2400买了120平方的新房子，今年八月初买了套市里的二手房，93年的，65平方，学区房，总价43万，送家具家电！ 非常想听听你对贵阳房市的看法，还有金阳新区的看法，感觉金阳就是房地产撑起的，如果地产有个风吹草动，金阳会是最容易受打击的，不知对否？ 另外93年的老房子以后卖时不好贷款，是不是会影响成交价格？ 谢谢\nkkndme：\n刚从贵阳回来没多久，呵呵。 贵阳投资房产有一定的风险，主要是城市比较小，不好变现。如果我在贵阳投资，即使再贵也会选择喷水池附近市中心的楼盘，稀缺性较强，变现相对容易。 贵阳是一个城区尚未开始升级改造的城市，zf大力打造金阳花溪等外围区域，但是将来一定会遇到较大的交通瓶颈，城区的升级改造早晚都要启动。 关于金阳实际上就是政府的造城运动，因为市政府的搬迁对房价有一定的支撑力，但是随着人口的大量入住，从金阳到主城的交通可能出现瘫痪状态，谁又能保证政府不进行二次搬迁呢？ 贵阳的美女确实很多啊，是这个城市最靓丽的风景，令人留恋。\n努力看透：\u2028贵阳小了，为什么房子不容易变现呢？毕竟全省只有贵阳繁华点，地方小，人多，更应该容易变现啊！我指的是市区房，不含郊区\nkkndme：\n市中心中高档房屋变现是没问题的，但市中心老房变现也不是很容易。贵阳的城中心改造升级还没有启动，市区存在大量的老公房，而贵阳最需要的是改善型中高端住房。现在zf全力打造金阳等外延区域，大片的新楼盘拔地而起，二手房交易的活跃度远不如其他省会城市。\n贵阳与成都、昆明这些西部城市略有区别，昆明、成都有大量的外地人口，这些外地人口构成了买房刚需，因此市区位置的稀缺性就显得尤为重要。 但是贵阳的外地人口相较昆明、成都要少，以本地改善型需求为主，所以城区楼盘的档次尤为重要。 作为相邻的省会城市，重庆的吸引力要大于贵阳，贵州许多地州的资金可能会被重庆分流。\n富人越富、穷人越穷 我爱的飞飞：\n其实很多空军比较SB，天天叫着加息，说是提高收入就可以买得起房子，试问穷人手里10万，富人有100万，按照现在的利息，穷人每年整存整取10万不开税收是2250元，而富人得到的是22500，加息以后假设穷人每年收入是4000，富人是40000万，成千上万的富人每年多出40000，而生产资料和资源是有限的，当每个富人的4万流入市场，试问是不是又要通膨呢？所以加息是最愚蠢的均贫富方法。行之有效的办法其实是重新发行货币。但是除了改朝换代几乎不可能。 其实穷人一穷就注定穷下去，除了少数几个可以翻身，原因很简单，因为生产资料掌握在富人手中，富人为什么有生产资料的支配和拥有权，答案很简单，只有革ming。 由此则可以明白为什么房子可以按照富人的想法定价，就因为土地，建材等生产资料掌握在富人手中。 妄想房子降价其实是更愚蠢的想法，为什么？GCD拼命给公务员和arm加薪，这些钱用印刷机印出来发到公务员手里最终却让老百姓埋单？统治阶层当然首先第一位维护和最大化自己的利益，任何朝代都是如此，只有当民心涣散的时候才出台一些政策缓和民心。现在看CCAV，对社会主义这充满美好想象的词的强调都逐渐弱化了，你不得不承认，在GCD的领导下大家都有肉吃了，国家安定，在这里嚷嚷的，不过是对贫富不均不满而已。\nkkndme：\n今年朝鲜搞货币改革，重新发行货币，结果导致不可控的通货膨胀，财政部长给枪毙了。\n我爱的飞飞：\n所以民众还是愚蠢的，只看到了15元最后换成1元的落差和失落，没有看到除去附加值的生产资料的价值。货币改革是富人最不愿意看到的，跟加息是一个道理，因为改革让货币的附加值骤然缩水，富人的货币不再比穷人有更多的附加值，而统治阶级恰恰是富人，没人愿意搬石头砸自己的脚。所以为什么我说不可能。\n通货膨胀的形成原因 我爱的飞飞：\n在谈谈通膨是怎么形成的。生产资料是有限的，生产资料其实一直都没有变，而货币只是一种虚拟附加值而已。像楼主所言，一个国家，有人手里有8元（假设他是建材行业的），有人有12元（假设是石油行业的），但是人心不足蛇吞象，建材行业的员工觉得不够用了，8元的想变成13元，石油行业的12元想变成20元。因此，建材行业把原来卖8元的水龙头提价成13元，对于石油行业的人，装修的时候拿着12元发现自己买不了13元的龙头了，于是琢磨着把石油卖到20元，由此各行业依次提价，物价越来越高，实际上水龙头还是水龙头，一桶石油还是一桶石油，生产资料始终没有变，稀少，远远不够人均分配，但是生产资料的价值变了，提高了。拿成都的房价为例，02年的时候成都人均收入800-1200，房价2000-4000，约为房价的3倍，现在成都人均收入2500-3000，成都房价7500左右，仍然为3倍比例，看似7500比2000翻了多翻，实际上房子作为所谓的生产资料，始终是稀缺的，在02年的时候，拿着当时的工资买4000的房子仍然不容易。任何时候，其实都是一种相对平衡的比例，而空军喜欢拿现在的工资跟过去的房价相比，但是那种状态太过理想，想明白的，就会觉得房子不贵。\n什么时候房价会下降，一句话供求关系，人口减少是房价下降的唯一出路。即便是出台房产税，很有可能富人顶着房产税不卖，变相加租抵消房产税，特别当今租房市场存在中介的操纵，很多房子都是通过中介渠道才租出，垄断的中介忽悠房东集体涨价，房产税很容易就转嫁给租房者。ZF也不是完全不作为，当你开着车逛着公园坐着快铁地铁的时候，就应该加速印刷的钞票有一部分投入了基础设施建设，如果不通过税收和出让土地收入来建设，我们很可能还走在乡间小路上。\n虽然瓷器国是中yang高度集权的国家，但是任何朝代都是诸侯之间相互制约，上面出台个政策，各个诸侯执行与否或者执行是否到位都可以影响房价甚至很大影响，且不谈上面是不是真的想降房价，即便是动真格，下面的诸侯听不听招呼是另外一回事。有心无力的事情不是不可能发生。共同富裕其实是一种美好愿望，因为人与人的竞争天性，不可能人人平等，只要有人还想凌驾于其他人之上，就永远不可能GC主义。\n任何社会都是这样的形态，忍无可忍-geming-平稳-不满足-垄断与剥削-改革-改革失败-再次忍无可忍。为何历史反反复复如此？就是因为人的劣根性，因为人性的贪婪。所以周而复始而已。\n人性的贪婪决定了社会进程，刚开始穷人只想平均，从富人手中夺取生产资料，当GEming之后，穷人开始不满足于仅仅是平均，穷人想要凌驾于其他人之上，想变成富人，于是利用geming占有的各种手段获取利益，最终变成了富人，被凌驾的穷人再次想通过变革改变自己的地位。。。。如此循环。。。\n深圳 \u0026amp; 昆明仇书记 \u0026amp; 通货膨胀体制内高枕无忧、体制外自求多福 sprina0321：\n楼主真是高人啊，追了两天，终于看完了。也想向楼主请教下房事\n不知楼主对深圳了解吗，我们来深圳七年了，结婚也好几年了，可是最近才去布吉买了首套，布吉的可园，二手，单价一万四。现在深圳关内10年的二手都一万六，好一点的两万，关内基本没新房了，有的都3万左右了。大量的新房都在关外，基本2万吧。我们本来也想买关内，可是想着同样的价格在关外可以买好点的，就买了关外，不知这个决定是否正确？按楼主的意思，还是要买市中心，可是市中心的话，只能牺牲面积，房子也旧，这样住着也不舒服啊。\n另外，我父母就在昆明，他们本来在一环上有套房改房，挺方便的，就像楼主说的，可恨的仇书记要制造需求，现在他们的房子说是要拆了，他们现在想买，可是一环外的都8000多，他们觉得有点贵，买了以后，手上的钱就都用完了，又想干脆等回迁。楼主觉得要不要买呢？ 我父母就我一个孩子，他们在深圳买过一套房子，就是市中心的塔楼，等我们不住了，这套房子要不要卖掉，还是留着出租好？\nkkndme：\n深圳不太了解，不过宁肯牺牲点品质也要选择市中心，这是无数人经过从市中心搬到郊区大户型再搬回市中心老房子而取得的宝贵经验，当然如果你在关外上班就另当别论了。 往历史人物上套，qh应该算作集酷吏与奸佞于一身，横施暴（）政早晚落到身败名裂的下场，不是不报时候未到。等拆迁主要是在昆明风险比较大，几年不知道能建起来，志远综合体就是很好的例子，如果有能力不妨先买一套。\n至于说房子卖不卖关键你是否需要用钱，如果不需要，又没有更好的投资，不妨先留着。\nsprina0321：\n我有时候想，像QH这样的人应该不得好死，断子绝孙，老天还真是不长眼。\n请楼主明示 志远综合体是怎么回事\n我父母家就在东站，董家湾中间那里，原来厂里也在，现在厂子搬到开发区了，家里的房子也逃脱不了被拆迁的命运了。 现在家里在一环出去点看中一个房子，房子挺不错的，大社区，新房，算下来9000多，不便宜啊。一环内的估计我们买不起，家里人年纪大了，想住电梯房。\n楼主对昆明现在的房价怎么看呢，会不会回调，感觉今年涨很多。 现在9000，难道以后涨到2万，和深圳现在价格一样？我和老公也工作很多年了，现在年收入30多万，我们都买不起2万的，我们去看过万科在深圳的新盘，房子没得说，带精装修，2万多一平，一套要300万，虽然很心动，也只能放弃，怎么现在昆明人这么有钱了？ 按照通货膨胀来说，如果以后昆明的房子卖2万，那深圳的岂不是要卖4万，那我们的收入也会涨到60多万吗？哈哈，实在算不过来了。通货膨胀对我们的收入有影响吗\nkkndme：\n一环外9000多的新盘，昆明还真没几个，滨江俊圆9000多，但容积率太高，又有大量的回迁户，个人很不看好。翡翠湾达到了12000，云上城、翠园等要开的楼盘估计开盘价也要上万了。呵呵 昆明的房价，我预计市中心将达到2万，一环二环间15000，滇池板块将达到12000，北市区及世博板块将达到1万。东市和西市在8000-9000。螺丝湾板块最不确定，但未来不会低于9000。 志远综合体早在几年前完成了莲花池片区的拆迁，但迟迟不动工盖房，时隔几年一点动静都没有，拆迁户没有买房的现在还在租房住。\n关于通货膨胀问题，体制内的职工工资一定会与时俱进的。体制外人员的薪水不取决于通货膨胀，而是取决于行业的利润率，企业的利润和个人的能力运气。对于多数竞争激烈，产能过剩行业内的民营企业一般员工，工资增长是很难抵御通胀的，而且由于通胀导致生产成本的价格上涨，减薪甚至裁员的可能反而更大。\n长春 wkzjx2008：\n楼主你好，请帮我分析一下，谢谢\n我在长春\n长春的市政府在前几年的时候搬到了城市的南部，南部因为是空地，所以盖的都是新盘，价钱现在7000多，而我工作的所在的位置是原来的一个商业区，这里原来都是学校，医院和一些机关单位，好企业的家属楼，因为原来的购买力强所以居民楼的一楼都变成了小店铺，所以形成了这个城市的一个没有大商场的一片繁华商业区，但现在随着原住民的逐渐迁走，这里租房的人多。但这里有一个优势是离市里最好的小学和高中都很近，这也是这里房价坚挺的原因。现在这里的二手房如果是大户型在5000左右每平米，小户型6000左右，基本都是八九十年代的房子，2000年以后的次新房很少，距离这个区域较近的一个新盘是商住两用的卖到9000多每平\n孩子现在在这上幼儿园，堵车太厉害了，为了孩子我在这租的房子 我现在手里有20万现金，请问这片区域值得购买么，买大的还是小的，我已经贷过一次公积金贷款，现在已经结清\n现在这个城市很远的地方新开的楼盘也要4000多一平米\n请楼主赐教，不胜感激\nkkndme：\n政府所在地区域又是学区房，这样的房子优势还是很大的，但是由于有大体量的老房子存在，将来有可能大规模拆迁，而拆迁补偿却决于zf是否铁腕，如果遇到铁腕领导，补偿额一定不会太高。这是购房的风险。对于非一线城市，新盘的风险肯定小于老房。\n佛山 爱佛僧傲瞪詹牧师： lz高人！ 不知道来过佛山没有？佛山紧邻广州，两地的地铁即将贯通接轨，房价应该会快速飙升，但是另一方面，佛山是个制造业城市，村镇工业高度发达，外来打工的比较多，流动性很大，lz所说的，今后买房只是有钱人游戏，房租会高涨，这点对佛山这样的小城市不知道成不成立？村镇里还是有很多便宜的出租屋的，高端点的打工者，如果房租太贵，应该会嫌贵干脆回家发展，最后只能留下低端制造业产业工人吧？这样房租应该还是很难上涨。\nkkndme：\n佛山还真没去过，只去过东莞和中山，呵呵。 对于广州一带房价相对偏低的原因是广州并非全省唯一的大型繁华城市，而是广东省内形成了大片的都市群，使得城市的经济得到了均衡的发展。这是最健康的城市发展模式，但也制约了房价的上升空间。随着地铁的贯通接轨，佛山的房价将呈稳步上涨态势。\n首付提高的逻辑 tianxiaobing11：\n请教楼主，最近有银行提高了首付，这是为什么？政府真要让中低层租房子吗？政府吃租赁的大蛋糕吗？\nkkndme：\n主要还是防范金融风险，政府调控的目的从来也不可能是解决穷人的买房问题。恰恰相反，金融风险来自于让穷人买房，所以提高首套房首付比例，杜绝穷人买房，才是防范金融风险的有效手段。同时可以推升租金上涨，政府推出的公租房才有市场，有钱可赚。\n四线城市 shs2009：\n楼主，我们这个城市离武汉60公里，四线城市吧。我打算在新开发的工业园区买一套房子，买的理由是认为工业区是人员比较集中的地方，应该有比较大的需求，无论租售都应该有潜力的。我的看法对吗？\nkkndme：\n四线城市一定要选择城中心或者高档住宅区买房\n苏州工业园 夏天来了我也来：\n我是昨天才看到LZ这个帖子的，一口气读完了，眼睛虽然有些累，但心里却是收获颇丰，今年四月ZY刚开始严厉调控的时候，我可是抱了一百分的信任，心想我们老百姓的好日子终于来了，终于可以用较低的价格买套属于自己的房子了，可现在都九月了，看着周围一直慢慢望上爬的房价，真的是失望极了！ 我九月三号的时候刚定了一套二手房，是我们的第一套房子，不知道LZ是否了解苏州工业园区的发展前景和房价，我们这套房子在园区的中心位置，也相当于市区吧，位置还不错，可就是这个房子属于政府修高速路时的拆迁安置房，房龄有十年了，原来房东的两证上写的土地性质是“出让”，不知道这样的房子以后是否有升值空间？因为在苏州园区同样的地段，同样旧的拆迁房价格基本都快一万了（我们定的这个房子因为离马路有些近，而且在顶楼，户型是小户带阁楼，上下两层复式结构的那种，所以便宜一些，只有八、九千），附近的高档商品房价格也要一万五左右！苏州和上海离的这么近，如你所说，江苏的有钱人都跑到上海买房了，苏州的房价是不是很难涨呢，同时也担心以后房价再继续上涨，ZY会出重拳打击楼市，真到那个时候，房价是不是要暴跌呢？\nkkndme：\n土地性质“出让”没有问题，“划拨”才有问题。 zf初重拳打击的结果往往取得相反的效果，因为政府如果希望继续执政是绝不可能让房地产崩盘的，房地产的崩盘将同时埋葬现有体制，社会“和谐”将不复存在。如何让房地产持续稳定与gdP同步上涨是政府最大的难题，完全取决于领导的智慧，但是以现在的水平来看，是很难做到的。 苏州工业园区房地产不是很了解，但是一个工厂及仓储所在地，缺乏高科技与文化历史底蕴的支持，房价一定会涨，但涨幅一定有限。\n住房公积金利率 facetowall：\n另一个问题啊，我准备用住房公积金购买首套房，在其它的一些帖子上看到政府将在某个时间点上加息，那么对住房公积金的贷款利息（3.87%）会不会同样上调呢？上调幅度会是多少？对这个比较关心，麻烦楼主给解答一下吧。谢谢了！\nkkndme：\n如果当年加息，再次年的元旦后贷款利率也会相应增加，但公积金贷款利率增加的幅度很小，不用担心。加息说明通货膨胀严重，如果不是连续过度加息，对房价没有影响。从长期看更是不可能影响房价上涨趋势，除非经济崩溃。如果经济崩溃，持有纸币也没有意义，等同于废纸。 90年代我国高度通货膨胀，银行存款年利率曾达到百分之十几，但并没有影响房价的上涨趋势。\n济南 \u0026amp; 大规律拆迁的城市房价不会下降 facetowall：\n不知道楼主对济南的房市了解如何？去年接着全运会的东风，济南房价涨了35%到40%，让许多人措手不及。现在市区的新开盘的楼盘依据位置不同大约在8000到13000rmb每平方。济南奥体中心附近的房子在9000到13000rmb每平方吧。我和老婆都在济南高校工作，目前俩人月收入6000+，公积金1100多吧。相比于其它省市地区高校，无论工资还是公积金\n都比较少。我感觉高校老师属于体制内的边缘群体，工作忙(很多人不认同这点)报酬少，并且目前已经没有什么福利分房了，都要到市场上购买商品房。我们的家庭情况是这样的：均为独生子女，目前有一个孩子，二岁了，双方父母均是事业单位退休人员，我父母退休金合计1万每月吧，她父母大约7000.由于我父母在济南有两套房改房，所以现在他们住一套，我们三口住一套，房产证上都是我父母的名字，所以我和老婆属于无房户。目前想买一套房子给岳父母住，毕竟我们俩是独生子女，将来接到济南来住是早晚的事。感觉济南的房价几乎没有下降的可能，因为全济南正处于最火热的拆迁阶段，山东省已经把济南的改造升级列为战略了，并且全国的知名地产商如绿地、中海、保利、绿城、万达(好像万科没有)都来拿地盖房并且已经推向市场了。目前看中了奥体中心附近的一套2005年的二手房，房子很新，毛坯房，环境物业都不错，大约120平米，单价得9100，总价110万。我们想拿出70万现金，再以公积金贷款50万(10万装修)/20年，不知道这样有没有风险。一个是担心房价下跌，再一个加息。请楼主给出明示，指导一下，万分感谢。\nkkndme：\n大规模拆迁的城市，房价没有下降的可能，可以忽略政策因素。既然城市大规模拆迁，就晚买不如早买，这是本贴中一再提到的。\nfacetowall：\n多谢楼主的解惑。感觉济南不像北京上海那样具有巨大的政经优势吸引全国的阔商巨贾和精英汇集，也不像昆明、杭州那样为渡假天堂，还不像西安、南京、武汉那样高校云集具有巨大的教育资源。也就是说济南不能吸引相当多的精英投资，始终是个不温不火的地方，所以济南的房价有点虚，再上涨的话就脱离了实际的承受能力。楼主对此有何看法？\nkkndme：\n济南的地理区位并不差，但城市搞的不好跟领导有关，济南的经济前景不错，而且房价的上涨是拆迁带动的，以后很多城市都会走这一步。\n公务员小区牛逼 何金银银金何：\n不知楼主是否了解哈尔滨的房价？小弟有套小房子 想换大点的，现在可是时机？哎 早拜读你这文章 今年年六月份就能换套大的了，可惜现在搞得自己换不起了……杯具\u0026amp;\n哈尔滨的公务员小区是没有产权的，不知道这种房子买了做第二套之后要不要征税？而且也非常贵，按使用面积要1w多一平了\n小弟小白，您有空给指点指点……\nkkndme：\n公务员小区比房产证和土地证还保险。我国不是一个法制国家，任何颁发的纸质文件的可信度都不高，反而公务员小区因为是特权房，信用度要远高于产权证。\n房屋朝向只要不是纯北西就行 \u0026amp; 买房首选市中心、公园地产 pohangcity：\n楼主。兄弟在一北方省会城市太原，目前这里的商品房平均价为5000左右，上周看了市中心的一套房子，112平米，紧挨市区里的公园（有一大湖），周边就是万达广场，万达的房子均价8500，已经售完，这个房子售价7000，已经是现房，结构还可以，唯一的问题是不是正房，朝向向东，周边一片混乱，全是施工的、拆迁的，说以后要以万达广场为中心，打造太原的CBD，也不知道能不能实现。 房子总价74万，首付24万，按揭月供3400，现家庭年收入税后10万，不可以公积金贷款，我已有一套住房，不过感觉还款压力很大。 我的问题是： 1、楼主帮我房子一下这个房子值不值？我想以后自己居住，现在的房子可出租1500左右。 2、太原也有万达、恒大的楼盘，位置是在太偏，价格6000带精装，户型也好，如何取舍？ 非常谢谢楼主~~~~~~\nkkndme：\n房屋朝向问题，随着城市房价的不断飙升，已经不那么讲究了。只要是不是纯北房或者纯西方，都可以接受。 建议首选还是城中心，特别是公园地产，未来将更稀缺。\n政府搬迁 xhyyhzy：\n楼主您好，从您的帖中收获很多。觉得以前真的被洗脑洗的很厉害，从天涯学到很多。非常感谢您，又让我明白了很多事情。\n请教您，市政府从原来的市中心，搬迁到另外一个地方，相对较远，因为城市不大。好的医院，学校，各种好的资源都在市中心。现在搬到一个特别偏远，荒凉的地方，重新开始建设，政府这么做是什么意思阿？以后这些医院，学校也会搬吗？多浪费阿。另，您怎么看该城市未来房价的变化。（注，离上海很近的3线城市）\n期待您的分析。\nkkndme：\n政府搬迁到郊区不仅仅是个别城市问题，而是大多数二三线城市面临的问题。政府的用意在于扩大城市规模，扩充人口，追求gDP的高速增长，但对于新开发出一块荒郊野地，没有政府的带头搬迁，是很难炒作起来的。政府的迁入是一个信号，告诉老百姓，政府都搬过去了，以后配套肯定不会有问题。于是概念将透支未来，房地产价格就会飙涨。但是未来建成后政府是否真的搬迁就不一定了。 医院和学校全部搬迁会加深社会矛盾，所以通常是在新规划的区域建分校。如果自住还是主城，如果投资投机，可以考虑新城。\n俄罗斯 有同志提起俄罗斯很可以再说一说的。\n俄罗斯的前身叫罗斯公国。首都不在莫斯科，而在基辅。\n建立罗斯公国的，是东斯拉夫人，日耳曼人眼中的劣等民族。有人说过，俄罗斯和西方国家的差别，并不仅仅是经济上的差别，而是民族和文化的差别。这种说法还是很有道理的。用我们现在的话来说，斯拉夫的人种有问题。善于侵略，欺软怕硬，野蛮无礼。这是斯拉夫人的特点。所以在罗斯的土壤，永远出不了骑士精神。\n罗斯人信奉基督教，源于弗拉基米尔一世娶了东罗马帝国安娜公主为妻。所以我们看到的俄罗斯教堂全部是拜占庭式的。拜占庭帝国灭亡后，东正教的中心就搬到俄罗斯。\n罗斯国并不是统一的帝国，而是象我们的西周，搞的是封建分封制（我国在秦以后就不是封建社会了，因为取消了封建分封制，丞相都是打工仔，这一点是与我们的课本不同的），到了十二世纪，礼崩乐坏，罗斯国分裂了，罗斯的周天子弗拉基米尔二世·莫诺马赫的统一大业未能完成，故罗斯的土地上居然出现了十八个公国，很有点象我们的十八路诸侯。\n十三世纪，成吉思汗的孙子，术赤的儿子，英勇的拔都同志西征，一个强大的统一的蒙古帝国攻击分裂的罗斯诸公国，很有点欺负人的味道。于是强大野蛮的东斯拉夫人在金帐汗国的铁蹄下，当了孙子。 莫斯科公国的伊凡一世·达尼洛维奇以贿赂的方式从金帐汗那里获取了弗拉基米尔大公的封号，并把东正教罗斯教区总主教驻地从弗拉基米尔迁到莫斯科。\n莫斯科大公是很有一手的，一面拍金帐汗的马屁，一面组织军队，终于利用金帐汗国的内部分裂，一举击败了马迈汗率领的大帐汗国军队，并且兼并了科斯特罗马公国、加里奇公国、白湖公国、乌格里奇公国、下诺夫哥罗德公国、木罗姆公国和苏霍纳河流域北部等广大东北罗斯地区。\n14世纪，莫斯科大公依凡三世在乌格拉河战役中，迫使阿合马特汗撤退，终于结束了金帐汗国长达两个多世纪的统治。\n直到1713年，莫斯科公国干掉了罗斯地区的绝大多数王公，才形成了统一的集权国家，正式命名为俄罗斯帝国。\n罗斯公国打得最精彩的战役就是楚德湖战役。 对手是称霸普鲁士的赫赫有名的三大骑士团之一，条顿骑士团，欧洲强大到令人恐怖的军事组织。 罗斯的最高指挥官是亚历山大诺夫格罗德公爵。 俄罗斯联军一方有1.5万到1.7万，主要是步兵。而条顿骑士团的大约有1万人，以重骑兵为主，其中大骑士应该不下千人，这是一支让整个欧洲都发抖的军队。 罗斯联军的步兵排成密集队形，据守冰湖东岸。骑士团的重骑兵以楔形阵发起冲锋。按常理看这是一场毫无悬念的战斗，罗斯步兵在强大的世界第一军事组织面前应该不堪一击。 但是亚历山大诺夫格罗德公爵是军事天才，军事才能相当于中国的乐毅。这位乐毅公爵仔细研究了重骑兵的楔形阵，认为弱点在于两翼的防御力量有限，如果重骑不能迅速撕开步兵防线，重骑的两翼会慢慢被侵蚀。 亚历山大同志于是把联军中主要的轻步兵安排在中间，列成加厚的方阵，消磨条顿重骑的突击能力，然后把他自己的诺夫格罗德精锐步兵放在两翼。 条顿骑士团的攻击开始还是成功的，但无法撕开罗斯步兵的军阵。最惨的还是条顿骑士狂妄自大，非要在楚德湖的冰面上发起冲锋（冬天结了冰），可想而知重骑兵跑到冰面上冲锋是什么样的效果，战争逐渐陷入僵持。 亚历山大的精锐步兵攻击骑士团的两翼，骑士团被包围了。亚历山大同志果断的派出最精锐的骑士亲兵卫队，从右翼后方包抄攻击骑士团。 可怜的条顿骑士，拥有世界上最强悍的战力，但在湖面上根本发挥不出来，大量的重装甲骑士掉进冰窟窿里，条顿骑士大团长也被俘虏了。 每次看这段历史，都为条顿骑士团唏嘘不已。\n条顿骑士团败的最惨的是另一场战役，塔能堡。是中世纪欧洲最大规模的战争。 对手是波兰、立陶宛联军。 著名的波兰小说“十字军骑士”就是讲的这段历史。 骑士团的大团长是荣金根，大概有投入1万多名士兵。 波兰、立陶宛联军大约有3万名士兵。 联军方面指挥官是波兰国王Jagiello和立陶宛大侯爵Witold。 条顿骑士大团长荣金根是一个位标准的日耳曼大骑士，开战前，骑居然给波兰国王Jagiello送去两把剑，表示要进行一场骑士之间的较量。斯拉夫人是不敢这么玩命的，立刻拒绝了日耳曼骑士的要求。 条顿骑士团的骑士拥有强大的武力，真不是盖的，荣团长挥动旗枪组织冲锋，立陶宛军立刻溃败，波兰的翼骑兵也根本无法抵挡日耳曼骑士强大的冲击力，准备开始溃逃。这时一个意外发生了，大团长兼倒霉蛋荣金根同志在奋勇冲锋时突然遭了冷箭挂掉了，骑士团缺了指挥官陷入混乱，无法阻止有效的进攻，波兰立陶宛联军乘机组织起冲锋，条顿骑士团莫名其妙的大败。 真是谋事在人，成事在天。强大的条顿骑士的惨遭溃败居然因为一个意外。\n珠海 \u0026amp; 唯一自住房不只是投资 \u0026amp; 调控是最佳的选房时机 期待艳阳天：\n楼主，想就以下问题请教： 1、珠海属几线城市？您对投资珠海的房产前景作何分析？ 2、我一朋友刚出手一套自住的房，打算租房住一段时间，想抄底再入，他是坚信房价会跌派，考虑到目前他供房确实有困难，且对刚出手的那套房不是很满意，请问他的做法是值得借鉴？ 3、我目前的对自住的房朝向及大小不太满意，也想倒手后再入，我目前的房出手的话比同地段的新房价略低10-30%（主要是小区及户型有差异），如果换大、好的承受不了借贷压力，但如果淘二手房的话，可以在附件找比我目前房价低20%左右的二手房，请问我是否可以考虑换个朝向、大小更满意的房？现在是好时机吗？\nkkndme：\n以上，请楼主不吝赐教！\n珠海是个适合居住的城市，干净整洁，生活节奏不快，相当安逸。 将自己唯一一套自住房卖掉，跌了买回，这样做的投机性心理太强，风险很大，往往得不偿失。当然如果为了换更大更好的住房就令当别论了。\n人的一生很短暂，在衣食住行中，住占了人生的大部分时间，有一个温暖的家，生活才觉得安逸。如果有能力确实应该换一套自己满意的舒适的住房。至于出手时机，我觉得房产不是股市，不能总想着抄底逃顶，只要房价的长期上涨趋势未变，调控时期正是选房的最佳时机。\n经济崩溃，最后接盘的是老百姓 vipboy223：\n看了LZ的帖子，受益非浅！谢谢！ 有一个问题还请教下：就像LZ所说，此次调控是ZY布局，赶出炒房者和小的kfs，目的是实现房子的垄断。但从政策和执行看，停止3套房贷并没有真正打击到真的炒房者，至多是改变了预期；二套房首付比例和利率的提高，确实实实在在的把改善性需求排除在外了；现在有些银行对首套房的首付都提高到4成，利率优惠也没有7折优惠了。当然我很愿意相信这次ZF在保护LBX，阻止老百姓去接房产暴利的最后一棒；显然这不是真正的原因。当然，首付和利率提高可以让银行增强金融防范能力。 随意想请教LZ对这个问题的看法；\nkkndme：\n政府阻止老百姓去接最后一棒？晕，如果真的到了崩盘的一天，接最后一棒的一定是老百姓，而且zf会千方百计的让老百姓接最后一棒。 分析问题不能用喜羊羊的头脑。\nvipboy223：\n显然LZ没有仔细看我写的内容。 换种方式问下：改善性需求是否现在就入市？首付高就不说了，利率1.1倍可是很厉害的；\nkkndme：\n如果是忙于拆迁的二三线城市就要抓紧买了，利率高也认了。 如果是一线城市不妨再看一下，但是观望也是有风险的，一旦上涨就买不到合适的房子了。\n命运之矛 荣金根团长的挂掉会不会跟命运之矛有关呢。\n1189年，神圣罗马帝国皇帝红胡子腓特烈一世在与教皇和解后，与狮心王理查一世、腓力二世·奥古斯都开始了第三次十字军东征。然而，红胡子腓特烈一世在小亚细亚渡过萨列法河时竟然意外溺死。原因是他突然丢失了传说中的命运之矛。\n命运之矛也叫郎基努斯之枪。\n正是一个叫郎基努斯的罗马士兵用这杆抢刺入了十字架上耶稣的身体，这只枪因沾有圣血成为圣物。\n传说持有命运之矛的人可以主宰世界的命运，但失去的人会即时毙命，神圣罗马帝国的皇帝红胡子腓特烈一世就拥有这只命运之矛。\n二战时期，希特勒从维也纳博物馆夺取了命运之矛，差不多占领了整个欧洲。但是在1945年4月30日下午2点10分，命运之矛又被美军夺走了，不到2小时，希特勒便吞枪自杀而亡，死时是下午3点30分，这难道仅仅是巧合？\n荣金根是否也拥有过这只命运之矛？\n我以为我们每个人都有一把属于自己的命运之矛，当你得到它的时候，你的事业、家庭、健康、财富都相当不错，但是当你失去它的时候，你的生命也将完结。\n每个人对生命之矛都有自己的理解，希望我们都能够找到它。\n除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘 戈者：\n不要枪，不要炮，我只要选票，有了票，谁不让老百姓好过，就让谁滚蛋\nkkndme：\n我们连依法治国都办不到，何谈选票。 我们是实行双轨制国家，在经济全球一体化的今天，内部并不与外部接轨。这个好比是互联网，我们重要部门的内网是绝不会跟外网联结的。 改变只有两个前提，一是外族入侵，二是出现全国性的大饥荒。否则期望房价崩盘重建一个新世界是没有可能的。\nkkndme聊北宋、唐朝 北宋时期，有个文豪及公务员叫苏东坡，一辈子也没能在首都开封买上房子，不得已，在外省小县城投资了几套房地产。苏文豪公务员的儿子在首都结婚的时候，居然都没搞到一套新房，苏公务员急眼了，最后想办法跟朋友借了一套房子，总算把喜事办了。北宋跟我们的现实还是有区别的，象苏文豪公务员这样的中层国家干部，在京城大都是有几套房子的。可见北宋时期公务员待遇还不如现在。\n苏文豪公务员的弟弟苏辙就比较幸运了。该同志也是公务员国家干部，工作上兢兢业业，勤勤恳恳，熬了几十年工龄，在七十岁的时候终于买到了房子，但是买的位置还算不上首都开封，而是在开封南边的许昌买的，相当于首都的卫星城。就好比在北京买不起房的同志，跑到天津去搞了一套。 苏辙公务员同志专门为买房的事写了诗，“我生发半白，四海无尺椽”，我老未有宅，诸子以为言”诗的意思反正是比较愤青，很想现在的傻空\n唐朝还有个白居易同志，也是个公务员，级别相当于正处级，工作是在中央办公厅负责校对红头文件。白公务员职务一般，但工资可不低，每月一万六千钱。但是白公务员却买不起房，在长安东郊常乐里租了四间茅屋，因为房租比较高，城区的租不起，所以上班比较远，很潇洒的买了一匹马，相当于我们买车。白公务员还是很懂享受生活的，雇了两个保姆，每月的总支出大约是七千五百钱。白公务员很象蜗居里的海萍，不肯高价租城里的好房子，而是把剩下八千五百钱存起来，一心要买套房。但是存了十年，他也没能买的起长安的房子，白公务员兼诗人的文学功底很高，但是不懂经济，不了解通货膨胀。\n最后白公务员急了，很愤青的说：“你们局级干部在长安炒房子，我处级干部就去周边炒房子。”于是白公务员跑到长安城的卫星城——陕西渭南县，买了套房子，平时在单位蹭房子住，逢假期和周末回渭南的家里跟老婆叉叉呕呕。可见唐朝时处级及以下公务员待遇也就跟我们的都市普通小白领差不多。\n宋代房奴 关于房奴，也是宋代就有记载。宋代有本书叫《白獭髓》，写的就是房奴生活：“妻孥皆衣蔽跣足……夜则赁被而居。” 大意就是所有的存款不够，还借来钱砸在房地产上，不得不节衣缩食还债，别说家里人买新衣服，就连被子都是租的。 不知此人炒房后来发财没有，那时买房可都是全款，没有银行贷款一说。\nZG民主 只许州官放火，不许百姓点灯，这就是我们的民主\n王安石的青苗法之国家出政策的动机 关于呼唤国家出政策已达成自己买车买房心愿的空空们，有必要听听王安石变法的故事。\n我国的官僚有几千的当官经验，最不怕的就是新政策，只要是新政策，无论目的是为了民生还是敛财，反正就找到了由头，就有办法敛财，有空子可钻。\n王安石变法的初衷是好的，但是不了解中国的官僚体制，变法让老百姓吃饭都成为了困难，加速了北宋的灭亡。所以盼着出房产税的空空要认真的用脑子想问题，梗着脖子泄愤是没有用处的。\n说说王安石同志的青苗法。\n青苗法，按理说是一项最为民生考虑的政策。\n在百姓青黄不接，缺少粮、钱的时候，让老百姓自己估计当年谷、麦产量，先向官府借钱，谷熟后还给官府，称“青苗钱”。\n青苗法规定把以往为备荒而设的常平仓、广惠仓的钱谷作为本钱。每年分两期，即在需要播种和夏秋未熟的正月和五月，按自愿原则，由农民向政府借贷钱物，收成后加息，随夏秋两税纳官。\n实行青苗法的目的肯定是好的，可以让农民在青黄不接时免受高利贷盘剥、并且让农民不至于在没粮的时候土地被大地主所兼并。同时,让政府获得一大笔“青苗息钱”的收入————单纯为了民生，政府收不到钱的事情王安石同志也不同意。\n按理说，出了这个政策，农民该欢呼了，zf出面了，农民们不用受地主老财剥削了，很多傻空老农民鸡冻的喊：“还是王领导的政策好啊。”\n地方官员也鸡冻了：“太牛了，发财的机会来了，王领导这人人品虽然不怎么样，但是很给我们挣钱的机会啊。”\n于是，王领导的青苗法一推行下去，完全走样了。\n首先青苗息钱从王领导定的年息二分，本来就挺高的贷款20%利率，比我们房贷可高多了。但是就这个年息二分，在地方一下子变成了半年息二分，年利率高达40%：因为是春季发一次贷款，秋季发一次贷款，所以地方官每半年收回本利，还是按二分收，所以变成了半年息二分，年息四分。到了后来地方官想怎么收怎么收，甚至年息高达百分之几百。\n傻空农民立刻傻眼，说反正自愿的，我不贷还不行吗？接着管地主老财借不行吗？\nzf说了：不行。你贷也得贷，不贷也得贷，于是变成了强制高利贷。\n王领导在推行青苗法的时候，还下了定额，贷款多少那是有任务的。任何朝代推行某个政策，只要涉及到收钱，都是有任务的。\n王领导下达了任务，地方官必须完成，不然要罢官丢脑袋，扣个阻碍变法的帽子可不得了，同时本着无利不早起的伟大思想，不但要完成任务还要层层加码。\n这下，傻空老农民彻底傻了，饭都吃不上了。\n结果是王领导给zf增加了税收，官员闷声大发财，老百姓彻底崩溃。\n所以请呼唤房产税的朋友，好好读一下王安石变法\ntjOOSAN:：\n我想 这个 “房产税”出不出。不是什么决策问题吧？\n是我们产权的解释问题！我们产权只有70年，换句话说就是租七十年，地和房子本身还是国家的！那么国家的房产再收税，是不是有点法理不通呢？ 这是 郎咸平说的\n楼主！这个。你让我再次质疑你了\n我其实 很想看进去你的文章！可惜。。。。唉 这成了您的历史秀了~~ 海\nkkndme:：\n连法制国家都不是还提什么法理。\n拆迁条例是违背宪法的，后来又违背了物权法，但是管用的既不是宪法也不是物权法，而是拆迁条例。一群人说要修改条例，牵扯到利益就没了下文。\n有时间你不妨研究一下，看看我们的政策有多少是违反宪法的。 在中国拿法理说事就比较搞笑了\n读懂历史\n对自己真没坏处。\n王安石不但动员zf放高利贷。\n还是我国搞中央政采、垄断企业和官倒的先驱。这就是王领导推行的均输法。\n宋初以来，为了供应京城皇室、百官、军队的消费，在东南六路设置发运使，负责督运各地“上供”物质。 发运司只照章办事，各路丰年物多价贱时不敢多办，歉年物少价贵时却又必须办足。物货运到京城后往往因不合需要而削价抛售，朝廷所需却又要另去搜括。这些做法给富商大贾操纵物价，控制市场，囤积居奇提供了方便。\n王领导希望能够节省劳务费，减少政府的财政支出和减轻人民的负担，就想出了均输法，相当于中央政府采购。\n于是官府直接做生意，行政机构变成了大型国有垄断企业。\n中石化、中石油、中国移动、电力等大企业的苦大家都吃过。\n垄断企业的低效率，fb，强迫定价，强制消费，这些古今中外都是一样。\n而且老百姓跟官府做生意，必须得上供。zf采购那是要多黑有多黑。 紧俏商品，官倒搞双轨制，体制内搞配额，体制外高价卖指标。 结果是zf闷声大发财，老百姓直接崩溃。\n王领导的独断专行，刚愎自用还是很为大家所称道的，呵呵\n张居正的一条鞭法从地主阶级的利益出发，反而成功了。\n而王领导从民生的利益出发，搞改革，失败的很惨。\n不能不说，历史是很搞笑的\n中年不惑吗：\n符合地主阶级利益的张居正变法？？\n怎么后来张被清算呢？\n封建社会官僚本来就是地主阶级的代言人\nkkndme:：\n张同志的清算不是因为变法，而是把万历同志架空了，比皇帝还牛的首辅能活到寿终正寝已经算是奇迹了，跟他的变法无关。\n这位徐阶先生的得意门生，政治上是青出于蓝的，无懈可击，贪污受贿大概也师承徐阶吧，呵呵\n很多人只对张居正同志是否和太后有一腿感兴趣，呵呵\n张居正通常是以正面形象出现，但是在贪污受贿方面是很有一手的。另一个贪污受贿的正面人物是戚继光。\n我国历朝历代的体制，不搞点潜规则什么事都干不成。\n比如一事无成的海瑞，光赢得了个好名，其实毫无建树。\n关于写青词的严嵩搞掉了正值的夏言，忍耐力超强的徐阶搞掉了老奸巨猾的严嵩，心狠手辣的高拱搞掉了徐阶，而张居正又搞掉了高拱。\n这是各机关、企业学习政治斗争的最好案例啊。\n什么是社会公平 古今中外，任何一次武装革命，无论最终成功还是失败，上位者因为野心的极度膨胀，都变得更加专制。陈胜、李自成、朱元璋、罗伯斯皮尔、斯大林、 ，都是一个个鲜活的例子。\n真正公平的社会并不是均贫富、等贵贱的乌托邦，也不是贵族享有领地少女初夜权的强权社会，而是法制社会，大家在一个完善的法律制度下，享有人身和财产自由，知道什么该做什么不该做，法典之下对于任何人都是平等的，无论是平民还是权贵。\n作为爱好和平，小富即安的我等小民，最愿意看到的是社会的稳定而不是动乱。\n还是有很多有钱人 说起空空们们不买房是因为没钱，我还真不相信。\n在某二线城市，调控重拳刚出的时候，我赶紧去买房，碰见一个大姐。\n那个大姐很有意思，说从08年底看房，一直觉得房价高，所以坚决不买，结果等到了2010年，一直盼着降，但是调控政策刚一出就心慌了，害怕后面是大暴涨，赶紧把房买了，这位大姐买房是一次性付款。到现在房价涨了30%。\n双轨制之体制内的福利 汝爱之罪：\n水木社区上有很多愤青打电话给北京建委，举报领秀慧谷捂盘内购的事，我跟了个贴子说不要太幼稚，结果被骂的很惨。今天他们接到建委电话了，说是没有违规。我在想：有这些不明真相的群众存在，房价怎么会跌呢？通胀怎么会停呢？股市IPO怎么会停呢？底层不被收割就奇怪了\nkkndme：\n让北京建委去查国资委就比较搞笑。北京的房优先安置各大部委，剩余很少的部分才用于商品房开发，所以才说北京四环房价5万一平都不算贵。\n开发商思维 鼻使豆豆：\n高房价不可怕，可怕的是没有辩别是非的能力，明明是老百姓，却有开发商的意识，可悲\nkkndme：\n其实这个道理是很浅显的，你不买房并不能代表房价不涨，而你买了房不但可以住的舒适，还可以获利。反而是有开发商的思维才能有好日子过。\n这个道理跟炒股票是相同的。大家知道，股票与房地产不同，并不能创造财富，只是财富再分配的工具，但是财富再分配，是庄家分配散户的钱，而不是散户分配庄家的钱。所以炒股要有庄家的思维才能挣钱。\n道理都是一样的。\n农民政权的缺点 tianxiaobing11：\n请问楼主，为什么历史上的农民起义军领袖，一旦得势后比原来的统治阶级还残暴呢？像黄巢，张献忠等等\nkkndme：\n是因为缺乏一个纲领。\n农民伯伯因为没饭吃拿起武器造反了，造反之后怎么办？——对不起，从来没想过。国家治理到底是怎么回事？——对不起，一概不懂。\n比如陈胜，刚占了一块地盘就不知道姓什么了，老子天下第一，农民暴富后，就想拼命享受，自己的属下和革命战友在自己眼中就是一坨屎，就更别说老百姓了。武装还没胜利呢，就生怕别人夺权，大搞内部政治斗争。吴广挂掉最高兴的就是陈胜。太平天国表现的更是淋漓尽致。\n朱元璋就不同，是个军事天才和政治天才，懂得治国之道，有做皇帝的野心，也懂得当皇帝需要的知识，朱清楚的知道靠均贫富等贵贱是不能坐天下的。\n古代能够夺取天下的，基本都是贵族阶层，有野心有理想有知识。最典型的就是李世民。汉高祖刘邦同样不是单纯的流氓无产者，他幸运的娶了吕雉，一跃成为地主家族的一员。\n历史上只有朱元璋是个异数。这也是毛为什么要推崇朱的原因。\n郑州有前景 larryzs：\n最喜欢看楼主评说历史了\n呵呵，看来历史要重新好好读一下了\n不知道楼主对河南郑州的房价了解吗？\n希望楼主对郑州将来的发展分析一下。\n现在郑州的房价均价也差不多快到6000了，郑东新区的一万以上。\n市政府也在大力修建地铁，个人认为还是有发展前景的。\nkkndme：\n郑州的交通区位决定了经济发展的空间，同意你的说法，很有前景\n公园地产是稀缺资源 klid：\nLZ，省会城市二环边公园边房产和市中心无天然气房产，选择哪个比较好？\nkkndme：\n公园地产未来是稀缺资源，市中心虽好，但是没有天然气毕竟不方便。两者相较还是公园边合适。\n张献忠屠川 关于张献忠屠四川，尽管学术上存在争议，但大致是不差的，虽不见于正史，但《蜀碧》及《求幸福斋随笔》都有记录。很多学者也做了大量的考证。\n张献忠此人曾经读过书，做过zf最基层公务员——捕快，但是被开除了。人格比较扭曲，不但好色，且好杀成性，是典型的流氓无产者。大明的苦难子民指望这样的有严重心理疾病的杀人狂拯救，那是毫无指望的。\n张献忠每攻城略地特别喜欢把当地的妇女同志送进军营当营妓，并且乐此不疲，军队没粮了，就把美丽的少女切成块做成腊肉。把儿童成群的围起来用火烧，谁往外跑就用刀刺，也是张大义军领袖最喜欢的游戏。\n对于张的行为，我们只能用有严重的心理疾病来解释。\n一个仇视社会的愤青，掌握了军队，破坏力是相当可怕的，是人民的灾难。\n张攻陷四川建立大西国政权，与柬埔寨的红色高棉政权简直是异曲同工。以至于清军进入四川受到了百姓的欢迎而不是抵抗。这跟越南入侵柬埔寨，越南军受到了柬埔寨人民的欢迎是多么相似啊。\n人民的眼睛是雪亮的，违反人性的，即使打着爱国的旗号，也终将被人民抛弃。\n洪秀全、黄巢、李自成 洪秀全同志，人生比较悲剧，人家好歹是个落地秀才。洪教主考了20多年，连个秀才都没考上，相当于小学都没毕业。\n洪教主考试不行，搞邪教确是个高手，夜里做梦居然梦见上帝（形象大概是个白胡子老道）说洪教主是他的二儿子。这个梦确实不太靠谱。很可能是洪教主有意编的。\n洪教主的拜上帝教应该算是白莲教的一支或者说是余孽。\n洪教主搞革命，对解放劳苦大众却一点不感冒，最感兴趣的是一夫多妻制，娶了88个后妃。好像历史上的农民军领袖对妇女同志都有出奇好感，大概是小时候性压抑的结果。\n太平天国攻下南京得了半壁江山，洪教主从41岁开始，直到11年后自杀，竟然没出南京城一步。大概是收罗的漂亮的妇女同志太多了，实在没有时间干别的。\n比起张大义军领袖的变态，洪教主还是比较有人性。好色，人之天性。\n不过洪教主进南京，并没有因为女性的爱情滋润，而让他变得温柔。虽然没有张大领袖变态，实行的也是三光政策：杀光、烧光、抢光。\n“凡掳之人，每视其人之手，如掌心红润，十指无重茧者，恒指为妖，或一见即杀，或问答后杀，或不胜刑掠自承为妖杀，或竞捶楚以死。”大意是手上没长茧子的就是妖人，就要统统杀掉。\n农民起义带来的不是均田地等贵贱的乌托邦，而是血腥恐怖\n说起洪教主玩弄的美女确实让人流口水，除了88个妃子外，女官侍婢不计其数，算下来用了11年时间玩了2300名妇女。\n有一本《江南春梦笔记》：王后娘娘下辖爱娘、嬉娘、妙女、姣女等16个名位共208人；24个王妃名下辖姹女、元女等七个名位共960人，两者共计1169人。以上都属嫔妃，都是要和洪秀全同床共枕的。天王府不设太监，所以另外还有许多服役的“女官”。以二品掌率60人各辖女司20人计算，合计为1200人。各项人数加起来，总计有2300多名妇女在天王府陪侍洪秀全一个人。\n一个农民当了教主，就有这样的眼福。换做了傻空当教主，会怎么做？\n黄巢比洪教主学问要高一些，但是屡试不第，当了私盐贩子。\n从起义的第一天开始，黄巢的脑子里也从来没有过百姓该如何如何的。\n他是一个彻头彻尾的投机分子，说是义军，不如说是强盗。\n新唐书中说，贼军所过州县，老百姓皆烧杀殆尽。黄巢的兵可并不懂三大纪律八项注意，那是能抢救抢，抢不了就烧就杀。\n无论是旧唐书、新唐书、还是资治通鉴，从头到尾，就没有出现过黄巢的一句好话。\n黄巢攻陷广州，至少屠杀了十二万人，把皇帝气晕了。\n皇帝还知道体恤子民呢，而黄巢就是彻头彻尾的强盗外加杀人犯。\n黄巢攻进长安当了天子，充分显现了流氓无产者的本质，穷奢极欲，挥霍无度，治理国家的事彷佛就跟他没有一点关系。不搞建设就只能做吃山空，结果长安的粮食都被糟蹋完了。\n长安没有余粮，黄巢就把长安老百姓抓来，煮着吃，十万大军靠吃老百姓过日子。\n幸好老天开眼，官军打进了长安，结果是老百姓对官军夹道欢迎。 农民军真是义军吗？\n不但中国的农民军领袖都是杀人魔鬼的化身，就是法国资产阶级大革命领袖罗伯斯皮尔，同样也是法西斯暴政的先驱者。最后被人民送上了断头台。\n只有一个真正的法制化国家，人民在法律的制约下，享有人身与财产自由，才能够安居乐业。\n李自成在军队纪律上，是要比张献忠高明一点的，所以李自成打进了北京。李自成到北京后，拷贝了黄巢进长安的淫乐经验，对美女极尽淫乱之能事，对百姓烧杀抢劫做的也很出色。\n历代农民军对妇女的态度与《水浒传》中梁山好汉完全相反。\n施耐庵笔下的梁山好汉们似乎对妇女有天生的仇视，动不动就把女同志劈死，李逵甚至终生不尽女色，就凭这一点，我们只能说梁山好汉是农民军中的异类。\n但是梁山好汉不是为了起义，而是为了招安。一群由小公务员和渔民组成的社会最底层群众梦想通过拉山头再跳槽的方式走进金字塔的中层，但是这个梦想破灭了。\n古代历史上，能够治理天下的穷苦人，只有一个：朱元璋。\n朱元璋 为什么朱元璋可以，而别人不可以。\n经过仔细研究发现，朱元璋的人生际遇不像黄巢、张献忠和李自成，他有点像刘邦，但又有很大区别。\n朱元璋是一个到处要饭吃的和尚，但是喜欢思考，见世面，交朋友，并且找到了自己的宗教信仰——明教（也叫摩尼教、白莲教）。\n朱元璋走投无路投奔起义军的时候，娶了起义军濠州大帅郭子兴的义女当老婆，就是那个著名的马皇后。郭子兴并不是一个农民，而是一个大地主，所以朱元璋加入的这个新家族，思想完全不同一个扛着扁担造反的农民。\n郭子兴作为农民军的统帅，却在逛街的路上，被其他的农民军兄弟（真正的农民）绑了票，大概是因为农民对地主阶级比较仇恨。最后被朱元璋救了出来。\n郭子兴看见朱元璋比自己强，反而起了憎恨之心，一心想把朱元璋弄死。\n朱元璋在丰富的人生经历中看到了农民起义军领袖们的鼠目寸光，要想成大事，必须有远大的理想和抱负，而这些是黄巢、张献忠、李自成、洪秀全都没有的。\n朱元璋与那些个农民军领袖最大的不同在于，他熟读历史，因此他把汉高祖刘邦作为榜样。目标是建立一个基业长青的强大统一的国家。\n朱元璋就懂得无论是得到天下，还是治理天下，就必须有能力的人来辅佐。嫉贤妒能的人只能被历史的车轮碾碎。\n曹参治国 人们最希望的，就是在一个良好的社会环境下，安居乐业，自食其力。zf的职责就是健全法制，维护一个良好的环境，剩下的事，交给民间去做。三天两头出政策，过度插手百姓如何过日子，甚至朝令夕改，就会让百姓的正常生产生活无所适从。 早在汉朝初期，曹参已经参悟了这个道理。 曹参是刘邦当亭长时的领导，也是刘邦最亲密的战友。萧何是文官，曹参则是武将，曾经在韩信麾下效力，除了披坚执锐外，最重要的工作就是监视韩信，防止韩大军事家谋反。 这样一个万夫难敌的勇将，却在革命胜利后被分配给齐王刘肥（刘邦的私生子）当相国，主抓齐国的政务。\n曹参是一介武夫，只懂得军事，并不懂治理地方，就用厚礼聘请了精通黄老之术的盖公。盖公认为：治理国家很简单，只要按照律法办事，给老百姓提供一个安全的稳定的环境，其他的都不用管，官府千万不要好大喜功，追求政绩，过多插手百姓的事物，顺其自然就好了。 曹参很赏识盖公，并且按照盖公的话去做，九年的时间，齐国变得非常繁荣。 这时候，传来噩耗，萧何挂了，皇帝刘盈聘请曹参出任相国。曹参上任以后，几乎罢免了所有办事效率高、口才好，有追求有抱负的能吏，提拔了一群只知道按部就班，照章办事的老实巴交的官员，然后就彻底大松心，成天喝酒吃肉听小曲。\n很多人对曹参不满就给皇帝刘盈打小报告，刘盈的表现是很愤怒。 曹参就问刘盈：是陛下你牛呢，还是先皇刘邦牛呢？ 刘盈：当然是先皇牛 曹参又问：那我跟萧何比，谁牛呢？ 刘盈愤怒的说：你比萧何差远了。 曹参做了个总结：您讲的太对了，先皇和萧相国拟定的法令已经非常清楚了，只要贯彻执行下去就好，我只要按照他们的法令办，不就行了吗？ 刘盈虽然不事朝政，但应该算是比较聪明的君主，一听就懂：对于已经定下的治国方针大略，只要执行下去，一定会使人民休养生息，国家富足。如果大搞政绩工程，对于先皇刚死，吕后掌权时期风雨飘摇的大汉来说，将是灾难性的。 民间把成天喝酒吃肉听小曲的曹参称为贤相。司马迁在史记中也给了曹参极高的评价。\n假设一个工程队要盖楼房，起初设计人员设计了20层，刚盖了两层，队长换人了，非要盖成30层，工人于是绞尽脑汁费劲办法改造。等盖到25层的时候，又换队长了，新队长说还是改成两层的别墅吧。刚把楼房都拆掉，别墅建了一半，又来了一个队长，说要建成比迪拜塔还高的大塔楼。这个楼建了n年也没建起来。 建房子跟治国的道理是一样的，我国汉代的相国曹参就已经明白了这个道理。\n晁错 刚才有人提到吴楚七国之乱，讲得是晁错。晁错其人是很值得讲讲的，一个有才能的人在错误的时间做了一个理论上正确的事，却导致吴楚七国之乱，汉景帝差点完蛋。结果是景帝砍了晁错的脑袋。\n这个故事，几乎家喻户晓，蕴藏的道理却很深，大家如果懒得看史料，有兴趣可以参看易中天“帝国的惆怅”，还是很值得一看的\n民营小企业的老板和打工者 糊涂人即使把道理说的再浅显，他也听不明白，呵呵。 现在我国已经进入高通胀期，但是地方巨额债务与人民币的升值又封杀了加息的空间，经济形式有可能恶化，民营小企业的老板和打工者只能自求多福了。\n汝爱之罪：\n刚查了一下央行的数据，8月份的M2是68.75万亿，我没记错的话，7月份的M2控制的很好，基本没怎么涨，但是到了8月份，没想到有那么猛的涨幅，看来不到12月，我国的M2就要到70万亿了。2007年1月份，我国的货币供应量是35万亿。\n今早去小摊买早点，原来一块五的加鸡蛋灌饼现在卖两块。如果涨工资，只会把通胀越推越高，如果不涨工资，P民就要忍受通胀的剥削。真是无语了\n郭解 从古到今，小老百姓遇到不公，受了委屈，幻想最多的就是跳出一个大侠，劫富济贫，为自己伸张正义。所以金庸的小说广为流传，被称为成年人的童话。 我国古代，真有大侠，不过古代的大侠并不是会降龙十八掌的郭靖，也不是小李飞刀，而是黑帮的老大，相当于西方的教父。 最有名的大侠叫郭解，汉朝时有极高的威望，不然也不会写进史记。 郭解的爸爸是个职业杀手，非常有名，用古龙的话说，最厉害的杀手是没有名字的，郭解的老爸名声太大，注定活不长。有个米商请郭解的老爸到监狱里救出犯了法的儿子，郭老爸看在钱的份上去了，就再也没能回来。\n郭解跟他老爸学过功夫，很有两下子，于是干起了抢劫和盗墓的这份很有前途的职业。因为功夫高，谁只要说句话让他不爱听，必然遭遇一顿暴打。本着流氓会武术谁也挡不住的精神，到了三十岁，郭解已经钱多的数不过来了。男怕入错行，女怕嫁错郎，看来抢劫和盗墓的职业选择对了。 30岁以后，郭解为了从强盗升级为教父，开始积累自己的名声，并且学习战国四公子，开始蓄养门客，但凡是哪个人有难，有求必应。俨然形成了一个严密的黑社会组织。在民间的声望，甚至超过了皇帝。 皇帝的权威是不容冒犯的，一个地方黑社会头子怎么能够这么嚣张呢？就把郭解抓了起来，虽然有大量的证据证明郭解作奸犯科草菅人命，但都是汉武帝大赦前的事情，没有办法定罪。汉武帝一筹莫展，人抓了不能定罪，又不能放掉，该怎么办呢？ 这时，正好有个书生，骂郭解不遵纪守法。正巧被郭解的门客听到了，就把那个书生给杀了。 汉武帝听了哈哈大笑，正巧找这个理由把郭解灭族。 侠客的黄金时代，从此结束\n剑侠情侣，快意江湖，听着是一个充满了浪漫的世界，而事实是完全不可取，一个没有法制的社会，奉行者赤裸裸的丛林法则，什么是对？什么又是错？理由就永远站在强者一边，强者可以随自己的意愿决定弱者的生死。 这个社会是可怕的。 郭解，就让他永远埋葬吧\n2010年的中国房地产 汝爱之罪：\n今天跟家里人打电话，姨妈说了下近一年来老家云南东北方向一个地级市曲靖的变化。\n主要就是：好些有资金的外地大佬大手笔拿地，开发酒店和商品房。都是市区的黄金地段。\n其实房地产开发在中国的任何一个城市每天都在发生，不过令人感慨的是这样的“四线”城市也如此火爆，购买力之强令人感慨，她说最近几天曲靖正在举行房交会，人头攒动。 现在老百姓有钱都向往好的房子和户型了，已经不满足90年代的老旧房子了，而且通货膨胀也逼得大家不得不置业保值。\n再回头看看北京，简直找不到跌的理由。那么多地铁要修，那么多优质生源每年涌向北京高校，那么多人口，每天要造就那么多富人。。。。\nkkndme：\n钱太多了，流动性泛滥，老百姓恐慌了。这次调控暂时抑制了一线城市房价的上涨势头，但是却直接导致了全国性房价的上涨，不光二三线城市，连四级以下城市都是如此。这就是领导水平。\n房奴算不上不幸，相当当不了才算 lanyu1121：\n普通老百姓都成房奴了。\nkkndme：\n成为房奴还算不上不幸，相当房奴当不了才不幸\n精英人群的平均收入决定房价 skysurfer2208：\n想请教一下楼主，对于很多的二线城市，比如武汉，市区房子的均价一万左右了，但当地的平均收入一般也就3000左右吧，难倒你不认为现在的房价里面有泡沫吗？特别是现在正处在调控期，对于我们这些近年打算买房的来说，是在等等看呢还是在在这个时期出手？多谢楼主\nkkndme：\n你所说的平均收入是什么概念？是人人都挣3000块，还是有人挣2000块，有人挣1万块。武汉的房价，要看湖北省包括各地市的人口，家庭收入上万的人有多少，如果你认为很少，几乎没有，那房价肯定存在泡沫。如果湖北省有20%的人口家庭月收入超过万元，那么武汉市区的房价就没有泡沫。\n内地不是香港、海南 johny__：\n那香港97年的时候还不是一样跌了一大截，按LZ的说法，1）土地资源很稀缺；2）作为消费群体的白领收入也能买房；3）作为世界城市，更是汇聚了世界级精英的购买力，仿佛现在上海。最后，不是一样大跌？？中产都成了负资产了。就连林百欣的儿子林建岳97年以69亿港元高价购入中环富丽华，还不是赔得一塌糊涂。\n楼价涨高了就要跌，哪都不例外，这个才是规律。什么通涨，精英购买力决定房价，都是涨了之后在找理由。\nkkndme：\n这就是体制上的不同啊，所以我们无法重复香港和日本。97年的金融风暴，还是中国以国家之力对抗索罗斯的量子基金，保住了香港，这种行为在西方国家是难以想象的。一个国家动用全国人民的外汇储备与美国的民间资本打一场战争，这是令全世界震惊的。索罗斯因为不了解中国的体制，悻悻而归。\n人民币不能在世界流通，依照我国实行的货币制度，货币只不过是一种符号。如果有一天我们的人民币能够自由兑换，香港发生的事也一定会发生在我们身上，但你认为我们的人民币能够自由兑换吗？\njohny__：\n那92年的海南崩盘有从何说起？从7000多掉到了几百元，这难道是海南体制？发币行是海南银行？同样是国内，同样的外汇管理制度，不是日本也不是香港，是中国海南。\n\u0026ndash;据《中国房地产市场年鉴（1996）》统计，1988年，海南商品房平均价格为1350元/平方米，1991年为1400元/平方米，1992年猛涨至5000元/平方米，1993年达到7500元/平方米的顶峰。短短三年，增长超过4倍。\n\u0026ndash;海峡对岸的北海，沉淀资金甚至高达200亿元，烂尾楼面积超过了三亚，被称为中国的“泡沫经济博物馆”。\n[经验交流]92年海南房地产泡沫始自于“击鼓传花”(转载) http://www.tianya.cn/publicforum/content/house/1/163988.shtml\nkkndme：\n全国的资金去炒海南、北海，炒的纯粹是概念，没有实体的支撑，就是一种博傻游戏。今年年初海南房地产的爆炒，同样积聚了巨大的风险。买房并不是全无风险，好比通州、燕郊，经历疯狂的炒作一定会理性的回归。但是如果指望北京四环内房价下跌，也只是痴心妄想。\n房产投资也不是随便买套房就只涨不跌，比如说山东乳山的房子，开发商疯狂炒作旅游地产概念，但如果真的想投资升值，那就成了天大的笑话，因为根本无法变现。\n什么样的房产适合投资，投资者不是傻子，都会有理性的判断。\n90年代初的强硬调控让海南和北海的经济崩盘，对全国来说不可怕，毕竟只是一隅之地，但是如果用粗暴手段搞崩了全国，zf一定会好好掂量的。\n历史是一面镜子 如果以为本帖讲的历史故事，那就完全理解错了。\n本帖讲得不是历史，而是总结前人的经验，讲得是故事背后的道理。 如果毛不是熟读历史，也不可能取得胜利。毛在进京的时候，说过一句话：我们不学李自成。\n只有认真总结过李自成失败的教训，才能够做出正确的选择。\n买房一次性到位比较好 包容会通：\n我老婆是长春人,岳父母退休,都有退休金.我和我老婆现在都在国外,准备3年以后回长春工作,我们现在有40万的现金,放在银行也没什么用,也担心3年以后,长春的房价还要涨.\n因此,现在准备用其中的20万作首付买套70平的小户型的,让岳父母住(岳父母有住房,但很快就要拆迁了).等3年以后回长春,把这套小的卖了换成大的.不知这样的计划是否可行?贷款如何弄? 谢谢兄弟.\nkkndme：\n既然是自住型需求，何不买套大点的，70平（建筑面积）的房子无论是自住、父母住还是合住，都比较拥挤。既然有40万的闲钱，还是一次到位比较好，3年后长春的房价一定要比现在高的多。\n只是贷款比较麻烦，你的父母是无法贷款的，除非你们夫妻能够回国，这种事用别人的名字办肯定是不行的，房价上涨后就有可能会陷入扯皮甚至打官司的境地。\n外汇管制 tianxiaobing11：\n楼主，这个tj连人民币不能自由兑换都不知道，可见他的水平也太差了，就不用和他计较了，从上个月开始人民币换美圆好象收紧了，是怕民众把人民币换美圆出逃吗？\nkkndme：\n外汇外流趋势比较严重，zf开始严管，包括携带50美元以上商品入境必须征税等措施，都是限制外汇外流。富人从穷人身上赚了钱，换成美元在国外消费，这是zf不愿意看到的，zf不在意富人搜刮穷人，但肉一定要烂在锅里\n一线和二线 yamazaki28：\n楼主好，小弟有问题请教，本人所在二线省会城市，存款40w,近来看中本市CBD区域高端住住宅一套，各方面条件十分优越，面积100左右，均价18000。但通过观察，又看中觉得北京五环附近的待建地铁房，均价16000，想贷款弄小户型60左右，不知哪个升值潜力大，本人已有房一套。谢楼主指点。\nkkndme：\n短期来看，二三线城市的房产升值速度要高于北京，这是这次调控造成的结果，从长期来看，北京房产的升值速度要高于二三线城市。五环附近地铁房，还是很有优势的。\n吕后篡权 大凡是60年代末，70年代初生人，小时候肯定看过一本小人书：吕后篡权。 在那个时代推出这本书，很有寓意，起到了很好的宣传效果。 吕后真的是十恶不赦的妖妇吗？让我们还原历史的真相。 我们读到的吕雉，通常的形象是蛇蝎心肠的女强人。 大家感兴趣的，首先是关于吕雉在项羽大营和审食其是否有一腿。 然后看到的是吕雉协助刘邦诛杀异性王、与倾国倾城的戚夫人争宠、帮助儿子刘盈与戚夫人的儿子刘如意争夺太子、杀害戚夫人和刘如意、提拔吕氏家族成员。 但是因为宣传的需要，几乎所有人都忽略了吕雉的另一面\n刘邦见上帝以后，吕雉掌权期间，对待老百姓还是很够意思的。 俗话说嫁出的女就是泼出去的水。吕雉可不同，吕雉非常照顾自己的娘家人，想把自己的娘家人都提拔起来。 秦始皇把分封制改成郡县制，搞天下大一统，意识比较超前，结果政权不稳定，秦朝很短时间就完蛋了。高祖刘邦吸取了这个教训，仍然搞分封制，不过分封制做了重大的改革:首先是分封的诸侯王必须是皇族，也就是说必须姓刘。其次是从中央派丞相给诸侯王，丞相掌握诸侯国的军政大权，防止生变。 吕雉提拔娘家干部最大的障碍就是：高祖说过，诸侯王只能姓刘。\n吕雉是一个极其精明的女人，她追尊自己的老爹吕公为宣王，吕公是刘邦的老岳父，追尊皇帝的老岳父，旁人自不能有异议。既然有了先例，剩下的事就好办了，吕雉趁机把自己吕姓家族的成员封为吕王。 吕王吕嘉这个人很嚣张，仗着外戚的身份，飞扬跋扈，不尊法纪。 吕雉是一个出色的国家领导人，不是黄巢李自成之类的强盗流民，是很关心民生的，所以很生气，把吕嘉给废了，让吕嘉的叔叔吕产当吕王。 吕雉掌权后，做了很多亲民的好事，减免老百姓的税赋，加强建设健康的人民文化娱乐，最受百姓欢迎的是废除了“三族罪”和“妖言令”。 三族罪的意思很直白，就是一人犯罪株连三族。 妖言令有点象后来的文字狱，哪里出现统治者认为的妖言，就把那个地方的所有百姓全部处死。这是一个伟大的历史进步。 吕雉还是女权运动的先驱者，在吕雉时代，女子也可以封官封侯，可以随意离婚再嫁。那个时代是中国古代史上，女人最幸福的时代之一。 吕雉，一个柔弱的女子，在残酷的宫廷政治斗争中表现的异常凶狠，然而权力的斗争本身就是你死我活，在治国方面，吕雉却无愧于一个贤明的统治者，可谓巾帼不让须眉。吕雉与后来的老佛爷完全就不是一个等级，毫无可比性。 吕雉执掌朝政十五年，直到病死后，吕氏家族才土崩瓦解。 还原真实的历史，我们不应该对这位叱诧风云的女政治家，致以深深的敬意吗？\n小产权房 大水牛跟水牛仔：\n楼主,可以谈谈小产权房的看法吗?父母是珠海的原居民且拥有两套小产权房,无房产证只有村里所发的使用证,是村委会卖给原居民的,离市中心约半小时车程,近河边,而一路之隔的位置己建有大型高尚住宅小区,在售价一万二以上,请问这些小产权房可靠吗?听说往后政府对这些小产权房采取放宽政策,只需补一点钱就可改成商品房,你觉得有可能吗?\nkkndme：\n这个补点钱就改商品房的可能性不大，如果是大片的小产权房，拆的可能性也不大。这个问题很让zf头痛，城乡双轨制的结果，所以zf能拖就拖。\n但是对于片区不大的小产权房，风险就很大\n大水牛跟水牛仔：\n谢谢楼主回复,父母手上的两套小产权房在同一小区,小区比较大,这类小区有好几个,由于村内将进行旧村改造,规划成高级住宅片区,那此类小产权房如遭迁拆的话会得到赔偿吗?\nkkndme：\n这个会比较扯皮，最坏的情况是按照原价退赔，最好的情况是回迁安置。如果原价退赔损失就很大。\n商铺和住宅 deeplp：\nkkndme 兄，你好。\n从这个帖子一开始就一只跟着，每天必看。受益良多。\n你对广州感觉如何？请教一个问题，不知你对商铺是否有研究？你觉得眼下投资商铺好呢，还是继续投资房产。 本人已有2套房产，都在广州市区且近地铁但不带很好学位。现有如下两个想法，\n分散投资，投资一个商铺，目前看中一个广州北京路拐弯处二楼商铺一个，靠近地铁。 继续房产，买一个130以上大户型且带学位房，方便以后小孩读书。（计划明年要小孩，现在就做打算是怕以后买不起阿。） 麻烦兄台给些意见。十分感谢。 kkndme：\n找到合适的商铺是很难的，因为商铺投资风险大，所以非常考验个人的眼光，属于高风险高回报，找对了，将财源滚滚，找错了很可能血本无归。 如果你有眼光，首选商铺。如果不具备这方面的能力投资住宅比较保险。\n体制内外 tuzi1976：\nkkndme兄，你好。上周提了几个问题，可能你没看到，再请教一次，请抽空指点一二。 看到楼主说过“人民币对外是升值，对内贬值”，我认识到“人民币对外是升值，对内贬值”这一点也有一年多了吧，主要是从生活经历、经济新闻中得到的结论（本人学工科、不懂经济）。虽然看到了表面现象，但对其发生的根本原因、对群众生活的深刻影响、“中产阶级（勉强算是有这么个阶级）”的应对之策等等尚没有深刻的认识。楼主看到我提的这些问题恐怕也觉得范围太大、难以回答？难道体制外的“中产阶级”只有任人宰割、移民海外、钻营往上爬这几个选择？诚心求教，风险自担（呵呵，楼主也不是神仙）\nkkndme：\n普天之下莫非王土，决定了今天的土地国有 万般皆下品，也决定了以后知识分子的前途必须进入体制内。 不能考中进士的明清两代知识分子，即使经商发了大财，也一样让人看不起，不能光宗耀祖。今天的知识分子将面临同样的命运。 体制外，凭个人的本事和运气，自生自灭。\n2010年的上海 youme5845：\n看到LZ的帖子真是太及时了！因为要解决小孩子上学，我最近开始密集型的看房子.\n感慨房价高的同时后悔没有早点考虑买房。头痛啊！！！\n说说我们的情况：目前现金40W,家庭收入1W5,住上海，目前看的房子为周边世纪公园地铁10分钟老公房(新房很少)，81P 190W,地段很好，但房子都是95年左右的了。算下来除了首付家里帮助外每个月供5K还30年(扣除公积金还款),我们现在可以出手么？还是等十一新政策出来后买？\n还是在交通稍微不便的地方买低价的房子？\n请LZ给个意见~ 在线等~ 多谢！！！！\nkkndme：\n月供5k,收入1万5，说明的你的压力不大，完全可以承受。如果地段好，可以不考虑房子的新旧。一线城市的买房时机最不好拿捏，因为一线城市是调控的目标，你要仔细观察，如果发现中介的铺面里看房客越来越多，建议赶紧下手。\nyoume5845：\n多谢！！！ 那我最近关注多一些！ 还有这块小区同时是学区房，是否可以买个100W出头的出租，然后自己租房住(我们长期租住房租很便宜 1700两室户)，这样即使以后出现金融危机等情况也不会担太大风险，是这样么？\nkkndme：\n对自己好一点的就会自己住，对钱看的比较重，可以买房出租，自己租便宜的。因人的性格而已。 不过人生苦短，在短短的有生之年，还是要对自己好一点。自己买的房子住起来跟租房子的感觉是完全不同的。\n收紧住房贷款 welldayzwb：\n顶楼主，越读越觉得受益良多 楼主分析一下，最近几年一线城市是否会一直收紧贷款，想改善住房是否也得必须全款了？一想起这个就很郁闷，去年机会没利用好，后面不仅仅是经济成本的问题了，又面临和无房空空类似的问题，攒钱永远赶不上房价了。。。\nkkndme：\n收紧住房贷款起码在未来的一段时间会成为常态。由于货币泛滥，一次性付款的人群数量庞大，收紧贷款虽然不能降低房价，但可以抑制房价上涨的速度，防止商品房卖给穷人，以规避金融风险，对社会稳定和经济平稳增长都是有利的。\n买房：物业与房贷 fallenleafe：\n关注本贴多日，非常欣赏楼主的睿智和理性。 小女子也是上海众多买房人之一，目前所谓单身剩女，得家人支持有一百五十万的首付金。基本确定买在内环交通方便的次新房（老公房停车太成问题）。 对上海浦西内环内的诸多区位和楼盘做过研究，发现离地铁近的同时能有苏州河景观的房源最具性价比，满足交通性和景观稀缺性的双重优势（上海内环内几乎没什么安静同时又具有自然资源的地方）。 现在基本确定了两个小区，比较纠结的问题有两个。 第一个问题，一个是小区管理和区位优势明显单价在3万3左右，另一个区位和管理比较差，名声不好，但是面苏州河的独一无二景观，单价在3万左右。从小区管理的角度，我也认可楼主的看法，管理好的小区升值空间大，管理差的小区由于群租问题严重，目前价格偏低，但是这个软件问题在日后随着自住率的提高貌似也能解决。究竟我该选一个景观资源非常稀缺的管理和配套相对较差的小区，还是一个相对成熟价格稍高同时综合配套比较好的小区？那个小区比较有保值和投资优势？ 第二个问题，目前的月收入税后刚过万元，如果拿150万的首付买一房大概80平左右，是比较轻松的，月供不成问题（目前租的一室一厅租金3500，已经可以做为还贷资金了）。但是考虑长远问题和一些小户型的局限性，非常想投资一套能长久居住的两房甚至三房（众所周知，一个小区里好的位置总是留给最大的户型）。这样的话，大概一套就要在320万甚至350万，我需要每月还贷1万2左右，基本和我的月工资持平。从个人观点来看，我比较想冒这个风险，比较合适的做法是首付降低到3成左右，留出三十万左右的还贷资金用以应付前面两至三年的还贷。由于目前单身，两至三年后也许家庭收入就可以完全承受这个月供。即使还是单身，目前事业发展良好，对2年后的收入在2万以上很有信心，因此还是认为可以目前阶段多点勇气，目光长远，以保证日后生活安康。 不知道楼主怎么看这个问题？如果是房价持续上涨的情况，也许更该相信我的工资也会持续上涨，是否我看问题太乐观？贷款200万的风险是不是会太大？\nkkndme：\n第一个问题：物业管理对于小区的价值起着至关重要的作用，好的物业管理才能让人居住舒适，这一点是非常重要的。软件的提升往往比硬件的提升难度更大。物业很差的景观楼盘，可以比喻为鲜花丛中的一坨屎，周边环境再好，它也是一坨屎。一坨屎能否脱胎换骨变成黄金，存在着较大的不确定性。 第二个问题：是否承受较高月供，取决于你对未来的预期，所以你要仔细分析你的行业前途，如果你所处的行业告诉成长，或者你的能力职位将得到进一步提升，你可以承受较高的月供。 一般来说月供不要超过全部收入的70%，如果超过这个边际，就会有较大风险。\n奸臣蔡京 现代的纸币发行成本很低，拿着印钞机印就是了。古代就没那么好办，金银的开采量是有限的，别说金银，就是铸铜钱用的铜，也不是想要多少就有多少。\n古代要想制造通货膨胀，最绝的办法就是拿一个铜钱当十个铜钱花，叫做当十大钱。搞当十大钱，扰乱货币秩序的领导，最有名的就是蔡京。\n蔡京这个名字并不陌生，不爱读历史的人也一定看过水浒传。就是这个领导，被宋史称为六贼之首。大家一提起他，就自然把他跟奸臣划了等号，恨不得在他脸上踹几脚。\n蔡京的确是个奸臣，但很多人可能不知道的是：蔡京是王安石的最得力干将，他的很多祸国殃民的政策，竟然是源于恢复王安石的变法。\n王安石可以说是一个品德高尚的人，但是变法的流毒，竟直接导致了北宋的灭亡。王安石是一个在历史上有争议的任务，但是他的得力骨干蔡京同志，却是不折不扣的奸臣。\n蔡京领导的罪恶，大家一致公认的就是那么几条 第一、花石纲，水浒传有精彩的描述，这个纯属于皇帝的个人爱好，似乎都推到蔡领导身上比较冤枉。 第二、大兴土木，大搞基础设施建设拉动内需，顺便搜刮点民财，以至于百姓怨愤 第三、恢复王安石时期的方田法，并且更改盐法茶法，国库和官员一起大肆搜刮民财，与民争利，结果租税混乱，富人把负担全部转嫁给穷人，穷苦百姓的负担更加沉重。 第四、就是当十大钱，制造通货膨胀，严重扰乱金融秩序和金融安全，北宋的经济崩溃了 蔡京，一个王安石变法的坚定执行者，最后成为祸国殃民的奸贼。\n关于蔡京的奸臣形象，到了现在，有人企图为他翻案。但终究声音比较弱小。 因为在中国的古代，肆意敛财、大兴土木、搞官商垄断，与民争利，以至于人民不堪重负的领导，都被称为奸臣。对于减轻人民赋税，不胡乱插手民间生产和贸易，让人民修养生息的，被称为贤臣。 中国的古代，奸臣远远多于贤臣。\n体制内的28原则 facetowall：\n有人说，高校里20%的人掌握着80%的资源和财源，本人深有同感。所以经常想怎样才能成为20%里面的人。每天也很努力工作着，科研教学也可以，但是总看不到希望。\nkkndme：\n从一个小吏变成中高级干部，是需要深入研究中国古代政治斗争史的。否则就变成了宋江，企图另立山头通过跳槽达到目的，最终的结果只能是失败。宋江是一个政治上的白痴。\n还有一个白痴叫贾谊，我们所熟知的“过秦论”的作者，才高八斗，政治却很白痴。被文帝做了棋子。如果贾谊同志知道晁错的下场，是无论如何不会仗着有才胡说八道，口无遮拦的\n贾谊 贾谊的粉墨登场，是有很深的政治大背景的。 首先要从吕雉死翘翘，以陈平、周勃为首的功臣集团铲出了吕氏一党说起。 吕氏一党灰飞烟灭，小皇帝是个吕雉制造出来的傀儡，甚至跟高祖刘邦都没有任何血缘关系。 难题是让谁当皇帝呢？ 于是中国历史上最为搞笑的一幕发生了，在高祖刘邦的子孙中要搞最弱外戚选举。\n大概是被吕雉专权搞怕了，大家推举皇帝，专门看哪个皇子的外戚弱。于是众人的目光投向了刘邦的第四个儿子，代王刘恒。原因是刘恒的母亲薄氏出身低微，为人又很低调，堪当最弱外戚之名望。 提起薄氏，野史里记载的很香艳，很可以拍三级片\n野史里说，楚汉争霸时期，高祖刘邦大败。 薄氏还是个姑娘的时候叫薄姬，逃难的时候占领了一个无人居住的民宅。忽然有一天看见一个浑身是血，穿着盔甲拿着兵器的男人闯进了自己的屋子，这个人就是刘邦。 薄姬听到后面有追兵，就把刘邦的盔甲和兵器藏了起来。然后放了一大桶洗澡水，把自己和刘邦脱光光，洗起了鸳鸯浴。追兵闯了进来，惊奇的看了一通三级片，然后走人。 这个只是野史，可信度不高，但是说明了薄氏的低微出身。\n不管怎麽说，有着最弱外戚称号，并且做事很低调的刘恒当了皇帝。但是对于刘恒来说，陈平、周勃等功臣集团有着很高的声望，齐王刘襄是高祖长孙并且在铲除吕党是很有功劳，声望也很高，受到了很多人的支持，而刘恒却毫无功劳，因为功臣集团平衡关系，天上掉下了皇帝的帽子，砸在自己脑袋上。 所以刘恒必须提拔自己人，这个人不能有很高的功劳，也不能有结党的嫌疑，最好比较有本事能治理国家，于是大才子贾谊粉墨登场了\n贾谊同志很有口才，一腔热血，要到现在来说最适合搞传销或者卖保险。 贾谊同志激愤起来甚至说：自己完全可以带兵打仗，灭了匈奴，把匈奴王象狗一样牵回来。”刘恒很贤德，但也很老谋深算，当然认为贾谊同志满嘴喷粪，所以一笑置之。 贾谊同志的胆子不是一般的大，向皇帝刘恒提供了一个深的帝心的建议：让所有的诸侯王滚回自己的封地。 为什么说这是深得帝心的建议？因为朝里功劳大的人太多，居功自傲，而自己却没有什么威望和功绩，如果功臣集团和齐王、淮南王联合起来造反怎么办？ 所以，最好的办法就是让诸侯王滚回封地。汉代的诸侯王可跟周朝不同，周朝的诸侯王是有实权的，有自己的军队。而汉代的诸侯王只能收收领地的税，军政事务全说了不算。 这个事，从贾谊嘴里说出来最好不过。\n汉代的京城是最繁华的，有全国最好的教育、医疗、商业，有钱人的天堂，大臣们都可以花天酒地。让诸侯王回到封地，大家都不干了，回封地有什么好？房价又低，又没什么娱乐，漂亮姑娘也不好找，偏远的地方气候还不好，梅雨一来全身都要发霉。 首先带头反对的是功臣集团的领袖周勃（陈平已经死翘翘了）。在历朝历代，多数皇帝并不是想干什么就干什么的。既然所有大臣都反对，那就先暂且作罢。 但是贾谊，已经为刘恒种下了希望的种子，给自己埋下了祸根。 贾谊注定了只能是一颗棋子。\n贾谊的建议没有被采纳，估计很郁闷，成天滔滔不绝的演讲，甚至建议刘恒削藩，要是贾谊知道晁错的下场，一定不敢这么建议。 这时候，贾谊已经得罪光了朝中几乎所有的大臣。于是大家的不满全部转移到贾谊的身上。 刘恒要的就是这个效果。\n随着政权的逐渐稳固，刘恒把矛头指向了周勃。给予周勃最高的赏赐，却经常在治理国家方面，询问一些周勃不可能知道的问题。让周勃很尴尬。 周勃有个门客，就对周勃说：“皇帝经常给你很多赏赐，您就安心的接受，这很危险。皇帝给你的赏赐越多，说明皇帝对您越不放心啊。” 功高震主，弄不好会有杀身之祸，周勃不是傻子，立刻明白了这个道理。所以周勃才能称的上除曹参外，最有政治头脑的武将，最后得了善终。 于是周勃就上表辞职，表示年老体病干不动了。周勃还期望皇帝能挽留一下，但皇帝一点挽留的意思都没有，立刻同意了。 刘恒让周勃起个带头作用，回到自己的封地去吧。并且赐予了大把的金银。其他诸侯王看周勃都走了，也扛不住了，只好都回到了封地，这叫射人先射马，擒贼先擒王。 刘恒为了安抚大家，把遭人恨的贾谊明升暗降，贬到了长沙，从此离开了政治中心。 后来有一天，刘恒想起了贾谊，找他来中央谈话。贾谊一见皇帝立刻滔滔不绝，把皇帝立马侃晕了。 刘恒想：我靠，这厮死不悔改，留着没用，有多远滚多远吧。 再次把贾谊贬到了梁国。 贾谊不多久就死了。\n关于魏豹和薄姬是否有一腿，也不好就肯定，也是个悬疑。因为记载薄姬的版本太多，我国古代人也比较八卦，呵呵。\nkkndme 推荐的历史书 welldayzwb：\n这个帖子最大的感受就是应该认真读一下历史了，麻烦楼主给列个入门级的书单，鉴于我的历史水平只有演艺级的，书单请尽量入门级，当然演绎过的就免了，别读历史还别人顺带洗脑，比较郁闷了\n先再次表示感谢！\nkkndme：\n比较浅显的是“史记”，入门级基本都读的懂。如果开始觉得部头太大，觉得累，刚开始可以从“古文观止”入门。逐渐增加难度。 入门以后，很多古文就好读了。 现代翻译的一般都加工的比较多，同一部历史可能有无数个解释。象易中天和当年明月，都是写的不错的。\n关于古文观止，很多文章都曾被节选进中小学课本，篇篇堪称经典，其中就包括贾谊的“过秦论”。不看过秦论真的不知道贾谊的才华呀。所以想读读历史的童鞋，不妨回过头再温习温习古文观止，边品茶边看，真是一种享受。\nEchoMa9999：\n楼主晚上好！ 我看之前有跟贴的朋友提过，请楼主列个史书入门级的书单，我不求列了很多书的书单，只请楼主推荐三本，佛渡有缘人，楼主，望不吝赐书名，先谢了！\nkkndme：\n我觉得读史最基本的就是古文观止，读了古文观止，有了功底，再读其他的就好读了。 开始读的时候，通史类是很难看得进去的，象“资治通鉴类”的也不好读，因为“资治通鉴”应当算评史算不上史书。 入门开读的话还是选择文学性强的比较好读，故事性趣味性都高，比如“史记”“三国志”“汉书”。 有了兴趣再读大部头的“宋史”“明史” 现代编写的中国史纲之类的就不要读了，纯粹洗脑，很多加工过的历史类读物就是瞎扯。\n特别是： 千万不要读“中国通史”那样的垃圾!!!!!!!!\n一定要读懂原文，跟中国通史讲得完全不是一回事。读不懂原文宁可不读，也不要让中国通史洗脑。\n打工不易：\n请问楼主，范文澜的《中国通史》也不值一读吗？\nkkndme：\n从始至终以唯物主义角度阐述的历史，可信度究竟有多高？\n唯物主义要很深的理解，比如子虚乌有的抢渡大渡河，就是唯物主义的杰作。\n范对封建社会的理解，也很有问题，是唯物主义的需要，不能还原历史的真实\nwelldayzwb：\n这个唯物主义的定义是什么？\nkkndme：\n我只能用唯物主义这个词，再直白就和谐了，呵呵\n我们的历史教科书很多都出自中国通史，但是你真正熟读了史官的著作以后，发现那有多扯，歪曲的有点太不靠谱。中国通史我把它定义成政治类书籍，是政治需要产生的，专门用于洗脑，不能当史书读。\nEchoMa9999：\n楼主，简单研究了一下古文观止/三国志/汉书/后汉书/史记，古文观止，以目前的水平，看起来着实吃力，决定还是先从史记开始看起吧\n淘宝上搜了一下，史记 （全四册），北方文艺出版社出版，2007年9月1号出版的，萧枫主编，绣像本，盒装， 这个版本的买来自读加收藏，可以吗？请楼主点评，谢谢！\nkkndme：\n古文观止可以买带注解的，但不要带译文的，看译文对读原文是有害的，可以通过注解提高古文水平。\n史记买太好的版本，我是舍不得拿出来读，不能勾勾画画，我一定会把它高束焉,庋藏焉。读史记，最好买个普通本，带注解的，方便阅读，可边读边勾画，以提高阅读水平。\n年轻人要早买房 GGKMM：\n看了三天，终于看完了。。有些是一眼带过的，有些是比较认真的看下来的；\n感觉回帖的筒子大多数都挺有钱的啊，至少相对我来说。因为都在计划一二百万的房子了。\n本人在福州，目前月薪只有4K，但是福州市区的房产均价已经越过一万了，市中心的更是到了1.5万这样高不可及的地步。我就那楼主口中那种民企私企的体制外的P民了，属于自生自灭型的。但也还是得活下去啊，今年也二十五了，过两年也要结婚了。房子成为不可避免的头等大事；\n不知道楼主对福州这样一个三线或者四线城市的房产怎么看待？平均工资水平约2000，有钱人据自己观察应该不少，至少超过20%的福州人口（有关这个，从大街上越来越多的好车做判断的，或许数字不准，但有钱人不少是肯定的）。如果在郊区能找到六千左右的小户型（65平左右），首付（还得存两年或者去借钱）自己掏，剩下的做货款，因为家里实在是没办法再支援了。这样的话应该还可承受，前提是付房贷的这二十年或者十五年里不失业。。\n希望楼主给分析分析，写得有点乱。。。\nkkndme：\n25岁不是考虑失业的年龄，35岁体制外没有混出来的群众才应该考虑失业问题。 所以房子一定要趁年轻买，刚开始钱不够，就不要计较太多，先买个小的，以后有能力再换，如果没混出来，以后起码有个自己的窝住。不至于租房子被人赶出来。\n福州是有点尴尬，明明是省会，又比不过厦门，不过市区1万左右的房价，在省会城市里真的谈不上高。你是自住，你又不打算去厦门生活，所以你该买还是得买。福州的房价也许涨得没那么块，但是也不可能跌。\n不要低估通货膨胀 someway2010：\n跟楼主请教一下： 楼主怎么看知春里小区的房子？那边连着双榆树小区，有大片的老房子，都是6层的板楼，都是上世纪8、90年代建的。环境看起来有点乱，以前的老公房，原单位早就没了，物业基本等于没有。将来拆迁的可能性有多大？值得买不？\nkkndme:：\n只要是4环内保值升值不会有问题，那个位置还是可以。关键是看投资还是自住，如果是自住，我就觉得那边有点乱糟糟的，不舒服。挨着中关村其实住着都不舒服，但不耽误升值。\nsomeway2010：\n多谢楼主，是自住因为老公在中关村上班，想离公司近些，所以就挑了那里是挺乱的，唉~ 希望以后等我们有钱了能换个别的地方的大房子，不过按照楼主的分析这个是极有可能实现不了了。。。5555~~~~~~ 再问一个，现在市场上卖200w的房子，十年后大概会涨到多少钱？麻烦楼主\nkkndme:：\n80年代你想象不出以后一瓶茅台会卖1000块 现在你同样想象不出十年后你的房子能卖多少钱。 那时也许人民币都是1000块一张的\n二三线城市与重庆 dali_05：\n浏览了楼主观点，和我之前的货币推动楼市的看法完全一致 但由于无法像楼主那样掌握一些基础数据，对一些楼市的演变细节还有几个疑问\n，还请lz指点 （1）二三线城市在这轮调控中的增长不出意料，但是二三线城市的房价增长，我始终认为存在一个最终谁接盘的问题。我是重庆人，以重庆为例，这个城市代表了典型的二三线城市。外来人口少，特别是外来的普通白领阶层。据我了解的数据，2008年之前，重庆的具备房子购买力的人群任然是净流出。到08年后才得以改观。但是流入任然缓慢，这也就是意味着重庆的楼市将没有长期稳定的接盘群体。而本地人，没有房子的是非常少的。在没有外来人群接盘的情况下，本地人在有房的情况下，任然投资囤积房产，最终，这些房产将如何变现。\n一句话，房价要持续的上涨，还得有没房者接盘，而且这些人还得要有购买力。多次购房者无法稳定的解决这个问题。那么我就有理由对这样的二三线城市的房产前景表示担忧。\nkkndme：\n重庆房价的上涨得益于zy的战略规划，打造中国的大后方，把重庆的经济发展提升到了政治的高度。因为如果发生战争，重庆将变成第二首都，是中国最安全的大后方，蒋同志就很有眼光的选择过重庆。 重庆并不是以城中心为核心向外辐射的城市，繁华区域相对比较分散，所以房价很难快速上涨。这也就是过去重庆长期滞涨的原因。 重庆房价的崛起可以说完全是中央规划概念推动的，至于日后是否会吸引大量的精英和富人来重庆发展，我想一定可以。作为上升到国家政治高度的发展计划，就算是代价再大，也一定会搞得起来。\ndali_05：\n（2）高端房产还是普通住宅？ 看了lz的观点，认为高端房产，由于其稀缺性，更具价值。 但我认为，房产和古玩还是存在差别的。古玩最大的价值在于收藏把玩，只要有钱，买再多古玩来玩都无所谓。但是房产不一样，房产的价值除了和古玩一样的投资外，真正的功能在于居住。但是目前的二三线城市，精英阶层的数量是非常有限的，他们谁没个3，5套别墅，在没有外来精英加入购买的前提下，这些高端的房产也就是在精英圈子中流转，这样封闭的流转，如何实现价值的增长呢？\n要知道，在2，3线城市，普通白领阶层能跳出自己的阶层而具备购买高端房产能力的概率是非常小的，不具有代表性。那这些每个富人，有权人都有很多的高端房产有什么价值可言？\n而普通住宅由于有普通白领的接盘，是否投资价值更大？\nkkndme：\n二三线城市房价的支撑，要因城市而异的，大体上二三线城市的核心区域与高端住宅区都不会有问题。毕竟一线城市的体量，不可能满足全国中产以上群体定居，而且一线城市随着竞争的日益激烈，钱也不是那么好赚的。有很大比例的富裕人群仍会选择二三线城市生活。 中国的二三线城市的富裕人口，要比大家想象的多的多，特别是二三线城市，有相当比例的人口都有较高的隐性收入，权力寻租现象更为严重。\ndali_05：\n（3）长期持有房产的变数 中国房产只有70年，甚至50年的使用权，如果长期持有，随着时间推移，房产价值是否会受到影响。因为我在重庆，这个问题尤其严重，重庆只有50年。\n如果我只是持有，出租。那我的租金将是较低的（相对房价而言），因为zf不会允许房租像房价那样疯涨，原因和粮食问题一样，基本需求嘛。那有可能50年到了，我的房租收益实际上还抵不上房款的综合支出。而那时房子早就是危房了，强拆将是完全可能的情况。那做为普通人，怎么可能和zf在赔偿上博弈。这个风险lz是怎么理解的？？\n我的理解是，房子不能长期持有，必须在5年左右变现，否则将存在贬值和变现难度加大的风险，请lz指点\nkkndme：\n关于中国的房产能够持有多少年的问题，这要持续观察zf的动向。对于现在的80后来说，如果在有生之年能够平安度过，不经历大的动乱，已经是很值得庆幸了。 如果有动乱发生，即使你没有买房，你手中的现金也将变成废纸。\ndali_05：\n（4）天津现象（或者即将出现的重庆现象） 天津房价在二线城市中增长是惊人的，但收入水平并没有达到那样的高度。这种依靠所谓开发区吸引资金推动房价的模式，是否具备可持续性？？\n我认为真正的天津常住精英阶层的资金实力是无法支撑这样的价格的，只能理解是外来游资的介入，推高了价格。 我想问的是，这些游资有可能退去吗，一旦退去，面临的风险是否很大。\n据我的理解，中国真正成功的开发区，都是由于本身的条件好，而非开发区本身的作用。\n比如深圳，享受的是经济转型的首发政策优势。上海浦东是由于本身就实力雄厚。而所谓的滨海新区，重庆两江新区，本身实力就不过如此，即使要真正实力上来，那也将是非常漫长的过程。那这些进入房地产的游资，将在概念炒作一遍之后，获得一定收益后撤出，一旦撤出，这些地区的房价将会是怎样的趋势？\n放眼中国，房价高的地方无不是富人集中，或周边富人多的区域。天津重庆这样的地方，一旦外地资金撤出，将何去何从？\n（5）新兴城区和老核心城区 新兴城区环境好，轨道交通也使得原本偏远的新兴城区变得方便起来。那老核心城区的房产是否不如这样的新兴城区有价值。这个问题一直很困惑。因为我是重庆人，这个问题尤其明显。现在重庆房价最高的是以前的郊区，江北，渝北。而传统的渝中，房价反而排着中等水平。这和北京的一二环贵，上海的黄埔徐汇贵完全不同。这样的状况具备可持续性吗，还是仅仅是阶段性的。但是感觉现在zf的规划更倾向于向外发展，避免主城区拆迁的高成本，这会否导致传统主城区的边缘化\n先问这几个问题，困惑很久了，期待lz的高论\n城区和郊区 hey-hey：\n楼主 我在上海， 小白领一枚。最近想买房。稍微好点的区均价已经至少2万5+了， 现在考虑在其他价格洼地的区买套新房，看中了均价1万7左右，买90送30，到手面积120左右。此楼盘开发建造定位2万/米以上，因政策调控，故现1万7。好处是小区规划不错，属大型国企房产公司，2012年交房。附近有超大型公园，地铁明年开通（升值利好），附近有医院，学校，路上看到的在建建筑较多（百废待兴）。不好处是离上班开车要1个小时，属工业区（在另外一个方向），路上集卡较多，有传空气质量不好。\n另外一个选择是在市中心或其他比较好的区买个小房子，大概5、60平方米左右，预算也是180万左右。 好处是地段好，租金回报可能较高。如果自住相对比较方便。\n单身，买房投资愿望大于自住愿望。 请楼主给分析分析。谢谢\nkkndme：\n多数人买房子都是郊区买个大的，后来上班实在不方便，再想办法城里买套小的。住郊区牺牲时间，住城里牺牲面积。总得来说，还是住城里更方便些。 关于房价升值，一定是郊区和城区版块轮动的。当郊区房价较低时，资金就会关注价值洼地，当郊区房价炒起来以后，城区的房价跟着上涨，但总的来说，城区的房价涨幅一定高于郊区，且比郊区更抗跌。\nhey-hey：\n谢谢楼主。真是纠结阿。一样的钱想买个新点的。而且周边的觉着还有这样那样的优势，比如公园，比如现在的性价比。比如大了一倍。比如该区未来发展空间和前途。如路建好了地铁修好了，城市辐射发展的面扩展了。 市区现在虽然完善，但未来没什么发展空间，该发展的都饱和了该配套的都配好了。升值的空间是否相对就小了。\n还请楼主再给说说。\nkkndme：\n你说的其实还是性价比的问题，比如郊区（前提是配套能发展的起来）1万7，城区2万5，那肯定是选择城区，毕竟相差不大。如果郊区1万7，城区3万以上，那肯定选择郊区。 好比北京的通州，城区2万的时候，通州8000，肯定选择通州，升值会快。但城区3万，通州2万5的时候，肯定会选城区。\n守着金碗要饭吃 守着金碗要饭吃，最典型的就是老一辈玩田黄寿山石的，收藏了一屋子石头，穷了大半辈子，第一次参加石头交易会，居然发现自己随便拿块石头出来能卖上千万。\n人制的社会，人就是制度 让李荣融来讲垄断巨头的功劳，这个事很有意思。\n西汉时期，功臣集团和他们的后人势力比较大，大街上瞎晃的黑社会头子比较多，皇帝提倡以法治国，靠法律来制约功臣集团，先是重用了皇宫守大门出身的张释之大法官。 张法官完全按法律办事，该杀头的绝不会流放，但是该流放的也绝不会杀头。张大法官实现了我国历代百姓追求的天下无冤民的梦想。 史书上记录：汉文帝车驾过中渭桥，一个人从桥底下突然钻出来把皇帝的御马惊了，刘恒很生气，让张法官治他的罪。张法官审讯后发现是个意外，属于民事事件，打算罚点钱放掉。刘恒不干了，那可是惊了圣驾呀。罪该杀头。张法官却认为：律条上没有说因意外惊了圣驾就必须杀头，按律条就应该罚钱放人。要不然陛下你就不要把这个人交给我审，直接杀掉算了。既然陛下让我审，就必须按法律办事。刘恒只好按照张法官的审判结果，放掉了那个人。 其实，遵守法律，按照法律办事的不仅仅是张法官，而是刘恒自己。刘恒为了保证社会安定、基业长青，就必须限制特权阶层，限制特权阶层就必须依法治国。 但是文景之后，武帝就不满足于完全依法办事的张释之法官这样的人了，而是开始重用酷吏，张汤、义纵、宁成这些新一代法官登上了历史舞台。法律是什么？法律就是张汤，张汤就是法律，犯了法的要往死理打，没犯法的也要往死里打。 唐朝武则天时期，出现了一个史无前例的酷吏：来俊臣。 来俊臣法官不管法律专搞冤狱，专门养了一大群打手无赖，凡是武则天不喜欢的人，还有他自己不喜欢的人，一律刑讯逼供，屈打成招。发明的酷刑比张汤有过之而无不及。 古代，法律是什么？是皇帝？是张释之？是张汤? 是来俊臣？其实，法律什么都不是。\n准公务员的好处 xufangliang1120：\n楼主，请问新进公务员队伍的人员今后还会不会有住房福利。像年纪大的都有分房或定向开发的商品房，已经分过了。象新进来的，工资不高，每月不到2000，平时无任何待遇，过年也就发个千来快意思意思。我在湖南常德，这里的房价也在4000左右，今年涨起来的。象我们这种情况要怎么办才好？请您指教！！谢谢！\nkkndme：\n大哥，公务员也是有级别的，想想宋江为什么上梁山呢？ 你要是在重要部门，或者到了级别自然就有了。 西汉的张释之，冯唐、郅都都是皇宫守大门的出身。皇宫看大门的，不算是公务员，是体制外编外人员，相当于协管员，连工资都不发，但为什么大家都趋之若鹜的争当皇宫传达室老大爷这种有前途的职业？因为，可以有机会见到皇上，有机会成为高级公务员。当上了高级公务员，你就有了票子房子妹子。\n最著名的皇宫传达室看门老大爷叫冯唐，头发都白了还在未央宫值班呢。皇帝刘恒没事瞎溜达，看见老大爷一脑袋白头发，就叫过来神侃。不侃则已，一侃才知道冯大爷的爷爷是赵国的官帅将，跟大名鼎鼎的名将李牧是哥们。而且冯大爷不愧是名将之后，太懂带兵打仗的道道了。 刘恒说：我要是能有李牧这样的大将，还怕什么匈奴啊。 冯唐很牛叉的说：就是有李牧这样的大将，也得不到重用。 冯大爷直接把皇帝气晕，皇帝转身就走了。 后来刘恒气消了，又找冯大爷问话。 冯大爷就说了一番大道理： 对待将士，要以激励为主，才能得到将士拼死效力的心。重惩罚，轻奖励，光拿大棒不掏胡萝卜，将士怎么肯用命呢？（皇帝是信奉法家的，法家的精神领袖商鞅同志认为管理手下最高境界就是基本不怎么用胡萝卜，直接用大棒的最牛——罚九赏一。） 云中太守魏尚是个名将，让匈奴文风丧胆。魏尚的手下都是农民子弟，魏尚对待士兵很好，很舍得犒劳，也和舍得给钱，所以大家都很拼命。但是陛下您经常因为军兵的一点小错误，就扣掉军兵的赏赐，因为魏尚虚报了几个斩获的首级数量，就把魏尚抓起来关监狱，奖励太轻，而惩罚太重了。所以说陛下有李牧这样的良将也不能重用。 刘恒大悟，拜冯大爷为车骑都尉。 唐代的王勃，很不得志，于是写了《秋日登洪府滕王阁饯别序》:“嗟乎!时运不齐，命途多舛;冯唐易老,李广难封。” 冯大爷一下子因为王勃的文学作品，家喻户晓了。\n小城市房价会因为人民币贬值涨价，但依然难变现 xufangliang1120：\n楼主,谢谢您的回复! 你您怎么看常德的房价呢,那我们现在还是想点办法先买房?\nkkndme：\n买一套自住房还是应该的，不是所有公务员都能够上位，也不是所有公务员能够分到房子，特别是二线以上城市，将来普通的底层公务员住公租房的可能性更大。\n对于小城市，房价也会因为人民币的贬值而上涨，只是可能不如大城市好变现而已。所以，有能力还是应该买一套自住房的。\n一线杭州 钱江风帆：\n看了个通宵啊，不知楼主对杭州了不了解，目前市区大概25000/m2,杭州未来房价的趋势如何？\nkkndme：\n杭州我都当一线城市看的，你就当一线城市理解。富人的天堂，房价多高都不稀奇\n二三线城市的发展靠拆迁 dali_05：\n支持楼主房价大涨房租必涨的观点\n但是这仅限于外来人口众多的一线城市 二三线城市本地人几乎没有没房的，如果算上父母的，将来普遍一个家庭拥有两套以上的房子 房租也就失去了大涨的基础 唯一可导致房租上涨的就是拆迁，一旦便宜的旧房子少了，房租肯定是要上调的 但那也是有限的 总之，外来人口极其可支配收入是房租的决定性因素\nkkndme：\n二三线城市的敛财和追求政绩方式，全靠大规模拆迁，城市搞升级改造，这个拆迁规模是一线城市市民难以想象的。有的城市已经搞得如火如荼了，有的城市还没开始，但都会走这一步。\n转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫” 中年不惑吗：\n一个忽悠了几亿中国人的伪概念-所谓“中国房地产泡沫”\n作者：罗伯特卡帕\n中国大陆大家目前最为关心，讨论最为热烈的一个问题就是中国的房地产泡沫问题。从政府到民间，从经济专家到普通百姓，大家都在关注这个问题。以前，我也觉得中国存在一个叫“中国房地产泡沫”的所谓概念，但今天我忽然感悟，原来多少年来包括我在内的几亿中国人都被蒙骗了，中国根本就不存在所谓“房地产泡沫”的问题，“房地产泡沫”这个概念本身就是一个伪概念。\n如同市场经济一样，房地产泡沫也是一个外来事物，它是市场经济的产物。但问题是，中国是市场经济吗？显然不是，否则为什么大多数西方国家都不承认中国是一个市场经济国家。尤其是中国大陆的房地产市场，更不是市场经济，而是计划经济与市场经济相结合的一个怪物，政府操纵着房地产行业，政府对房地产有着绝对的掌控能力。\n房地产泡沫是市场经济的产物，既然是泡沫，那么这个泡沫也会遵循市场经济的规律，即当泡沫足够大的时候，会破裂。因为日本与美国的经济是市场经济，所以当日本与美国的房地产产生泡沫的时候，就会破裂。\n目前包括中国在内的几乎所有世界经济学家都以为，当年日本与美国的房地产泡沫破裂了，中国的房地产泡沫比日美大几倍，当然也会破裂。事实却是，中国的房地产泡沫在几年年前的膨胀程度就超过了当年日本与美国的房地产泡沫，中国的泡沫几年来虽然翻倍，但却没有破裂，这是何故？显然，经济学家们犯了一个错误，那就是把中国的房地产乃至中国经济当成了市场经济来看待，而事实是中国的房地产市场根本不是市场经济。所以，西方市场经济国家所有的房地产泡沫，在中国也根本不存在，所谓的“中国房地产泡沫”根本就是一个伪概念。\n当然，我说到这里时，肯定有很多人不服气，中国的房地产明明几年之内翻了很多倍，远远超过了普通人的收入水平，这不是泡沫这是什么？我的回答是，中国的房地产价格确实虚高，远远超过普通人的收入水平，这是事实，但这不是“房地产泡沫”，因为泡沫会破，而中国的这个被大家称为“泡沫”的东西却不会破，因为它的真实名字其实不叫泡沫，应该叫“变相的税收”或者“房地产垄断价格”。\n中国的房地产业本质上已经不是一种行业，像中国大陆的税收与垄断行业的垄断价格一样，成了少数人剥夺多数人财富的一种工具。在这个工具上，寄生着很多食利者。这个食物链的最上层为地方政府，地方政府通过卖地与房地产税收，养着一大批高薪的公务员及满足他们的奢侈需求。食物链的第二层为与官员勾结的房地产商以及受贿吃回扣的官员，第三层是炒房者，炒房者相当部分为拥有大量现金的官员及家属。\n市场经济的泡沫会破裂的，但中国的房地产不是市场经济，房地产价格也不是“泡沫”，所以它也不会破裂。中国的房地产价格被政府严格操控着，不说是操控自如，也是有绝对的控制力。因为政府掌控着土地银行汇率等房地产的关键要素。中国的高税收是泡沫吗？中国的垄断行业的高垄断价格如水价电价油价是泡沫吗？当然不是，他们是转移财富的手段。中国的房地产价格也是一种变相的“税收与垄断价格”，其“税率”与“垄断价格”是政府控制的。这也解释了为何中国几年来房价如此之高，却不下跌，所谓“泡沫”却不破裂的原因。\n中国房地产的所谓“泡沫”会“破裂”吗？会，只要政府愿意。中国的房地产的“泡沫”会不破裂吗？会，只要政府愿意。\n其实，中国所有的问题都是政治问题，而不是经济问题，离开政治谈经济，永远找不到问题的答案。\n拆迁补偿 拆迁补偿的两种方式：1、现金补偿；2、回迁安置。 在二三线及以下城市，通常采用第二种，因为多数开发商没有钱现金补偿，房地产开发基本上是靠zf关系，空手套白狼，就是有钱也不愿意拿出来。 对于拆迁户来说，现金补偿也不划算，因为补偿的现金在与原地同级别的位置肯定是买不了相同面积的住房的，所以多数拆迁户选择回迁安置。 但是越小的城市开发新盘的速度越慢，往往回迁房盖个三五年也不见得盖得起来。在这期间，开发商会按月补偿拆迁户一定的租金，用于过渡。 手里现金多的拆迁户会先买房住，慢慢等拆迁，但是现金不多的拆迁户，就不得不拿着开发商的过渡款租房住。通常这笔过渡款都要高于相同位置的租金，所以拆迁户就把房租炒起来了。\n北京已经没有原地回迁的说法了，一线城市，还有部分较发达的二线城市都不搞原地回迁了，土著一旦拆迁了就赶到郊区。反而是二、三线城市，特别是三线以下城市多数还在搞原地回迁。主要原因是城市小，住户多多少少都有些背景，特别是单位的老公房，开发商不让原地回迁，根本就拆不动，阻力太大。\n房子从拆到迁是有时间的，快的情况是1年多，但很多情况都是拆迁安置房3,4年盖不起来。比如昆明的莲花池片区，大概是06年左右拆迁的，但拆迁安置房现在才开始动工，2012年才盖的起来。这种事情并不是个案。 贵州更离谱，房子04年拆了就再也没有音讯，开发商一直盖不起来，到现在都6年了。原来的拆迁户，现在还在租房住。\n城市底层 游泳横渡马六甲：\n经常有人说收入是决定因素，其实人均收入没有意义。北京姑娘去外企做前台一个月2000，和公司外地姑娘拿这么多，和做公务员的外地姑娘拿这些，生活成本天差地远。不是说有10万个月入2000的外来人口，四环内就有一万处他们能承受的住房。而个体的外来人口的支出，会随着生活成本调整。开始很难理解月入两三千的白领在北京市如何生活，毕竟他们不可能像楼下卖蔬菜水果的大叔那样，炖点猪肉粉条就算开荤，穿特价五块的汗衫就算工作服。一样的月入，白领的幸福起点高得多。后来知道他们原先偶尔用兰蔻改成一直用大宝，早餐不再喝豆浆，住单位附近的搬到五环外，有人在燕郊买了房……突然想起小时候学新概念英语，说起蓝领工资比白领高，但还有人为了能西装革履宁可减薪做白领。\n对80后而言，最恐怖的绝不是房价，而是养老。这也不是计生的问题，一个社会的生活资源是有限的，老龄化早晚会到来，为了改变老龄化呼吁多生育，那是饮鸩止渴。等多生出来这部分老了，再这么循环？而福利社会如英国是50多岁的人最幸福，有稳定养老金，二三十岁最痛苦，看不到未来依靠。家底不厚的像希腊，透支做社会福利，后果还不如不做。中国则是取不足以奉有余，竭全民之力供特权阶层挥霍，没有哪个年龄段享受过全民福利，还得共同面对养老难题。房子，真不算此生最纠结的事\nkkndme：\n正是如此，以后城市的底层吃饭都是问题，zf最喜欢拿房子说事转移矛盾\n垄断企业 我们的垄断企业其实都是第二税务局的角色，比如石油、移动、电力、水务、地产、银行等等。zf一定要掏空百姓的钱包，所以说什么泡沫不泡沫，就是个笑话\n农村自来水 说起农村建自来水更搞笑，亲眼目睹要不然真不敢相信。 贵州有个村子，以前，自来水是村子集体出钱买的管子，然后全村出劳力从山上接下来（用的山泉水），要是水管坏了，大家再摊钱摊劳动力修。 结果zf不愿意了，说他们修的不规范，zf给重新修，还是从山泉引水下来，zf包给工程队换了一下管子，然后每户给按了水表，安好了以后，要按照2块钱一吨收费，全村都炸了窝了，集体抗议，现在还没有结果。\n袁盎 丛林社会就是要承认人与人之间的差别，性格决定命运。 我要讲一个奇人，这个人叫袁盎。故事的出处是《史记·袁盎晁错列传》，如果鸡冻同志认为我瞎编，可以自己去看原文。\n袁盎同志的神奇是一般人都无法想象的，这个奇人在吴国当相国的时候，他手下的一个小公务员跟老袁同志的爱妾乱搞，经常背着老袁嘿咻嘿咻。老袁知道了这个事就装聋作哑。 有人跟那个小公务员说:坏了，你跟袁领导的二奶私通的事让袁领导知道了，你死定了。 小公务员一听吓坏了，骑了马就跑，公务员这份全世界最令人羡慕的工作也不要了。 小公务员一跑，袁领导就使劲追，小公务员就更拼命跑，袁领导就更拼命追。袁领导的马要好一点，跑的快，终于把小公务员追上了。小公务员只好下马等死。 袁领导急了，对小公务员说：你跑什么呀？我正打算把我的二奶送给你。兄弟如手足，妻子如衣服。大概就是这个意思。 小公务员感激涕零，抱着袁领导的二奶继续嘿咻。 所以说老袁这人最仗义，人缘最好。上下都买他的帐。\n老袁也有个把敌人。老袁在皇宫里当小跟班的时候，得罪了汉文帝宠爱的一个太监叫赵谈的，所以特别害怕，怕赵太监哪天找茬把自己给黑了。 老袁征求了侄子的意见，认为自己应该先下手为强，应该当众侮辱一下赵太监，这样如果赵太监再黑自己，就没人信了，别人都以为是公报私仇。老袁的政治手腕还是相当高的。 一天，文帝刘恒跟找太监坐在一辆车子里外出，老袁上前拦住车子，大义凛然的说：能够跟天子共乘一车的，都是天下豪杰，天子怎么能跟一个没小鸡鸡的人坐一辆车呢？ 赵太监当场就气哭了，还不能说什么。以后赵太监要黑老袁，也没那么容易了，因为大家都知道老袁义正言辞，充满正义的得罪了赵太监，如果赵太监再说老袁坏话，就是公报私仇。\n老袁的人缘是公认的好，但是在朝里有一个最大的敌人，就是大名鼎鼎的晁错。 晁错这个人学的是商鞅之术，法家的代表人物。为人冷酷，不讲人情，人缘特别差。老袁和晁错关系不好，可能跟两个人的性格很有关系。 晁错跟贾谊很有一拼，特别喜欢喷，口才也特别好，跟贾谊同志喷的内容也差不多，一会儿说打匈奴其实很简单啦，一会儿说必须削藩啦。刘恒听晁错喷的很有水平，很欣赏，但是刘恒不是傻子。 打匈奴？那得是国力强大以后的事，现在必须让老百姓修养生息。 削藩？我也想削藩，但是总得有合适时机才行啊，现在削藩不是逼人造反吗？ 刘恒对晁错这种人的态度就是，你建议你的，我听听就可以了，不能当真。\n晁错同志懂得要想发达，必须选择一个有前途的职业，所以凭着他气死保险推销员的口才，当上太子的老师。这个太子就是汉景帝刘启。 晁错的时代终于来了，原因是刘恒挂掉了。 刘启生下来就是锦衣玉食，可没他老子那两下子，也不怎么懂帝王之术，晁错说什么就是什么。 晁错于是抖起来了，不知姓什么了，仗着是皇帝的老师，飞扬跋扈，人缘极差。晁老师最爱追求政绩，立刻提出削藩。 削藩的结果就是吴楚七国反了。 这个故事跟明代朱允文同志的削藩如出一辙。明朝朱允文同志削藩的结果就是朱棣反了，当了皇帝。朱允文被迫流浪，泡吉普赛美眉去了。 吴王不是朱棣，性格有点象袁绍，生性多疑，手下有人才不会用，所以没能成大事，被周亚夫跟干掉了。如果吴王能有朱棣的本事，汉朝的历史就会改写。\n吴王一反，老袁就着急了。老袁给吴国当过相国，吴王造了反，晁错必然要借机宰了老袁，老袁觉得自己冤枉啊，吴王造反不是你晁错逼的吗？ 晁错果然趁机对老袁打击报复，安排了两个手下去弹劾老袁。但是晁错的人缘实在太差了，老袁的人缘实在太好了，那两个手下竟然不同意弹劾老袁。而且还劝晁错,大意是：现在七国兵马造反了，形式很危急，我们还搞内斗就不好了。老袁这个人是不可能参与谋反的。 晁错也着急叛乱的事，就把老袁放一边了。政治斗争，不是你死就是我活。 晁错错了，赔进了自己的老命。 窦婴同学也曾经在吴国当过相国，立刻跟老袁站在了一条战线上，准备给晁错来个致命一击。 晁错这个人的死，完全是他自己性格造成的，对人苛刻，政治上又是白痴。吴楚七国打着“诛晁错，清君侧”的名义造反，皇帝问晁错应该怎么办? 晁错的白痴精神充分发挥了出来，“陛下您御驾亲征，臣留守长安，做好看家的工作。” 皇帝估计当时心里要多愤怒有多愤怒。你自己惹的祸，你一个当臣子的在家躲起来，让我当天子的上去当炮灰，你是何居心? 不过刘启涵养好，没说出来。 这时候老袁跑了进来，说有平乱之计，要单独跟皇帝说。刘启很不客气的就把晁老师请了出去。 老袁立刻献计，既然反叛打着清君侧的名义，就先把晁老师宰了，叛军就出师无名了，就得不到老百姓的响应，事情就好办了。 刘启一听挺高兴，正恨晁老师让自己当炮灰的事呢，立刻同意，腰斩晁错。 晁错的下场要比贾谊惨多了。\n不过老袁的下场也并不好。皇帝的老妈想让皇帝的弟弟梁王在刘启驾崩后继承皇帝这份工作，但是老袁不同意，坚决表示反对，得罪了梁王。 梁王不是一般的高级公务员，最喜欢搞黑社会，找了杀手把老袁干掉了。 这个故事又告诉我们，即使人缘再好，在政治斗争中活下来也是不容易的。\nwelldayzwb：\n最好把历史故事表达的直白的意思讲出来，不排除观众里像我这么愚钝的人不少\nkkndme：\n我说的不是袁盎也不是晁错，说的是削藩，皇帝削藩怎么样？看看朱允文的下场，晁错几乎独揽了大权，削藩的下场是什么？腰斩。清查空置率，zf不参与一级开发，不是扯淡吗？\n二三线城市，选新城还是老城 wofuleyumin1：\n楼主 我又有问题了。。。。请务必回答 谢谢\n1。目前很多城市开发新城 我们主要谈二三线城市吧。。。这些地方的新城会超越老城吗？ 我们投资该投新城还是老城？\n比如成都 南边的天府新城，口号国际城南。。\n2。投资一定投越靠市中心越好吗？ 比如成都，西三环是比东二环还好。。但未来2环是否最终比3环好？\nkkndme：\n拆迁是块硬骨头，不够铁腕的领导会避开破旧但繁华的老城区的问题，转而开发新城，所以往往形成倒挂，即新城一下子变成了新贵聚居区，新城的房价甚至高过老城区。 但这是一种倒挂，老城升级改造是必然的一步棋，只是时间的早晚。未来老城区的升级改造，老城区的价值就会凸显，价格要远远高于新城。\n但是老城区的多数老房子都可能面临拆迁，投资老城区的老房子不见得划算，特别是二三线城市的拆迁，离皇帝越远的城市，争取合理补偿越困难。\n在中国，普通人手上闲钱不多的人被剥削 抽着雪茄喝着绿茶：\n兰州，我近来盛干人民币的贬值力度之强烈 现在手上还有十万的盈余 做什么好呢 咬紧牙关供一套房？买黄金？还是买车呢？ 总之不能空放着， 这样通货膨胀下去，汽车的价格也会涨吗？\nkkndme：\n买车是消费，不是投资，如果追求享受，可以买车，但不能保值增值。汽车属于工业品，通过扩大生产规模可以使边际成本下降，所以汽车会因为档次的不同有涨有跌。 黄金可以适当配置，但由于黄金的定价权不在国内，所以买黄金有一定的风险。 十几万买房子估计不够首付，除非特别小的城市。但小城市的房产变现起来比较麻烦。 至于古玩字画茅台酒之类的，真假难辨，不是专家很难参与投资，且一般人变现还是很困难的。 所以资金越小，资金实现保值增值越困难。我国实行的高通胀低利率政策，是对手中闲钱不多的普通群众赤裸裸的剥削。而手中闲钱较多的中产阶层，相对好一点，可以投资住宅商铺进行保值增值。\n三分天注定，七分靠打拼 汝爱之罪：\n从晁错的上位过程可以看出，口才很重要\nkkndme：\n呵呵，这个也不一定，一个是看老板的风格，一个是看自身的运气。 说汉文帝刘恒去参观皇家动物园（上林苑）就问动物园园长：“咱们动物园有多少动物啊，都有什么品种啊？”一下子把园长问晕了，吭吭叽叽答不上来。 这时有个负责老虎的工作人员跑了出来，作了一通汇报，如数家珍，回答的头头是道。刘恒特别高兴，觉得这个管理老虎的工作人员口才特别好，想提拔他当动物园园长。 这时候张释之蹦了出来，对皇帝说：秦朝的时候，赵高口才就特别好，特别巧言善辩，结果忠厚的大臣都被迫害了，天下大乱，秦朝完蛋了。陛下要是提拔这个管理大老虎的人，恐怕所有的大臣都会效仿他，专门学习卡耐基演讲，并且天天琢磨吹牛拍马，就没人真正为皇帝干活了。 结果是可怜的管理老虎的工作人员白高兴了一场，不但没得到奖赏，还得罪了动物园园长。\n人的前程有的时候不掌握在自己手里 某城市从外省调来个姓q的一把手。该一把手一上任就把该市原来的骨干公务员全部晾到一边，一概不用，名义上对外宣称的是：领导干部年轻化。提拔了一批没有工作经验刚毕业的博士生当处级干部，大多数30岁还不到。这些人一点工作经验没有，以至于外界都很惊讶，甚至惊动了日本友人。 该一把手正是要用这些毫无工作经验的白纸，第一：人是自己一手提拔的，他能不感激涕零吗？第二：这些人啥也不懂，自己想怎么干就怎么干，这些人听话就行。不这样做，怎么能一手遮天呢？ 一批期望往上爬的老公务员就这样牺牲掉了，而一批新丁就此崛起。人生的前程往往不掌握在自己手里。\n河南郑州与洛阳 scdf1234：\n楼主，我想咨询一下，像洛阳这样的城市，它的经济在河南是第二位，但又离省会郑州很近，洛阳的房价现在大概是四千多，您认为洛阳的房价上涨的空间大吗？ 谢谢！！！！！！！！！！！！\nkkndme：\n洛阳只能成为郑州的影子，如果自住，趁早在洛阳买房，以后一定会涨，如果投资，还是在郑州买，郑州的上涨空间，肯定大于洛阳。 不过95年以后，我就再也没去过洛阳，所以洛阳买哪个楼盘升值快，你得自己仔细研究。\n杭州 灵魂被枪决：\n不知道楼主还在不在，因为只看完前面几页。\n我前两天刚定了一套二手房，昨天打了首付款，下星期应该就要办银行按揭手续了。\n我一直很想买房，但我LG一直不愿意买房，就在定下这套房子之前他还是很不乐意，但\n因为我的坚持，我们终于买了房子了。房子定下后一个石头落地了，但另一个石头有悬\n地半空了，因为我们是做个体户生意的，就怕生意有变故贷款接不上（我是个悲观主义\n者，总先把最坏情况打算在前）。我们是在杭州，虽然不是市中心，但也算是市区了，\n请问楼主能分析一下杭州楼市情况吗？？\n先谢过了，楼主的文章对我启发真的很大\nkkndme：\n前面说过了，杭州我是当一线城市看的。杭州这个城市，本来就是富人的天堂，房价涨到多高都不奇怪，而且极好变现。所以你根本无须担忧资金问题。\n西安与重庆 ttan12345：\n用了一整天的时间拜读了楼主的精彩文章，很是佩服！\n印象最深刻的就是北周宇文式和苏的关于贪官的对答，古人真有高人啊！\n感觉楼主知识面相当的宽广，尤其对世界历史比较精通，许多观点非常符合世界发展的规律\n关于房产的问题，我也一直认为，最终不是我们小老百姓可以玩的东子，所以能买就\n尽早买。看了楼主不止一次给大家推荐去投资西安和重庆的地产，楼主问什么看好西安\n和重庆这两个地方，现在各个省会城市哪个不是大兴土木呢？为何西安和重庆会进入你\n的法眼？\nkkndme：\n重庆我就不多说，论述的比较多了，发展重庆是国家战略性的，这是政治任务。 西安是西北地区唯一的大城市（乌市比较特殊，不讨论乌市），教育资源丰富，且房价基数较低，所以说后续发展潜力很大，未来该城市的发展一定会纳入zy的视野\n谢国中「空置率」 林语边的鸽子：\n谢国中:\u0026ldquo;一是加息预期；二是政府对房地产的政策调控力度不改；三是市场对人民币升值的预期减弱；四是参考了实际的供应量，“到2012年，房地产的空置率会非常高，全中国13亿老百姓要有的房子都有了。” 谢国忠预测，“接下来可能会看到交易量一直在增长，而房价却不死不活地拖几年，房地产没有第二场戏了\n请问楼主对谢国中的说法怎么看? 谢谢\nkkndme：\n谢是油价和中国房地产的长期唱空者，从04年开始唱空中国房产。谢的有些话还是很有道理的，但有些预测就另有目的了，毕竟屁股决定脑袋。 今年谢一直呼吁的是加息，兼带唱空房地产，唱空房地产的主要依据是空置率。 谢自己也说中国的房地产最大受益的是zf，但却用空置率给出了一个下跌的结论。 人民币升值，呼吁加息，唱空房地产，摩根史丹利的喉舌作用显而易见的\n打工不如有一技之长的小老板 中年不惑吗：\n现在他们已经比一般的小白领强了\n人力成本只会越来越高\n现在去读个技校，当个技工\n肯定比一般大学出来强多了\n还有一个问题：\n一般企业的工资10年没有变\n10年前某个职位是5000，\n10年后这个职位也是5000；\n而在10年间，民工工资可能从1000涨到了3000， 房价更是涨了10倍；\n菜价生活用品也翻了数倍\n高房价问题其实就是分配问题\n如果某个从事的职位10年前和10年后是一样的\n那也就相当于这个职位的薪水降了相当多\nkkndme：\n进不了体制内的，无论是不是大学毕业，凡是有头脑的、懂做生意的，会一技之长的，只要不懒，活的肯定比无特长一般在公司打工的小白领强。 古代也是这样的，街面上卖爆肚的肯定比大户人家厨房里负责切葱的日子过的稳当。卖爆肚的小本生意很累很辛苦，但是有个手艺就不会饿肚子。大户人家切葱的上班期间日子过的比较轻松，甚至收入比卖爆肚的还强点，在大户人家也体面些。但一旦大户人家不要切葱的了，裁员了，这个切葱的出来还真没办法养活自己。 大学文凭顶多算个秀才资格，有这个资格才有机会举士，但是举不了士的，就必须学点技术，否则收入远远赶不上瓦工、电工。 过去的穷秀才，饭都吃不饱，但是社会地位却不差，一旦中了恩科，就是宰相根苗。现在有点不同，进不了体制内，又没点技术，那肯定沦为社会的最底层，不要说买房子了，能不能解决吃饭问题都不一定。\n一线、二线的生活 一线和二线选择哪个城市生活，其实就是围城。 在一线打拼，有技术有背景或者机会好的，进了金字塔的中层。对于没背景的，运气差点的，看着没什么希望就离开了，到二线发展，起码二线生活成本还低点。混不下去的离开了，又有大量的打算拼一把的冲进来。 很多人宁可在大城市当底层，也不愿意回小城市。这还是个观念问题。小城市从城东走到城西也就二十分钟，觉得过得太枯草。大城市灯红酒绿的，虽然跟自己其实没多大关系，但是看着就是舒服。\n讲故事含沙射影ZG之房子不属于市场经济 不说历史了，讲个故事吧。这个故事纯属虚构，如有雷同，纯属巧合。讲故事麽，就不要和谐了。 传说王安石变法失败，后人小王跑到了海外，发现了大西洲。大西洲正处于混乱阶段，军阀割据，外族入侵。小王是个政治军事天才，煽动农民起义，统一了大西洲政权，建立了大西国。 小王继承了王安石变法的理想，建立了一个中央高度集权，百姓与百姓之间完全消灭差别的理想国家。农场、工厂、商场全部由国家统一经营，老百姓只需要在国家的农场、工厂、商场里快乐打工就行了。老百姓穿一样的，吃一样的，连结婚都是国家给安排。 大西国里有的知识分子认为这样治理国家太机器化了，有违人性。小王同志对这些知识分子很生气。 遥远的东方，有一个白鹿洞书院，书院的院长是个伟大的导师，这个人叫朱熹，此人提出了存天理、灭人欲的理论，给了小王同志治理国家理论上的支持。 于是小王同志大搞禁欲主义，凡是学习过陆九渊、王阳明心学理论的都抓起来改造。\n不久，大西国经营的农场、工厂、商场就出了问题。效率特别低，老百姓出工不出力，胡干蛮干的比比皆是，后来出现了大饥荒，饿死了不少人。小王同志干不下去，被人赶走了。 新领导上台后，先把农场划分给农民，提高农民的积极性，先解决粮食问题。但是工厂、商场就比较不好办。 新领导认为，工厂、商场效益低，赔钱是因为负担太重了，城市里的老百姓生老病死都是由国家的工厂、商场负责，国家哪里管的起呢？ 于是新领导就提出给国家的企业减负，给点优惠政策，拿出胡萝卜，让胆子大愿意自己单干的同志们主动离开国家企业。对于很多死活不肯走的同志，新领导强令这些人卷铺盖，国家不再负担这些人的生老病死了。大家自己解决吧，国家不管了。 新领导把还留在国家企业的自己人，定义为内部人员。离开国家企业的，就是外人，定义为社会闲杂人等。 社会闲杂人等，有人欢喜有人忧。有人利用内部人员的关系，大把赚钱，有人跑去给外国人当洋买办赚的也不少，还有的知识分子凭着有点文化，给人打工生活的也不错，反正这些人都挺高兴，比在内部受穷强。当然也有没本事的，就比较惨，生活的比较困难。\n新领导看见内部都是自己人了，闲杂人等都清理掉了，于是着手内部改革，凡是稀缺的，与老百姓生产生活密切相关的行业，都由内部来经营，不需要动脑子搞创新，只要定个价，老百姓就必须得接受。 而需要创新动脑子的产业，不具备稀缺性必须充分竞争的产业，不是跟老百姓生产生活密切相关的产业都交给社会闲杂人等去自由竞争。 相当于把肉都留给了内部自己，把骨头扔给了外部闲杂人员。 这样做还有个好处：新领导喜欢内部自己人直接跟外国人做生意，但是只要跟外国人做生意就赔钱，赔的还不是一点半点。赔的钱从哪里补呢？ 只要通过内部自己人经营的企业，抬高定价，将赔掉的钱转嫁给社会闲杂人等就可以了。 于是，当初离开内部的社会闲杂人等发现，钱也难赚了，生活成本也越来越高了，日子过得变得越来越艰难了。 这时有个傻空跳出来说：我就不信了，市场经济没有只涨不跌的商品。房价肯定会跌。 有个明白人告诉他：市场经济是分品种的。外部社会闲杂人等经营的电脑、电视是市场经济。但是内部人经营的石油、房地产不是市场经济。不能拿市场经济来解释。 这个傻空不信，本来在大西国能买房的，结果一直没买，后来买不起了，只好一直租房住。但是房租老涨价，吃饭越来越困难，一年难得吃两回肉。\n什么是好的政策 好的政策就象挂在驴子鼻子上的胡萝卜，让人永远有希望，但是拼命追也吃不到。这就是中国政治家的最高智慧。\n洋人进北京，老佛爷把义和团推出来，结果拳匪搞的鸡飞狗跳，没法收场。 保钓也打算发动群众，靠爱国激情转嫁矛盾。不过好像这招不灵了。老板怎么对待员工，员工就会怎么回报老板。\n李商隐「渣男」祖师爷 中秋节将至，撇开房地产的涨跌。喝一壶好酒，聊聊古人。\n云母屏风烛影深，长河渐落晓星沉。 嫦娥应悔偷灵药，碧海青天夜夜心。\n借着中秋节的千古名句，我们八卦一下李商隐。 李商隐帅哥很有女人缘，据说谈了n多次荡气回肠的恋爱，不过这些恋爱经历没记录进正史，而是唐代的八卦记者通过李商隐帅哥的文学作品，侦破出来的。\n李商隐帅哥不光会写诗，年轻人还在玉阳山修习过道术。但是当道士期间并没有认真的清修，以李帅哥的魅力，竟然吸引了一个美丽多情的女道士的目光。\n这个女道士叫宋华阳，本来是个侍奉公主的宫女，跟随公主进山当了女道士。两人邂逅于山中，缠绵悱恻，但终究没有结果，宋美眉怀了李帅哥的宝宝，李帅哥也被轰下了山。但好像李帅哥也没负什么责任。\n李帅哥伤痛的写下了“无题”以示纪念： 昨夜星辰昨夜风， 画楼西畔桂堂东。 身无彩凤双飞翼， 心有灵犀一点通。 隔座送钩春酒暖， 分曹射覆蜡灯红。 嗟余听鼓应官去， 走马兰台类转蓬。\n李帅哥的第二个女朋友，被八卦记者们认为是锦瑟，锦瑟是谁？八卦记者们认为是令狐楚家的一个美丽温婉的侍女。\n李帅哥很有才华，但是在晚唐时代，有点生不逢时。当时牛僧孺和李德裕搞党争，李帅哥跑去给牛党的重要人物令狐楚当幕僚，结果泡上了令狐大人的侍女。这个李帅哥和锦瑟谈恋爱的证据是根本没有。八卦记者是根据李帅哥的诗找到的蛛丝马迹。\n这首诗就叫锦瑟。\n锦瑟无端五十弦，一弦一柱思华年。 庄生晓梦迷蝴蝶，望帝春心托杜鹃。 沧海月明珠有泪，蓝田日暖玉生烟。 此情可待成追忆，只是当时已惘然。\n春 风光冉冉东西陌，几日娇魂寻不得。 蜜房羽客类芳心，冶叶倡条遍相识。 暖蔼辉迟桃树西，高鬟立共桃鬟齐。 雄龙雌凤杳何许？絮乱丝繁天亦迷。 醉起微阳若初曙，映帘梦断闻残语。 愁将铁网罥珊瑚，海阔天宽迷处所。 衣带无情有宽窄，春烟自碧秋霜白。 研丹擘石天不知，愿得天牢锁冤魄。 夹罗委箧单绡起，香肌冷衬琤琤佩。 今日东风自不胜，化作幽光入西海。\n夏 前阁雨帘愁不卷，后堂芳树阴阴见。 石城景物类黄泉，夜半行郎空柘弹。 绫扇唤风阊阖天，轻帏翠幕波洄旋。 蜀魂寂寞有伴未？几夜瘴花开木棉。 桂宫流影光难取，嫣薰兰破轻轻语。 直教银汉堕怀中，未遣星妃镇来去。 浊水清波何异源，济河水清黄河浑。 安得薄雾起缃裙，手接云輧呼太君。 秋 月浪衡天天宇湿，凉蟾落尽疏星入。 云屏不动掩孤嚬，西楼一夜风筝急。 欲织相思花寄远，终日相思却相怨。 但闻北斗声回环，不见长河水清浅。 金鱼锁断红桂春，古时尘满鸳鸯茵。 堪悲小苑作长道，玉树未怜亡国人。 瑶琴愔愔藏楚弄，越罗冷薄金泥重。 帘钩鹦鹉夜惊霜，唤起南云绕云梦。 璫璫丁丁联尺素，内记湘川相识处。 歌唇一世衔雨看，可惜馨香手中故。\n冬 天东日出天西下，雌凤孤飞女龙寡。 青溪白石不相望，堂上远甚苍梧野。 冻壁霜华交隐起，芳根中断香心死。 浪乘画舸忆蟾蜍，月娥未必婵娟子。 楚管蛮弦愁一概，空城罢舞腰支在。 当时欢向掌中销，桃叶桃根双姊妹。 破鬟倭堕凌朝寒，白玉燕钗黄金蝉。 风车雨马不持去，蜡烛啼红怨天曙。\n这是李帅哥写的燕台诗四首。 有个叫柳枝的美女，是洛阳大富翁的女儿，吟唱了这首诗后，就爱慕上了李帅哥。这个美女很大胆主动跟李帅哥约会，并没有嫌弃李帅哥没车没房，但不幸被李帅哥放了鸽子。李帅哥其实很喜欢这个柳枝，事后非常后悔，准备把失去的爱情找回来，但是柳枝已经给有权有势的大佬做了妾。\n飒飒东风细雨来，芙蓉塘外有轻雷。 金蟾啮锁烧香入，玉虎牵丝汲井回。 贾氏窥帘韩掾少，宓妃留枕魏王才。 春心莫共花争发，一寸相思一寸灰。\n这首诗名为“无题”，写得是荷花。荷花是民间传说中李帅哥又一个女朋友的名字，也是李的初恋。美丽的荷花陪李帅哥进京赶考，半路上得了重病，李帅哥天天陪伴着她，但不幸的是，荷花还是香消玉损。李帅哥悲痛不已，常常以荷花为题，以纪念此段恋情。\n李帅哥的才华，被节度使王茂元看中了，把女儿嫁给了这位帅哥。李帅哥娶了这位娇妻的同时，也给自己带来了麻烦。\n原因是王茂元是李党的重要人物，而李帅哥的老师令狐楚却是牛党的重要人物。娶了王美人，李帅哥掉进了牛、李两党的夹缝，于是前途杯具了。\n这个故事告诉我们，如果有个老大罩着你，日子过的还不错，就千万别轻易向老大的对手抛媚眼。否则，只能是杯具。\n李帅哥尽管前途杯具了，但是跟娇妻王氏感情很好，王氏突然病逝，李帅哥伤痛万分，写下了“悼伤后赴东蜀辟至散关遇雪” 剑外从军远，无家与寄衣。 散关三尺雪，回梦旧鸳机。\n无题 相见时难别亦难，东风无力百花残。 春蚕到死丝方尽，蜡炬成灰泪始干。 晓镜但愁云鬓改，夜吟应觉月光寒。 蓬山此去无多路，青鸟殷勤为探看。 夜雨寄北 君问归期未有期，　巴山夜雨涨秋池。 何当共剪西窗烛， 却话巴山夜雨时。 读这两首诗，第一个感觉就是李帅哥的用情之深，令人叹为观止；第二个感觉就是，其克女朋友的本事，也令人叹为观止啊\n将近中秋，闲扯了一通李商隐，就以李商隐的无题结束这个闲话吧。\n凤尾香罗薄几重，碧文圆顶夜深缝。 扇裁月魄羞难掩，车走雷声语未通。 曾是寂寥金烬暗，断无消息石榴红。 斑骓只系垂杨岸，何处西南待好风。 重帏深下莫愁堂，卧后清宵细细长。 神女生涯元是梦，小姑居处本无郎。 风波不信菱枝弱，月露谁教桂叶香。 直道相思了无益，未妨惆怅是清狂。\n西五环内的别墅，是相当稀缺的资源 黎明中的星光：**\n楼主，认真阅读您的帖子快两周了，以史为鉴，深入浅出，感觉受益匪浅！\n这两天，也在为在北京买房子的事很纠结，请您指点一二：\n为自住，我们最近要买房了，此前，已经关注一年了，一年中，看上的房子都翻了倍。\n最近我们在西四环西五环之间选了一个低密度花园别墅，叠层，新房，小区面积不大，只有200多户，（第一期08年开盘，大约2万上下单价，已入住，这次是二期）。小区密度是1.0。一期为3到5层，2期为5层坡屋顶。小区本身绿化环境不错，堪称绿意盎然，对内部环境很满意，我们选的是1、2层叠层带小花园的房子，220平方米左右。 这个小区叫：“金隅—长安山麓”，您从网上可以查到。\n目前价格均价37000元左右。年初开盘时31000左右。开发商的策略是每次小部分放量，慢慢卖，拉开每栋楼开盘时间。最近我们看上的这个，是8月份开盘的。\n我们认为优点是： 1、低密度带花园；这在大都市太难得了。 2、周围绿色环境好，多。向北是香山方向，一路绿色。 3、距离石景山万达距离近，3公里左右吧。万达出现在哪里，哪里基本是一个商业服务中心了。\n缺点是： 1、周围没有紧密连接大型服务超市，商场等。最近的沃尔玛在2公里以外。 2、周围环境还不够理想。饭后散步、娱乐休闲的地方几乎没有。\n担忧和想咨询您的问题是： 1、现在出手买，是否太冒险？ 2、您对这个小区的前景判断如何？ 3、我有朋友说买市中心的高层更好，万一卖掉也方便。怕这里以后不好出手。\n楼主，再次打扰，百忙中能帮分析下吗？不胜感谢！\nkkndme：\n关于西五环内的别墅，是相当稀缺的资源，相当于奢侈品，奢侈品是不会随着调控有大幅度的调整，可以参考收藏品的投资，收藏品的风险在于战乱发生或者**经济崩盘。\n“奸臣”贾似道 说一个存在争议的人物，这个人被宋史写入“奸臣传”，就是大名鼎鼎的贾似道。几乎所有人眼中的贾似道都是大奸贼的形象，仗着是贵妃的姐姐，由一个游手好闲不学无术的二流子，摇身一变成了飞扬跋扈的大汉奸。他贪污受贿，搜罗奇珍美女，蒙古人打过来媚外卖过，还向皇帝谎报军情，最后南宋在他手里灭亡。反正老百姓眼中奸臣能干的所有坏事，都安在了贾似道的头上，然而历史真的如此吗？\n经过多方面史料对照，读书仔细的筒子会发现，宋史的说法并不可信，自相矛盾的地方太多，几乎可以说宋史几乎收罗的都是野史和民间传说。是什么原因使一部正史却采用了大量的野史资料呢？\n原因只有一个，贾似道得罪的人太多。\n贾似道得罪人的原因，在于推行了一个政策：公田法。推出的背景是连年征战，南宋需要庞大的军费开支。军费的开支从哪里来呢？当然是从最底层的农民的肚子挤出来。南宋的经济已经是非常困难了，巧妇难为无米之炊，于是zf推出了纸币，相当于给人民打白条，可见纸币并不是现在的专利。这就是恶性通货膨胀。眼看国家经济崩盘了。贾似道想的办法就是：公田法。\n公田法的意思跟傻空说的把多军的财产充公的意思差不多，就是限制地主的田地，凡是超过标准的，超过部分的三分之一充公给zf，zf给佃农耕种，产出的粮食用于军粮。有点相当于物业税的意思。\n就凭贾似道想出的这个政策，说贾似道是个不学无术的混混，说什么我也不会相信的。\n贾的办法很大程度上缓解了南宋经济的彻底崩盘，延缓了南宋生存的时间，但是贾却得罪了几乎所有的地主士大夫阶层。\n贾不是一个贤臣，但绝非二流子，政治上也许不够成熟，但是为了南宋的艰难维持也算是呕心沥血。关于向蒙古大军求和，也并不能就说明他是个汉奸，那样一个经济崩溃，军队毫无战斗力的朝廷，你让他硬着头皮打，下场也就相当于鸦片战争。当然，关于宋史里讲到的贾似道极尽献媚之能事，把汉奸表演得淋漓尽致，应当是士大夫出于地主阶层对公田法的憎恨，狂泼的屎盆子。因为宋史的记录实在是疑点颇多。\n南宋的将领如范文虎、夏贵之流，才真是腐败透顶，拥兵自重，对抗元军极尽脚底抹油之能事，而贾似道能够亲自督师，所以说贾似道是个大汉奸，实在开玩笑有点过火。南宋灭亡了，元世祖抓了南宋投降的将领问话：你们为什么这么容易就投降了呢？\n降将回答：都是贾似道，只重视文官，不重视我们，所以就投降了。\n元世祖哈哈大笑：就你们这样的武将，贾似道能重视你们才怪。\n贾似道最后被郑虎臣擅自给杀了。郑虎臣是个大地主，自己的利益被公田法害得不轻，恨透了贾似道。\n贾似道死了，全体士大夫阶层拍手称快，并且把他列入了奸臣传，永世不得翻身。\n全因为一个公田法。\n关于拆迁 关于拆迁，我国只有一部91年颁布的拆迁管理条例，但是就是这个简单的东西，很多拆迁时并不遵守。\n常规来说，拆迁应持有拆迁许可证，开发商的开发项目应通过规划局的审核（这个可以在规划局查到），如果连开发商是谁，有没有资格开发都不知道就奇怪了。\n是否同意拆迁取决于拆迁户和拆迁方的博弈，但是拆迁补偿办法一定要具体详细，包括如何补偿，过渡期的约定，具体要有时间和操作办法，还要签订违约责任。关于协议不可能只留在拆迁方手中，这是不合法的。\n暴利拆迁，zf侵害拆迁户的利益的例子比比皆是，关键是自己如何争取主动。\n保钓事件之死要面子活受罪 保钓事件，既定对策就是争取更多小国穷国的舆论支持，减免他国债务，加大对外经济援助。钱的来源，要靠底层国民勒紧裤腰带。\n自古以来，泱泱大国，威仪四海，对外“恩”显示国力强大，对内“威”显示权力强大，恩威并施，千古国策。\n朱棣的恩泽海外，死要面子，是做的比较极致的。结果是国库空虚，人民吃饭一下成了问题。所以才有后来坚定的禁海。\n如果开通海外贸易，不是为了皇帝的面子，而是为了充实国库和老百姓的腰包，明代的官僚就不会坚持禁海，中国的历史就会改写。\n郑和下西洋，反而堵塞了中国通向大海的道路。\ntjOOSAN\n我只能说，楼主不懂政治，就触及了。钓鱼岛就算所有您所谓的“小国”都支持。也没用啊。神经病 就是神经病\nkkndme\n这个做法不新鲜，从周恩来时期，我们的外交政策就是拉拢第三世界国家的选票，远到非洲拉美，近到越南缅甸柬埔寨，支援铁路基建，捐钱捐物，自认第三世界国家的带头人。但是第三世界国家基本有奶就是娘。比如拉美的苏里南，我国刚捐了钱物，米国给了点好处，马上又投向米国。\ntjOOSAN\n建议您看看nhk的中国力量。真实偷拍的中国在非洲都做了什么。\n1、资源。铁矿石 2、建立国家通信网 3、人力。\n呵呵。援助是拉拢，但是有条件的。\n越南最新的高铁，由日本公司建设。中国从来没援建过越南。\n唉。。。。你把中国当傻子了。\nkkndme\n周时代，越南的生产工具、军火、粮食，都是中国无偿援助。无知不可怕，无知还满嘴喷粪最可怕\ntjOOSAN\n呵呵！\n援建越南？？！哪了？给我证据？！？\n关于非洲，我给你们穿了视频！自己看就知道了\n中年不惑吗\n还非洲的力量\n当年红太阳把大米鸡蛋东方红拖拉机运到阿尔及利亚\n换来的是“中国人民是我们最好的朋友”和对中国各种口头的声援\n这和kkndme兄说的难道不一致吗\n现在不给钱给物了\n你还能听到“中国人民是我们最好的朋友”的说法吗？\n拉拢非洲小兄弟，是具有政治意义的\n你英国是一票，人家再穷的小国也是一票\nkkndme\n你理解力看来真有问题，你哪只眼睛看到争取小国穷国的舆论支持里面，包括越南。\n这个事是温总定的调子，挂在搜狐首页\ntjOOSAN\n中年！kk！！ 你们这两个同学啊！一看就跟成天上网的学生，没两样。争来争去。\n哎呀，非要你赢他输。\n唉。。。你说的怎么就对呢？？！证据！！明白吗？？\n光你自己打嘴炮。没用啊！\n呵呵 我得出去玩会了\n你们继续网络吧！~~ 两个宅男\nkkndme\ntjOOSAN你去图书馆查查当年的报纸，什么都清楚了。\n典型的愚民政策教育出来的傻蛋。\n中国的房地产不可能软着陆 中国的房地产不可能软着陆，甚至也不可能出现日本的硬着陆。一旦积蓄的问题爆发，会直接崩，崩的绝不会只是房地产。那时候绝对没有人会关心房价，很多人将庆幸于当天能够勉强填饱肚子，但绝不奢望还能见到第二天的日出。\nxiangshangpa\n请教楼主，如果出现您说的大部分老百姓勉强甚至不能填饱肚子，房价没人关心的时候，也就是社会动荡的时候，作为您这样的中产以上的阶级，还没有移民，如何自保？我很感兴趣，谢谢！祝中秋快乐！\nkkndme\n这种事要静观其变，所谓山雨欲来风满楼，发生之前一定会有大的征兆。 自保是没**有办法的，只能看形势不对，脚底抹油。\nxxx\n按照我的理解，在发生很大征兆之前，党国就会采取措施，实施闭关锁国政策（倒回50年代），跑是跑不掉的，如果大量难民出去，也没有几个国家会接受，中产，富裕阶层也不例外，现在很多国家已经提高移民门槛了，我对这种情况的出现感到悲观，调适空间十分有限，权贵集团真的是永远无法满足，唉\nkkndme\n呵呵，人的命，天注定，自求多福吧。\n中年不惑吗\n我倒没有kkndme兄那么悲观\n去看看美国20世纪30年代的新闻和文章\n也是一片哀嚎\n资本主义已经完蛋了，无可救药了\n贫富差距太大，老百姓活不下去了\n美国当时的知识界很多人都是向往苏俄模式的\n左倾的名流非常多（包括卓别林和爱因斯坦等等）\n即使到了20世纪50年代，美国还要搞麦卡锡主义\n也说明了当年左倾很有市场\n现在了，苏俄成为历史，资本主义反倒越活越精神了\n还有就是如果在南北战争的时候想象一个黑人能当总统\n人家肯定说你是凡尔纳\n就是马丁路德的时候\n也只是奢望能给黑人争取公平和权益 社会进步总是靠人推进的\n可以是谭嗣同蔡锷，也可以是邹容和陈天华\n何必太悲观了\n难道不是事在人为吗 自己都不努力改变\n怎么能埋怨前辈的选择错误不作为了\n关于购买经济适用房 大学生007\n楼主你好，质询个问题： 我家要买个二手房，房子是经济适用房，房产证上写的是土地划拨，中介说买了之后就是商品房了，那买了以后房产证上写的还是不是划拨啊，如果以后遇到拆迁什么的是不是补偿跟人家正规商品房不一样啊？谢谢\nkkndme\n经济适用房需要补交土地款后才能上市销售，补交土地款后，就变成了商品房，所以不用担心。 购买经济适用房一定要把补交的地价款算进去，才知道房价是否高于或低于周边商品房楼盘。 我国房地产交易很不规范，特别是中介有很多办法欺骗客户，买房无论是自住还是投资都要多长几个心眼。\n地级市买房 我是射手520\n楼主，您好。有幸看到您盖的楼，您对历史、政治和经济的研究让我如醍醐灌顶，很多隐约迷惑的东西，似乎有了出路能去寻找答案。万分感谢。 说到置业，您对一线二线城市谈的较多，想听听您对类似我们这样城市楼市和经济的看法。 我所在的是地级市，离您帖子提到的武汉有500公里。我所在的地市以汽车工业为主导，是三大汽车集团其中之一的发源地，目前是该企业的商用车基地。 在全省范围，离省会最远，但是在城市建设、居民生活水平、物价和房价可以排在全省前面，以前分析是因为我们这里是以工业为主，故经济发展比其他以农业为主的地市发展的要好，看了楼主的帖子，感觉跟离武汉最远也有关系。 我们当地最贵房价从05年前2000以内，到09年3000-4000元，到今年的5000元，最贵的6000元。 房价的飙升一方面随着全国大环境有关，我分析同时跟当地政府的发展思路密不可分，05年开始引进外地大开发商，新修了很多路，其中跟旧城区主干道平行的最重要的一条路，随着市政府入住，体育馆、美术馆，大开发商进驻，经过5年发展，该路段已经成为我们这里房价最贵的一条路，我们是小城市，在这里买房子的，除了投机成分以外，大部分应该是改善型住房，要大型小区，要绿化，这条路目前房子也是越盖越高。通过建设，当地政府财政也充裕，明显感觉对市政投入也大多了。 我们这里养老还是不错的，山多，空气好，工业城市，经济发展也交好。 我目前的置业状况是，在老城区广场旁边有单位分高层住宅一套，虽然是塔楼，但在广场旁边，弱化了容积率高，当年放弃了单位地段相对没这个中心，总价低的多层住宅，就是看中了地段，这个投资较成功，按照现在市价，房屋总价基本翻番，该房屋目前由父母住。 08年底，在开始说的新地段够买一套房屋，120平米，多层住宅，周边政府规划为大学城，周边有两所大专院校，对于该房屋地段较为满意，虽然比不上新修的路的北边和中部靠近体育馆，靠近政府地段升值快，但较看好该地段前景，该地段新修了 一条连接老城区的通道，唯一不太满意是购买的顶楼，因为是购买的该小区的多层住宅没有电梯，如果有了孩子，住顶楼生活就不太方便。购入均价2900，目前周边的新盘均价4500元，该楼盘创造了摇号去选房的记录。该套房屋自住，当年购买房屋没有多贷款一步到位，现在如果想换个满意的难度就大的多，满意的房屋都5000往上了。这套房屋有15万左右的贷款。 虽然很看好武汉的楼盘，远远现阶段大于经济承受能力，目前放弃。 对于我们当地的楼盘，也超出了我们这种普通人的能力，虽然最近楼盘都卖的很火。 好在单位公积金较多，我打算收复30%，剩下用公积金贷款，再购置一套房屋，怕再过一段时间，我的改善型需求就满足不了。 前一段时间，有个机会，但是考虑按照目前房价，30%首复，要耗尽目前自己和家人积蓄，犹豫中，错过了机会。 目前这种状况，不知道是否该再次买房？ 再次买房考虑标准时什么？我不太喜欢高层，但是原中心城区，没有大盘，都是单位或者小开发商盖的，基本没有绿化，在中心城区边上也有了一套高层住宅。 考虑学位房？我们城市不大，目前这套中心城区房屋虽然没有画片在最好的小学中学，但是离这些学校距离比较近。 在靠近那条政府搬入的路的北边靠近体育馆、美术馆（同时也靠近两所重点高中）地方置业，那里房价已经5000多，年底开盘的都是30层以上的高层，自住又不太考虑高层，总价也超出了承受范围。 在当地，离那个大企业居住地，区政府也新开了一条路，那条路待开发状态，据说区政府要搬过去（要搬也是2年以后，现在那条路只有一个大开发商在开发），那条路开车到市中心20分钟，那次有机会买的就是那个大开发商的楼盘，主推多层住宅并且带电梯，去年就预售完毕，这次犹豫中，错过了，住宅品质较好，目前地段太偏。 如果再有机会，该如何选择呢？\nkkndme\n地级市选房是比较麻烦的，因为投资风险要大于一线城市和省会城市。 地级市的购房需求，主要是以改善性需求为主，追求的是大盘，低密度，低楼层，高绿化，最好有个江景或者水景，环境优美的别墅是首选。 因为低级市城市较小，绝对的城中心如果环境比较嘈杂，小区不够高档最好不要选择。没有实力购置别墅，可以选择环境优美的高端住宅，最好是品牌大盘，一眼能够让人赏心悦目。\n","permalink":"https://vcvvvc.github.io/post/tianya_kk/","tags":["易"],"title":"天涯 kkndme备份"},{"categories":null,"contents":"I/O模型 https://vcvvvc.github.io/post/server_actor/\nI/O多路复用 Select、Poll、Epoll, 多路是指？多个业务方（句柄）并发下来的 IO 。 复用是指？复用这一个后台处理程序。\nSelect select()函数主要解决的是accept()函数阻塞问题，而没有解决recv()和send()函数阻塞问题\n#include \u0026lt;sys/select.h\u0026gt; int select(int nfds, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout); nfds参数指定被监听的文件描述符的总数。\nreadfds, writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。\n#include \u0026lt;sys/select.h\u0026gt; int FD_ZERO(int fd, fd_set *fdset); //一个 fd_set类型变量的所有位都设为 0 int FD_CLR(int fd, fd_set *fdset); //清除某个位时可以使用 int FD_SET(int fd, fd_set *fd_set); //设置变量的某个位置位 int FD_ISSET(int fd, fd_set *fdset); //测试某个位是否被置位 timeout参数用来设置select函数的超时时间 struct timeval{ long tv_sec; /*秒 */ long tv_usec; /*微秒 */ } select示例代码: select.cpp Poll #include \u0026lt;poll.h\u0026gt; int poll(struct pollfd *ufds, unsigned int nfds, int timeout); struct pollfd { int fd;\t//文件描述符 short events;\t//要求查询的事件掩码 short revents;\t//返回的事件掩码 }; ufds是一个数组，即poll函数可以监视多个文件描述符。\nnfds为监听事件集合fds的大小\ntimeout 为poll的超时时间，单位毫秒。timeout 为-1时，poll永远阻塞，直到有事件发生。timeout为0时，poll立即返回。\npoll示例代码: poll.cpp Epoll epoll示例代码: epoll.cpp 1. 创建一个epoll的句柄 int epoll_create(int size); 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。\n这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。\n2. 将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //op为注册事件 epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。\n用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。\nEPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd； 3. 等待事件触发，当超过timeout还没有事件触发时，就超时 int epoll_wait(int epfd, struct epoll_event * events, intmaxevents, int timeout);\n等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中, 并且将注册在epfd上的socket fd的事件类型给清空\n参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。\n如果下一个循环你还要关注这个socket fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,\u0026amp;ev)来重新设置socket fd的事件类型。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。\ntypedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合:\nEPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；\nEPOLLOUT：表示对应的文件描述符可以写；\nEPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\nEPOLLERR：表示对应的文件描述符发生错误；\nEPOLLHUP：表示对应的文件描述符被挂断；\nEPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。\nEPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n触发模式 epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。\n水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件 //LevelTriggered(LT) //缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。\n边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。 //Edge Triggered(ET) //高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)\n假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除， 则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。 总结: LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。 ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据, 也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样; 而LT模式是只要有数据没有处理就会一直通知下去的. epoll IO多路复用模型实现机制 设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？ 在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。 epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统，把原先的select/poll调用分成了3个部分：\n调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)\n调用epoll_ctl向epoll对象中添加这100万个连接的套接字\n调用epoll_wait收集发生的事件的连接\n只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。\nLinux内核具体的epoll机制实现思路 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关\n/* * This structure is stored inside the \u0026#34;private_data\u0026#34; member of the file * structure and rapresent the main data sructure for the eventpoll * interface. */ struct eventpoll { /* Protect the this structure access */ spinlock_t lock; /* * This mutex is used to ensure that files are not removed * while epoll is using them. This is held during the event * collection loop, the file cleanup path, the epoll file exit * code and the ctl operations. */ struct mutex mtx; /* Wait queue used by sys_epoll_wait() */ wait_queue_head_t wq; /* Wait queue used by file-\u0026gt;poll() */ wait_queue_head_t poll_wait; /* List of ready file descriptors */ /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ struct list_head rdllist; /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/ /* RB tree root used to store monitored fd structs */ struct rb_root rbr; /* * This is a single linked list that chains all the \u0026#34;struct epitem\u0026#34; that * happened while transfering ready events to userspace w/out * holding -\u0026gt;lock. */ struct epitem *ovflist; /* The user that created the eventpoll descriptor */ struct user_struct *user; }; 每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。\n而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。\n在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示:\n/* * Each file descriptor added to the eventpoll interface will * have an entry of this type linked to the \u0026#34;rbr\u0026#34; RB tree. */ struct epitem { /* RB tree node used to link this structure to the eventpoll RB tree */ //红黑树节点 struct rb_node rbn; /* List header used to link this structure to the eventpoll ready list */ //双向链表节点 struct list_head rdllink; /* * Works together \u0026#34;struct eventpoll\u0026#34;-\u0026gt;ovflist in keeping the * single linked chain of items. */ struct epitem *next; /* The file descriptor information this item refers to */ //事件句柄信息 struct epoll_filefd ffd; /* Number of active wait queue attached to poll operations */ int nwait; /* List containing poll wait queues */ struct list_head pwqlist; /* The \u0026#34;container\u0026#34; of this item */ //指向其所属的eventpoll对象 struct ![Uploading EPOLL_663944.jpg . . .] eventpoll *ep; /* List header used to link this item to the \u0026#34;struct file\u0026#34; items list */ struct list_head fllink; /* The structure that describe the interested events and the source fd */ //期待发生的事件类型 struct epoll_event event; }; 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。\n通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。\n代码示例 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; const int MAX_EVENT_NUMBER = 1024; const int BUFFER_SIZE = 10; int setnonblocking(int fd); void addfd(int epollfd, int fd, bool enable_et); void lt(epoll_event *events, int number, int epollfd, int listenfd); void et(epoll_event *events, int number, int epollfd, int listenfd); int main(int argc, char **argv) { int port = 20999; struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); int listenfd = socket(AF_INET, SOCK_STREAM, 0); assert(listenfd != -1); int reuse = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;reuse, sizeof(reuse)); int ret = bind(listenfd, (struct sockaddr*) \u0026amp;addr, sizeof(addr)); assert(ret != -1); ret = listen(listenfd, 10); assert(ret != -1); epoll_event events[MAX_EVENT_NUMBER]; int epollfd = epoll_create(5); assert(epollfd \u0026gt; 0); addfd(epollfd, listenfd, true); while (true) { int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1); if (ret \u0026lt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;epoll failed \u0026#34; \u0026lt;\u0026lt; std::endl; break; } //lt(events, ret, epollfd, sockfd);\t//LT模式 et(events, ret, epollfd, listenfd);\t//ET模式 } return 0; } //设置非阻塞文件描述符 int setnonblocking(int fd) { int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option; } //将描述符fd的EPOLLIN注册到epollfd提示的epoll内核事件中，参数enable_et指定是否启用ET模式 void addfd(int epollfd, int fd, bool enable_et) { epoll_event event; event.data.fd = fd; event.events = EPOLLIN; if (enable_et) { event.events |= EPOLLET; } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026amp;event); setnonblocking(fd); } //LT模式 void lt(epoll_event *events, int number, int epollfd, int listenfd) { char buf[BUFFER_SIZE]; for (int i = 0; i \u0026lt; number; i++) { int sockfd = events[i].data.fd; if (sockfd == listenfd) { struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr*)\u0026amp;client_address, \u0026amp;client_addrlength); addfd(epollfd, connfd, false); } else if (events[i].events \u0026amp; EPOLLIN) {\t//只要socket读缓存中还有未读出的数据，就会被触发 std::cout \u0026lt;\u0026lt; \u0026#34;event trigger once\u0026#34; \u0026lt;\u0026lt; std::endl; memset(buf, \u0026#39;\\0\u0026#39;, BUFFER_SIZE); int ret = recv(sockfd, buf, BUFFER_SIZE-1, 0); if (ret \u0026lt;= 0) { close(sockfd); continue; } std::cout \u0026lt;\u0026lt; \u0026#34;get: \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; \u0026#34; bytes of content: \u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;something else happened\u0026#34; \u0026lt;\u0026lt; std::endl; } } } //ET模式 void et(epoll_event *events, int number, int epollfd, int listenfd) { char buf[BUFFER_SIZE]; for (int i = 0; i \u0026lt; number; i++) { int sockfd = events[i].data.fd; if (sockfd == listenfd) { struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr*)\u0026amp;client_address, \u0026amp;client_addrlength); addfd(epollfd, connfd, true); } else if (events[i].events \u0026amp; EPOLLIN) { std::cout \u0026lt;\u0026lt; \u0026#34;event trigger once\u0026#34; \u0026lt;\u0026lt; std::endl; int ret = 0; //因为ET模式不会重复触发，所以我们要循环读取所有数据 while (true) { memset(buf, \u0026#39;\\0\u0026#39;, BUFFER_SIZE); ret = recv(sockfd, buf, BUFFER_SIZE-1, 0); if (ret \u0026lt; 0) { //对于非阻塞I/O，下面的条件成立时表示数据已全部读取完毕 if (errno == EAGAIN || errno == EWOULDBLOCK) { std::cout \u0026lt;\u0026lt; \u0026#34;read later!\u0026#34; \u0026lt;\u0026lt; std::endl; break; } close(sockfd); break; } else if (ret == 0) { close(sockfd); } else { std::cout \u0026lt;\u0026lt; \u0026#34;get \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; \u0026#34; bytes of content: \u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; std::endl; } } } else { std::cout \u0026lt;\u0026lt; \u0026#34;something else happened\u0026#34; \u0026lt;\u0026lt; std::endl; } } } 三种概念 1）阻塞I/O 进程发起read后，如果kernel未准备好数据，进程就会被block，进入等待阶段；\n等待kernel将数据准备好，才会返回数据，解除阻塞；\n2）非阻塞I/O 进程发起read请求，kernel未准备好数据，直接返回一个error，进程无需阻塞等待；\n进程会轮询发送read请求，如此往复；\n一直到kernel准备好数据，才把数据拷贝并返回给进程，结束轮询；\n3）I/O多路复用 进程调用select/poll/epoll，select/poll/epoll会将进程block起来；\nkernel会‘监视’所有select负责的socket；\n当任何一个socket准备好数据，select就会返回（也就是图中的return medable）；\n进程调用read（图中第二次 system call），将数据从kernel拷贝到用户进程；\n总结：所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。\nRe: select\nhttps://www.cnblogs.com/skyfsm/p/7079458.html\nhttps://segmentfault.com/a/1190000019207061\npoll\nhttps://blog.csdn.net/oqqYuJi12345678/article/details/106313768\nepoll\nhttps://blog.csdn.net/lingfengtengfei/article/details/12398299\not\nhttps://www.jianshu.com/p/722819425dbd\nhttps://www.jianshu.com/p/3137248d9ac5\n","permalink":"https://vcvvvc.github.io/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","tags":["Linux","Select","Poll","Epoll","Server"],"title":"I/O多路复用"},{"categories":null,"contents":"总结分析传统io, mmap, sendfile\n传统IO 通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过write()写入到socket缓冲区，最后写入目标。\n整个过程发生了4次用户态和内核态的上下文切换和4次拷贝\n用户进程通过read()方法向操作系统发起调用，此时上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，read()返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将应用缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回 mmap #用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize); 调用 mmap() 系统调用对文件进行映射后，用户对映射后的内存进行读写实际上是对文件缓存的读写，所以减少了一次系统调用，从而加速了对文件读写的效率。\n整个过程发生了4次用户态和内核态的上下文切换和3次拷贝，具体流程如下：\n用户进程通过mmap()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 上下文从内核态转为用户态，mmap调用返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回 munmap int munmap(void *addr, size_t len); munmap()用来取消参数start 所指的映射内存起始地址，参数length 则是欲取消的内存大小。当进程结束或利用exec 相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。\nSendfile sendfile函数在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。\nssize_t senfile(int out_fd,int in_fd,off_t* offset,size_t count); 整个过程发生了2次用户态和内核态的上下文切换和3次拷贝\n用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，sendfile调用返回 sendfile+DMA Scatter/Gather 它将读缓冲区中的数据描述信息\u0026ndash;内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程\n整个过程发生了2次用户态和内核态的上下文切换和2次拷贝，其中更重要的是完全没有CPU拷贝\n用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储 CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区 DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡 sendfile()调用返回，上下文从内核态切换回用户态 Re: https://zhuanlan.zhihu.com/p/348586130\nhttps://zhuanlan.zhihu.com/p/357820303\nhttp://c.biancheng.net/cpp/html/138.html\nhttps://www.cnblogs.com/huxiao-tee/p/4660352.html\n","permalink":"https://vcvvvc.github.io/post/use_mmap/","tags":["Linux","CPP"],"title":"总结mmap(零拷贝)"},{"categories":null,"contents":"我测试了好几篇文章,终于有个成功了\nlocal.service vim /etc/systemd/system/rc-local.service\n输入以下内容:\n[Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.local [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardOutput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target rc.local vim /etc/rc.local\n#!/bin/sh -e ## rc.local sh /root/startup.sh exit 0 收尾 授权 chmod +x /etc/rc.local\n自启动 systemctl enable rc-local\n运行 systemctl start rc-local.service\n查看状态 systemctl status rc-local.service\n先别重启, ps -x配合grep搜索关键字看看进程启动没有\n之后保存好文件重启进行测试 再次查看是否启动\n举个例子:\nstartup.sh\n#!/bin/bash -e cd /root/News-D/ nohup python3 main.py \u0026amp; cd /root/News-D/Finance/ nohup python3 -m http.server 20777 \u0026amp; rm nohup.a.out exit 0 Re: https://www.cnblogs.com/Deskew/p/13798595.html\n","permalink":"https://vcvvvc.github.io/post/ubuntu20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/","tags":["Linux","Startup"],"title":"Ubuntu20开机自启脚本"},{"categories":null,"contents":"2021-09-07 发帖时间为安装时间 有些包下载较慢可以挂vpn\nffmpeg 完全安装 解决brew install ffmpeg会报错\ninstall brew tap homebrew-ffmpeg/ffmpeg brew options homebrew-ffmpeg/ffmpeg/ffmpeg brew install ffmpeg --HEAD ffmpeg -version 安装过程如果缺库 https://formulae.brew.sh/formula/ffmpeg 到这个链接查\n现在这步好像不需要了\n#完全安装 brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-chromaprint --with-fdk-aac --with-game-music-emu --with-libbluray --with-libbs2b --with-libcaca --with-libgsm --with-libmodplug --with-librsvg --with-libsoxr --with-libssh --with-libvidstab --with-libvmaf --with-libxml2 --with-opencore-amr --with-openh264 --with-openjpeg --with-openssl --with-rav1e --with-rtmpdump --with-rubberband --with-speex --with-srt --with-tesseract --with-two-lame --with-webp --with-xvid --with-zeromq --with-zimg Re: http://www.manks.top/ffmpeg-install-mac.html\nhttps://www.jianshu.com/p/85fffceddf04\nhttps://zhuanlan.zhihu.com/p/90099862\n","permalink":"https://vcvvvc.github.io/post/brew_ffmpeg_install/","tags":["Macos"],"title":"Brew_ffmpeg_install"},{"categories":null,"contents":"https://github.com/VcSpace/News-M.git 闻讯——获取主流财经新闻网站新闻信息获取, 将数据聚合、归类并写入表格中 。\nNews-M \u0026ndash;News Spider, Crawling news from mainstream financial news websites, categorize and write data into tables .\n目的 时间与精力是有限的 为了节省查阅信息的时间成本故此创作News-M用来快捷提取有效信息, 节约时间, 放松精力。\nTime and energy are limited. In order to save the time cost of consulting information, news-m is created to quickly extract effective information, save time and relax energy.\n运行程序 #Run pip install -r requirements.txt python3 main.py 如果你想启用网盘功能 在命令行运行bypy info获取token, 在main.py将bd_flag改为True\nIf you want to enable the network disk function, run bypy info on the command line to get the token, and BD will be displayed in main.py Change bd_flag to true\n如果你想在服务器中定时运行 请修改当前main为start函数，添加相应的库即可\nIf you want to run regularly in the server, please modify the current main to the start function and add the corresponding library\n可能还需要看这篇文章 https://vcvvvc.github.io/post/linux_ssh_nohup/\nYou may also need to read this articlehttps://vcvvvc.github.io/post/linux_ssh_nohup/\nNote 1. 操作完成后生成Finace文件夹 Windows系统在桌面 Linux在运行目录下\n1. After the operation, the finace folder will be generated. The windows system is on the desktop and the Linux is in the running directory\n2. 表格行高列宽是可以自动调整的 不用自己手动一行行的调整 具体操作看图\n2. The height and width of a table row can be adjusted automatically. You don't need to adjust one row manually. See the figure for the specific operation\n3. 享受阅读的乐趣\n3. Enjoy reading\n","permalink":"https://vcvvvc.github.io/post/news_wps/","tags":["News-M","Python","Tutorial"],"title":"News-M Tutorial"},{"categories":null,"contents":"#把原来的main设置为start函数 在末尾添加如下代码即可 #https://blog.csdn.net/ainivip/article/details/106296599 if __name__ == \u0026#39;__main__\u0026#39;: while True: logger = logging.getLogger() logger.setLevel(logging.INFO) log_time = time.strftime(\u0026#34;%Y_%m_%d\u0026#34;, time.localtime()) # 刷新 logfile = \u0026#34;./\u0026#34; + log_time + \u0026#34;.log\u0026#34; fh = logging.FileHandler(logfile,mode=\u0026#39;w\u0026#39;) fh.setLevel(logging.INFO) while True: formatter = logging.Formatter(\u0026#34;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s\u0026#34;) fh.setFormatter(formatter) logger.addHandler(fh) time_now = time.strftime(\u0026#34;%H\u0026#34;, time.localtime()) # 刷新 if time_now == \u0026#34;21\u0026#34; or time_now == \u0026#34;10\u0026#34;: # 设置要执行的时间 start() logger.info(\u0026#34;sleep(20000) start news_d\u0026#34;) time.sleep(1500) elif time_now == \u0026#34;00\u0026#34;: logger.info(\u0026#34;new day, log end\u0026#34;) time.sleep(6000) break else: logger.info(\u0026#34;wait sleep(600)\u0026#34;) time.sleep(600) 服务器ssh连接https://vcvvvc.github.io/post/linux_ssh_nohup/\n","permalink":"https://vcvvvc.github.io/post/news-m%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C/","tags":["Python"],"title":"News M定时运行"},{"categories":null,"contents":"Linux系统SSH客户端断开后保持进程继续运行配置方法\nnohup python3 main.py \u0026amp; Re: https://help.aliyun.com/document_detail/42523.html\n","permalink":"https://vcvvvc.github.io/post/linux_ssh_nohup/","tags":["Linux"],"title":"Linux_ssh_nohup"},{"categories":null,"contents":"import time while True: time_now = time.strftime(\u0026#34;%H%M\u0026#34;, time.localtime()) # 刷新 if time_now == \u0026#34;00:01\u0026#34;: # 设置要执行的时间 # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 elif time_now == \u0026#34;08:01\u0026#34;: # 设置要执行的时间: # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 elif time_now == \u0026#34;16:01\u0026#34;: # 设置要执行的时间: # 要执行的代码 time.sleep(61) # 停止执行61秒，防止反复运行程序。 Re: 原文链接：https://blog.csdn.net/ainivip/article/details/106296599\n","permalink":"https://vcvvvc.github.io/post/python%E6%AF%8F%E5%A4%A9%E5%9B%BA%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E6%9F%90%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/","tags":["Python"],"title":"Python每天固定时间运行某程序代码"},{"categories":null,"contents":"结合了个人理解 可能有差错 可以评论指出\n由于最近个人关注的股有一支要发转债, 故来了解下。\n什么是可转换债券 可转换债券是债券持有人可按照发行时约定的价格将债券转换成公司的普通股票的债券。如果债券持有人不想转换，则可以继续持有债券，直到偿还期满时收取本金和利息，或者在流通市场出售变现。如果持有人看好发债公司股票增值潜力，在宽限期之后可以行使转换权，按照预定转换价格将债券转换成为股票，发债公司不得拒绝。该债券利率一般低于普通公司的债券利率，企业发行可转换债券可以降低筹资成本。可转换债券持有人还享有在一定条件下将债券回售给发行人的权利，发行人在一定条件下拥有强制赎回债券的权利。\n这里自己去查下百科就行了： https://baike.baidu.com/item/可转换债券/397601\n基本概念 三大特征:\n债权性 股权性 可转换性 可转债有可能赚但不会亏的保底性质\n比如可转债的转股价为10元, 而当前股价为20， 一张债券100块面额根据转股价可转为10股 收益率100%。\n当股价为5元时此时转股亏损50%，正常人都不会转股。选择不转股到期拿回本金和利息，保底性质\n发债前打压股价 上市公司正股价是由市场决定，但是转股价是在发行前就可以制定的。根据相关规定，转股价为可转债募集说明书公告日前20个交易日公司股票交易均价和前一交易日公司股票交易均价二者之间的较高者。\n所以上市公司发行可转债前打压股价就是为了让转股价更低一点，从而促使投资者转股。如果转股价定得太高，转债上市后正股价低于转股价，那么投资者是不会愿意转股的。\n可转债发布之后，利好消息推高股价。\n转股之后债权变成了股权，企业也不必再支付额外的利息。\n核心就是转股价低于正股价 想方设法让你转股，符合条件的强制赎回。 有点人家吃肉我喝汤的感觉。\n两个重要条款 可转债有转股价下调条款，强制赎回条款。\n转股价向下修正条款: https://baike.baidu.com/item/转股价向下修正条款/10596894\n赎回条款：https://wiki.mbalib.com/wiki/赎回条款\nRe:\nhttps://zhuanlan.zhihu.com/p/367802793\nhttps://www.csai.cn/licai/1306470.html\n","permalink":"https://vcvvvc.github.io/post/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%8F%AF%E8%BD%AC%E5%80%BA/","tags":["Stock"],"title":"个人理解可转债"},{"categories":null,"contents":"类静态成员类外初始化与在另一个类成员函数赋值\n为什么类的静态成员要在类外初始化 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。\nC++的静态成员是需要初始化的（实际上需要分配一个内存，不一定需要赋值），初始化是赋一个初始值，而定义是分配内存。静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义。 静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用于相同的情况下会导致重名的问题。\n静态常量成员可以在类内初始化 类的静态成员变量在另一个类赋值 //头文件代码 a.h class SPostMsgToMain { public: //存储消息线程的指针 static CWinThread* m_pThread; }; //a.cpp SPostMsgToMain::m_pThread=NULL; //此处为静态成员的定义。该定义要写在实现文件里面，不能写在头文件里面 //thread.cpp QueryThread::QueryThread(void) { SPostMsgToMain::m_pThread = this; } Re:\nhttps://blog.csdn.net/sevenjoin/article/details/81772792\nhttps://blog.csdn.net/lvquanye9483/article/details/81946116\n下面是09年已经删除的帖子，这是bing保存的快照:\nhttp://cncc.bingj.com/cache.aspx?q=类的静态成员变量在另一个类赋值\n","permalink":"https://vcvvvc.github.io/post/%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/","tags":["CPP"],"title":"类静态成员初始化、赋值"},{"categories":null,"contents":"macos11.4下 grpc-cpp安装\nlib brew install autoconf automake libtool shtool gflags cmake pkg-config grpc-cpp git clone https://github.com/grpc/grpc.git git checkout -b v1.38.x # 下载所有子模块 git submodule update --init --recursive protobuf3 install git clone https://github.com/google/protobuf.git cd protobuf git checkout v3.9.0 sh ./autogen.sh ./configure --prefix=/usr/local/protobuf/ make sudo make install 查看版本\ncd /usr/local/protobuf/bin/ ./protoc --version 将下面指令加入.bash_profiile中之后执行source ~/.bash_profile\nexport PATH=$PATH:/usr/local/protobuf/bin/ grpc install cd grpc export MY_INSTALL_DIR=$HOME/.local mkdir -p $MY_INSTALL_DIR export PATH=\u0026#34;$MY_INSTALL_DIR/bin:$PATH\u0026#34; mkdir -p cmake/build pushd cmake/build cmake -DgRPC_INSTALL=ON \\ -DgRPC_BUILD_TESTS=OFF \\ -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \\ ../.. make -j2 sudo make install popd mkdir -p third_party/abseil-cpp/cmake/build pushd third_party/abseil-cpp/cmake/build cmake -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \\ -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE \\ ../.. make sudo make install popd HelloWorld test cd examples/cpp/helloworld mkdir -p cmake/build pushd cmake/build cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR ../.. make -j2 编译完成之后\n./greeter_server # 另一终端 ./greeter_client Re:\nhttps://grpc.io/docs/languages/cpp/quickstart/\nhttps://blog.csdn.net/weileshenghuo1/article/details/104428017\n","permalink":"https://vcvvvc.github.io/post/grpc_install/","tags":["grpc"],"title":"grpc install"},{"categories":null,"contents":"安装过程(转)\nhttps://blog.csdn.net/qq_34892981/article/details/110181452\n","permalink":"https://vcvvvc.github.io/post/centos8_install_redis/","tags":["Centos","Redis"],"title":"Centos8 install redis"},{"categories":null,"contents":"yum update -y sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io -y sudo yum install docker-ce docker-ce-cli sudo systemctl start docker docker --version sudo systemctl enable docker 出现安装包问题\nsudo yum install docker-ce docker-ce-cli containerd.io -y --allowerasing 更换容器镜像 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\ncd /etc/docker\nvim daemon.json\n# url改成自己的加速器地址，亦可使用该地址 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://k01sfudd.mirror.aliyuncs.com\u0026#34;] } systemctl daemon-reload systemctl restart docker Re: https://blog.csdn.net/jcmj123456/article/details/117742182\nhttps://www.jianshu.com/p/6d9e725da273\n","permalink":"https://vcvvvc.github.io/post/centos8_install_docker/","tags":["Docker","Centos"],"title":"Centos8 install docker"},{"categories":null,"contents":"几天前聚餐小饮一杯48度蒸馏酒，微醺。回家之, 看书有感，口出惊言: \u0026ldquo;道可道也\u0026hellip;， 生之，养之\u0026hellip;\u0026rdquo;\n趁着还有点意识利用以前写过的项目拼凑了一下获取了一部道德经\nhttps://github.com/vcvvvc/hanchengwang.git 天下皆知美之为美, 恶已; 皆知善为善，斯不善矣。\n项目只需修改参数亦可下载其他古籍， 请自行研究使用\n项目提供本人制作的道德经成品mobi\\word版本, 已内置目录\n项目提供本人制作的成品mobi\\word版本, 已内置目录\n这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取\n这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取\n这是一个公益性网站 请不要修改sleep时间避免给服务器过大压力, 能使用成品就不要再次爬取\n程序支持跨平台, 但仅测试了mac\n","permalink":"https://vcvvvc.github.io/post/hanchengwang/","tags":["Python"],"title":"汉程网"},{"categories":null,"contents":"三次握手 第一次握手:\n(客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。)\nClient端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。\n第二次握手:\n(服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。)\nServer端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack=seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK=1、SYN=1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。\n第三次握手:\n(客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1)\nClient收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。\n四次挥手 第一次挥手\n(主动方发送Fin+Ack报文,并置发送序号为x)\n假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN=1，这个控制位代表客户端想要断开连接；序列号seq=u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。\n第二次挥手\n(被动方送ACK报文,并置发送序号为Z,在确认序号为x+1)\n服务端收到客户端的报文后发出确认报文，控制位ACK=1；确认号ack=u+1；序列号seq=v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。\n第三次挥手\n(被动方发送Fin+Ack报文,并置发送序号为Y,在确认序号为x)\n客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN=1，表示服务端向客户端发送断开连接请求；确认标志ACK=1；确认序号ack=u+1；序号seq=w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。\n第四次挥手\n(主动方发送ack报文,并置发送序号为x,在确认序号为Y)\n客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK=1；确认号ack=w+1;序号seq=u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。\n相关面试题\nTCP三次握手？为什么不是两次？为什么不是四次？\n第一次握手, 目的端确认源端的发送能力、目的端确认目的端的接受能力 第二次握手, 源端确认源端的发送能力、源端确认源端的接受能力、源端确认目的端的发送能力、源端确认目的端的接收能力 第三次握手, 目的端确认源端的接收能力、目的端确认目的端的发送能力 因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。\nTCP四次挥手？为什么不是三次？为什么不是五次？\n第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN=1）。\n如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。\n在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？\n客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：\n客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN=1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；\n等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。\n注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\nRe: https://zhuanlan.zhihu.com/p/137942749\nhttps://zhuanlan.zhihu.com/p/40013850\nhttps://zhuanlan.zhihu.com/p/138272238\n","permalink":"https://vcvvvc.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","tags":["TCP"],"title":"TCP_三次握手与四次挥手"},{"categories":null,"contents":"空间配置器 容器类型 标准STL序列容器: vector,string、 deque和list. 标准STL关联容器: set, multiset. map和multimap. 非标准序列容器slist和rope, slist是一个单向链表, rope本质上是一“重型\u0026quot; string 非标准的关联容器hash-set, hash-multiset. hash-map和hash-multimap 标准的非STL容器,包括数组、bitset. valarray、 stack, queue和priority_queue. Vector template \u0026lt;class T, class Alloc=alloc\u0026gt; class vector{ private: //vector的嵌套型别定义 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type\u0026amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protect: // simple_alloc是SGI STL默认的空间配置器 typedef simple_alloc\u0026lt;value_type, Alloc\u0026gt; data_allocator; iterator start;\t// 表示目前使用空间的头 iterator finish;\t// 表示目前使用空间的尾 iterator end_of_storage;\t// 表示目前可用空间的尾 }; vector提供的接口：包括得到vector的属性接口、vector的操作接口以及构造函数：\n构造函数：vector()、vector(size_type n、const T\u0026amp; value)、vector(size_type n)； 属性函数：begin、end、size、capacity、empty、operator[]、front和back 操作函数：push_back()、pop_back()、erase()、resize()、clear()。 ","permalink":"https://vcvvvc.github.io/post/cpp_stl/","tags":["CPP","STL"],"title":"Cpp_stl"},{"categories":null,"contents":"时间戳获取 using namespace std::chrono; auto millisec_since_epoch = duration_cast\u0026lt;milliseconds\u0026gt;(system_clock::now().time_since_epoch()).count(); auto msec = duration_cast\u0026lt;microseconds\u0026gt;(system_clock::now().time_since_epoch()).count(); auto sec_since_epoch = duration_cast\u0026lt;seconds\u0026gt;(system_clock::now().time_since_epoch()).count(); std::cout \u0026lt;\u0026lt; \u0026#34;seconds since epoch: \u0026#34; \u0026lt;\u0026lt; sec_since_epoch \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;milliseconds since epoch: \u0026#34; \u0026lt;\u0026lt; millisec_since_epoch \u0026lt;\u0026lt; std::endl; 秒seconds since epoch: 1622534342 微妙 milliseconds since epoch: 1622534342050 标准年月日+时间获取 std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()); char re_time[256] = {0}; std::strftime(re_time, sizeof(re_time), \u0026#34;%Y-%m-%d %X\u0026#34;, std::localtime(\u0026amp;now)); std::cout \u0026lt;\u0026lt; “注册时间 ” \u0026lt;\u0026lt; re_time \u0026lt;\u0026lt; std::endl; 注册时间: 2021-06-01 15:56:42\nRe:\nhttps://www.delftstack.com/howto/cpp/how-to-get-time-in-milliseconds-cpp/\nhttp://cn.voidcc.com/question/p-ynucfjxu-sk.html\n","permalink":"https://vcvvvc.github.io/post/chrono_use/","tags":["CPP","Chrono","Time"],"title":"Chrono_use"},{"categories":null,"contents":"主角得拿出来文字记录下。 一个m阶的B树具有如下属性:\n每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。 在含有n个关键字的B树上查找时，从根结点到关键字结点的 路径上涉及的结点数不超过log |m/2| ((n+1)/2)+1。\n不错的讲解\nhttps://www.yiibai.com/data_structure/b-tree.html https://blog.nowcoder.net/n/ef07c1ad8f8346078eeab66518152bf0 https://blog.csdn.net/alzzw/article/details/97633941 一棵m阶的B+树和m阶的B树的差异在于:\n有n棵子树的结点中包含有n个关键字； 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录 的指针，叶子结点本身依关键字的大小自小而大顺序链接； 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或 最小）关键字。 实现\nhttps://blog.csdn.net/liu1064782986/article/details/7982290\n2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩（我们称它为2结点）或三个孩子（我们称它为3结点）。\n一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。\n这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。\n一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。\n","permalink":"https://vcvvvc.github.io/post/b_tree/","tags":["数据结构","CPP"],"title":"B_Tree"},{"categories":null,"contents":"本来想等着越狱来着 没想到还会自动更新。。\n去更新 创建了个zip再改名为update.bin.tmp.partial\nchmod a=r update.bin.tmp.partial 查看文件权限 ls -ld update.bin.tmp.partial -rw-r--r-- 1 root root 208 5月 10 2021 update.bin.tmp.partial 当亚马逊向你的 Kindle 推送更新固件时，会在 Kindle 根目录创建一个名为 update.bin.tmp.partial 的临时文件（该临时文件其实就是未下载完成的新固件文件，即便网络不稳定，它也会不断续传直至下载完毕），但是如果 Kindle 根目录有同名文件，它就无法创建了，从而达到阻止 Kindle 固件自动更新的目的。\nchattr 这个问题相关解答很少 帖子也很老 算了\n#这个保护命令没成 root@: mount --bind /media/root/Kindle/ /mnt/kindle/ root@: chattr +i update.bin.tmp.partial - chattr: 对设备不适当的 ioctl 操作 读取 update.bin.tmp.partial 的标志时 Re:\n书伴 https://bookfere.com/post/472.html\n","permalink":"https://vcvvvc.github.io/post/kindle_%E5%8E%BB%E6%9B%B4%E6%96%B0/","tags":["Kindle"],"title":"Kindle 防止自动更新"},{"categories":null,"contents":"计算机网络 应用层 HTTP HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。\nCookie\nHTTP 是一种不保存状态，即无状态（stateless）协议。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。 请求方法\nOPTIONS\n请求一些选项信息，允许客户端查看服务器的性能 GET\n请求指定的页面信息，并返回实体主体 HEAD\n类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 PUT\n从客户端向服务器传送的数据取代指定的文档的内容 DELETE\n请求服务器删除指定的页面 TRACE\n回显服务器收到的请求，主要用于测试或诊断 报文\n报文\n是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 实体\n作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。 客户端(请求报文)\n请求行\n用于请求的方法，请求 URI 和 HTTP 版本 状态行\n含表明响应结果的状态码，原因短语和 HTTP 版本 首部字段\n表示请求和响应的各种条件和属性的各类首部 通用首部 请求首部 响应首部 实体首部 服务端(响应报文) 内容同上\n内容编码\n压缩传输的内容编码\n内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。 分块传输编码\n在传输大容量数据时，通过把数据分割成 多块，能够让浏览器逐步显示页面。 每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标 记。 多部分对象集合\nMIME\nMultipurpose Internet Mail Extensions Content-type\n在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。\nmultipart/form-data\n在 Web 表单文件上传时使用。 multipart/byteranges\n状态码 206（Partial Content，部分内容）响应报文包含了多个范 围的内容时使用。 multipart/form-data\nmultipart/byteranges\n范围请求(Range Request)\nRange: bytes=5000- 内容协商(Content Negotiation)\n服务器驱动协商（Server-driven Negotiation） 客户端驱动协商（Agent-driven Negotiation） 透明协商（Transparent Negotiation） Accept Accept-Charset Accept-Encoding Accept-Language Content-Language 返回状态码\n状态码\n1XX\nInformational（信息性状态码） 接收的请求正在处理 2XX\nSuccess（成功状态码） 请求正常处理完毕 200 OK 204 No Content 206 Partial Content 3XX\nRedirection（重定向状态码）\n需要进行附加操作以完成请求\n3XX 重定向\n301 Moved Permanently\n302 Found\n临时性质 303 See Other\n304 Not Modified\n307 Temporary Redirect\n临时重定向。与 302 Found 有着相同的含义 4XX\nClient Error（客户端错误状态码） 服务器无法处理请求 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 5XX\nServer Error（服务器错误状态码） 服务器处理请求出错 500 Internal Server Error 503 Service Unavailable 报文首部\n请求报文\n方法 HTTP 版本 HTTP 首部字段 首部字段\n首部\n由首部字段名和字段值构成 中间用冒号“:” 分 隔。 首部字段名: 字段值 端到端首部（End-to-end Header） 逐跳首部（Hop-by-hop Header） 请求首部字段（Request Header Fields）\n从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加 内容、客户端信息、响应内容相关优先级等信息。\nAccept\n通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。 若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。 Accept-Charset\n通知服务器用户代理支持的字符集及 字符集的相对优先顺序。应用于内容协商机制的服务器驱动协商。 Accept-Encoding\n告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。 Accept-Language\n告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级 Authorization\n告知服务器，用户代理的认证信息（证书值）。 Expect\n期望出现的某种特定行 为。 From\n服务器使用用户代理的用户的电子邮件地 址。 Host\n请求的资源所处的互联网主机名和端口号。 If-Match\n为条件请求。服务器接 收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。 If-Modified-Since\n若 If- Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应。 If-None-Match\n指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。 If-Range\nIf- Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。 If-Unmodified-Since\n告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。 Max-Forwards\n接收到 Max-Forwards 值为 0 的请求 时，则不再进行转发，而是直接返回响应。 Proxy-Authorization\n接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。 Range\n对于只需获取部分资源的范围请求 Referer\n首部字段 Referer 会告知服务器请求的原始资源的 URI。 TE\n服务器客户端能够处理响应的传输编码方式及相 对优先级。 User-Agent\n将创建请求的浏览器和用户代理名称等信息传 达给服务器。 通用首部字段（General Header Fields）\n请求报文和响应报文两方都会使用的首部。\nCache-Control\n能够控制缓存的行为 Connection\n控制不再转发给代理的首部字段\nConnection: 不再转发的首部字段名 管理持久连接\nConnection: close Date\n创建 HTTP 报文的日期和时间。 Pragma\n仅作为与 HTTP/1.0 的向后兼容而定义。 Pragma: no-cache Trailer\n事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。 Transfer-Encoding\n规定了传输报文主体时采用的编码方式。 Upgrade\n用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。 Via\n追踪客户端与服务器之间的请求和响应报文 的传输路径。 Warning\n告知用户一些与缓存相关的问题的警告。 响应首部字段（Response Header Fields）\n从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加 内容，也会要求客户端附加额外的内容信息。\nAccept-Ranges\n客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。 Age\n告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。 ETag\n告知客户端实体标识。\n强 ETag 值\n不论实体发生多么细微的变化都会改变其值。 ETag: \u0026ldquo;usagi-1234\u0026rdquo; 弱 Tag 值\n只用于提示资源是否相同。只有资源发生了根本改变，产 生差异时才会改变 ETag 值。 ETag: W/\u0026ldquo;usagi-1234\u0026rdquo; Location\n将响应接收方引导至某个与请求 URI 位置 不同的资源。 Proxy-Authenticate\n把由代理服务器所要求的认证信息发送 给客户端。 Retry-After\n告知客户端应该在多久之后再次发送请求。 Server\n告知客户端当前服务器上安装的 HTTP 服务器应用程 序的信息。 Vary\n可对缓存进行控制。 WWW-Authenticate\n用于 HTTP 访问认证。 实体首部字段（Entity Header Fields）\n针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更 新时间等与实体有关的信息。\nAllow\n通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。 Content-Encoding\n告知客户端服务器对实体的主体部分选 用的内容编码方式。 Content-Language\n告知客户端， 体主体使用的自然语言 （指中文或英文等语言）。 Content-Length\n表明了实体主体部分的大小（单位是字 节）。 Content-Location\n给出与报文主体部分相对应的 URI。 Content-MD5\n是一串由 MD5 算法生成的值，其目的在于检 查报文主体在传输过程中是否保持完整，以及确认传输到达。 Content-Range\n针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。 Content-Type\n说明了实体主体内对象的媒体类型。 Expires\n会将资源失效的日期告知客户端。 Last-Modified\n指明资源最终修改的时间。 Cookie首部\nSet-Cookie\n开始状态管理所使用的Cookie信息(响应首部字段)\nexpires\nCookie 的有效期 path\n将服务器上的文件目录作为Cookie的适用对象（若不指定则默 认为文档所在的文件目录） domain\n作为 Cookie 适用对象的域名 Secure\n仅在 HTTPS 安全通信时才会发送 Cookie HttpOnly\n加以限制，使 Cookie 不能被 JavaScript 脚本访问 Cookie\n服务器接收到的Cookie信息(请求首部字段) 其他首部字段\nX-Frame-Options\n用于控制网站内容 在其他 Web 网站的 Frame 标签内的显示问题。 X-XSS-Protection\n属于 HTTP 响应首部 它是针对跨站脚本 攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。 DNT\nDo Not Track 的简 称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方 法。 P3P\n保护用户隐私 身份认证\nBASIC 认证\nDIGEST 认证\nSSL 客户端认证\nSSL 客户端认证采用双因素认证 基于表单认证\nHTTPS HTTP 的缺点\n不验证通信方的身份，因此有可能遭遇伪装\n验证通信方的身份\n查明对方身份, 因HTPP任何人都可发起请求 查明对手的证书 无法证明报文的完整性，所以有可能已遭篡改\n接收到的内容可能有误\n请求或响应在传输途中，遭攻击者拦截并篡改内容的攻 击称为中间人攻击（Man-in-the-Middle attack，MITM）。\n防止篡改\nMD5 SHA-1 散列值校验的方法， 以及用来确认文件的数字签名方法。 通信使用明文（不加密），内容可能会被窃听\nTCP/IP 是可能被窃听的网络\n防止窃听\nSSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议） 内容加密 HTTPS加密\nHTTP+ 加密 + 认证 + 完整性保护 =HTTPS\nHTTPS 是身披SSL外壳的 HTTP\nHTTP-SSL-TCP-IP SSL 加密技术\n采用一种 叫做公开密钥加密（Public-key cryptography）的加密处理方式。\n公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。\n加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。\n使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥 确保交换的密钥是安全的前提下,使用共享密钥加密方式进行通信 证明公开密钥正确性的证书\nHTTPS通信\n客户端通过发送 Client Hello 报文开始 SSL通信。 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。 之后服务器发送 Certificate 报文。报文中包含公开密钥证 书。 最后服务器发送 Server Hello Done 报文通知客户端，最初阶 段的 SSL握手协商部分结束。 SSL第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。 服务器同样发送 Change Cipher Spec 报文。 服务器同样发送 Finished 报文。 服务器和客户端的 Finished 报文交换完毕之后，SSL连接 就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。 应用层协议通信，即发送 HTTP 响应。 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。 在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡 改，从而保护报文的完整性。 DNS 运输层 TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。\n状态控制码\nTCP：状态控制码（Code，Control Flag），占 6 比特\nURG：紧急比特（urgent）\n当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。 ACK：确认比特（Acknowledge）\n只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。 PSH： (Push function)\n若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 SYN：同步比特(Synchronous)\nSYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。 FIN：终止比特(Final)\n用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 特征\n面向连接\n可靠交互\n如何保证可靠传输？\n确认和超时重传 数据合理分片和排序 流量控制 拥塞控制 数据校验 全双工通信\n面向字节流\n数据包首部\n以太网包首部 IP包首部 TCP包首部 数据 数据单位\n包\n全能性述语 帧\n数据链路层中包的单位 数据报\n数据报是IP和UDP等网络层以上的分层中包的单位 段\nTCP数 据流中的信息 消息\n应用协议中数据的单位 发送数据包\n应用程序处理\nTCP模块的处理\nIP模块的处理\n网络接口（以太网驱动）的处理\n每个包首部中至少都会包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。 每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。 TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗 口控制等机制实现可靠性传输。\n通过序列号与确认应答提高可靠性\n在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一 个已收到消息的通知。这个消息叫做确认应答（ACK（ACK（Positive Acknowled-gement）意指已经接收。） ）。 重发超时\n重发超时是指在重发数据之前，等待确认应答到来的那个特定时间 间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重 发。 在每次发 包时都会计算往返时间（Round Trip Time也叫RTT。是指报文段的往返 时间。） 及其偏差（RTT时间波动的值、方差。有时也叫抖动。） 。将 这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点 的值。 连接管理\nTCP提供面向有连接的通信传输。面向有连接是指在数据通信开始 之前先做好通信两端之间的准备工作。 UDP是一种面向无连接的通信协议，因此不检查对端是否可以通 信，直接将UDP包发送出去。 TCP以段为单位发送数据\n在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可 以称其为“最大消息长度”（MSS：Maximum Segment Size）。 窗口控制\n使用大量的缓冲区（缓冲区（Buffer）在此处表示 临时保存收发数据的场所。通常是在计算机内存中开辟的一部分空 间。） ，通过对多个段同时进行确认应答的功能。 流控制\nTCP提供一种机制可以让发送端根据接 收端的实际接收能力控制发送的数据量。 接收端主机向发送端主机通知自己可以接收数据的大小，于 是发送端会发送不超过这个限度的数据。 拥塞控制\n为了在发送端调节所要发送数据的量\n在慢启动的时候，将这个拥塞窗口的大小设置为1 个数据段（1MSS） 发送数据，之后每收到一 次确认应答（ACK），拥塞窗口的值就加1。\n随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的 增长，拥堵状况激增甚至导致网络拥塞的发生。\n为了防止这些，引入了 慢启动阀值的概念。只要拥塞窗口的值超出这个阀值，在每收到一次确 认应答时，只允许以下面这种比例放大拥塞窗口 提高网络利用率的规范\nNagle算法\n送端即使还有应该发送的数据，但如果这部分数据很 少的话，则进行延迟发送的一种处理机制。 延迟确认应答\n接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一 个较小的窗口。那是因为刚接收完数据，缓冲区已满。 捎带应答\n根据应用层协议，发送出去的消息到达对端，对端进行处理以后， 会返回一个回执。 UDP UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。\n数据报格式\n源端口号（Source Port）\n表示发送端端口号，字段长16位。该字段是可选项。 目标端口号（Destination Port）\n表示接收端端口，字段长度16位。 包长度（Length）\n保存了UDP首部的长度跟数据的长度之和 校验和（Checksum）\n校验和是为了提供可靠的UDP首部和数据而设计。在计算校验和时，附加在UDP伪首部与UDP数据报之前。 网络层 IP IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。\nIP地址由网络和主机两部分标识组成\nIP地址的分类\n为A类、B类、C类、D类（还有一个一 直未使用的E类。) 子网掩码\n子网与子网掩码\n子网掩码（subnet mask）：用来判断 IP 所属网络 特点\n不可靠\n不可靠(unreliable)的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。 无连接\n无连接(connectionless)这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。\nIP属于面向无连接型\n即在发包之前，不需要建立与对端目标地址之间的 连接。上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包 发送出去。 一是为了简化，二是为了提速。 IP为了实现简单化与 高速化采用面向无连接的方式。 三大作用模块\nIP寻址\nIP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。\n子网寻址\n不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。 路由\n将分组数据发送到最终目标地址的功能。\n发送数据至最终目标地址\nHop译为中文叫“跳”。它是指网络中的一个区间。IP包正是在网络 中一个个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决 定着包在下一跳被转发的路径。 IP分包与组包\nMTU\n在线路上传送比包长还要小的MTU IP分片(IP Fragmentation)\n将较大的IP包分成多个较小的IP包 广播地址\n用于在同一个链路中相互连接的主机之间发送数据包。\n本地广播\n在本网络内的广播叫做本地广播 直接广播\n在不同网络之间的广播叫做直接广播。 ARP发送一份称作 A R P请求的以太网数据帧给以太网上的每个主机。这个过程称作广ARP发送一份称作 ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播\nIP多播\n同时发送提高效率\n多播用于将包发送给特定组内的所有主机。由于其直接使用IP协 议，因此也不存在可靠传输。 IP多播与地址\n多播使用D类地址。 IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议 IPv6\nIP地址的扩大与路由控制表的聚合\n性能提升\n包首部长度采用固定的值（40字节），不再采用首部检验码。 支持即插即用功能\n即使没有DHCP服务器也可以实现自动分配IP地址。 采用认证与加密功能\n多播、Mobile IP成为扩展功能\n全局单播地址\n全局单播地址是指世界上唯一的一个地址。 链路本地单播地址\n在同一个数据链路内唯一的地址。 唯一本地地址\n是不进行互联网通信时所使用的地址。 IPv6分段处理\nIPv6的分片处理只在作为起点的发送端主机上进行，路由器不参与 分片。这也是为了减少路由器的负荷，提高网速。 最小MTU为1280字节。 IPV4首部\n数据报格式\n版本（Version）\n表示标识IP首部的版本号。 首部长度（IHL：Internet Header Length）\n表明IP首部的大小, 单位为4字节（32比特） 区分服务（TOS：Type Of Service）\n由8比特构成，用来表明服务质量。 DSCP段与ECN段\nDSCP（Differential Services Codepoint，差分服务代码点）是 TOS（Type Of Service）的一部分。现在统称为DiffServ ，用来进行质量控制。 总长度（Total Length）\n表示IP首部与数据部分合起来的总字节数。该字段长16比特。 标识（ID：Identification）\n由16比特构成，用于分片重组。同一个分片的标识值相同，不同分 片的标识值不同。 标志（Flags）\n由3比特构成，表示包被分片的相关信息。\n0 未使用。现在必须是0。 1 指示是否进行分片（don\u0026rsquo;t fragment） 0- 可以分片 1- 不能分片 2 包被分片的情况下，表示是否为最后一个包（more fragment）。 0- 最后一个分片的包 1- 分片中段的包 片偏移（FO：Fragment Offset）\n由13比特构成，用来标识被分片的每一个分段相对于原始数据的位 置。第一个分片对应的值为0。 生存时间（TTL：Time To Live）\n由8比特构成，它最初的意思是以秒为单位记录当前包在网络上应 该生存的期限。然而，在实际中它是指可以中转多少个路由器的意思。 协议（Protocol）\n由8比特构成，表示IP首部的下一个首部隶属于哪个协议。 首部校验和（Header Checksum）\n由16比特（2个字节）构成，也叫IP首部校验和。该字段只校验数 据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。 源地址（Source Address）\n由32比特（4个字节）构成，表示发送端IP地址。 目标地址（Destination Address）\n由32比特（4个字节）构成，表示接收端IP地址。 可选项（Options）\n长度可变，通常只在进行实验或诊断时使用。 填充（Padding）\n也称作填补物。在有可选项的情况下，首部长度可能不是32比特的 整数倍。为此，通过向字段填充0，调整为32比特的整数倍。 IPV6首部\n版本（Version）\n与IPv4一样，由4比特构成。IPv6其版本号为6，因此在这个字段上 的值为“6”。 通信量类（Traffic Class）\n相当于IPv4的TOS（Type Of Service）字段，也由8比特构成。 流标号（Flow Label）\n由20比特构成，准备用于服务质量（QoS：Quality Of Service）控制。 有效载荷长度（Payload Length）\n有效载荷是指包的数据部分。IPv4的TL（Total Length）是指包括 首部在内的所有长度。然而IPv6中的这个Playload Length不包括首部， 只表示数据部分的长度。由于IPv6的可选项是指连接IPv6首部的数据， 因此当有可选项时，此处包含可选项数据的所有长度就是Playload Length 下一个首部（Next Header）\n由8比特构成。通常表示IP的上一层协 议是TCP或UDP。不过在有IPv6扩展首部的情况下，该字段表示后面第 一个扩展首部的协议类型。 跳数限制（Hop Limit）\n由8比特构成。与IPv4中的TTL意思相同。 源地址（Source Address）\n由128比特（8个16位字节）构成。表示发送端IP地址。 目标地址（Destination Address）\n由128比特（8个16位字节）构成。表示接收端IP地址。 ARP ARP（Address Resolution Protocol，地址解析协议）\n以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设 备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过 ARP查找下一跳路由器的MAC地址。不过ARP只适用于IPv4 RARP（Reverse Address Resolution Protocol）是将ARP反过来，从 MAC地址定位IP地址的一种协议。\n操作字段指出四种操作类型，它们是 ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）\n如果A R P请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托 A R P或A R P代理(Proxy ARP)。\nARP代理也称作混合ARP (promiscuousARP)或ARP出租(ARP hack) 0x0806为arp类型\nICMP ICMP（Internet Control Message Protocol，网际控制报文协议）\n确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。\nICMP目标不可达消息\nIP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回 一个目标不可达（Destination Unreachable Message）的ICMP消息，并在 这个消息中显示不可达的具体原因 ICMP重定向消息\n如果路由器发现发送端主机使用了次优的路径发送数据，那么它会 返回一个ICMP重定向（ICMP Redirect Message）的消息给这个主机。 ICMP超时消息\nIP包中有一个字段叫做TTL（Time To Live，生存周期），它的值 随着每经过一次路由器就会减1（当IP包在路由器上停留1秒以上时减去 所停留的秒数，但是现在绝大多数设备并不做这样的处理。） ，直到 减到0时该IP包会被丢弃 ICMP回送消息\n用于进行通信的主机或路由器之间，判断所发送的数据包是否已经 成功到达对端的一种消息。 ICMP原点抑制消息\n。ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。 ICMP路由器探索消息\n主要用于发现与自己相连网络中的路由器。 ICMP地址掩码消息\n主要用于主机或路由器想要了解子网掩码的情况。 不会产生的条件\nICMP差错报文(但是, ICMP查询报文可能会产生ICMP差错报文)。 目的地址是广播地址或多播地址(D类地址)的IP数据报。 作为链路层广播的数据报。 不是IP分片的第一片 源地址不是单个主机的数据报。这就是说,源地址不能为零地址、环回地址、广播地址或多播地址。 IGMP IGMP（Internet Group Management Protocol，网际组管理协议） DHCP 为了实现自动设置IP地址、统一管理IP地址分配 NAT NAT（Network Address Translator）是用于在本地网络中使用私有 地址，在连接互联网时转而使用全局IP地址的技术。 路由控制 互联网是由路由器连接的网络组合而成的。为了能让数据包正确达 地到达目标主机，路由器必须在途中进行正确地转发。这种向“正确的 方向”转发数据所进行的处理就叫做路由控制或路由。\n静态路由\n静态路由是指事先设置好路由器和主机中并将路由信息固定的一种 方法。 动态路由\n动态路由是指让路由协议在运行过程中自动地设置路由控制信 息的一种方法。 路由控制的范围\nIGP（Interior Gateway Protocol） EGP（Exterior Gateway Protocol） 自治系统（路由选择域）\n内部动态路由采用的协议是域内路由协 议，即IGP。而自治系统之间的路由控制采用的是域间路由协议，即 EGP。 数据链路层 三个目的 为I P模块发送和接收IP数据报 为ARP模块发送ARP请求和接收ARP应答 为RARP发送RARP请求和接收RARP应答。 以太网 无线LAN PPP(光纤) 主要信道 点对点信道\n点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议\n数据单元：帧\n三个基本问题\n封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check） 广播信道\n数据链路的段是指一个被分割的网络。 从网络层的概念看，它是一个网络（逻辑上）→即，从网络层的 立场出发，这两条网线组成一个段。 从物理层的概念看，两条网线分别是两个物体（物理上）→即， 从物理层的观点出发，一条网线是一个段。 网络拓扑 网络的连接和构成的形态称为网络拓扑（Topology）。网络拓扑 包括总线型、环型、星型、网状型等。 相关技术 MAC地址\n识别数据链路中互连的节点\n根据MAC地址转发\n交换机转发方式\n存储转发\n检查以太网数据帧末尾的FCS位后再进行转发。可以避免发送由于冲 突而被破坏的帧或噪声导致的错误帧。 直通转发\n不需要将整个帧全部接收下来以后再进行转发 共享介质型网络\n指由多个设备共享一个通信介质的一种网络。\n争用方式\n争用方式（Contention）是指争夺获取数据传输的权力，也叫 CSMA（载波监听多路访问）。 令牌传递方式\n发送一种叫做“令牌”的特殊报文 非共享介质网络\n指不共享介质，是对介质采取专用的一种传输控 制方式。 全双工通信方式 半双工是指，只发送或只接收的通信方式 环路检测技术\n最坏的情况下，数据帧会在环路 中被一而再再而三地持续转发。而一旦这种数据帧越积越多将会导致网 络瘫痪。\n生成树方式\n每个网桥必须在每1～10秒内相互交换 BPDU（Bridge Protocol Data Unit）包，从而判断哪些端口使用哪些不使 用，以便消除环路。 源路由法\n判断发送数据的源 地址是通过哪个网桥实现传输的，并将帧写入RIF（Routing Information Field）。网桥则根据这个RIF信息发送帧给目标地址。 VLAN\n采用带有 VLAN技术的网桥，就不用实际修改网络布线，只需修改网络的结构即 可。 以太网 无线通信 PPP 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议 在串行链路上封装 I P数据报的方法。 建立、配置及测试数据链路的链路控制协议（ LCP：Link Control Protocol）。 针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。 双工 MTU 最大传输单元MTU\n如果IP层有一个数据报要传,而且数据的长度比链路层的MTU还大,那么IP层 就需要进行分片( fragmentation),把数据报分成若干片,这样每一片都小于MTU 路径MTU\n两台通信主机路径中的最小MTU. 物理层 物理层 各层作用/协议 RJ45、CLOCK、IEEE802.3（中继器，集线器） 通过媒介传输比特，确定机械及电气规范（比特 Bit） 数据链路层 各层作用/协议 PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 将比特组装成帧和点到点的传递（帧 Frame） 网络层 各层作用/协议 IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 负责数据包从源到宿的传递和网际互连（包 Packet） 运输层 各层作用/协议 TCP、UDP、SPX 提供端到端的可靠报文传递和错误恢复（ 段Segment） 会话层 各层作用/协议 NFS、SQL、NETBIOS、RPC 建立、管理和终止会话（会话协议数据单元 SPDU） 表示层 各层作用/协议 JPEG、MPEG、ASII 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） 应用层 各层作用/协议 FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 允许访问OSI环境的手段（应用协议数据单元 APDU） ","permalink":"https://vcvvvc.github.io/post/computer_network/","tags":["Http","TCP"],"title":"Computer_network"},{"categories":null,"contents":"2021-05-06更新 完善一下\n网上教程坑特别多 这个步骤是我自己装好总结的\n电脑dell\n显卡1650\n1. 去残留 sudo apt-get remove --purge nvidia* 2. 添加规则 vim /etc/modprobe.d/blacklist.conf\nblacklist nouveau options nouveau modeset=0 3. 验证是否成功 重启 重启之后输入命令\nsudo update-initramfs -u lsmod | grep nouveau 如果没有返回信息代表成功\n有信息的话 先检查下步骤2 再重启, 也可忽视 我这边见过一次有返回\n4.选择合适的版本 1.输入命令: ubuntu-drivers devices\n2.官网：Nvidia Official website\n选择合适的版本来进行安装\nsudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update #选择自己的版本 例如我这边安装440 sudo apt-get install nvidia-driver-440 5.选择驱动应用 ubuntu配置点击 软件和更新 ==\u0026gt; 附件驱动 然后选择合适版本的驱动\nOpen warehouse =\u0026gt; additional drivers =\u0026gt; choose you drivers .\n6. End 重启 之后输入命令\nnvidia-smi ##完成 ","permalink":"https://vcvvvc.github.io/post/install_nvidia/","tags":["Linux","Ubuntu"],"title":"Ubuntu20 Install Nvidia drivers"},{"categories":null,"contents":"补充实例： cpp_class继承: https://vcvvvc.github.io/post/cpp_inherit\n1. private, public, protected 访问标号的访问范围\nprivate：只能由1.该类中的函数、2.其友元函数访问。 不能被任何其他访问，该类的对象也不能访问。\nprotected：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问。 但不能被该类的对象访问。\npublic：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。\n注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。\n2 类被继承后方法属性变化\nprivate 属性不能够被继承。 使用private继承， 父类的protected和public属性在子类中变为private； 使用protected继承，父类的protected和public属性在子类中变为protected； 使用public继承， 父类的protected和public属性不发生改变;\n3 private继承和public继承的适用情况\nC++将public继承视为is-a关系。private继承则并不意味着is-a关系，private继承意味着implemented-in-terms-of（根据某物实现出）。private继承意味着只有实现部分被继承，接口部分被略去。private继承在软件设计层面上没有意义，其意义只在于软件实现层面。\nprivate继承：\n1）编译器不会自动将一个子类对象转换为一个父类对象，而public继承会；\n2）子类中由父类继承而来的成员（protected和public）都变为private。\nimplemented-in-terms-of也可以由复合实现。在应用域，复合意味着has-a；在实现域，复合意味着is-implemented-in-terms-of。尽可能使用复合实现这种关系，必要时（涉及protected成员或virtual函数时）才使用private继承。\n原文链接：https://blog.csdn.net/kingzone_2008/article/details/10066181 虚继承 C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。解决二义性。\nclass sum {}; class a : virtual public sum { ... } class b : virtual public sum { ... }; class c:: public a, public b { ... }; ","permalink":"https://vcvvvc.github.io/post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/","tags":["cpp"],"title":"cpp_class权限 继承"},{"categories":null,"contents":"c++标准网络库对比 https://vcvvvc.github.io/post/c++标准网络库/ socket struct整理 https://vcvvvc.github.io/post/socket_struct/ socket编程需要的头文件整理 https://vcvvvc.github.io/post/socket_file/ socket function https://vcvvvc.github.io/post/socket/ I/O复用 https://vcvvvc.github.io/post//io多路复用 sem function https://vcvvvc.github.io/post/sem/ server io actor https://vcvvvc.github.io/post/server_actor/ timer function https://vcvvvc.github.io/post/timer_function/ Linux Pthread 线程创建与使用 https://vcvvvc.github.io/post/pthread/\nC++11 thread https://vcvvvc.github.io/post/cppthread/\nUnp note https://vcvvvc.github.io/post/unp_note/\nTCP_IP | 计算机网络 https://vcvvvc.github.io/post/computer_network/\nexception class 异常类 https://vcvvvc.github.io/post/cpp_exception/\n","permalink":"https://vcvvvc.github.io/post/server_sum/","tags":["Socket","CPP","Linux","Server"],"title":"Server sum"},{"categories":null,"contents":"2021-5-31更新\n#include \u0026lt;unistd.h\u0026gt; extern char *optarg; extern int optind, opterr, optopt; #include \u0026lt;getopt.h\u0026gt; int getopt(int argc, char * const argv[],const char *optstring); int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); 参数以及返回值介绍（以上三个函数都适用）：\n1、argc和argv和main函数的两个参数一致。\n2、optstring: 表示短选项字符串。\n形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下：\n只有一个字符，不带冒号——只表示选项， 如-c 一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100 一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格,形式应该如-b 3、longopts：表示长选项结构体。结构如下：\nstruct option { const char *name; int has_arg; int *flag; int val; }; static struct option longOpts[] = { { \u0026#34;daemon\u0026#34;, no_argument, NULL, \u0026#39;D\u0026#39; }, { \u0026#34;dir\u0026#34;, required_argument, NULL, \u0026#39;d\u0026#39; }, { \u0026#34;out\u0026#34;, required_argument, NULL, \u0026#39;o\u0026#39; }, { \u0026#34;log\u0026#34;, required_argument, NULL, \u0026#39;l\u0026#39; }, { \u0026#34;split\u0026#34;, required_argument, NULL, \u0026#39;s\u0026#39; }, { \u0026#34;http-proxy\u0026#34;, required_argument, \u0026amp;lopt, 1 }, { \u0026#34;http-user\u0026#34;, required_argument, \u0026amp;lopt, 2 }, { \u0026#34;http-passwd\u0026#34;, required_argument, \u0026amp;lopt, 3 }, { \u0026#34;http-proxy-user\u0026#34;, required_argument, \u0026amp;lopt, 4 }, { \u0026#34;http-proxy-passwd\u0026#34;, required_argument, \u0026amp;lopt, 5 }, { \u0026#34;http-auth-scheme\u0026#34;, required_argument, \u0026amp;lopt, 6 }, { \u0026#34;version\u0026#34;, no_argument, NULL, \u0026#39;v\u0026#39; }, { \u0026#34;help\u0026#34;, no_argument, NULL, \u0026#39;h\u0026#39; }, { 0, 0, 0, 0 } }; (1)name:表示选项的名称,比如daemon,dir,out等。\n(2)has_arg:表示选项后面是否携带参数。 该参数有三个不同值，如下：\na: no_argument(或者是0)时 ——参数后面不跟参数值，eg: \u0026ndash;version,\u0026ndash;help b: required_argument(或者是1)时 ——参数输入格式为：\u0026ndash;参数 值 或者 \u0026ndash;参数=值。eg:\u0026ndash;dir=/home c: optional_argument(或者是2)时 ——参数输入格式只能为：\u0026ndash;参数=值 (3) flag:这个参数有两个意思，空或者非空。\na:如果参数为空NULL，那么当选中某个长选项的时候，getopt_long将返回val值。eg，可执行程序 --help，getopt_long的返回值为h. b:如果参数不为空，那么当选中某个长选项的时候，getopt_long将返回0，并且将flag指针参数指向val值。eg: 可执行程序 --http-proxy=127.0.0.1:80 那么getopt_long返回值为0，并且lopt值为1。 (4) val：表示指定函数找到该选项时的返回值，或者当flag非空时指定flag指向的数据的值val。\n4、longindex：longindex非空，它指向的变量将记录当前找到参数符合longopts里的第几个元素的描述，即是longopts的下标值。\n5、全局变量：\n（1）optarg：表示当前选项对应的参数值。 （2）optind：表示的是下一个将被处理到的参数在argv中的下标值。 （3）opterr：如果opterr = 0，在getopt、getopt_long、getopt_long_only遇到错误将不会输出错误信息到标准输出流。opterr在非0时，向屏幕输出错误。 （4）optopt：表示没有被未标识的选项。 6、返回值：\n（1）如果短选项找到，那么将返回短选项对应的字符。 （2）如果长选项找到，如果flag为NULL，返回val。如果flag不为空，返回0 （3）如果遇到一个选项没有在短字符、长字符里面。或者在长字符里面存在二义性的，返回“？” （4）如果解析完所有字符没有找到（一般是输入命令参数格式错误，eg： 连斜杠都没有加的选项），返回“-1” （5）如果选项需要参数，忘了添加参数。返回值取决于optstring，如果其第一个字符是“：”，则返回“：”，否则返回“？”。 注意：\nlongopts的最后一个元素必须是全0填充，否则会报段错误\n短选项中每个选项都是唯一的。而长选项如果简写，也需要保持唯一性。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; using namespace std; int main(int argc, char **argv) { int opt; int digit_optind = 0; int option_index = 0; /* * 形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下： * (1)只有一个字符，不带冒号——只表示选项， 如-c * (2)一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100 * (3)一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格 * 形式应该如-b200 */ char *optstring = \u0026#34;a:b:c:d\u0026#34;; static struct option long_options[] = { /* * no_argument (即 0) 表明这个长参数不带参数（即不带数值，如：--name） * required_argument (即 1) 表明这个长参数必须带参数（即必须带数值，如：--name Bob） * optional_argument（即2）表明这个长参数后面带的参数是可选的，（即--name和--name Bob均可） */ { \u0026#34;reqarg\u0026#34;, required_argument, NULL, \u0026#39;r\u0026#39;}, { \u0026#34;noarg\u0026#34;, no_argument, NULL, \u0026#39;n\u0026#39;}, { \u0026#34;optarg\u0026#34;, optional_argument, NULL, \u0026#39;o\u0026#39;}, { 0, 0, 0, 0} }; /* * 如果longindex非空，它指向的变量将记录当前找到参数符合longopts里的第几个元素的描述，即是longopts的下标值。 * optind表示的是下一个将被处理到的参数在argv中的下标值。 */ while((opt = getopt_long(argc, argv, optstring, long_options, \u0026amp;option_index)) != -1) { cout \u0026lt;\u0026lt; \u0026#34;opt = \u0026#34; \u0026lt;\u0026lt; opt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;optarg = \u0026#34; \u0026lt;\u0026lt; optarg \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;optind = \u0026#34; \u0026lt;\u0026lt; optind \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;argv[optind -1] = \u0026#34; \u0026lt;\u0026lt; argv[optind - 1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;option_index = \u0026#34; \u0026lt;\u0026lt; option_index \u0026lt;\u0026lt; endl; } return 0; } root@Tk:~/git/Cplusplus/test/getopt# ./a.out -a 100 -b 200 --reqarg opt = 97(a) optarg = 100 optind = 3 argv[optind -1] = 100 option_index = 0 opt = 98(b) optarg = 200 optind = 5 argv[optind -1] = 200 option_index = 0 ./a.out: option \u0026#39;--reqarg\u0026#39; requires an argument opt = 63 Re:\nhttps://blog.csdn.net/cashey1991/article/details/7942809\nhttps://blog.csdn.net/qq_33850438/article/details/80172275\n","permalink":"https://vcvvvc.github.io/post/getopt_long/","tags":["Linux","CPP"],"title":"getopt_long"},{"categories":null,"contents":"备忘 简洁明了的教程\nhttps://www.jianshu.com/p/d9162722f189\nhttps://www.jianshu.com/p/a57a5b0e58f0\nhttps://zhuanlan.zhihu.com/p/74812069\n","permalink":"https://vcvvvc.github.io/post/tcpdump/","tags":["Linux","Tcpdump"],"title":"Tcpdump"},{"categories":null,"contents":"计算机体系结构 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 封装 链路层 链路层主要有三个目的：\n为IP模块发送和接收IP数据报； 为ARP模块发送ARP请求和接收ARP应答； 为RARP发送RARP请求和接收RARP应答。 PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。\n环回接口\nre: mtu\n网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输\n不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。\n无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。\nIP 地址分类:\nIP 地址 ::= {\u0026lt;网络号\u0026gt;,\u0026lt;主机号\u0026gt;} IP地址类别 网络号 网络范围 主机号 IP地址范围 A 类 8bit，第一位固定为0 0——127 24bit 1.0.0.0——127.255.255.255 B 类 16bit，前两位固定为10 128.0——191.255 16bit 128.0.0.0——191.255.255.255 C 类 24bit，前三位固定为110 192.0.0——223.255.255 8bit 192.0.0.0——223.255.255.255 D 类 前四位固定为1110，后面为多播地址 E 类 前五位固定为11110，后面保留为今后所用 ARP 地址解析协议 ARP为IP地址到对应的硬件地址之间提供动态映射。\nRARP是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或 X终端），它需要系统管理员进行手工设置。\nARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。可以用apr -a来进行检查ARP高速缓存\nARP分组格式\nARP实例\nRARP 逆地址解析协议 RARP协议是许多无盘系统在引导时用来获取IP地址的。RARP分组格式基本上与ARP分组一致。一个RARP请求在网络上进行广播，它在分组中标明发送端的硬件地址，以请求相应IP地址的响应。应答通常是单播传送的。\nICMP 网际控制报文协议 ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。\nICMP报文通常被IP层或更高层协议（TCP或UDP）使用。一些ICMP报文把差错报文返回给用户进程。\nICMP报文是在IP数据报内部被传输的\n检验和字段覆盖整个ICMP报文。\nICMP报文类型 下面各种情况都不会导致产生ICMP差错报文:\nICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。 目的地址是广播地址或多播地址（D类地址）的IP数据报。 作为链路层广播的数据报。 不是IP分片的第一片。 源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。 对于其他类型的ICMP查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。\nping程序 IP数据报中的RR选项的一般格式\n运输层 tcp—udp UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。\nUDP首部\nUDP数据报中的伪首部 UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。其目的是让UDP两次检查数据是否已经正确到达目的地。\nIP分片 在分片时，除最后一片外，其他每一片中的数据部分（除 I P首部外的其余部分）必须是 8 字节的整数倍。 位于@符号后的数字是从数据报开始处计算的片偏移值。 IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后） 分组是指在IP层和链路层之间传送的数据单元。 一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。 ICMP不可达差错 发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果路由器没有提供这种新的ICMP差错报文格式，那么下一站的MTU就设为0。\nip数据报格式: https://www.jianshu.com/p/d3f9e70c6220\n","permalink":"https://vcvvvc.github.io/post/tcp_ip/","tags":["TCP","IP","UDP","Socket","Server"],"title":"Tcp_ip"},{"categories":null,"contents":"环境 Macos Clion2020.3.2 Server: ubuntu18 设置 1. 首先添加一个ssh\n2. 部署服务器上传文件\n选择SFTP协议\n3. 设置本地与远程文件路径\n4. 上传文件\n5. 设置自动上传\n环境配置 安装环境\nCentos # cmake yum install cmake -y # gcc \u0026amp; gdb yum install gcc-c++ -y yum install gdb -y #gdbserver yum install gdb-gdbserver -y Ubuntu apt-get install cmake apt-get install gcc apt-get install g++ apt-get install gdb apt-get install gdbserver gdbserver配置\ntarget remote中格式是: tcp:ip:port\n远程调试 编译程序 -g 或者cmkae\ncmake .. -DCMAKE_BUILD_TYPE=Debug make #注意这个10234是端口 跟上图中设置的对应 gdbserver :10234 ./WebServer clion设置断点之后 点击debug开始\n我写了个小脚本 方便操作\n#!/bin/bash cd /root/git/server/debug read -p \u0026#34;Enter server port: \u0026#34; port make gdbserver :$port ./WebServer Re:\nhttps://cloud.tencent.com/developer/article/1406250\n","permalink":"https://vcvvvc.github.io/post/clion_remote_debug/","tags":["Clion","Linux"],"title":"Clion_remote_debug"},{"categories":null,"contents":"GDB 教程 转载自：https://github.com/DAN-AND-DNA/learn-gdb-by-example-for-c.git\n内容 原理 启动gdb 退出gdb 为gdb进行编译 调试程序 CoreDump简单概念 产生CoreDump文件 调试CoreDump文件 help命令 list命令 start命令 next命令 step命令 break命令 查看断点 删除断点 tbreak命令 continue命令 backtrace命令 查看当前所处的函数堆栈帧 选择函数堆栈帧 打印函数局部变量 run命令 修改变量值 查看变量类型 查看线程运行 启动图像界面 原理 断点功能一般是通过gdb捕获特定的内核信号来实现的，然后定位目标程序停止的地址来判断断点是否成功触发。大致的流程为， 首先gdb fork()出来一个子进程，该子进程启动目标程序(通过ptrace() 和 exec())， 父进程捕获该子进程的所有的信号(通过ptrace() 和 wait())，当子进程收到信号时，子进程就会被挂起，直到父进程通知其继续运行(通过ptrace())\n启动gdb 1 常规启动，非常多的提示信息:\n$ gdb GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026quot;show copying\u0026quot; and \u0026quot;show warranty\u0026quot; for details. This GDB was configured as \u0026quot;x86_64-redhat-linux-gnu\u0026quot;. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. (gdb) 2 简约启动，关闭提示信息:\n$ gdb -q (gdb) 退出gdb 1 输入quit:\n$ gdb -q (gdb) quit 2 输入Ctrl-d:\n$ gdb -q (gdb) quit 为gdb进行编译 为了获得调试信息，需要添加 CFLAGS=-g -o0 选项 具体参考gdb手册\n调试程序 //boom.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void fun(void) { printf(\u0026#34;hello\\n\u0026#34;); } int main() { fun(); sleep(1000); return 0; } 1 直接启动:\n方法1\n$ gdb boom -q (gdb) 方法2\n$ gdb -q (gdb) file boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) 2 调试正在运行的程序:\n$ ps ux | grep boom | grep -v 'grep' dan 5647 0.0 0.0 11520 472 pts/0 S+ 15:31 0:00 ./boom $ gdb boom 5647 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. Attaching to program: /home/dan/work/learn_core/build/bin/boom, process 5647 Reading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done. [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Loaded symbols for /lib64/libpthread.so.0 Reading symbols from /lib64/libdl.so.2...(no debugging symbols found)...done. Loaded symbols for /lib64/libdl.so.2 Reading symbols from /lib64/libm.so.6...(no debugging symbols found)...done. Loaded symbols for /lib64/libm.so.6 Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done. Loaded symbols for /lib64/libc.so.6 Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done. Loaded symbols for /lib64/ld-linux-x86-64.so.2 0x00007f1e2185be10 in __nanosleep_nocancel () from /lib64/libc.so.6 Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) 具体参考gdb手册\nCoreDump简单概念 CoreDump即核心转储，是程序运行异常崩溃时，系统内核为该程序产生的内存、寄存器、运行栈等快照，并保存为一个二进制文件，可以利用该文件进行GDB调试，发现运行错误。\n产生CoreDump文件 # macosx sudo sysctl kern.coredump=1 :kern.coredump: 1 -\u0026gt; 1 # 设置 /cores 目录属性 sudo mkdir /cores sudo chown root:admin /cores sudo chmod 1775 /cores sudo chmod o+w /cores ulimit -c unlimited : /cores/core.* 查看系统是否已经开启了该功能:\n$ ulimit -c 0 上述输出结果为0说明当前系统已经关闭了该功能，所以需要打开该功能:\n临时启用\n$ ulimit -c unlimited $ ulimit -c unlimited 永久启用\n在/etc/security/limits.conf添加一行: * soft core unlimited 修改文件格式，例如： echo \u0026quot;core.%e.%p.%t\u0026quot; \u0026gt;/proc/sys/kernel/core_pattern or echo \u0026quot;/home/dan/mycore/core.%e.%p.%t\u0026quot; \u0026gt;/proc/sys/kernel/core_pattern 调试CoreDump文件 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int* p = NULL; printf(\u0026#34;here\u0026#34;); *p = 7; sleep(1000); return 0; } 运行上述程序就会产生core dump 文件，如果修了core dump文件的位置就需要加上绝对地址如:\n方法1\n$ gdb /home/dan/work/learn_core/build/bin/boom /home/dan/mycore/core.boom.5859.1557305516 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 5859] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) 方法2\ngdb -q (gdb) file /home/dan/work/learn_core/build/bin/boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) core /home/dan/mycore/core.boom.5859.1557305516 [New LWP 5859] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) 如果没有修改core dump文件的位置，该文件就会在程序的当前位置产生，就可以直接启动如:\n方法1\n$ gdb boom core.boom.5941.1557306910 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 5941] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) 方法2\n$ gdb -q (gdb) file boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) core core.boom.5941.1557306910 [New LWP 5941] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400770 in main () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) help命令 简写为h，查询命令帮助手册，例如:\n$ gdb -q (gdb) help start Run the debugged program until the beginning of the main procedure. You may specify arguments to give to your program, just as with the \u0026quot;run\u0026quot; command. (gdb) list命令 简写为l，查看源代码，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } list num 指定行号\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) l 7 void func() { printf(\u0026quot;here\u0026quot;); } int main() { int a = 0; list function 指定函数名\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list func #include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026quot;here\u0026quot;); } int main() { int a = 0; (gdb) list start,end 指定范围\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,22 #include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026quot;here\u0026quot;); } int main() { int a = 0; func(); a++; return 0; } (gdb) list + 向后打印 list - 向前打印\nstart命令 start命令会给main函数的第一个可执行语句打上临时断点，然后运行程序直到该断点，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) start Temporary breakpoint 1 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) next命令 简写为n，继续运行到下一个代码行，遇到函数则直接运行函数，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) start Temporary breakpoint 1 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) next 11 func(); (gdb) n 12 a++; (gdb) 13 return 0; (gdb) 14 } (gdb) 0x00007ffff730e3d5 in __libc_start_main () from /lib64/libc.so.6 (gdb) Single stepping until exit from function __libc_start_main, which has no line number information. here[Inferior 1 (process 6236) exited normally] (gdb) next num 可以指定连续运行的代码行数量，例如:\n(gdb) start Temporary breakpoint 2 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 2, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; (gdb) n 3 13 return 0; (gdb) step命令 简写为s，继续运行到下一个代码行，遇到函数则进入函数，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) start Temporary breakpoint 1 at 0x40074a: file /home/dan/work/learn_core/boom.c, line 10. Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, main () at /home/dan/work/learn_core/boom.c:10 10 int a = 0; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) step 11 func(); (gdb) func () at /home/dan/work/learn_core/boom.c:5 5 printf(\u0026quot;here\u0026quot;); (gdb) 6 } (gdb) main () at /home/dan/work/learn_core/boom.c:12 12 a++; (gdb) 13 return 0; (gdb) 14 } (gdb) 0x00007ffff730e3d5 in __libc_start_main () from /lib64/libc.so.6 (gdb) Single stepping until exit from function __libc_start_main, which has no line number information. here[Inferior 1 (process 6252) exited normally] (gdb) break命令 简写为b，设置断点，程序运行到断点就会暂停挂起，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,20 1 #include \u0026lt;stdio.h\u0026gt; 2 3 void func() 4 { 5 printf(\u0026quot;here\u0026quot;); 6 } 7 8 int main() 9 { 10 int a = 0; 11 func(); 12 a++; 13 return 0; 14 } (gdb) b 5 Breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) run Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Breakpoint 1, func () at /home/dan/work/learn_core/boom.c:5 5 printf(\u0026quot;here\u0026quot;); Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) 查看断点 info breakpoints 可以查看全部设置的断点，命令缩写成 i b，例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,20 1 #include \u0026lt;stdio.h\u0026gt; 2 3 void func() 4 { 5 printf(\u0026quot;here\u0026quot;); 6 } 7 8 int main() 9 { 10 int a = 0; 11 func(); 12 a++; 13 return 0; 14 } (gdb) b 5 Breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) info break Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400731 in func at /home/dan/work/learn_core/boom.c:5 (gdb) 删除断点 #include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) list 1,20 1 #include \u0026lt;stdio.h\u0026gt; 2 3 void func() 4 { 5 printf(\u0026quot;here\u0026quot;); 6 } 7 8 int main() 9 { 10 int a = 0; 11 func(); 12 a++; 13 return 0; 14 } (gdb) b 5 Breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) info break Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400731 in func at /home/dan/work/learn_core/boom.c:5 (gdb) delete 1 (gdb) info break No breakpoints or watchpoints. (gdb) tbreak命令 设置临时断点，指令简写为tb，该断点一旦触发就会失效例如:\n#include \u0026lt;stdio.h\u0026gt; void func() { printf(\u0026#34;here\u0026#34;); } int main() { int a = 0; func(); a++; return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) tb 5 Temporary breakpoint 1 at 0x400731: file /home/dan/work/learn_core/boom.c, line 5. (gdb) info b Num Type Disp Enb Address What 1 breakpoint del y 0x0000000000400731 in func at /home/dan/work/learn_core/boom.c:5 (gdb) run Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Temporary breakpoint 1, func () at /home/dan/work/learn_core/boom.c:5 5 printf(\u0026quot;here\u0026quot;); Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) info b No breakpoints or watchpoints. (gdb) continue命令 遇到断点可以选择next，step等命令继续运行到下一个代码行，也可以使用continue，继续运行整个程序，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; printf(\u0026#34;d=%d\\n\u0026#34;, d); } void func2() { int c = 3; printf(\u0026#34;c=%d\\n\u0026#34;, c); func3(); } void func1() { int b = 2; printf(\u0026#34;b=%d\\n\u0026#34;, b); func2(); } int main() { int a = 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); func1(); return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 5 Breakpoint 1 at 0x400775: file /home/dan/work/learn_core/boom.c, line 5. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. a=1 b=2 c=3 Breakpoint 1, func3 () at /home/dan/work/learn_core/boom.c:5 5 int d = 4; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) c Continuing. d=4 [Inferior 1 (process 4209) exited normally] (gdb) backtrace命令 打印函数堆栈帧，回溯整个调用过程，之类简写为bt，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) bt #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 #3 0x000000000040079b in main () at /home/dan/work/learn_core/boom.c:29 bt full 可以打印每个函数的局部变量\n(gdb) bt full #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 d = 4 p = 0x0 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 c = 3 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 b = 2 #3 0x000000000040079b in main () at /home/dan/work/learn_core/boom.c:29 a = 1 (gdb) 查看当前所处的函数堆栈帧 通过 info frame 可以查看当前所处的函数堆栈帧信息，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } $ gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) i frame Stack level 0, frame at 0x7ffddb0d63d0: rip = 0x400744 in func3 (/home/dan/work/learn_core/boom.c:8); saved rip 0x400765 called by frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d63c0, args: Locals at 0x7ffddb0d63c0, Previous frame's sp is 0x7ffddb0d63d0 Saved registers: rbp at 0x7ffddb0d63c0, rip at 0x7ffddb0d63c8 (gdb) 选择函数堆栈帧 通过frame 可以选择指定的函数堆栈帧，该指令缩写为f，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } $ gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) bt #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 #3 0x000000000040079b in main () at /home/dan/work/learn_core/boom.c:29 (gdb) info frame Stack level 0, frame at 0x7ffddb0d63d0: rip = 0x400744 in func3 (/home/dan/work/learn_core/boom.c:8); saved rip 0x400765 called by frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d63c0, args: Locals at 0x7ffddb0d63c0, Previous frame's sp is 0x7ffddb0d63d0 Saved registers: rbp at 0x7ffddb0d63c0, rip at 0x7ffddb0d63c8 (gdb) frame 2 #2 0x0000000000400780 in func1 () at /home/dan/work/learn_core/boom.c:22 22 func2(); (gdb) info frame Stack level 2, frame at 0x7ffddb0d6410: rip = 0x400780 in func1 (/home/dan/work/learn_core/boom.c:22); saved rip 0x40079b called by frame at 0x7ffddb0d6430, caller of frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d6400, args: Locals at 0x7ffddb0d6400, Previous frame's sp is 0x7ffddb0d6410 Saved registers: rbp at 0x7ffddb0d6400, rip at 0x7ffddb0d6408 (gdb) 打印函数局部变量 通过info locals 可以打印当前函数堆栈帧内的局部变量，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; (void)(d); int* p = NULL; *p = 7; } void func2() { int c = 3; (void)(c); func3(); } void func1() { int b = 2; (void)(b); func2(); } int main() { int a = 1; (void)(a); func1(); return 0; } $ gdb boom core.boom.4042.1557369051 -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. [New LWP 4042] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Core was generated by `./boom'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400744 in func3 () at /home/dan/work/learn_core/boom.c:8 8 *p = 7; Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) i frame Stack level 0, frame at 0x7ffddb0d63d0: rip = 0x400744 in func3 (/home/dan/work/learn_core/boom.c:8); saved rip 0x400765 called by frame at 0x7ffddb0d63f0 source language c. Arglist at 0x7ffddb0d63c0, args: Locals at 0x7ffddb0d63c0, Previous frame's sp is 0x7ffddb0d63d0 Saved registers: rbp at 0x7ffddb0d63c0, rip at 0x7ffddb0d63c8 (gdb) info locals d = 4 p = 0x0 (gdb) frame 1 #1 0x0000000000400765 in func2 () at /home/dan/work/learn_core/boom.c:15 15 func3(); (gdb) info locals c = 3 (gdb) run命令 简写为 r，直接运行程序直到发生错误或者遇到断点，和start不同的是，不会在第一个可执行点暂停，例如:\n#include \u0026lt;stdio.h\u0026gt; void func3() { int d = 4; printf(\u0026#34;d=%d\\n\u0026#34;, d); } void func2() { int c = 3; printf(\u0026#34;c=%d\\n\u0026#34;, c); func3(); } void func1() { int b = 2; printf(\u0026#34;b=%d\\n\u0026#34;, b); func2(); } int main() { int a = 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); func1(); return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. a=1 b=2 c=3 d=4 [Inferior 1 (process 4201) exited normally] Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) b 5 Breakpoint 1 at 0x400775: file /home/dan/work/learn_core/boom.c, line 5. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. a=1 b=2 c=3 Breakpoint 1, func3 () at /home/dan/work/learn_core/boom.c:5 5 int d = 4; (gdb) 修改变量值 利用set 命令可以修改程序变量，利用print 可以打印变量的值，缩写为p，例如:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void func1() { int i = 0; while(i \u0026lt; 200) { sleep(1); } } int main() { func1(); return 0; } $ gdb -q (gdb) file boom Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 8 Breakpoint 1 at 0x40073c: file /home/dan/work/learn_core/boom.c, line 8. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. Breakpoint 1, func1 () at /home/dan/work/learn_core/boom.c:8 8 while(i \u0026lt; 200) Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) p i $1 = 0 (gdb) set var i = 200 (gdb) p i $2 = 200 (gdb) s 12 } (gdb) main () at /home/dan/work/learn_core/boom.c:17 17 return 0; (gdb) 18 } (gdb) 0x00007ffff730e3d5 in __libc_start_main () from /lib64/libc.so.6 (gdb) Single stepping until exit from function __libc_start_main, which has no line number information. [Inferior 1 (process 4361) exited normally] (gdb) 要用print打印数组，如果数组的元素数量大于200，是没办法显示完全的，但是可以设置最大元素数量，如:\nset print elements 0 //不进行限制 查看变量类型 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; struct User { char openid[15]; int age; }; void func1() { struct User u = {\u0026#34;wx1234567\u0026#34;, 7}; printf(\u0026#34;openid = %s\\n\u0026#34;, u.openid); int i = 0; while(i \u0026lt; 200) { sleep(1); } } int main() { func1(); return 0; } $ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 17 Breakpoint 1 at 0x4007b8: file /home/dan/work/learn_core/boom.c, line 17. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. openid = wx1234567 Breakpoint 1, func1 () at /home/dan/work/learn_core/boom.c:17 warning: Source file is more recent than executable. 17 while(i \u0026lt; 200) Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) ptype u type = struct User { char openid[15]; int age; } (gdb) 查看线程运行 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; void* func(void *p_arg) { while(1) { sleep(3); } } int main() { pthread_t t1; pthread_t t2; char t1n[] = \u0026#34;t1\u0026#34;; char t2n[] = \u0026#34;t2\u0026#34;; pthread_create(\u0026amp;t1, NULL, func, t1n); pthread_create(\u0026amp;t2, NULL, func, t2n); sleep(100); return 0; } info threads 可以查看全部的线程运行情况，包括线程的id和系统id以及当前栈， info thread ID 可以查看单独的线程的运行情况。\n$ gdb boom -q Reading symbols from /home/dan/work/learn_core/build/bin/boom...done. (gdb) b 23 Breakpoint 1 at 0x40080b: file /home/dan/work/learn_core/boom.c, line 23. (gdb) r Starting program: /home/dan/work/learn_core/build/bin/boom [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026quot;/lib64/libthread_db.so.1\u0026quot;. [New Thread 0x7ffff72eb700 (LWP 4675)] [New Thread 0x7ffff6aea700 (LWP 4676)] Breakpoint 1, main () at /home/dan/work/learn_core/boom.c:23 23 sleep(100); Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) i threads Id Target Id Frame 3 Thread 0x7ffff6aea700 (LWP 4676) \u0026quot;boom\u0026quot; 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 2 Thread 0x7ffff72eb700 (LWP 4675) \u0026quot;boom\u0026quot; 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 * 1 Thread 0x7ffff7fee740 (LWP 4671) \u0026quot;boom\u0026quot; main () at /home/dan/work/learn_core/boom.c:23 (gdb) thread apply ID bt 命令可以打印 指定线程的调用栈\n(gdb) thread apply 3 bt Thread 3 (Thread 0x7ffff6aea700 (LWP 4676)): #0 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 #1 0x00007ffff73b0cc4 in sleep () from /lib64/libc.so.6 #2 0x00000000004007b3 in func (p_arg=0x7fffffffe3b0) at /home/dan/work/learn_core/boom.c:10 #3 0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0 #4 0x00007ffff73e9ead in clone () from /lib64/libc.so.6 thread apply all bt 命令可以打印 全部线程的调用栈\n(gdb) thread apply all bt Thread 3 (Thread 0x7ffff6aea700 (LWP 4676)): #0 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 #1 0x00007ffff73b0cc4 in sleep () from /lib64/libc.so.6 #2 0x00000000004007b3 in func (p_arg=0x7fffffffe3b0) at /home/dan/work/learn_core/boom.c:10 #3 0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0 #4 0x00007ffff73e9ead in clone () from /lib64/libc.so.6 Thread 2 (Thread 0x7ffff72eb700 (LWP 4675)): #0 0x00007ffff73b0e2d in nanosleep () from /lib64/libc.so.6 #1 0x00007ffff73b0cc4 in sleep () from /lib64/libc.so.6 #2 0x00000000004007b3 in func (p_arg=0x7fffffffe3c0) at /home/dan/work/learn_core/boom.c:10 #3 0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0 #4 0x00007ffff73e9ead in clone () from /lib64/libc.so.6 Thread 1 (Thread 0x7ffff7fee740 (LWP 4671)): #0 main () at /home/dan/work/learn_core/boom.c:23 (gdb) 具体参考gdb手册\n启动图像界面 $ gdb boom -tui -q启动图像界面\n具体参考gdb手册\n","permalink":"https://vcvvvc.github.io/post/use_gdb/","tags":["Linux","GDB","CPP"],"title":"Use_gdb"},{"categories":null,"contents":" 非活跃，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。\n定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。\n定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。\n定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。\nLinux下提供了三种定时的方法:\nsocket选项SO_RECVTIMEO和SO_SNDTIMEO SIGALRM信号 I/O复用系统调用的超时参数 Socket选项 struct timeval timeout; timeout.tv_sec = time; timeout.tv_usec = 0; socklen_t time_len = sizeof(timeout); ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, \u0026amp;timeout, time_len); //发送数据超时 用返回值errno判断是否达到指定时间 (errno == SO_SNDTIMEO) SIGALRM信号 sigaction结构体\nstruct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); } sa_handler是一个函数指针，指向信号处理函数 sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息 sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号 sa_flags用于指定信号处理的行为 SA_RESTART，使被信号打断的系统调用自动重新发起 SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号 SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程 SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号 SA_RESETHAND，信号处理之后重新设置为默认的处理方式 SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数 sa_restorer一般不使用\n#include \u0026lt;signal.h\u0026gt; int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); Re:\n定时器-Web服务器项目\n","permalink":"https://vcvvvc.github.io/post/timer_function/","tags":["Linux","Timer","Server"],"title":"Timer function"},{"categories":null,"contents":"同步IO模型通常用于实现Reactor模式, 异步IO模型则用于实现Proactor模式。\nReactor Reactor模式要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。\nReactor工作流程∶\n主线程往 epoll内核事件表中注册 socket 上的读就绪事件。 主线程调用epoll_wait 等待socket上有数据可读。 当socket上有数据可读时，epoll_wait 通知主线程。主线程则将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件。 主线程调用epoll_wait 等待socket可写。 当socket可写时，epoll_wait 通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。 Procactor 将多有I/O操作都交给主线程和内核来处理, 工作线程仅负责业务逻辑\nProactor工作流程∶\n主线程调用aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的 man 手册）。 主线程继续处理其他逻辑。 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。 主线程继续处理其他逻辑。 当用户缓冲区的数据被写人 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。 模拟Proactor 使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程∶\n主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket上有数据可读。 当 socket 上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket上的写就绪事件。 主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll wait 通知主线程。主线程往 socket 上写人服务器处理客户请求的结果。 半同步/半异步 在I/O模型中，\u0026ldquo;同步\u0026quot;和\u0026quot;异步\u0026quot;区分的是内核向应用程序通知的是何种 I/O 事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。在并发模式中，\u0026ldquo;同步\u0026quot;指的是程序完全按照代码序列的顺序执行∶\u0026ldquo;异步\u0026quot;指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。\n工作流程 异步线程用于处理 I/O事件，相当于图8-4中的I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。\n反应堆模式 在服务器程序中，如果结合考虑两种事件处理模式和几种 I/O模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（halfsynchalf-reactive）模式\n异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听 socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接 socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。\n半同步 / 半反应堆模式存在如下缺点∶\n主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从详 求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费 CPU时间。 每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较 少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量 CPU 时间。 高效半同步半异步 主线程只管理监听 socket，连接 socket 由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接 socket 派发给某个工作线程，此后该新 socket上的任何I/O 操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发 socket 的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新 socket上的读写事件注册到自己的 epoll 内核事件表中。\n领导者/追随者模式 领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序都仅有一个领导者线程，它负责监听 I/O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理L/O事件。此时，新的领导者等待新的 I/O 事件，而原来的领导者则处理 I/O 事件，二者实现了并发。\n领导者/追随者模式包含如下几个组件∶句柄集（HandleSet）、线程集（ThreadSet）、事件处理器（EventHandler）和具体的事件处理器（ConcreteEventHandler）。\n1.句柄集 句柄（Handle）用于表示 I/O 资源，在Linux下通常就是一个文件描述符。句柄集管理众多句柄，它使用wait_for event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。领导者则调用绑定到Handle上的事件处理器来处理事件。领导者将 Handle 和事件处理器绑定是通过调用句柄集中的 register_handle方法实现的。 2.线程集 这个组件是所有工作线程（包括领导者线程和追随者线程）的管理者。它负责各线程之间的同步，以及新领导者线程的推选。线程集中的线程在任一时间必处于如下三种状态之一∶ Leader∶ 线程当前处于领导者身份，负责等待句柄集上的 I/O 事件。 Processing∶线程正在处理事件。领导者检测到I/O事件之后，可以转移到Processing状态来处理该事件，并调用 promote_new_leader方法推选新的领导者;也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导者，则它将成为新的领导 者，否则它就直接转变为追随者。 Follower∶线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。图 8-13 显示了这三种状态之间的转换关系。 需要注意的是，领导者线程推选新的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员 Synchronizer来同步这两个操作，以避免竞态条件。\n3. 事件处理器和具体的事件处理器 事件处理器通常包含一个或多个回调函数 handle_event。这些回调函数用于处理事件对应的业务逻辑。事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的 handle_event 方法，以处理特定的任务。\n由于领导者线程自己监听 I/O 事件并处理客户请求，因而领导者/追随者模式不需要在线程之间传递任何额外的数据，也无须像半同步/半反应堆模式那样在线程之间同步对请求队列的访问。但领导者/追随者的一个明显缺点是仅支持一个事件源集合，因此也无法像图 8-11 所示的那样，让每个工作线程独立地管理多个客户连接。\n","permalink":"https://vcvvvc.github.io/post/server_actor/","tags":["Linux","Server","Reactor","Proactor"],"title":"Server actor"},{"categories":null,"contents":"信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：\nP，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行 V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一 int sem_init(sem_t *sem, int pshared, unsigned int value)\n初始化m_sem value为指定信号量的初始值\npshared为0 信号量在进程的线程之间共享 pshared非0 信号量在进程之间共享 sem_init函数用于初始化一个未命名的信号量 sem_destory函数用于销毁信号量 sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞 sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程 调用seminit函数时，操作系统将创建信号量对象，此对象中记录着“信号量值”（semaphoreValue）整数。 该值在调用sem_post函数时增1，调用semwait函数时减1。 但信号量的值不能小于0，因此，在信号量为0的情况下调用sem一vait函数时，调用函数的线程将进人阻塞状态（因为函数未返回）。 当然，此时如果有其他线程调用sem一post函数，信号量的值将变为1，而原本阻塞的线程可以将该信号量重新减为0并跳出阻塞状态。 实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为1）。 **类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制\nclass sem{ public: //构造函数 sem() { //信号量初始化 if(sem_init(\u0026amp;m_sem,0,0)!=0){ throw std::exception(); } } //析构函数 ~sem() { //信号量销毁 sem_destroy(\u0026amp;m_sem); } private: sem_t m_sem; }; Reference:\nhttps://blog.csdn.net/m0_45867846/article/details/109021863\n","permalink":"https://vcvvvc.github.io/post/sem/","tags":["Linux","Sem"],"title":"Linux Sem"},{"categories":null,"contents":"Downloads mysql 社区版官网下载: https://dev.mysql.com/downloads/mysql/\nStart 下载之后安装一路点继续 设置完root密码\n安装完成后 需要开启/关闭Mysql 系统偏好设置-Mysql图标\n停止MySQL服务 sudo mysql.server stop 重启MySQL服务 sudo mysql.server restart 查看MySQL服务状态 sudo mysql.server status Connect Mysql 终端输入 vim ~/.bash_profile\nPATH=$PATH:/usr/local/mysql/bin PATH=$PATH:/usr/local/mysql/support-files 再执行 source ~/.bash_profile\nLogin mysql -u root -p 输入密码之后成功进入mysql\nmysql\u0026gt; select version();查看MySQL版本\nReference: https://www.jianshu.com/p/07a9826898c0\nhttps://www.cnblogs.com/nickchen121/p/11145123.htm\n","permalink":"https://vcvvvc.github.io/post/mac_install_mysql/","tags":["Mac","Mysql"],"title":"Mac install mysql_8.0"},{"categories":null,"contents":"2021-12-13更新 系统为big sur 11.4\n接近完美 可以用intel网卡连接wifi 速度还不错\n已知麦克风、隔空投送不能用\n镜像下载 搜素：黑果小兵\nbig sur用11.4\n重要前提 如果你没有网线，并且没有其他PC设备联网 你需要提前下载这些\nhttps://github.com/OpenIntelWireless/itlwm/releases/ #AirportItlwm https://5435.lanzouo.com/isRfBxjxq4f #四叶草+occ Start //OC git clone https://github.com/Pinming/Dell-Inspiron-7590-Hackintosh-Opencore //Diskgenius 官网自行下载最新版 //balennaEther 官网自行下载最新版 1. 先把Dell-Inspiron-7590-Hackintosh-Opencore重命名为OC\n2. 打开OC文件夹 根据屏幕改名1080P的屏幕使用config-1080p.plist需改名成config.plist 如果你是4K屏 不需要修改\n3. balennaEther烧录dmg镜像文件到U盘\n4. 打开Diskgenius 进入U盘的ESP分区文件夹 删除Clover文件夹 然后将OC文件夹拖入\n5. 打开U盘ESP分区中的EFI 将Diskgenius程序文件夹拖进去 备用 以免出问题\n提前准备好安装空间建议300g 至少200g\n6. 用Diskgenius分ESP区 建议400m\n7. 双系统需要保存好windows efi\n安装 1. 重启F2 关闭Secure Boot安全启动 检查磁盘模式为ACHI 百度搜\n2. 进入Boot Sequence \u0026lsquo;add option\u0026rsquo; 添加一个引导 选择启动文件为自己的U盘EFI(找到EFI/OC/OpenCore.efi这个文件)\n3. 重启F12 选择刚才新建的启动项 选择Install mac big sur\n4. 选择磁盘工具先抹盘 选择你提前分好的空间 命名个macos就行 选择格式为APFS 抹不掉就先做成exft 再抹一次\n5. 左上角退出磁盘工具继续安装 然后自动重启 再次选mac启动项 (此时我读条完毕 一直在转圈 等了5分钟 我手动强制关机)\n6. 重启f12 选择install mac 本步骤需要重复几次 直到进入系统设置 创建用户的步骤才算完成\nSiri不启用 iCloud先不要登陆 先创建好一个本地账户 7.1 重启f12 选择winPE, 在我的电脑 EFI中找到Diskgenius 打开程序将U盘的EFI文件复制到桌面, 此时可以把win10的efi加回去\n7.2 选择磁盘的ESP-EFI将OC拖入\n8.1 Disk这个软件可以设置启动项,或者重启F2, Boot Sequence add option 这里我命名为macos 选择磁盘中EFI\\OC\\OpenCore.efi\n8.2 把选项置顶。开机自动进入 选择macos\nWifi设置 下载\u0026ndash;点击: 前提文件\n挂载EFI\n将AirportItlwm_xx.kext加入efi-oc-kexts，再拖入occ内核设置\n安装成功 三码洗白 电脑提前退出账号\n删除登陆的电脑设备 手机-设置-最上方进去-找到型号删除掉\n一定要找对自己的型号 dell7590选择MacPro 16.4\n重启登陆 正常使用功能\n关闭SIP(可选) 增加一个csr-active-config填写值FF0F0000\nReference: https://zhuanlan.zhihu.com/p/190441192\nhttps://zhuanlan.zhihu.com/p/117680791\nhttps://zhuanlan.zhihu.com/p/148640325\n三码参考 https://blog.csdn.net/shuiyunxc/article/details/104912457\nSIP https://www.mfpud.com/topics/2821/\n参考视频 安装系统操作 https://www.bilibili.com/video/BV1854y1X7oP\n安装wifi操作 https://www.bilibili.com/video/BV12y4y167Qv\nOC 2021-12-10更新至2.54.1.0-适配0.7.6-12-07正式版与0.7.7-12-10编译版 2021-12-06更新至2.54.0.0-适配0.7.5-11-02正式版与0.7.6-12-06编译版 2021-11-08更新至2.53.0.0-适配0.7.5-11-02正式版与0.7.6-11-08编译版 2021-10-29更新至2.52.0.1-适配0.7.4-10-05正式版与0.7.5-10-29编译版 2021-10-15更新至2.52.0.0-适配0.7.4-10-05正式版与0.7.5-10-13编译版 2021-10-07更新至2.51.0.0-适配0.7.4-10-05正式版与0.7.5-10-07编译版 2021-09-23更新至2.50.0.0-适配0.7.3-09-07正式版与0.7.4-09-23编译版 2021-09-15更新至2.49.0.2-适配0.7.3-09-07正式版与0.7.4-09-15编译版 2021-09-13更新至2.49.0.1-适配0.7.3-09-07正式版与0.7.4-09-13编译版 2021-09-11更新至2.49.0.0-适配0.7.3-09-07正式版与0.7.4-09-11编译版 2021-08-19更新至2.48.1.0-适配0.7.2-08-03正式版与0.7.3-08-19编译版 2021-08-05更新至2.48.0.0-适配0.7.2-08-03正式版与0.7.3-08-05编译版 2021-07-22更新至2.47.1.0-适配0.7.1-07-06正式版与0.7.2-07-22编译版 2021-07-18更新至2.47.0.0-适配0.7.1-07-06正式版与0.7.2-07-18编译版 2021-07-12更新至2.46.1.0-适配0.7.1-07-06正式版与0.7.2-07-12编译版 2021-07-08更新至2.46.0.0-适配0.7.1-07-06正式版与0.7.2-07-08编译版 2021-06-24更新至2.45.0.0-适配0.7.0-06-08正式版与0.7.1-06-24编译版 2021-06-12更新至2.44.0.0-适配0.7.0-06-08正式版与0.7.1-06-12编译版 2021-06-10更新至2.43.0.0-适配0.7.0-06-08正式版与0.7.1-06-10编译版 2021-06-05更新至2.42.0.0-适配0.6.9-05-04正式版与0.7.0-06-05编译版 2021-06-01更新至2.41.0.0-适配0.6.9-05-04正式版与0.7.0-06-01编译版 2021-05-28更新至2.40.0.1-适配0.6.9-05-04正式版与0.7.0-05-28编译版 2021-05-26更新至2.40.0.0-适配0.6.9-05-04正式版与0.7.0-05-26编译版 2021-05-22更新至2.39.0.0-适配0.6.9-05-04正式版与0.7.0-05-22编译版 2021-05-20更新至2.38.0.0-适配0.6.9-05-04正式版与0.7.0-05-20编译版 2021-05-14更新至2.37.0.0-适配0.6.9-05-04正式版与0.7.0-05-14编译版 2021-05-06更新至2.36.1.0-适配0.6.9-05-04正式版与0.7.0-05-06编译版 2021-05-05更新至2.36.0.0-适配0.6.9-05-04正式版与0.7.0编译版 2021-04-21更新至2.35.0.0-适配0.6.9-04-20 2021-04-08更新至2.34.0.0-适配0.6.9-04-16 2021-04-08更新至2.33.1.2-适配0.6.9-04-08 2021-04-07更新至2.33.1.0-适配0.6.8-04-06正式版 2021-04-05更新至2.33.0.0-适配0.6.8-04-04 2021-04-01更新至2.32.0.0-适配0.6.8-03-31 2021-03-19更新至2.31.0.0-适配0.6.8-03-19 2021-03-13更新至2.30.1.0-适配0.6.8-03-13 2021-03-11更新至2.30.0.0-适配0.6.8-03-09 2021-02-26更新至2.28.0.0-适配0.6.7-02-25 2021-02-03更新至2.27.0.0-适配0.6.6正式版 ","permalink":"https://vcvvvc.github.io/post/dell7590_install_macos/","tags":["Dell","Mac"],"title":"Dell7590 install macos"},{"categories":null,"contents":"unlocker git clone https://github.com/paolo-projects/auto-unlocker.git\nDownload cdr https://www.mfpud.com/topics/3888/\nTutorial https://www.mfpud.com/topics/612/\n进入之后先选择磁盘工具 抹掉磁盘 安装即可\nOther 安装VMware Tools，参照https://www.lovyou.top/post/52.html\n调整MacOS屏幕分辨率参考https://blog.csdn.net/icarus666/article/details/79529766\n","permalink":"https://vcvvvc.github.io/post/vmware_install_macos/","tags":["Mac","Vmware"],"title":"vmware16pro unlock install macos"},{"categories":null,"contents":"Ubuntu20.04.1LTS 2020-01-14-Successful\nlib Install apt-get install -y build-essential pkg-config cmake apt-get install -y libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev Download github: git clone https://github.com/opencv/opencv.git gitee: git clone https://gitee.com/mirrors/opencv.git Install cd opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_GTK=ON -D OPENCV_GENERATE_PKGCONFIG=YES .. make -j4 make install Set echo \u0026#34;include /usr/loacal/lib\u0026#34; \u0026gt;\u0026gt; /etc/ld.so.conf ldconfig echo \u0026#34;PKG_CONFIG_PATH=\\$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig\u0026#34; \u0026gt;\u0026gt; /etc/bash.bashrc echo \u0026#34;export PKG_CONFIG_PATH\u0026#34; \u0026gt;\u0026gt; /etc/bash.bashrc Show version pkg-config --modversion opencv4 pkg-config --cflags opencv4 pkg-config --libs opencv4 ","permalink":"https://vcvvvc.github.io/post/ubuntu20_install_opencv/","tags":["Ubuntu","Opencv"],"title":"Ubuntu20 install opencv"},{"categories":null,"contents":"基本流程图 示范代码: https://github.com/vcvvvc/CPP_Test/tree/master/server/socket/practice/8_socket\nTCP UDP 客户角度 服务器角度 套接字选项 config_init connect_mysql init_socket setsockopt linger ","permalink":"https://vcvvvc.github.io/post/unp_note/","tags":["TCP/IP","Server","Linux","CPP"],"title":"Unp_Note"},{"categories":null,"contents":"pymysql.err.OperationalError: (1698, “Access denied for user ‘root’@‘localhost’”)\nsudo mysql -u root mysql\u0026gt; USE mysql; mysql\u0026gt; UPDATE user SET plugin=\u0026#39;mysql_native_password\u0026#39; WHERE User=\u0026#39;root\u0026#39;; mysql\u0026gt; FLUSH PRIVILEGES; mysql\u0026gt; exit; service mysql restart ","permalink":"https://vcvvvc.github.io/post/pymysql_err_1698/","tags":["Python","Mysql"],"title":"Pymysqlerr 1698"},{"categories":null,"contents":"字体 因为wine对HiDPI不会默认适配dpi值。解决方案:\n注意WINEPREFIX这个环境变量指向你的deepin wine容器目录，比如TIM在~/.deepinwine/Deepin-TIM，微信在~/.deepinwine/Deepin-WeChat 执行以下命令\nWINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine winecfg 打开wine设置页面，在显示选项卡中调整屏幕分辨率的dpi值即可。比如想实现win 10的150% DPI只需要将96改到144即可，125%放大则对应120。手工调整下合适的DPI就可以了\n对于中文乱码是空格的情况，安装中文字体解决\nsudo apt-get install fonts-droid-fallback ttf-wqy-zenhei ttf-wqy-microhei fonts-arphic-ukai fonts-arphic-uming ","permalink":"https://vcvvvc.github.io/post/ubuntu_tim_wechat/","tags":["Wine","Ubuntu"],"title":"Ubuntu tim_wechat"},{"categories":null,"contents":"ssize_t write(int fd, const void*buf,size_t nbytes);\nwrite函数将buf中的nbytes字节内容写入文件描述符fd.\n成功时返回写的字节数.失败时返回-1. 并设置errno变量. 在网络程序中,当我们向套接字文件描述符写时有两可能. 1)write的返回值大于0,表示写了部分或者是全部的数据. 这样我们用一个while循环来不停的写入，但是循环过程中的buf参数和nbyte参数得由我们来更新。也就是说，网络写函数是不负责将全部数据写完之后在返回的。 2)返回的值小于0,此时出现了错误.我们要根据错误类型来处理. 如果错误为EINTR表示在写的时候出现了中断错误. 如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接).\nssize_t read(int fd,void *buf,size_t nbyte)\nread函数是负责从fd中读取内容.\n当读成功 时,read返回实际所读的字节数,如果返回的值是0 表示已经读到文件的结束了,小于0表示出现了错误.如果错误为EINTR说明读是由中断引起 的, 如果是ECONNREST表示网络连接出了问题. 和上面一样,我们也写一个自己的读函数.\nrecv和send函数提供了和read和write差不多的功能.不过它们提供了第四个参数来控制读写操作.\nint recv(int sockfd,void *buf,int len,int flags) int send(int sockfd,void *buf,int len,int flags) 前面的三个参数和read, write一样,第四个参数可以是0或者是以下的组合\n标题 内容 MSG_DONTROUTE 不查找表 MSG_OOB 接受或者发送带外数据 MSG_PEEK 查看数据,并不从系统缓冲区移走数据 MSG_WAITALL 等待所有数据 MSG_DONTROUTE:是 send函数使用的标志.这个标志告诉IP.目的主机在本地网络上面,没有必要查找表.这个标志一般用网络诊断和路由程序里面. MSG_OOB:表示可以接收和发送带外的数据.关于带外数据我们以后会解释的.\nMSG_PEEK:是recv函数的使用标志, 表示只是从系统缓冲区中读取内容,而不清除系统缓冲区的内容.这样下次读的时候,仍然是一样的内容.一般在有多个进程读写数据时可以使用这个标志.\nMSG_WAITALL 是recv函数的使用标志,表示等到所有的信息到达时才返回.使用这个标志的时候recv回一直阻塞,直到指定的条件满足,或者是发生了错误. 1)当读到了指定的字节时,函数正常返回.返回值等于len 2)当读到了文件的结尾时,函数正常返回.返回值小于len 3)当操作发生错误时,返回-1,且设置错误为相应的错误号(errno)\nRe:\nhttps://blog.csdn.net/petershina/article/details/7946615\n","permalink":"https://vcvvvc.github.io/post/socket_write_send/","tags":["Linux","Socket","Send","Server"],"title":"Socket write_send"},{"categories":null,"contents":"import threading import time def worker(): print “worker” time.sleep(1) return for i in xrange(5): t = threading.Thread(target=worker) t.start() 这段代码就使用了多线程，但是没法传递参数，而实际使用多线程，往往是需要传递参数的，这么写实现传递参数的多线程：\nimport threading import time def worker(number): print “worker” time.sleep(number) return for i in xrange(5): t = threading.Thread(target=worker,args=(i,)) t.start() 第一个参数是线程函数变量，第二个参数args是一个数组变量参数，如果只传递一个值，就只需要i, 如果需要传递多个参数，那么还可以继续传递下去其他的参数，其中的逗号不能少，元组中只包含一个元素时，需要在元素后面添加逗号。\nRe:\nhttps://blog.csdn.net/chpllp/article/details/54381141\n","permalink":"https://vcvvvc.github.io/post/python_thread_mis/","tags":["Python","Thread"],"title":"Python thread parameter transfer"},{"categories":null,"contents":" font(字体类)：字号、字体颜色、下划线等 fill(填充类)：颜色等 border(边框类)：设置单元格边框 alignment(位置类)：对齐方式 number_format(格式类)：数据格式 protection(保护类)：写保护 \u0026gt;\u0026gt;\u0026gt; from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font \u0026gt;\u0026gt;\u0026gt; font = Font(name=\u0026#39;Calibri\u0026#39;, size=11, bold=False, italic=False, vertAlign=None, underline=\u0026#39;none\u0026#39;, strike=False, color=\u0026#39;FF000000\u0026#39;) \u0026gt;\u0026gt;\u0026gt; fill = PatternFill(fill_type=None, start_color=\u0026#39;FFFFFFFF\u0026#39;, end_color=\u0026#39;FF000000\u0026#39;) \u0026gt;\u0026gt;\u0026gt; border = Border(left=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;), right=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;), top=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;), bottom=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;), diagonal=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;), diagonal_direction=0, outline=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;), vertical=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;), horizontal=Side(border_style=None, color=\u0026#39;FF000000\u0026#39;) ) \u0026gt;\u0026gt;\u0026gt; alignment=Alignment(horizontal=\u0026#39;general\u0026#39;, vertical=\u0026#39;bottom\u0026#39;, text_rotation=0, wrap_text=False, shrink_to_fit=False, indent=0) \u0026gt;\u0026gt;\u0026gt; number_format = \u0026#39;General\u0026#39; \u0026gt;\u0026gt;\u0026gt; protection = Protection(locked=True, hidden=False) 以上几种样式（字体、填充、边框、位置和保护）实例一旦被创建实例的属性就不可更改，只能重新创建实例。\n对一个cell进行格式设置：\nws[\u0026#34;B5\u0026#34;].font = ft ws[\u0026#34;B5\u0026#34;].fill =fill ws[\u0026#34;B5\u0026#34;].border = bd ws[\u0026#34;B5\u0026#34;].alignment = alignment ws[\u0026#34;B5\u0026#34;].number_format = number_format ws[\u0026#34;B5\u0026#34;].value =\u0026#34;pynote.net\u0026#34; 编辑页面设置\nws.page_setup.orientation = ws.ORIENTATION_LANDSCAPE ws.page_setup.paperSize = ws.PAPERSIZE_TABLOID ws.page_setup.fitToHeight = 0 ws.page_setup.fitToWidth = 1 Re:\nhttps://blog.csdn.net/aishenghuomeidaoli/article/details/52165305\nhttps://www.pynote.net/archives/2229\n","permalink":"https://vcvvvc.github.io/post/opepyxl_sytle/","tags":["Python","Openpyxl"],"title":"Opepyxl sytle"},{"categories":null,"contents":"编译安装 #https://www.cnblogs.com/JoiT/p/build_from_source_for_linux_vim.html apt install libncurses5-dev libgtk2.0-dev libatk1.0-dev \\ libcairo2-dev libx11-dev libxpm-dev libxt-dev apt-get remove --purge vim-tiny vim vim-runtime gvim vim-common vim-gui-common vim-nox ./configure --with-features=huge \\ --enable-multibyte \\ --enable-gui=gtk3 \\ --enable-cscope \\ --prefix=/usr/local make make install 主题配置 首先要确认你的终端支持真彩，一般来说，主流的比如iTerm2, Putty, Powershell的最新版本都已经支持了。我们可以运行以下命令检测一下\n(echo -e '\\e[48:2:1:2:3m\\eP$qm\\e\\\\' ; xxd)\n\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;=\u0026gt;全局配置\u0026lt;=\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;关闭vi兼容模式\u0026#34; set nocompatible \u0026#34;设置历史记录步数\u0026#34; set history=1000 \u0026#34;开启相关插件\u0026#34; \u0026#34;侦测文件类型\u0026#34; filetype on \u0026#34;载入文件类型插件\u0026#34; filetype plugin on \u0026#34;为特定文件类型载入相关缩进文件\u0026#34; filetype indent on \u0026#34;当文件在外部被修改时，自动更新该文件\u0026#34; set autoread \u0026#34;激活鼠标的使用\u0026#34; set mouse=a set selection=exclusive set selectmode=mouse,key \u0026#34;保存全局变量\u0026#34; set viminfo+=! \u0026#34;带有如下符号的单词不要被换行分割\u0026#34; set iskeyword+=_,$,@,%,#,- \u0026#34;通过使用: commands命令，告诉我们文件的哪一行被改变过\u0026#34; set report=0 \u0026#34;被分割的窗口间显示空白，便于阅读\u0026#34; set fillchars=vert:\\ ,stl:\\ ,stlnc:\\ \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;=\u0026gt;字体和颜色\u0026lt;=\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;自动开启语法高亮\u0026#34; syntax enable \u0026#34;设置字体\u0026#34; \u0026#34;set guifont=dejaVu\\ Sans\\ MONO\\ 10 set guifont=Courier_New:h10:cANSI \u0026#34;设置颜色\u0026#34; \u0026#34;colorscheme desert \u0026#34;#set t_Co=256 记着注释或者删除这一行\u0026#34; if has(\u0026#34;termguicolors\u0026#34;) set termguicolors endif \u0026#34;高亮显示当前行\u0026#34; \u0026#34;set cursorline 白色条框 不喜欢可以关闭\u0026#34; set cursorline \u0026#34;hi cursorline guibg=#00ff00\u0026#34; \u0026#34;hi CursorColumn guibg=#00ff00\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;=\u0026gt;代码折叠功能\u0026lt;=\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;激活折叠功能\u0026#34; set foldenable \u0026#34;set nofen（这个是关闭折叠功能）\u0026#34; \u0026#34;设置按照语法方式折叠（可简写set fdm=XX）\u0026#34; \u0026#34;有6种折叠方法： \u0026#34;manual 手工定义折叠\u0026#34; \u0026#34;indent 更多的缩进表示更高级别的折叠\u0026#34; \u0026#34;expr 用表达式来定义折叠\u0026#34; \u0026#34;syntax 用语法高亮来定义折叠\u0026#34; \u0026#34;diff 对没有更改的文本进行折叠\u0026#34; \u0026#34;marker 对文中的标志进行折叠\u0026#34; set foldmethod=manual \u0026#34;set fdl=0（这个是不选用任何折叠方法）\u0026#34; \u0026#34;设置折叠区域的宽度\u0026#34; \u0026#34;如果不为0，则在屏幕左侧显示一个折叠标识列 \u0026#34;分别用“-”和“+”来表示打开和关闭的折叠 set foldcolumn=0 \u0026#34;设置折叠层数为3\u0026#34; setlocal foldlevel=3 \u0026#34;设置为自动关闭折叠\u0026#34; set foldclose=all \u0026#34;用空格键来代替zo和zc快捷键实现开关折叠\u0026#34; \u0026#34;zo O-pen a fold (打开折叠) \u0026#34;zc C-lose a fold (关闭折叠) \u0026#34;zf F-old creation (创建折叠) \u0026#34;nnoremap \u0026lt;space\u0026gt; @=((foldclosed(line(\u0026#39;.\u0026#39;)) \u0026lt; 0) ? \u0026#39;zc\u0026#39; : \u0026#39;zo\u0026#39;)\u0026lt;CR\u0026gt; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;=\u0026gt;文字处理\u0026lt;=\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;使用空格来替换Tab\u0026#34; set expandtab \u0026#34;设置所有的Tab和缩进为4个空格\u0026#34; set tabstop=4 \u0026#34;设定\u0026lt;\u0026lt;和\u0026gt;\u0026gt;命令移动时的宽度为4\u0026#34; set shiftwidth=4 \u0026#34;使得按退格键时可以一次删除4个空格\u0026#34; set softtabstop=4 set smarttab \u0026#34;缩进，自动缩进（继承前一行的缩进）\u0026#34; \u0026#34;set autoindent 命令打开自动缩进，是下面配置的缩写 \u0026#34;可使用autoindent命令的简写，即“:set ai”和“:set noai” \u0026#34;还可以使用“:set ai sw=4”在一个命令中打开缩进并设置缩进级别 set ai set cindent \u0026#34;智能缩进\u0026#34; set si \u0026#34;自动换行” set wrap \u0026#34;设置软宽度\u0026#34; set sw=4 \u0026#34;行内替换\u0026#34; set gdefault \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;=\u0026gt;Vim 界面\u0026lt;=\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;增强模式中的命令行自动完成操作\u0026#34; set wildmenu \u0026#34;显示标尺\u0026#34; set ruler \u0026#34;设置命令行的高度\u0026#34; set cmdheight=1 \u0026#34;显示行数\u0026#34; set nu \u0026#34;不要图形按钮\u0026#34; set go= \u0026#34;在执行宏命令时，不进行显示重绘；在宏命令执行完成后，一次性重绘，以便提高性能\u0026#34; set lz \u0026#34;使回格键（backspace）正常处理indent, eol, start等\u0026#34; set backspace=eol,start,indent \u0026#34;允许空格键和光标键跨越行边界\u0026#34; set whichwrap+=\u0026lt;,\u0026gt;,h,l \u0026#34;设置魔术\u0026#34; set magic \u0026#34;关闭遇到错误时的声音提示\u0026#34; \u0026#34;关闭错误信息响铃\u0026#34; set noerrorbells \u0026#34;关闭使用可视响铃代替呼叫\u0026#34; set novisualbell \u0026#34;高亮显示匹配的括号([{和}])\u0026#34; set showmatch \u0026#34;匹配括号高亮的时间（单位是十分之一秒）\u0026#34; set mat=2 \u0026#34;光标移动到buffer的顶部和底部时保持3行距离\u0026#34; set scrolloff=3 \u0026#34;搜索逐字符高亮\u0026#34; set hlsearch set incsearch \u0026#34;搜索时不区分大小写\u0026#34; \u0026#34;还可以使用简写（“:set ic”和“:set noic”）\u0026#34; set ignorecase \u0026#34;用浅色高亮显示当前行\u0026#34; autocmd InsertLeave * se nocul autocmd InsertEnter * se cul \u0026#34;输入的命令显示出来，看的清楚\u0026#34; set showcmd \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;=\u0026gt;编码设置\u0026lt;=\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;设置编码\u0026#34; set encoding=utf-8 set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936 \u0026#34;设置文件编码\u0026#34; set fileencodings=utf-8,gbk,latin1 \u0026#34;设置终端编码\u0026#34; set termencoding=utf-8 \u0026#34;设置语言编码\u0026#34; set langmenu=zh_CN.UTF-8 set helplang=cn \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;=\u0026gt;其他设置\u0026lt;=\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;开启新行时使用智能自动缩进\u0026#34; set smartindent set cin set showmatch \u0026#34;在处理未保存或只读文件的时候，弹出确认\u0026#34; set confirm \u0026#34;隐藏工具栏\u0026#34; set guioptions-=T \u0026#34;隐藏菜单栏\u0026#34; set guioptions-=m \u0026#34;置空错误铃声的终端代码\u0026#34; set vb t_vb= \u0026#34;显示状态栏（默认值为1，表示无法显示状态栏）\u0026#34; set laststatus=2 \u0026#34;状态行显示的内容\u0026#34; set statusline=%F%m%r%h%w\\ [FORMAT=%{\u0026amp;ff}]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %{strftime(\\\u0026#34;%d/%m/%y\\ -\\ %H:%M\\\u0026#34;)} \u0026#34;粘贴不换行问题的解决方法\u0026#34; set pastetoggle=\u0026lt;F9\u0026gt; \u0026#34;设置背景颜色\u0026#34; set background=dark \u0026#34;文件类型自动检测，代码智能补全\u0026#34; set completeopt=longest,preview,menu \u0026#34;共享剪切板\u0026#34; set clipboard+=unnamed \u0026#34;从不备份\u0026#34; set nobackup set noswapfile \u0026#34;自动保存\u0026#34; set autowrite \u0026#34;显示中文帮助\u0026#34; if version \u0026gt;= 603 set helplang=cn set encoding=utf-8 endif \u0026#34;设置高亮相关项\u0026#34; highlight Search ctermbg=black ctermfg=white guifg=white guibg=black ","permalink":"https://vcvvvc.github.io/post/vim_config/","tags":["CPP","Vim","Linux"],"title":"Vim_config"},{"categories":null,"contents":"const 作用\n修饰变量，变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026amp;a; // 指针变量，指向常对象 const A \u0026amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = \u0026#34;Hello\u0026#34;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); const 的指针与引用 指针 指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer） 引用 指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer 用法小结 指针\nconst int * pOne; //指向整形常量的指针，它指向的值不能修改(指针变量，指向字符数组常量) int * const pTwo; //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改(自身是常量的指针，指向字符数组变量) const int *const pThree; //指向整形常量的常量指针 。它既不能再指向别的常量，指向的值也不能修改(自身是常量的指针，指向字符数组常量) 类定义、类成员\n// 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026amp;a; // 指针变量，指向常对象 const A \u0026amp;q = a; // 指向常对象的引用 类成员函数\nint getValue() const; //该函数为只读函数，不允许修改其中的数据成员的值。 const int getValue(); //修饰的是返回值，表示返回的是指针所指向值是常量。 引用\nint \u0026amp;a = 20; //错误 字面常量是右值 const int \u0026amp;c = b; # 常量左值引用绑定到非常量左值，编译通过 const int \u0026amp;e = c; # 常量左值引用绑定到常量左值，编译通过 const int \u0026amp;b =2; # 常量左值引用绑定到右值，编程通过 void s1(const \u0026amp;ra) //ra不可改变 ","permalink":"https://vcvvvc.github.io/post/cppconst/","tags":["CPP","Const","Pointer"],"title":"CPP_Const"},{"categories":null,"contents":"什么是C/S和B/S架构？\nC/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。\nB/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。\n第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。\n第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。\n优点/缺点 C/S架构的优点\na. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。\nb. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。\nc. 客户端直接操作界面。\nC/S架构的缺点\na\u0026gt; C/S架构适用于局域网，对网速的要求比较高。\nb\u0026gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。\nc\u0026gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。\nd\u0026gt; 系统的维护也比较麻烦。\nB/S架构的优点 a\u0026gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。\nb\u0026gt; 浏览器只处理一些简单的逻辑事务，负担小。\nc\u0026gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。\nd\u0026gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。\ne\u0026gt; B/S建立在广域网上，所以需要的网速要求不高。\nf\u0026gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。\ng\u0026gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。\nB/S架构的缺点 a\u0026gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。\nb\u0026gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。\n第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。 https://blog.csdn.net/qq_42828949/article/details/82822901\nhttps://blog.csdn.net/zhengqijun_/article/details/53056624\n","permalink":"https://vcvvvc.github.io/post/cs_bs/","tags":["Linux","TCP"],"title":"C/S_B/S 架构"},{"categories":null,"contents":"O(1)常数阶 \u0026lt; O(logn)对数阶 \u0026lt; O(n)线性阶 \u0026lt; O(n^2)平方阶 \u0026lt; O(n^3)(立方阶) \u0026lt; O(2^n) (指数阶)\nFor O(n) int function1(int x, int n) { int result = 1; // 注意 任何数的0次方等于1 for (int i = 0; i \u0026lt; n; i++) { result = result * x; } return result; } Recursion O(n) int function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } Recursion2 O(n) int function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n/2) * function3(x, n/2)*x; } return function3(x, n/2) * function3(x, n/2); } Recursion3 O(logn) int function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n/2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t*t*x; } return t*t; } ","permalink":"https://vcvvvc.github.io/post/recursion/","tags":["Algorithm","CPP","Recursion"],"title":"Algorithm x^n"},{"categories":null,"contents":"int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)\n其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构 pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用， 默认值是PTHREAD_ PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。\n注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_destroy（pthread_cond_t cond）。\n也可以静态的初始化条件变量\npthread_cond_t my_condition = PTHREAD_COND_INITIALIZER; pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr); // 初始化锁变量mutex。 // attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t *mutex); // 加锁（阻塞操作） pthread_mutex_trylock(pthread_mutex_t *mutex); // 试图加锁（不阻塞操作） // 当互斥锁空闲时将占有该锁；否则立即返回 // 但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t *mutex); 销毁一个不再需要的互斥量，释放系统资源。 pthread_cond_wait() / pthread_cond_timedwait -----等待条件变量，挂起线程，区别是后者，会有timeout时间， 如果到了timeout,线程自动解除阻塞，这个时间和 time()系统调用相同意义的。以1970年时间算起。 pthread_cond_signal ----激活等待列表中的线程， pthread_cond_broadcast() -------激活所有等待线程列表中最先入队的线程 条件变量\n条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：\n1）一个线程等待\u0026quot;条件变量的条件成立\u0026quot;而挂起； 2）另一个线程使\u0026quot;条件成立\u0026quot;（给出条件成立信号）。 为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。\n注意：\n1）上面这几个函数都是原子操作，可以为理解为一条指令，不会被其他程序打断\n2）上面这个几个函数，必须配合使用。\n3）pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，继续执行pthread_cond_wait\n返回值:\npthread_mutex_lock() 和 pthread_mutex_unlock() 返回0，否则返回一个错误的提示码\npthread_mutex_trylock() 在成功获得了一个mutex的锁后返回0，否则返回一个错误提示码错误\npthread_mutex_lock() 和 pthread_mutex_unlock()失败的时候 [EINVAL] mutex在生成的时候，它的protocol属性的值是 PTHREAD_PRIO_PROTECT，同时调用线程的优先级(priority)比该mutex的当前prority上限高\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);\n第一个参数为指向线程标识符的指针。 第二个参数用来设置线程属性。 第三个参数是线程运行函数的起始地址。 最后一个参数是运行函数的参数。 https://blog.csdn.net/weibo1230123/article/details/81410241\nint pthread_join(pthread_t thread, void **retval); 子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。\nthread: 需要等待的线程,指定的线程必须位于当前的进程中，而且不得是分离线程\nretval: 线程tid所执行的函数返回值（返回值地址需要保证有效），其中status可以为NULL\nint pthread_detach(pthread_t tid);\n主线程与子线程分离，子线程结束后，资源自动回收。 其他操作 #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_init(pthread_condattr_t* attr); int pthread_condattr_destroy(pthread_condattr_t* attr); //返回值：成功返回0；失败返回错误编码 pthread_condattr_init\n功能：对条件变量属性结构体初始化 调用此函数之后，条件变量属性结构体的属性都是系统默认值，如果想要设置其他属性，还需要调用不同的函数进行设置 pthread_condattr_destroy\n功能：对条件变量属性结构体反初始化（销毁） 只反初始化，不释放内存 #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setshared(pthread_condattr_t* attr,int pshared); int pthread_condattr_getshared(const pthread_condattr_t* restrict attr,int* restrict pshared); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setshared\n功能：设置条件变量的进程共享属性 pthread_condattr_getshared\n功能：获取条件变量的进程共享属性 #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setclock(pthread_condattr_t* attr,clockid_t clock_id); int pthread_condattr_getclock(const pthread_condattr_t* restrict attr,clockid_t *restrict clock_id); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setclock\n功能：此函数用于设置pthread_cond_timewait函数使用的时钟ID pthread_condattr_getclock\n功能：此函数获取可被用于pthread_cond_timedwait函数的时钟ID。pthread_cond_timedwait函数使用前需要用pthread_condattr_t对条件变量进行初始化 Linux 线程库版本\ngetconf GNU_LIBPTHREAD_VERSION\npthread_create 创建一个线程\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 线程结束\nvoid pthread_exit(void *retval);\n线程回收\nint pthread_join(pthread_t thread, void **retval);\n取消线程\nint pthread_cancel(pthread_t thread);\n目标线程可以设置是否允许被取消以及如何取消\nint pthread_setcancelstate(int state, int *oldstate); int pthread_setcanceltype(int type, int *oldtype); 初始化线程属性对象\nint pthread_attr_init(pthread_attr_t *attr);\n销毁线程属性对象, 被销毁的线程属性对象只有再次初始化之后才能继续使用\nint pthread_attr_destroy(pthread_attr_t *attr);\nPOSIX信号量函数\n//初始化一个未命名的信号量 int sem_init(sem_t *sem, int pshared, unsigned int value); 其中sem是要初始化的信号量，pshared表示此信号量是在进程间共享还是线程间共享，value是信号量的初始值。 //用于销毁信号量 int sem_destroy(sem_t *sem); 其中sem是要销毁的信号量。只有用sem_init初始化的信号量才能用sem_destroy销毁。 等待信号量，如果信号量的值大于0,将信号量的值减1,立即返回。如果信号量的值为0,则线程阻塞。相当于P操作。成功返回0,失败返回-1。 //以原子操作的方式将信号量值减1 int sem_wait(sem_t *sem); //始终立即返回,不论被操作的信号是否有非0值 int sem_trywait(sem_t *sem); //以原子操作的方式将信号量的值加1 信号量大于0时 其他正在调用sem_wait等待信号量的线程将被唤醒** int sem_post(sem_t *sem); 释放信号量，让信号量的值加1。相当于V操作。 互斥锁 //初始化互斥锁 int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); //用于销毁互斥锁 int pthread_mutex_destroy(pthread_mutex_t *mutex); //以原子操作的方式给一个互斥锁加锁 int pthread_mutex_lock(pthread_mutex_t * mutex); //立即返回 不论被操作的互斥锁是否已经被加锁 int pthread_mutex_trylock(pthread_mutex_t * mutex); //以原子操作的方式给一个互斥锁解锁 int pthread_mutex_unlock(pthread_mutex_t * mutex); 互斥锁属性 // 初始化互斥锁属性对象 int pthread_mutexattr_init(pthread_mutexattr_t *attr); //销毁互斥锁属性对象 int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); //获取和设置互斥锁的pshared属性 int pthread_mutexattr_getpshared(const pthread_mutexttr_t * attr, int * pshred); int pthread_mutexattr_setpshared(pthread_mutex_attr_t * attr, int pshared); //获取和设置互斥锁的type属性 int pthread_mutexattr_gettype(const pthread_mutexattr_t * attr, int * type); int pthread_mutexattr_settype(pthread_mutexattr_t * attr, int type); //确保fork调用后父进程和子进程都拥有一个清楚的锁状态 int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); //1. 在主线程创建出其他子线程之前就调用 pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样做之后，实际上所有线程都不会响应被屏蔽的信号了。 //设置线程信号掩码 int pthread_sigmask(int how, const sigset_t * restrict set, sigset_t * restrict oset); //2. 在某个线程中调用如下函数来等待信号并处理之∶ int sigwait(const sigset_t *restrict set, int *restrict sig); 条件变量 //初始化条件变量 int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr); //销毁条件变量 int pthread_cond_destroy(pthread_cond_t *cv); //以广播方式唤醒所有等待目标条件变量的线程 int pthread_cond_broadcast(pthread_cond_t *cv); //释放被阻塞在指定条件变量上的一个线程 int pthread_cond_signal(pthread_cond_t * cond); //等待目标条件变量 int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex); 进程池和线程池 Reference: https://blog.csdn.net/qq_41453285/article/details/90904870\nhttps://blog.csdn.net/liangxanhai/article/details/7767430\nhttps://blog.csdn.net/wushuomin/article/details/80051295\nhttps://blog.csdn.net/lovecodeless/article/details/24885127\nhttps://blog.csdn.net/weibo1230123/article/details/81410241\n","permalink":"https://vcvvvc.github.io/post/pthread/","tags":["Linux","Pthread","CPP"],"title":"Linux Pthread"},{"categories":null,"contents":"class derived-class: access-specifier base-class\nclass Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; Rectangle rect; rect.setWidth(3); rect.setHeight(5); #rect result = 15 cout \u0026lt;\u0026lt; rect.getArea() \u0026lt;\u0026lt; endl; 访问控制和继承\n访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 ","permalink":"https://vcvvvc.github.io/post/cpp_inherit/","tags":["CPP"],"title":"Cpp_inherit"},{"categories":null,"contents":" Mysql ex mysql_init() 获取或初始化MYSQL结构 mysql_real_connect() 连接到MySQL服务器。 mysql_query() 执行指定为“以Null终结的字符串”的SQL查询 mysql_use_result() 初始化逐行的结果集检索 mysql_field_count() 返回上次执行语句的结果集的列数 mysql_fetch_row() 从结果集中获取下一行 mysql_num_fields() 返回结果集中的字段数 class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; }; 基本步骤\n使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接 Re:\nhttps://blog.csdn.net/lisonglisonglisong/article/details/25071793\n","permalink":"https://vcvvvc.github.io/post/mysql_use/","tags":["Mysql","CPP","Linux"],"title":"CPP_Mysql_use"},{"categories":null,"contents":"Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo\n[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc Install Mongodb sudo yum install -y mongodb-org Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use Re:\nhttps://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n","permalink":"https://vcvvvc.github.io/post/install_mongodb/","tags":["Linux","Mongodb"],"title":"Centos7 Install mongodb"},{"categories":null,"contents":"升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo \u0026#34;source /opt/rh/devtoolset-9/enable\u0026#34; \u0026gt;\u0026gt; /etc/profile gcc -v 安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis 配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf\ndaemonize no 改为 daemonize yes 开机自启 vim /etc/systemd/system/redis.service\n[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.service systemctl enable redis.service Re:\nhttps://blog.csdn.net/wanTN/article/details/108502856\n","permalink":"https://vcvvvc.github.io/post/install_redis/","tags":["Linux","Redis"],"title":"Centos7 Install_redis"},{"categories":null,"contents":"1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled\n3.安装Mysql5.7 sudo yum -y install mysql-community-server\n4.启动Mysql sudo systemctl start mysqld\n5.设置系统启动时自动启动 sudo systemctl enable mysqld\n6.查看启动状态 sudo systemctl status mysqld\n7.root 密码 cat /var/log/mysqld.log | grep -i 'temporary password'\n8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等\nmysql_secure_installation\n9.设置数据库编码为utf8 sudo vim /etc/my.cnf\n[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect=\u0026#39;SET NAMES utf8\u0026#39; character-set-server = utf8 reboot sudo systemctl restart mysqld\nRe:\nhttps://juejin.im/post/6844903732145045517\n","permalink":"https://vcvvvc.github.io/post/install_mysql/","tags":["Mysql","Linux"],"title":"Centos7 Install mysql"},{"categories":null,"contents":"创建数据库 CREATE DATABASE IF NOT EXISTS vctest DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. CREATE DATABASE IF NOT EXISTS mytestdb;\n删除数据库 drop database test1; 2. DROP DATABASE IF EXISTS mytestdb;\n查看All DB show databases;\n导入sql source test.sql\nselect\nuse vctest select city, phone, country from `offices`; SELECT语句由以下列表中所述的几个子句组成：\n语句中的SELECT和FROM语句是必须的，其他部分是可选的。\nSELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。 即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。\nSELECT lastname, firstname, jobtitle FROM employees WHERE jobtitle = \u0026#39;Sales Rep\u0026#39;; INSERT 创建表\nCREATE TABLE [IF NOT EXISTS] table_name( column_list ) engine=table_type; CREATE TABLE IF NOT EXISTS user ( uid INT(11) AUTO_INCREMENT, username VARCHAR(45) NOT NULL, registration_time DATE DEFAULT NULL, PRIMARY KEY(uid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 首先，指定要在CREATE TABLE子句之后创建的表的名称。表名在数据库中必须是唯一的。 IF NOT EXISTS是语句的可选部分，允许您检查正在创建的表是否已存在于数据库中。 如果是这种情况，MySQL将忽略整个语句，不会创建任何新的表。 强烈建议在每个CREATE TABLE语句中使用IF NOT EXISTS来防止创建已存在的新表而产生错误。 其次，在column_list部分指定表的列表。字段的列用逗号(，)分隔。我们将在下一节中向您展示如何更详细地列(字段)定义。 第三，需要为engine子句中的表指定存储引擎。可以使用任何存储引擎，如：InnoDB，MyISAM，HEAP，EXAMPLE，CSV，ARCHIVE，MERGE， FEDERATED或NDBCLUSTER。如果不明确声明存储引擎，MySQL将默认使用InnoDB。 查看表的列属性\n1. show columns from user; 2. desc user; ALTER TABLE语句来设置列的自动递增属性\nALTER TABLE tasks CHANGE COLUMN task_id task_id INT(11) NOT NULL AUTO_INCREMENT; 添加新列\nALTER TABLE vendors ADD COLUMN phone VARCHAR(15) AFTER name; ALTER TABLE tasks ADD COLUMN complete DECIMAL(2,1) NULL AFTER description; 修改列的属性\n原来表dictionary的一列enword的属性为VARCHAR(32),修改为VARCHAR(64) NOT NULL. ALTER TABLE table_name MODIFY COLUMN column_name VARCHAR(64) NOT NULL; 删除列\nALTER TABLE tasks DROP COLUMN description; 重命名表\nALTER TABLE tasks RENAME TO work_items; 2. RENAME TABLE old_table_name TO new_table_name; 插入数据\nINSERT INTO tasks(subject,start_date,end_date,description) //插入到tasks表中 VALUES(\u0026#39;Learn MySQL INSERT\u0026#39;,\u0026#39;2017-07-21\u0026#39;,\u0026#39;2017-07-22\u0026#39;,\u0026#39;Start learning..\u0026#39;); 插入多行\nINSERT INTO table(column1,column2...) VALUES (value1,value2,...), (value1,value2,...), (value1, value2,...); 插入日期出错\n#https://blog.csdn.net/weixin_50518271/article/details/113761164 select @@SQL_MODE SET @@SQL_MODE = REPLACE(@@SQL_MODE, \u0026#39;NO_ZERO_DATE\u0026#39;, \u0026#39;\u0026#39;); 复制表结构\nCREATE TABLE tasks_bak LIKE tasks; INSERT INTO tasks_bak SELECT * FROM tasks; MySQL INSERT与ON DUPLICATE KEY UPDATE\nINSERT INTO tasks(task_id,subject,start_date,end_date,description) VALUES (4,\u0026#39;Test ON DUPLICATE KEY UPDATE\u0026#39;,\u0026#39;2017-01-01\u0026#39;,\u0026#39;2017-01-02\u0026#39;,\u0026#39;Next Priority\u0026#39;) ON DUPLICATE KEY UPDATE task_id = task_id + 1, subject = \u0026#39;Test ON DUPLICATE KEY UPDATE\u0026#39;; 等同于UPDATE语句\nUPDATE tasks SET task_id = task_id + 1, subject = \u0026#39;Test ON DUPLICATE KEY UPDATE\u0026#39; WHERE task_id = 4; UPDATE\nUPDATE employees SET lastname = \u0026#39;NKS\u0026#39;, email = \u0026#39;mary.new@yiibai.com\u0026#39; WHERE employeeNumber = 1056; 随机选择一个职位是Sales Rep的员工\nSELECT employeeNumber FROM employees WHERE jobtitle = \u0026#39;Sales Rep\u0026#39; ORDER BY RAND() LIMIT 1; 需要更新customers表中的销售代表员工编号(employeeNumber)列\nUPDATE customers SET salesRepEmployeeNumber = (SELECT employeeNumber FROM employees WHERE jobtitle = \u0026#39;Sales Rep\u0026#39; LIMIT 1) WHERE salesRepEmployeeNumber IS NULL; 备份数据库\nhttps://www.yiibai.com/mysql/how-to-backup-database-using-mysqldump.html\nDELETE\n删除表 DROP TABLE IF EXISTS tasks;\n删除指定条件\nDELETE FROM employees WHERE officeCode = 4; 删除表中所有行 delete from employees;\n删除指定行数\nDELETE FROM customers ORDER BY customerName LIMIT 10; //10行 删除五个法国客户\nDELETE FROM customers WHERE country = \u0026#39;France\u0026#39; ORDER BY creditLimit LIMIT 5; 创建函数\nDELIMITER // CREATE PROCEDURE get_employee(IN p_id INT) begin SELECT first_name ,last_name ,dept_name FROM employees INNER JOIN departments using (department_id) WHERE id = p_id; END; // DELIMITER; 运行 CALL get_employee(1);\nMysql技巧 https://www.yiibai.com/mysql/mysqltips.html\nMySQL存储过程 https://www.yiibai.com/mysql/stored-procedure.html\nRe:\nhttps://www.yiibai.com/mysql\nhttps://stackoverflow.com/questions/3401982/error-with-mysql-procedures-error-1304-error-1305\nhttps://blog.csdn.net/yuxin6866/article/details/52722913\n","permalink":"https://vcvvvc.github.io/post/mysqluse/","tags":["Mysql","Linux"],"title":"Mysql_use"},{"categories":null,"contents":"形参（形式参数）\n在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。\n实参（实际参数）\n函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。\n形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。\nRe: http://c.biancheng.net/view/1853.html 左值和右值\nhttp://c.biancheng.net/view/1510.html\n常量和变量\nhttps://www.runoob.com/cprogramming/c-variables.html\nhttps://www.runoob.com/cprogramming/c-constants.html\nhttp://c.biancheng.net/cpp/html/19.html\n","permalink":"https://vcvvvc.github.io/post/leftright/","tags":["CPP"],"title":"Left_Right"},{"categories":null,"contents":"https://zhuanlan.zhihu.com/p/33074506\nhttps://www.runoob.com/w3cnote/c-volatile-keyword.html\n","permalink":"https://vcvvvc.github.io/post/volatile/","tags":["CPP","Volatile"],"title":"About function: Volatile"},{"categories":null,"contents":"struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。\n但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：\nstruct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息\nsin_family指代协议族，在socket编程中只能是AF_INET\nsin_port存储端口号（使用网络字节顺序）\nsin_addr存储IP地址，使用in_addr这个数据结构\nstruct in_addr { unsigned long s_addr; }; 这个数据结构是由于历史原因保留下来的，主要用作与以前的格式兼容。\ns_addr按照网络字节顺序存储IP地址\nsin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节\n设置地址信息的示例：\nstruct sockaddr_in sa; sa.sin_family = AF_INET; sa.sin_port = htons(3490); /* short, NBO*/ sa.sin_addr.s_addr = inet_addr(\u0026#34;132.241.5.10\u0026#34;); bzero(\u0026amp;(sa.sin_zero), 8); 注意：如果sa.sin_addr.s_addr ＝ INADDR_ANY，则不指定IP地址（用于Server程序）\n","permalink":"https://vcvvvc.github.io/post/socket_struct/","tags":["Sokcet","Linux","CPP"],"title":"Socket struct"},{"categories":null,"contents":"socket编程中需要用到的头文件\nsys/types.h：数据类型定义\nsys/socket.h：提供socket函数及数据结构\nnetinet/in.h：定义数据结构sockaddr_in\narpa/inet.h：提供IP地址转换函数\nnetdb.h：提供设置及获取域名的函数\nsys/ioctl.h：提供对I/O控制的函数\nsys/poll.h：提供socket等待测试机制的函数\n其他在网络程序中常见的头文件\nunistd.h：提供通用的文件、目录、程序及进程操作的函数\nerrno.h：提供错误号errno的定义，用于错误处理\nfcntl.h：提供对文件控制的函数\ntime.h：提供有关时间的函数\ncrypt.h：提供使用DES加密算法的加密函数\npwd.h：提供对/etc/passwd文件访问的函数\nshadow.h：提供对/etc/shadow文件访问的函数\npthread.h：提供多线程操作的函数\nsignal.h：提供对信号操作的函数\nsys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数\n建议：在编写网络程序时，可以直接使用下面这段头文件代码\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; 涉及到用户权限及密码验证问题时加入如下语句：\n#include \u0026lt;shadow.h\u0026gt; #include \u0026lt;crypt.h\u0026gt; #include \u0026lt;pwd.h\u0026gt; 需要注意的是，应该在编译时链接加密算法库，即增加编译选项：-lcrypt\n涉及到文件及时间操作加入如下语句\n#include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;utime.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/file.h\u0026gt; 涉及到多进程操作时加入如下语句\n#include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;signal.h\u0026gt; 涉及到多线程操作时加入如下语句\n#include \u0026lt;pthread.h\u0026gt; #include \u0026lt;sys/poll.h\u0026gt; 需要注意的是，应该在编译时链接线程库，即增加编译选项：-lthread\n","permalink":"https://vcvvvc.github.io/post/socket_file/","tags":["Socket","Linux","CPP","Server"],"title":"Socket file"},{"categories":null,"contents":"class exception{ public: exception () throw(); //构造函数 exception (const exception\u0026amp;) throw(); //拷贝构造函数 exception\u0026amp; operator= (const exception\u0026amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。\nexception 类的继承层次: exception 类 直接派生类\nexceptopn explain login_error logic error runtime_error 运行时错误 bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常 bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常 bad_cast 使用 dynamic_cast 转换失败时抛出的异常 ios_base::failure io 过程中出现的异常 bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型 logic_error 的派生类\n异常名称 说明 length_error 试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作 domain_error 参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数 out_of_range 超出有效范围 invalid_argument 参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常 runtime_error 的派生类\n异常名称 说明 range_error 计算结果超出了有意义的值域范围 overflow_error 算术计算上溢 underflow_error 算术计算下溢 Re:\nhttp://c.biancheng.net/cpp/biancheng/view/3028.html\n","permalink":"https://vcvvvc.github.io/post/cpp_exception/","tags":["CPP","Linux","exception"],"title":"Cpp exception class"},{"categories":null,"contents":"获取Backtrace #include \u0026lt;execinfo.h\u0026gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file. */ void backtrace_symbols_fd(void *const *array, int size, int fd); int backtrace(void **buffer,int size)\n该函数用与获取当前线程的调用堆栈,获取的信息将会被存放在buffer中,它是一个指针数组。参数 size 用来指定buffer中可以保存多少个void* 元素。函数返回值是实际获取的指针个数,最大不超过size大小在buffer中的指针实际是从堆栈中获取的返回地址,每一个堆栈框架有一个返回地址。\n注意某些编译器的优化选项对获取正确的调用堆栈有干扰,另外内联函数没有堆栈框架;删除框架指针也会使无法正确解析堆栈内容\nchar ** backtrace_symbols (void *const *buffer, int size)\nbacktrace_symbols将从backtrace函数获取的信息转化为一个字符串数组. 参数buffer应该是从backtrace函数获取的数组指针,size是该数组中的元素个数(backtrace的返回值)，函数返回值是一个指向字符串数组的指针,它的大小同buffer相同.每个字符串包含了一个相对于buffer中对应元素的可打印信息.它包括函数名，函数的偏移地址,和实际的返回地址\nvoid backtrace_symbols_fd (void *const *buffer, int size, int fd)\nbacktrace_symbols_fd与backtrace_symbols 函数具有相同的功能,不同的是它不会给调用者返回字符串数组,而是将结果写入文件描述符为fd的文件中,每个函数对应一行.它不需要调用malloc函数,因此适用于有可能调用该函数会失败的情况。\n使用它们的时候有一下几点需要我们注意的地方：\nbacktrace的实现依赖于栈指针（fp寄存器），在gcc编译过程中任何非零的优化等级（-On参数）或加入了栈指针优化参数-fomit-frame-pointer后多将不能正确得到程序栈信息；\nbacktrace_symbols的实现需要符号名称的支持，在gcc编译过程中需要加入-rdynamic参数；\n内联函数没有栈帧，它在编译过程中被展开在调用的位置；\n尾调用优化（Tail-call Optimization）将复用当前函数栈，而不再生成新的函数栈，这将导致栈信息不能正确被获取。\nRe:\nhttps://blog.csdn.net/jxgz_leo/article/details/53458366\nhttps://www.cnblogs.com/mickole/p/3246702.html\n","permalink":"https://vcvvvc.github.io/post/backtrace/","tags":["Linux","CPP","Backtrace"],"title":"Linux cpp put Backtrace"},{"categories":null,"contents":"#include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string str = \u0026#34;Hello\u0026#34;; std::vector\u0026lt;std::string\u0026gt; v; //调用常规的拷贝构造函数，新建字符数组，拷贝数据 v.push_back(str); std::cout \u0026lt;\u0026lt; \u0026#34;After copy, str is \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; //调用移动构造函数，掏空str，掏空后，最好不要使用str v.push_back(std::move(str)); std::cout \u0026lt;\u0026lt; \u0026#34;After move, str is \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;The contents of the vector are \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;, \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\\n\u0026#34;; } Cout:\nAfter copy, str is \u0026#34;Hello\u0026#34; After move, str is \u0026#34;\u0026#34; The contents of the vector are \u0026#34;Hello\u0026#34;, \u0026#34;Hello\u0026#34; 函数原型 template \u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; t) { return static_cast\u0026lt;typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(t); } 原型定义中的原理实现: 公式一）X\u0026amp; \u0026amp;、X\u0026amp;\u0026amp; \u0026amp;、X\u0026amp; \u0026amp;\u0026amp;都折叠成X\u0026amp;，用于处理左值\nstring s(\u0026#34;hello\u0026#34;); std::move(s) =\u0026gt; std::move(string\u0026amp; \u0026amp;\u0026amp;) =\u0026gt; 折叠后 std::move(string\u0026amp; ) 此时：T的类型为string\u0026amp; typename remove_reference\u0026lt;T\u0026gt;::type为string 整个std::move被实例化如下 string\u0026amp;\u0026amp; move(string\u0026amp; t) //t为左值，移动后不能在使用t { //通过static_cast将string\u0026amp;强制转换为string\u0026amp;\u0026amp; return static_cast\u0026lt;string\u0026amp;\u0026amp;\u0026gt;(t); } 公式二）X\u0026amp;\u0026amp; \u0026amp;\u0026amp;折叠成X\u0026amp;\u0026amp;，用于处理右值\nstd::move(string(\u0026#34;hello\u0026#34;)) =\u0026gt; std::move(string\u0026amp;\u0026amp;) //此时：T的类型为string // remove_reference\u0026lt;T\u0026gt;::type为string //整个std::move被实例如下 string\u0026amp;\u0026amp; move(string\u0026amp;\u0026amp; t) //t为右值 { return static_cast\u0026lt;string\u0026amp;\u0026amp;\u0026gt;(t); //返回一个右值引用 } 右值经过T\u0026amp;\u0026amp;传递类型保持不变还是右值，而左值经过T\u0026amp;\u0026amp;变为普通的左值引用.\n②.对于static_cast\u0026lt;\u0026gt;的使用注意：任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。\ndouble d = 1; void* p = \u0026amp;d; double *dp = static_cast\u0026lt;double*\u0026gt; p; //正确 const char *cp = \u0026#34;hello\u0026#34;; char *q = static_cast\u0026lt;char*\u0026gt;(cp); //错误：static不能去掉const性质 static_cast\u0026lt;string\u0026gt;(cp); //正确 ③对于remove_reference是通过类模板的部分特例化进行实现的\n//原始的，最通用的版本 template \u0026lt;typename T\u0026gt; struct remove_reference{ typedef T type; //定义T的类型别名为type }; //部分版本特例化，将用于左值引用和右值引用 template \u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; //左值引用 { typedef T type; } template \u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; //右值引用 { typedef T type; } //举例如下,下列定义的a、b、c三个变量都是int类型 int i; remove_refrence\u0026lt;decltype(42)\u0026gt;::type a; //使用原版本， remove_refrence\u0026lt;decltype(i)\u0026gt;::type b; //左值引用特例版本 remove_refrence\u0026lt;decltype(std::move(i))\u0026gt;::type b; //右值引用特例版本 总结： std::move实现，首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过T\u0026amp;\u0026amp;传递类型保持不变还是右值，而左值经过T\u0026amp;\u0026amp;变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。\n然后我们通过static_cast\u0026lt;\u0026gt;进行强制类型转换返回T\u0026amp;\u0026amp;右值引用，而static_cast之所以能使用类型转换，是通过remove_refrence::type模板移除T\u0026amp;\u0026amp;，T\u0026amp;的引用，获取具体类型T。\nRe https://blog.csdn.net/p942005405/article/details/84644069\n","permalink":"https://vcvvvc.github.io/post/move/","tags":["CPP","Liux","move"],"title":"Cpp11 move"},{"categories":null,"contents":"create_thread Ex 1.导入#include\u0026mdash;用于创建线程\n2.导入#include\u0026ndash;用于时间延时 获取时间之类的\n定义一个线程对象t1，这就自动创建了一个线程，参数就是你要线程去执行的函数，t1是变量名字 随便取\nstd::thread t1(func);\n下面这里返回一个毫秒级别的时间间隔参数值，间隔10毫秒\nstd::chrono::milliseconds(10) this_thread::sleep_for（）就是让此线程休眠，可以传入休眠的时间 this_thread::sleep_for(std::chrono::milliseconds(10));让本线程休眠10毫秒 thread4\njoin()就是阻塞线程 阻塞的目的就是让Main主线程等待一下创建的线程，免得我函数还在跑，程序就直接结束了。 detach()将线程与线程对象分离 thread5\nc++11还提供了一个lock_guard类，它利用了RAII机制可以保证安全释放mutex。\n在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。\n在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。\nlock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；\n而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。\nthread6\nc++11还提供了std::unique_lock\n类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 unique_lock比lock_guard使用更加灵活，功能更加强大。 使用unique_lock需要付出更多的时间、性能成本。 thread7\n互斥量很像的条件变量的知识\n条件变量std::condition_variable的使用 std::condition_variable 是为了解决死锁而生的。 当互斥操作不够用而引入的。\n比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。\nstd::condition_variable:\nnotify_one()用于唤醒一个线程； notify_all() 则是通知所有线程。 C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。\nthread8\n原子变量的使用\n在新标准C++11，引入了原子操作的概念，原子操作更接近内核，并通过这个新的头文件提供了多种原子操作数据类型.\n例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。\nthread9\nfuture与promise的使用\n在c++11中增加的线程库很方便的让我们去使用线程，但是因为做出了一些改变，我们并不能像往常一样直接使用thread.join()获取线程函数的返回值了，而我们有时候又确实要利用线程函数的返回值。\nthread库提供了future用来访问异步操作的结果，因为一个异步操作的结果往往不能立即获取，只能在未来的某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future .\nfuture和promise的作用是在不同线程之间传递数据。\n假设线程1需要线程2的数据，那么组合使用方式如下:\n线程1初始化一个promise对象和一个future对象，promise传递给线程2，相当于线程2对线程1的一个承诺；future相当于一个接受一个承诺，用来获取未来线程2传递的值\n线程2获取到promise后，需要对这个promise传递有关的数据，之后线程1的future就可以获取数据了。\n如果线程1想要获取数据，而线程2未给出数据，则线程1阻塞，直到线程2的数据到达\nthread10\nfuture与package_task的使用\nstd::packaged_task包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果。\nstd::packaged_task将其包装的可调用对象的执行结果传递给一个std::future对象，与std::promise某种程度上是很像的，promise保存一个共享状态的值，而package_task保存的是一个函数。\nthread11\n线程异步操作函数async的用法\nstd::async比std::packaged_task，std::promise中，std::thread更高一层，它可以直接用来创建异步的task，异步的结果也保存在future中。完成后，外面再通过future.get/wait来获取这个未来的结果，强烈推荐使用async，我们不需要关注异步任务的结果，只要等待任务完成获取值就行了。\n现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args...)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：\nstd::launch::async 在调用async就开始创建线程。 std::launch::deferred 延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。 第二个参数是线程函数，第三个参数是线程函数的参数。\nthread12\nstd::future::wait_for()函数作用\ntemplate\u0026lt; class Rep, class Period \u0026gt; std::future_status wait_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration ) const; 等待结果变得可用。阻塞直至经过指定的 timeout_duration ，或结果变为可用，两者的先到来者。返回值鉴别结果的状态。\n此函数可能由于调度或资源争议延迟而阻塞长于 timeout_duration 。\n推荐标准库用稳定时钟度量时长。若实现用系统时钟代替，则等待时间可能也对时钟调整敏感。\n若调用此函数前 valid()== false 则行为未定义。\n参数 解释 future_status::deferred 要计算结果的函数仍未启动 future_status::ready 结果就绪 future_status::timeout 已经过时限 异常\n时钟、时间点或时长在执行中可能抛的任何异常（标准库提供的时钟、时间点和时长决不抛出）。 注意\n鼓励实现在调用前检测 valid == false 的情况并抛出以 future_errc::no_state 为 error_condition 的 future_error . Re:\nhttps://www.cnblogs.com/DOMLX/p/10945309.html\n","permalink":"https://vcvvvc.github.io/post/cppthread/","tags":["CPP","thread"],"title":"CPP11_thread"},{"categories":null,"contents":"简介 #include \u0026lt;sys/epoll.h\u0026gt;\nepoll与select\nEpoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。\n触发模式 epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。\n水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件 //LevelTriggered(LT) //缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。\n边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。 //Edge Triggered(ET) //高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)\n假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除， 则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。 总结: LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。 ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据, 也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样; 而LT模式是只要有数据没有处理就会一直通知下去的. 1. 创建一个epoll的句柄 int epoll_create(int size); 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。\n这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。\n2. 将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //op为注册事件 epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。\n用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。\nEPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd； 3. 等待事件触发，当超过timeout还没有事件触发时，就超时 int epoll_wait(int epfd, struct epoll_event * events, intmaxevents, int timeout);\n等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中, 并且将注册在epfd上的socket fd的事件类型给清空\n参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。\n如果下一个循环你还要关注这个socket fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,\u0026amp;ev)来重新设置socket fd的事件类型。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。\ntypedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合:\nEPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；\nEPOLLOUT：表示对应的文件描述符可以写；\nEPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\nEPOLLERR：表示对应的文件描述符发生错误；\nEPOLLHUP：表示对应的文件描述符被挂断；\nEPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。\nEPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\nepoll IO多路复用模型实现机制 设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？ 在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。 epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统，把原先的select/poll调用分成了3个部分：\n调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)\n调用epoll_ctl向epoll对象中添加这100万个连接的套接字\n调用epoll_wait收集发生的事件的连接\n只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。\nLinux内核具体的epoll机制实现思路 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关\n/* * This structure is stored inside the \u0026#34;private_data\u0026#34; member of the file * structure and rapresent the main data sructure for the eventpoll * interface. */ struct eventpoll { /* Protect the this structure access */ spinlock_t lock; /* * This mutex is used to ensure that files are not removed * while epoll is using them. This is held during the event * collection loop, the file cleanup path, the epoll file exit * code and the ctl operations. */ struct mutex mtx; /* Wait queue used by sys_epoll_wait() */ wait_queue_head_t wq; /* Wait queue used by file-\u0026gt;poll() */ wait_queue_head_t poll_wait; /* List of ready file descriptors */ /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ struct list_head rdllist; /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/ /* RB tree root used to store monitored fd structs */ struct rb_root rbr; /* * This is a single linked list that chains all the \u0026#34;struct epitem\u0026#34; that * happened while transfering ready events to userspace w/out * holding -\u0026gt;lock. */ struct epitem *ovflist; /* The user that created the eventpoll descriptor */ struct user_struct *user; }; 每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。\n而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。\n在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示:\n/* * Each file descriptor added to the eventpoll interface will * have an entry of this type linked to the \u0026#34;rbr\u0026#34; RB tree. */ struct epitem { /* RB tree node used to link this structure to the eventpoll RB tree */ //红黑树节点 struct rb_node rbn; /* List header used to link this structure to the eventpoll ready list */ //双向链表节点 struct list_head rdllink; /* * Works together \u0026#34;struct eventpoll\u0026#34;-\u0026gt;ovflist in keeping the * single linked chain of items. */ struct epitem *next; /* The file descriptor information this item refers to */ //事件句柄信息 struct epoll_filefd ffd; /* Number of active wait queue attached to poll operations */ int nwait; /* List containing poll wait queues */ struct list_head pwqlist; /* The \u0026#34;container\u0026#34; of this item */ //指向其所属的eventpoll对象 struct ![Uploading EPOLL_663944.jpg . . .] eventpoll *ep; /* List header used to link this item to the \u0026#34;struct file\u0026#34; items list */ struct list_head fllink; /* The structure that describe the interested events and the source fd */ //期待发生的事件类型 struct epoll_event event; }; 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。\n通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。\n代码示例 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; const int MAX_EVENT_NUMBER = 1024; const int BUFFER_SIZE = 10; int setnonblocking(int fd); void addfd(int epollfd, int fd, bool enable_et); void lt(epoll_event *events, int number, int epollfd, int listenfd); void et(epoll_event *events, int number, int epollfd, int listenfd); int main(int argc, char **argv) { int port = 20999; struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); int listenfd = socket(AF_INET, SOCK_STREAM, 0); assert(listenfd != -1); int reuse = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;reuse, sizeof(reuse)); int ret = bind(listenfd, (struct sockaddr*) \u0026amp;addr, sizeof(addr)); assert(ret != -1); ret = listen(listenfd, 10); assert(ret != -1); epoll_event events[MAX_EVENT_NUMBER]; int epollfd = epoll_create(5); assert(epollfd \u0026gt; 0); addfd(epollfd, listenfd, true); while (true) { int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1); if (ret \u0026lt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;epoll failed \u0026#34; \u0026lt;\u0026lt; std::endl; break; } //lt(events, ret, epollfd, sockfd);\t//LT模式 et(events, ret, epollfd, listenfd);\t//ET模式 } return 0; } //设置非阻塞文件描述符 int setnonblocking(int fd) { int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option; } //将描述符fd的EPOLLIN注册到epollfd提示的epoll内核事件中，参数enable_et指定是否启用ET模式 void addfd(int epollfd, int fd, bool enable_et) { epoll_event event; event.data.fd = fd; event.events = EPOLLIN; if (enable_et) { event.events |= EPOLLET; } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026amp;event); setnonblocking(fd); } //LT模式 void lt(epoll_event *events, int number, int epollfd, int listenfd) { char buf[BUFFER_SIZE]; for (int i = 0; i \u0026lt; number; i++) { int sockfd = events[i].data.fd; if (sockfd == listenfd) { struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr*)\u0026amp;client_address, \u0026amp;client_addrlength); addfd(epollfd, connfd, false); } else if (events[i].events \u0026amp; EPOLLIN) {\t//只要socket读缓存中还有未读出的数据，就会被触发 std::cout \u0026lt;\u0026lt; \u0026#34;event trigger once\u0026#34; \u0026lt;\u0026lt; std::endl; memset(buf, \u0026#39;\\0\u0026#39;, BUFFER_SIZE); int ret = recv(sockfd, buf, BUFFER_SIZE-1, 0); if (ret \u0026lt;= 0) { close(sockfd); continue; } std::cout \u0026lt;\u0026lt; \u0026#34;get: \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; \u0026#34; bytes of content: \u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;something else happened\u0026#34; \u0026lt;\u0026lt; std::endl; } } } //ET模式 void et(epoll_event *events, int number, int epollfd, int listenfd) { char buf[BUFFER_SIZE]; for (int i = 0; i \u0026lt; number; i++) { int sockfd = events[i].data.fd; if (sockfd == listenfd) { struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr*)\u0026amp;client_address, \u0026amp;client_addrlength); addfd(epollfd, connfd, true); } else if (events[i].events \u0026amp; EPOLLIN) { std::cout \u0026lt;\u0026lt; \u0026#34;event trigger once\u0026#34; \u0026lt;\u0026lt; std::endl; int ret = 0; //因为ET模式不会重复触发，所以我们要循环读取所有数据 while (true) { memset(buf, \u0026#39;\\0\u0026#39;, BUFFER_SIZE); ret = recv(sockfd, buf, BUFFER_SIZE-1, 0); if (ret \u0026lt; 0) { //对于非阻塞I/O，下面的条件成立时表示数据已全部读取完毕 if (errno == EAGAIN || errno == EWOULDBLOCK) { std::cout \u0026lt;\u0026lt; \u0026#34;read later!\u0026#34; \u0026lt;\u0026lt; std::endl; break; } close(sockfd); break; } else if (ret == 0) { close(sockfd); } else { std::cout \u0026lt;\u0026lt; \u0026#34;get \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; \u0026#34; bytes of content: \u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; std::endl; } } } else { std::cout \u0026lt;\u0026lt; \u0026#34;something else happened\u0026#34; \u0026lt;\u0026lt; std::endl; } } } Re:\nhttps://www.jianshu.com/p/718c24af400f\nhttps://www.bbsmax.com/A/l1dymR3Gde/\nhttps://www.jianshu.com/p/397449cadc9a\nhttps://zhuanlan.zhihu.com/p/165162146\n","permalink":"https://vcvvvc.github.io/post/epoll_use/","tags":["Linux","Socket","Epoll","Server"],"title":"epoll use"},{"categories":null,"contents":"setsockopt\n获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 SO_LINGER选项\nstruct linger { int l_onoff; int l_linger; }; l_onoff = 0, 数据保持发送完成后立即返回 l_onoff = 1, l_linger = 0, 立即放回 放弃发送, 发送rst 自身立即复位 l_onoff = 1, l_linger = 1, 阻塞到超时或数据发送完成, 保持尝试发送,超时后立即结束 SO_REUSEADDR选项\n改变了通配绑定时处理源地址冲突的处理方式, 让端口释放后立即就可以被再次使用\n允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。一般不用于tco服务器 允许完全重复的捆绑 Re:\nhttps://www.cnblogs.com/my_life/articles/5174585.html\nhttps://www.jianshu.com/p/141aa1c41f15\nhttps://blog.csdn.net/u010144805/article/details/78579528\nint fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：\n1.复制一个现有的描述符（cmd=F_DUPFD）. 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD). 3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL). 4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN). 5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW). Re: https://www.cnblogs.com/xuyh/p/3273082.html\n非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。\n对于一个给定的描述符两种方法对其指定非阻塞I/O:\n1.调用open获得描述符，并指定O_NONBLOCK标志 2.对已经打开的文件描述符，调用fcntl，打开O_NONBLOCK文件状态标志。 flags = fcntl( s, F_GETFL, 0 ) ) fcntl( s, F_SETFL, flags | O_NONBLOCK ) Re: https://blog.csdn.net/zhulinfeiba/article/details/5011573\nhtonl()\u0026ndash;\u0026ldquo;Host to Network Long int\u0026rdquo; 32Bytes 将主机的无符号长整形数转换成网络字节顺序。//将无符号长整型网络字节序转换为主机字节序\nntohl()\u0026ndash;\u0026ldquo;Network to Host Long int\u0026rdquo; 32Bytes 将一个无符号长整形数从网络字节顺序转换为主机字节顺序。\nhtons()\u0026ndash;\u0026ldquo;Host to Network Short int\u0026rdquo; 16Bytes 将主机的无符号短整形数转换成网络字节顺序。//将无符号短整型主机字节序转换为网络字节序\nntohs()\u0026ndash;\u0026ldquo;Network to Host Short int\u0026rdquo; 16Bytes 将一个无符号短整形数从网络字节顺序转换为主机字节顺序。\ninet_addr() 将一个点间隔地址转换成一个in_addr\ninet_ntoa() 是编程语言，功能是将网络地址转换成“.”点隔的字符串格式。\ninet_aton() 与inet_ntoa()作用相反。本函数将点分十进制转换为整数\natoi() array to integer将字符串转换为整形数\n新型网路地址转化函数inet_pton和inet_ntop 这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。\n#include \u0026lt;arpe/inet.h\u0026gt; int inet_pton(int family, const char *strptr, void *addrptr); //将点分十进制的ip地址转化为用于网络传输的数值格式 返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1 const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len); //将数值格式转化为点分十进制的ip地址格式 返回值：若成功则为指向结构的指针，若出错则为NULL 1.这两个函数的family参数既可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.\n2.第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.\n3.inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达式（strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。\ninet_pton(AF_INET, ip, \u0026amp;foo.sin_addr); // 代替 foo.sin_addr.addr=inet_addr(ip); char str[INET_ADDRSTRLEN]; char *ptr = inet_ntop(AF_INET,\u0026amp;foo.sin_addr, str, sizeof(str)); // 代替 ptr = inet_ntoa(foo.sin_addr) 示例代码\nint main() { char IPdotdec[20]; // 存放点分十进制IP地址 struct in_addr s; // IPv4地址结构体 // 输入IP地址 printf(\u0026#34;Please input IP address: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;IPdotdec); // 转换 inet_pton(AF_INET, IPdotdec, (void *)\u0026amp;s); printf(\u0026#34;inet_pton: 0x%x\\n\u0026#34;, s.s_addr); // 注意得到的字节序 // 反转换 inet_ntop(AF_INET, (void *)\u0026amp;s, IPdotdec, 16); printf(\u0026#34;inet_ntop: %s\\n\u0026#34;, IPdotdec); } Run: Please input IP address: 127.0.0.1 inet_pton: 0x100007f inet_ntop: 127.0.0.1 Re: https://blog.csdn.net/zyy617532750/article/details/58595700\nhttps://www.cnblogs.com/wuyuxuan/p/10772779.html\nint send( SOCKET s,char *buf,int len,int flags )\n功能：不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。\n参数一：指定发送端套接字描述符；\n参数二：存放应用程序要发送数据的缓冲区；\n参数三：实际要发送的数据的字节数；\n参数四：一般置为0。\nint recv( SOCKET s, char *buf, int len, int flags)\n功能：不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。\n参数一：指定接收端套接字描述符；\n参数二：指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；\n参数三：指明buf的长度；\n参数四 ：一般置为0。\nRe: https://blog.csdn.net/lanzhihui_10086/article/details/40681617\nread(sock, buf, sizeof(buf) -1)\nread从套接字文件中读取数据, fd为要读取的文件的描述符，buf为要接收数据的缓冲区地址，nbytes为要读取的数据的字节数。\n/* * 本函数向服务ip发起请求 服务器ip port 保存在sockaddr_in中 * int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); //Linux * int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows * sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。 */ connect(sock, (struct sockaddr*) \u0026amp;serv_addr, sizeof(serv_addr)); linux mutex block\npthread_mutexattr_t mattr\nint pthread_mutexattr_init(pthread_mutexattr_t *mattr)\npthread_mutex_init() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。\nSuccess: return 0 POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁\npthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; 动态方式是采用pthread_mutex_init()函数来初始化互斥锁\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr) 其中mutexattr用于指定互斥锁属性（见下），如果为NULL则使用缺省属性, pthread_mutex_destroy()用于注销一个互斥锁\nint pthread_mutex_destroy(pthread_mutex_t *mutex) 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。\n2.属性 3. 锁操作\nRe: https://www.cnblogs.com/lidabo/p/4566693.html\n互斥锁的类型：有以下几个取值空间:\nPTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。\nPTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。\nPTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。\nPTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。 *pthread_mutexattr_settype(pthread_mutexattr_t attr , int type) **pthread_mutexattr_gettype(pthread_mutexattr_t attr , int type)\nRe: https://blog.csdn.net/happylzs2008/article/details/89067028\n销毁互斥锁属性对象\npthread_mutexattr_destroy(3C) 可用来取消分配用于维护 pthread_mutexattr_init() 所创建的属性对象的存储空间。 对于互斥锁属性对象，必须首先通过调用pthread_mutexattr_destroy(3C)将其销毁，才能重新初始化该对象。pthread_mutexattr_init() 调用会导致分配类型为 opaque 的对象。如果未销毁该对象，则会导致内存泄漏\nRe: https://blog.csdn.net/jasmineal/article/details/8807744\n对锁的操作主要包括加锁 pthread_mutex_lock()、解锁pthread_mutex_unlock()和测试加锁 pthread_mutex_trylock()三个。\nint pthread_mutex_lock(pthread_mutex_t *mutex) int pthread_mutex_unlock(pthread_mutex_t *mutex) int pthread_mutex_trylock(pthread_mutex_t *mutex) pthread_mutex_trylock()语义与pthread_mutex_lock()类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待\npthread_mutex_lock 用于解决由于竞争产生的优先级反转问题。没锁更新所有权,锁住\nRe: https://blog.csdn.net/jasmineal/article/details/8807744\nhttps://blog.csdn.net/oqqYuJi12345678/article/details/100585669\nbacktrace backtrace_symbols backtrace_symbols_fd To: https://vcvvvc.github.io/post/backtrace/\npthread_cond_broadcast(\u0026amp;cond1)的作用是唤醒所有正在pthread_cond_wait(\u0026amp;cond1,\u0026amp;mutex1)的线程。\nwhile(lock_status_[lid] == LOCKED) { pthread_cond_wait(\u0026amp;c_, \u0026amp;m_); } pthread_cond_broadcast(\u0026amp;c_); 一旦某个锁被释放，所有的阻塞线程都会被唤醒，但唯有阻塞在这个锁的线程才能真正被唤醒。\npthread_cond_signal(\u0026amp;cond1)的的作用是唤醒所有正在 pthread_cond_wait(\u0026amp;cond1,\u0026amp;mutex1)的至少一个线程。（虽然我还没碰到过多于一个线程的情况，但是man帮组手册上说的是至少一个）\nRe:\nhttps://www.cnblogs.com/XiaoXiaoShuai-/p/11855408.html\nhttps://www.cnblogs.com/zhouzhuo/p/3781511.html\nstruct hostent{ char *h_name; //official name char **h_aliases; //alias list int h_addrtype; //host address type int h_length; //address lenght char **h_addr_list; //address list } h_name：官方域名（Official domain name）。官方域名代表某一主页，但实际上一些著名公司的域名并未用官方域名注册。 h_aliases：别名，可以通过多个域名访问同一主机。同一 IP 地址可以绑定多个域名，因此除了当前域名还可以指定其他域名。 h_addrtype：gethostbyname() 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取IP地址的地址族（地址类型）信息，IPv4 对应 AF_INET，IPv6 对应 AF_INET6。 h_length：保存IP地址长度。IPv4 的长度为 4 个字节，IPv6 的长度为 16 个字节。 h_addr_list：这是最重要的成员。通过该成员以整数形式保存域名对应的 IP 地址。对于用户较多的服务器，可能会分配多个 IP 地址给同一域名，利用多个服务器进行均衡负载。 gethostbyname\nstruct hostent *gethostbyname(const char *hostname);\ngethostbyaddr 根据ip地址获取主机的完整信息\nstruct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);\nRe:\nhttp://c.biancheng.net/view/2357.html\ngetservbyname 根据名称获取某个服务的完整信息\nstruct servent *getservbyname(const char *name, const char *proto)\ngetservbyport 根据端口号获取某个服务的完整信息\nstruct servent *getservbyport(int port, const char *proto)\ngetaddrinfo 通过主机名获得IP地址也能通过服务名获得端口号\nint getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);\n之后用freeaddrinfo 释放getaddrinfo所分配的内存\nvoid freeaddrinfo(struct addrinfo *res);\ngetnameinfo 通过socket地址同时获得字符串表示的主机名和服务名\nint getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags); readv 将数据从文件描述符读到分散的内存块中\nssize_t readv(int fd, const struct iovec *iov, int iovcnt);\nwritev 将多块分散的数据一并写入文件描述符中\nssize_t writev(int fd, const struct iovec *iov, int iovcnt);\nsendfile 在两个文件描述符之间传递数据 避免内核缓冲区和用户之间的数据拷贝-零拷贝\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\nmmap 申请一段内存空间 将这段内存作为进程间通信的共享内存,可以将文件直接映射到其中\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); munmap 释放mmap创建的内存空间\nint munmap(void *addr, size_t length);\nsplice 用于在两个文件描述符之间移动数据-零拷贝\nssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);\nsyslog和rsyslogd 守护进程通信\nvoid syslog(int priority, const char *format, ...); openlog改变syslog默认输出方式 进一步结构化日志内容\nvoid openlog(const char *ident, int option, int facility); setlogmask 设置日志掩码\nint setlogmask(int mask);\ncloselog关闭日志功能\nvoid closelog();\nget_uid获取和设置当前进程真实用户\nuid_t getuid(void); //真实用户ID uid_t geteuid(void); //有效用户ID gid_t getgid(void); //真实组ID gid_t getegid(void); //有效组ID int setuid(uid_t uid); //设置真实用户ID int seteuid(uid_t euid); //设置有效用户ID int setgid(gid_t gid); //设置真实组ID int setegid(gid_t egid); //设置有效组ID getpgid 获取进程组ID\npid_t getpgid(pid_t pid);\nsetpgid 设置用户组ID int setpgid(pid_t pid, pid_t pgid);\nsetsid 创建一个会话\npid_t setsid(void);\ngetsid 读取sid\npid_t getsid(pid_t pid);\nrlimit 系统资源读取\\设置\nint getrlimit(int resource, struct rlimit *rlim);\nint setrlimit(int resource, const struct rlimit *rlim);\nstruct rlimit { rlim_t rlim_cur; rlim_t rlim_max; } cwd 获取进程当前工作目录和改变进程工作目录\nchar *getcwd(char *buf, size_t size);\nint chdir(const char *path);\nchroot 改变进程根目录\nint chroot(const char * path);\ndaemon 守护进程\nint daemon(int nochdir, int noclose);\n基本框架\nreactor 要求主线程只负责监听文件描述上是否有事情发生 有的话立即将该事件通知工作线程\nproactor 将所有I/0操作都交给主线程和内核来处理 工作线程仅仅负责业务逻辑\n同步模拟的Procator\n并发模式\n半同步/半异步模式\n存在的缺点\n高效模式\n领导者/追随者模式 是多个工作线程轮流获得事件源集合, 轮流监听、分发并处理事件的一种模式\n1. 句柄集 句柄表示I/O资源 在linux下通常是一个文件描述符 句柄集管理众多句柄\n2. 线程集 负责各线程之间的同步 以及新领导者线程的推选. 线程集里的线程在任何时间都必须处于一下三种状态之一\n领导者/追随者 工作流程图\nselect 在一段指定时间内 监听用户感兴趣的文件描述符上的可读、可写、异常等事件, readfds\\writefds\\exceptfds分别指向可读、可写、异常\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\npoll 指定时间内轮询一定数量的文件描述符 测试其中是否有就绪者\nint poll(struct pollfd *fds, nfds_t nfds, int timeout); epoll 把用户关心的文件描述符上的事件放在内核里的一个事件表中, 从而无需每次调用都要重复传入文件描述符集或事件集, 但epoll需要额外的文件描述符, 来唯一标识内核中的事件表\nepoll_create 创建文件描述符\nint epoll_create(int size);\n操作epoll的内核事件表\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\nepoll_wait 在一段超时时间内等待一组文件描述符上的事件\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\nLT 水平触发是默认工作模式、ET边缘触发\nselect\\poll\\epoll 区别比较\nkill 一个进程给其他进程发送信号\nint kill(pid_t pid, int sig);\nkill出错的情况\n信号处理函数SIG_DFL使用信号的默认处理方式、SIG_IGN表示忽略目标信号\n//原型: typedef void (* __sighandler_t) (int); #define SIG_DFL((__sighandler_t) 0) #define SIG_IGN((__sighandler_t) 1) signal信号设置处理函数\nsighandler_t signal(int signum, sighandler_t handler);\nsignal更健壮的接口\nint sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);\n信号集\nint sigemptyset(sigset_t * _set) //清空信号集 int sigfillset(sigset_t * _set) //在信号集中设置所有信号 int sigaddset(sigset_t * _set, int _signo) //将信号 _signo添加至信号集中 int sigdelset(sigset_t * _set, int _signo) //将信号 _signo从信号集中删除 int sigismember(const sigset_t * _set, int _signo) //测试 _signo是否在信号集中 设置或查看进程信号掩码\nint sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\nsigpending 获得进程当前被挂起的信号集 成功返回0 失败-1\nint sigpending(sigset_t *set);\nSO_RCVTIMEO接收数据超时时间 SO_SNDTIMEO发送数据超时时间\n高性能定时器 时间轮\nfork 复制当前进程, 在内核进程表中创建一个新的进程表项\npid_t fork(void);\nexec 在子进程中执行其他程序, 即替换当前进程映像\nint execl(const char* path, const char * arg, ...); int execlp(const char* file, const char* arg, ...); int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */); int execv(const char *pathname, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[], char *const envp[]); wait 在父进程中调用, 等待子进程的结束, 并获取子进程的返回信息,避免了僵尸进程的产生或使子进程的僵尸态立即结束, wait函数将阻塞进程,直到进程的某个子进程结束运行为止\npid_t wait(int *wstatus); pid_t waitpid(pid_t pid, int *wstatus, int options); semget 系统调用创建一个新的信号量集, 或者获取一个已经存在的信号量集\nint semget(key_t key, int nsems, int semflg);\nsemop 对信号量的操作是对这些内核变量的操作\nint semop(int semid, struct sembuf *sops, size_t nsops);\nsemctl 系统调用允许调用者对信号量进行直接控制\nint semctl(int semid, int semnum, int cmd, ...);\nshmget 系统调用创建一段新的共享内存,或者获取一段已存在的共享内存\nint shmget(key_t key, size_t size, int shmflg);\nshmat shmdt 共享内存被创建\\获取后,不能立即访问,而是需要先将它关联到进程的地址空间中,使用完共享内存之后,也需要将它从进程地址空间中分离\nvoid *shmat(int shmid, const void *shmaddr, int shmflg); int shmdt(const void *shmaddr); shmctl系统调用控制内存的某些属性\nint shmctl(int shmid, int cmd, struct shmid_ds *buf);\nshm_open 创建或打开POSIX共享内存对象. Linux提供了一种利用mmap在无关进程之间共享内存的方式,这种方式无须任何文件支持,但它需要先使用shm_open 创建\\打开一个POSIX共享内存对象\n//编译时需要指定链接: -lrt int shm_open(const char *name, int oflag, mode_t mode); shm_unlink 删除创建的共享内存对象\nint shm_unlink(const char *name);\nsocketpair()函数用于创建一对无名的、相互连接的套接子。\nhttps://blog.csdn.net/weixin_40039738/article/details/81095013\nint socketpair(int d, int type, int protocol, int sv[2])； 如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中。\n基本用法：\n这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读； 如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功； 读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程。如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写。因为文件描述副sv[0]和sv[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。 sendmsg、recvmsg、send函数的使用**\n#sendmsg()用来将数据由指定的socket传给对方主机. 失败返回-1 int sendmsg(int s, const strcut msghdr *msg, unsigned int flags); #函数说明：recvmsg()用来接收远程主机经指定的socket 传来的数据. 失败返回-1 int recvmsg(int s, struct msghdr *msg, unsigned int flags); #send()用来将数据由指定的socket 传给对方主机. 失败返回-1 int send(int s, const void * msg, int len, unsigned int falgs); 函数send参数flags 一般设0, 其他数值定义如下：\nMSG_OOB 传送的数据以out-of-band 送出. MSG_DONTROUTE 取消路由表查询 MSG_DONTWAIT 设置为不可阻断运作 MSG_NOSIGNAL 此动作不愿被SIGPIPE 信号中断. ","permalink":"https://vcvvvc.github.io/post/socket/","tags":["Linux","CPP","Socket","Server"],"title":"Socket function"},{"categories":null,"contents":"V1 ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $\u0026lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET) Reference: Makefile 文件 -只有include和src文件夹\n","permalink":"https://vcvvvc.github.io/post/makefile_template/","tags":["CPP","Linux","Makefile"],"title":"Makefile template"},{"categories":null,"contents":" 性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。\n性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。\n性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数 为n 2 ,则n 0 =n 2 +1。\n性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x 的最大整数)。\n性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序 编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:\n1.如果i=1,则结点i是二叉树的根,无双亲;如果i\u0026gt;1,则其双亲是结 点。\n2.如果2i\u0026gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是 结点2i。\n3.如果2i+1\u0026gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。\n树转换为二叉树 将树转换为二叉树的步骤如下\n1.加线。在所有兄弟结点之间加一条连 线。\n2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删 除它与其他孩子结点之间的连线。\n3.层次调整。以树的根结点为轴心, 将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子 是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子\n森林转换为二叉树 森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .\n1.把每个树转换为二叉树。 2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵 二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。 当所有的二叉树连接起来后就得到了由森林转换来的二叉树。 二叉树转换为树 二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。\n1.加线。若某结点的左孩子结点存在,则将 这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右 孩子结点\u0026hellip;\u0026hellip;哈,反正就是左孩子的n个右孩子结点都作为此结点的孩 子。将该结点与这些右孩子结点用线连接起来。 2.去线。删除原二叉树中所有结点与其右孩子结点的连线。 3.层次调整。使之结构层次分明。 二叉树转换为森林 判断一棵二叉树能够转换成一棵树还是森林,标准很简单,那就是只要 看这棵二叉树的根结点有没有右孩子,有就是森林,没有就是一棵树。\n1.从根结点开始,若右孩子存在,则把与右孩子结点的连线删除,再查看分离后的二叉树,若右孩子存在,则连线删除\u0026hellip;\u0026hellip;,直到所有右孩子连线都删除为止,得到分离的二 叉树。 2.再将每棵分离后的二叉树转换为树即可。 树与森林的遍历 树的遍历分为两种方式。\n1.一种是先根遍历树,即先访问树的根结点, 然后依次先根遍历根的每棵子树。 2.另一种是后根遍历,即先依次后根 遍历每棵子树,然后再访问根结点。比如图tree6/7中右下方的树,它的 先根遍历序列为ABEFCDG,后根遍历序列为EFBCGDA。 森林的遍历也分为两种方式:\n1.前序遍历:先访问森林中第一棵树的根 结点,然后再依次先根遍历根的每棵子树,再依次用同样方式遍历除去 第一棵树的剩余树构成的森林。比如图6-11-5下面三棵树的森林,前序 遍历序列的结果就是ABCDEFGHJI。 2.后序遍历:是先访问森林中第一 棵树,后根遍历的方式遍历每棵子树,然后再访问根结点,再依次同样 方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5下面三棵树 的森林,后序遍历序列的结果就是BCDAFEJHIG。 ","permalink":"https://vcvvvc.github.io/post/binary_tree/","tags":["CPP","Algorithm","DataStruct","BinaryTree"],"title":"Binary Tree"},{"categories":null,"contents":" Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 1.shared_ptr shared_ptr\u0026lt;T\u0026gt; sp\n多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。\n支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 3. make_shared make_shared\u0026lt;T\u0026gt;(args)\nshared_ptr\u0026lt;int\u0026gt; p = make_shared\u0026lt;int\u0026gt;(42); 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象\n3.weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。\n可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 4.unique_ptr unique_ptr\u0026lt;T\u0026gt; up\nunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。\nunique_ptr 用于取代 auto_ptr 5.auto_ptr 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。\nReference(1-5): github/Interview\n6.Other p.get() 返回p中保存的指针。 若智能指针释放了其对象，返回的指针所指向的对象也就消失了。\np.use_count() 返回与p共享对象的智能指针数量 用于调试\np.unqiue() 若p.use_count = 1, return true; 反之 return false\n","permalink":"https://vcvvvc.github.io/post/cpp_auto_ponit/","tags":["CPP","point"],"title":"C++ auto ponit"},{"categories":null,"contents":"0.Array int url[10]; //true int url[6 + 4] //true int len = 10; int url[len] //flase 1.Constexpr #include \u0026lt;iostream\u0026gt; using namespace std; int main() { /* * If have not constexpr, CPP throw error */ constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts\u0026lt;\u0026lt; url[1] \u0026lt;\u0026lt; endl; return 0; } 2.Only have one \u0026lsquo;return\u0026rsquo; # Error constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } # True constexpr int display(int x) { return 1 + 2 + x; } 3.Must have \u0026lsquo;return\u0026rsquo; # Error constexpr void display() { ... } # True constexpr int display() { ... } 4.Must have funciion declaration #include \u0026lt;iostream\u0026gt; using namespace std; int noconst_dis(int x); // constexpr constexpr int display(int x); constexpr int display(int x){ return 1 + 2 + x; } int main() { int a[display(3)] = { 1,2,3,4 }; cout \u0026lt;\u0026lt; a[2] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; noconst_dis(3) \u0026lt;\u0026lt; endl; return 0; } int noconst_dis(int x) { return 1 + 2 + x; } 5.\u0026lsquo;Return\u0026rsquo; must constant expession #include \u0026lt;iostream\u0026gt; using namespace std; int num = 3; constexpr int display(int x){ return num + x; } int main() { //display(3) not is constant int a[display(3)] = { 1,2,3,4 }; return 0; } 6.Constexpr struct # Error #include \u0026lt;iostream\u0026gt; using namespace std; constexpr struct myType { const char* name; int age; }; int main() { constexpr struct myType mt { \u0026#34;zhangsan\u0026#34;, 10 }; cout \u0026lt;\u0026lt; mt.name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mt.age \u0026lt;\u0026lt; endl; return 0; } # True #include \u0026lt;iostream\u0026gt; using namespace std; struct myType { constexpr myType(char *name,int age):name(name),age(age){}; const char* name; int age; }; int main() { constexpr struct myType mt { \u0026#34;zhangsan\u0026#34;, 10 }; cout \u0026lt;\u0026lt; mt.name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mt.age \u0026lt;\u0026lt; endl; return 0; } 7. CLass #include \u0026lt;iostream\u0026gt; using namespace std; //自定义类型的定义 class myType { public: constexpr myType(const char *name,int age):name(name),age(age){}; constexpr const char * getname(){ return name; } /* * unsupport virtual function */ constexpr int getage(){ return age; } private: const char* name; int age; //其它结构体成员 }; int main() { constexpr struct myType mt { \u0026#34;zhangsan\u0026#34;, 10 }; constexpr const char * name = mt.getname(); constexpr int age = mt.getage(); cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; return 0; } 8.Template #include \u0026lt;iostream\u0026gt; using namespace std; struct myType { const char* name; int age; }; template\u0026lt;typename T\u0026gt; constexpr T dispaly(T t){ return t; } int main() { struct myType stu{\u0026#34;zhangsan\u0026#34;,10}; struct myType ret = dispaly(stu); cout \u0026lt;\u0026lt; ret.name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ret.age \u0026lt;\u0026lt; endl; constexpr int ret1 = dispaly(10); cout \u0026lt;\u0026lt; ret1 \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://vcvvvc.github.io/post/constexpr/","tags":["CPP","const","function"],"title":"Constexpr"},{"categories":null,"contents":"./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value $* 1 2 3 4 ","permalink":"https://vcvvvc.github.io/post/shell_commans/","tags":["Linux","shell"],"title":"Shell_command($!, $@...)"},{"categories":null,"contents":"1. install xorg systemctl enable dhcpcd pacman -S xorg-server xorg-xinit install tool pacman -S zsh alacritty fctix fcitx-im fcitx-configtool i3 git sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts add user 这一步随意\nuseradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim login new user touch .zshrc startx cp /etc/X11/xinit/xinitrc ~/.xinitrc vim ~/.xinitrc exec i3 reboot startx tool pacman -S compton pacman -S polybar pacman -S rofi feh #快捷程序启动 壁纸 #feh --randomize --bg-fill ~/Pictureso/DesktopBackground pacman -S ntfs-3g #识别NTFS格式的硬盘 pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei #安装几个开源中文字体 一般装上文泉驿就能解决大多wine应用中文方块的问题 pacman -S noto-fonts-cjk noto-fonts-emoji noto-fonts-extra #安装谷歌开源字体及表情 pacman -S firefox chromium #安装常用的火狐、谷歌浏览器 pacman -S ark #与dolphin同用右键解压 pacman -S p7zip unrar unarchiver lzop lrzip #安装ark可选依赖 #pacman -S packagekit-qt5 packagekit appstream-qt appstream #确保Discover(软件中心）可用 需重启 pacman -S gwenview #图片查看器 pacmain -S rofi vim ~/.config/i3/config\n#run rofi bindsym $mod+d exec rofi -show run mod+shift+r 刷新以下 set static ip pacman -S netctl - vim /etc/netctl/ens33-static Description=\u0026#39;ens33\u0026#39; Interface=ens33 Connection=ethernet IP=static Address=(\u0026#39;192.168.0.14/24\u0026#39;) #Routes=(\u0026#39;192.168.0.0/24 via 192.168.0.1\u0026#39;) Gateway=\u0026#39;192.168.0.1\u0026#39; DNS=(\u0026#39;192.168.0.1\u0026#39;) TimeoutUp=300 TimeoutCarrier=300 wallpaper feh -bg-center Downloads/jpeg vim .xinitrc exec feh -bg-center Downloads/jpeg \u0026amp; polybar https://www.cnblogs.com/bluestorm/p/5929478.html\nhttps://www.bilibili.com/video/BV1gW411H7Ke/\nhttps://www.yuque.com/sunhl/mvumc2/rq64vb\nohmysh option https://www.jianshu.com/p/17790d2fc2f6 https://www.jianshu.com/p/d194d29e488c?open_source=weibo_search https://blog.csdn.net/sgzqc/article/details/46627817 # static ip https://github.com/AshNobita/i3andpolybarconfig Re: https://blog.csdn.net/duke56/article/details/104011412\nhttps://www.wnark.com/archives/162.html\nhttps://blog.csdn.net/r8l8q8/article/details/103889972\n","permalink":"https://vcvvvc.github.io/post/arch_desktop/","tags":["Arch","Linux","i3wm"],"title":"Arch Beautify desktop"},{"categories":null,"contents":"0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso 准备最新景象\n选择UEFI引导\n1. Start ls /sys/firmware/efi/efivars 这条命令检测是否在EFI模式下\n禁用 reflector\nsystemctl stop reflector.service\n检查网络, ping qq.com\nArchwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.\nUpdate systime\ntimedatectl set-ntp true 2. Partition the disks cfdisk /dev/sda #choose gpt Move to Write , enter, yes, last Quit . 3. Format the partitions 3.1 Format:\nmkfs.fat -F32 /dev/sda1 mkswap /dev/sda2 swapon /dev/sda2 mkfs.ext4 /dev/sda3 3.2 Mount the file systems\nmount /dev/sda3 /mnt mkdir -p /mnt/boot/EFI mount /dev/sda1 /mnt/boot/EFI lsblk #check mount 4. Install dev 4.1 According to your country choose your mirror source\nvim /etc/pacman.d/mirrorlist 4.2 install\npacstrap -i /mnt base base-devel linux-lts linux-firmware vi net-tools 5. Configure the system 5.1 Fstab\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 5.2 Check your fstab files, like the img\nvim /mnt/etc/fstab 6. System configuration 6.1 Chroot\narch-chroot /mnt 6.2 Time\nln -sf /usr/share/zoneinfo/Region/City /etc/localtime hwclock --systohc --utc 6.3 Localization\nvi /etc/locale.gen #according to your country, choose, del :wq locale-gen locale -a echo LANG=en_US.UTF-8 \u0026gt; /etc/locale.conf locale ex: #en_US.UTF8 UTF-8 del #: en_US.UTF-8 UTF-8 6.4 hostname\necho hostname \u0026gt; /etc/hostname 6.5 hosts\nvi /etc/hosts 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.0.1 hostname.localdomain hostname 6.6 root password\npasswd 7. install UEFI pacman -S grub efibootmgr grub-install --recheck /dev/sda grub-mkconfig -o /boot/grub/grub.cfg 8. End pacman -S dhcpcd exit umount -R /mnt reboot Arch Beautify Reference:\nArch wiki and S.T.BLOG and V2EX\nhttps://archlinuxstudio.github.io/ArchLinuxTutorial\n","permalink":"https://vcvvvc.github.io/post/arch_install/","tags":["Linux","Arch"],"title":"Vmware install Archlinux "},{"categories":null,"contents":"0. Hugo \u0026amp; Markdown Hugo \u0026amp;\u0026amp; MarkDown\n1. MarkDown template --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} lastmod: {{ .Date }} draft: false tags: [ ] categories: [ ] comment: true --- 2. Hugo command hugo #build html havn\u0026#39;t draft=true hugo -D #build html and dragt=true hugo server #Start hugo server 3. Other Reference\n","permalink":"https://vcvvvc.github.io/post/hugomarkdown/","tags":["hugo","markdown"],"title":"Hugo \u0026 Markdown"},{"categories":null,"contents":" void fun(char * fmt, \u0026hellip;); int vsprintf(char *str, const char *format, va_list arg);\nTest programming #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; /* * Re: https://github.com/antirez/kilo/kilo.c * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html */ char buffer[80]; int editorSetstatus(const char * fmt, ...) { va_list ap; va_start(ap, fmt); int ret; ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap); va_end(ap); return (ret); } int main(int argc, char **argv) { int len = 20; editorSetstatus(\u0026#34;%d\u0026#34;, len); printf(\u0026#34;%s \\n\u0026#34;, buffer); return 0; } gcc -Wall -g fun.c -o fun\n./fun\nlen = 20\n","permalink":"https://vcvvvc.github.io/post/variable_function/","tags":["CPP","GCC"],"title":"Variable function(fun(char *, ...)) and vsnprintf()"},{"categories":null,"contents":" Boost C++ is Cpp programming language that provides support for tasks and structures\nDownload Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压) Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc Compile \u0026amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr Test programming #include \u0026lt;boost/thread/thread.hpp\u0026gt; //boost thread #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026#34;func1:\u0026#34; \u0026lt;\u0026lt; cnt1++ \u0026lt;\u0026lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026#34;\\tfunc2:\u0026#34; \u0026lt;\u0026lt; cnt2++ \u0026lt;\u0026lt; endl; sleep(2); } } int main() { boost::thread thread1(\u0026amp;func1); boost::thread thread2(\u0026amp;func2); system(\u0026#34;read\u0026#34;); isRuning = false; thread2.join(); thread1.join(); cout \u0026lt;\u0026lt; \u0026#34;exit\u0026#34; \u0026lt;\u0026lt; endl; return 0; } g++ main.cpp -g -o main -lboost_thread -lpthread\n","permalink":"https://vcvvvc.github.io/post/linux_install_boost/","tags":["Boost","Linux","CPP"],"title":"Linux install Boost c++"},{"categories":null,"contents":"Start Download FFmpeg Install tool 1. install yasm\nsudo apt-get install yasm if not installed yasm, os will output \u0026ldquo;nasm/yasm not found or too old. Use \u0026ndash;disable-x86asm for a crippled build.\u0026rdquo;\n2. install SDL2\nSDL2-2.0.12(stable)\ntar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg\ncd ffmpeg/ ./configure sudo make -j4 sudo make install 3. Check ffmpeg -version ffplay -version ","permalink":"https://vcvvvc.github.io/post/ffmpeg_install/","tags":["linux","FFmpeg","Ubuntu"],"title":"Ubuntu20 install FFmpeg"},{"categories":null,"contents":"比特币：一种点对点的电子现金系统 ​\t作者：中本聪\nAbstract. A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they\u0026rsquo;ll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.\n概要：一个纯粹的点对点版本的电子现金系统，将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名虽然提供了部分解决方案，但，若是仍然需要被信任的第三方来防止双重支出的话，那么电子支付的主要优势就被抵消了。我们提出一个方案，使用点对点网络去解决双重支出问题。点对点网络将为每笔交易标记时间戳，方法是：把交易的散列数据录入一个不断延展的、以散列为基础的工作证明链上，形成一个如非完全重做就不可能改变的记录。最长链，一方面用来证明已被见证的事件及其顺序，与此同时，也用来证明它来自于最大的 CPU 算力池。只要绝大多数 CPU 算力被良性节点控制 —— 即，它们不与那些尝试攻击网络的节点合作 —— 那么，良性节点将会生成最长链，并且在速度上超过攻击者。这个网络本身需要最小化的结构。信息将以最大努力为基本去传播，节点来去自由；但，加入之时总是需要接受最长的工作证明链作为它们未参与期间所发生之一切的证明。\n1. 简介 (Introduction) Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party.\n互联网商业几乎完全依赖金融机构作为可信第三方去处理电子支付。虽然针对大多数交易来说，这个系统还算不错，但，它仍然被基于信任的模型所固有的缺陷所拖累。完全不可逆转的交易实际上并不可能，因为金融机构不能避免仲裁争议。仲裁成本增加了交易成本，进而限制了最小可能交易的规模，且干脆阻止了很多小额支付交易。除此之外，还有更大的成本：系统无法为那些不可逆的服务提供不可逆的支付。逆转的可能性，造成了对于信任的需求无所不在。商家必须提防着他们的顾客，麻烦顾客提供若非如此（如若信任）就并不必要的更多信息。一定比例的欺诈，被认为是不可避免的。这些成本和支付不确定性，虽然在人与人之间直接使用物理货币支付的时候是可以避免的；但，没有任何一个机制能在双方在其中一方不被信任的情况下通过沟通渠道进行支付。\nWhat is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes.\n我们真正需要的是一种基于加密证明而非基于信任的电子支付系统，允许任意双方在不需要信任第三方的情况下直接交易。算力保障的不可逆转交易能帮助卖家不被欺诈，而保护买家的日常担保机制也很容易实现。在本论文中，我们将提出一种针对双重支出的解决方案，使用点对点的、分布式的时间戳服务器去生成基于算力的证明，按照时间顺序记录每条交易。此系统是安全的，只要诚实节点总体上相对于相互合作的攻击者掌握更多的 CPU 算力。\n2. 交易 (Transactions) We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.\n我们将一枚电子硬币定义为一个数字签名链。一位所有者将一枚硬币交给另一个人的时候，要通过在这个数字签名链的末尾附加上以下数字签名：上一笔交易的哈希（hash，音译，亦翻译为“散列值”），以及新所有者的公钥。收款人可以通过验证签名去验证数字签名链的所属权。\nThe problem of course is the payee can\u0026rsquo;t verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank.\n这个路径的问题在于收款人无法验证曾经的所有者之中没有人双重支付过。常见的解决方案是引入一个可信的中心化权威方，或称“铸币厂”，让它去检查每一笔交易是否存在双重支付。每一次发生交易之后，硬币必须返回到铸币厂，铸币厂再发行一枚新的硬币。进而，只有铸币厂直接发行的硬币才是可信的、未被双重支付过的。这个解决方案的问题在于，整个货币系统的命运被拴在运营铸币厂的那个公司（就好像银行那样）身上，每一笔交易必须通过它。\nWe need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don\u0026rsquo;t care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced1, and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received.\n我们需要一种方式，可以让收款人确认之前的所有者并没有在任何之前的交易上签名。就我们的目的而言，只有最早的交易是算数的，所以，我们并不关心其后的双重支付企图。确认一笔交易不存在的唯一方法是获悉所有的交易。在铸币厂模型之中，铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。为了能在没有“被信任的一方”参与的情况下完成以上任务，交易记录必须被公开宣布1，进而我们需要一个系统能让参与者们认同它们所接收到的同一个唯一的交易历史。收款人需要证明在每笔交易发生之时，大多数节点能够认同它是第一个被接收的。\n3. 时间戳服务器 (Timestamp Server) The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post2 3 4 5. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.\n本解决方案起步于一种时间戳服务器。时间戳服务器是这样工作的：为一组（block）记录（items）的哈希打上时间戳，而后把哈希广播出去，就好像一份报纸所做的那样，或者像是在新闻组（Usenet）里的一个帖子那样2 3 4 5。显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链；每一个新的时间戳被添加到之前的时间戳之后。\n4. 工作证明 (Proof-of-Work) To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back\u0026rsquo;s Hashcash6, rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash.\n为了实现一个基于点对点的分布式时间戳服务器，我们需要使用类似亚当·伯克的哈希现金6那样的一个工作证明系统，而不是报纸或者新闻组帖子那样的东西。所谓的工作证明，就是去寻找一个数值；这个数值要满足以下条件：为它提取散列数值之后 —— 例如使用 SHA-256 计算散列数值 —— 这个散列数值必须以一定数量的 0 开头。每增加一个 0 的要求，将使得工作量指数级增加，并且，这个工作量的验证却只需通过计算一个哈希。\nFor our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block\u0026rsquo;s hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it.\n在我们的时间戳网络中，我们是这样实现工作证明的：不断在区块之中增加一个随机数（Nonce），直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。一旦 CPU 的耗费算力所获的的结果满足工作证明，那么这个区块将不再能被更改，除非重新完成之前的所有工作量。随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。\nThe proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added.\n工作证明同时解决了如何决定谁能代表大多数做决定的问题。如果所谓的“大多数”是基于“一个IP地址一票”的方式决定的话，那么任何一个可以搞定很多 IP 地址的人就可以被认为是“大多数”。工作证明本质上来看，是“一个CPU一票”。所谓的“大多数决定”是由最长链所代表的，因为被投入最多工作的链就是它。如果大多数 CPU 算力被诚实的节点所控制，那么诚实链成长最为迅速，其速度会远超其他竞争链。为了更改一个已经产生的区块，攻击者将不得不重新完成那个区块以及所有其后区块的的工作证明，而后还要追上并超过诚实节点的工作。后文展示为什么一个被拖延了的攻击者能够追上的可能性将随着区块的不断增加而指数级降低。\nTo compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they\u0026rsquo;re generated too fast, the difficulty increases.\n为了应对硬件算力综合的不断增加，以及随着时间推进可能产生的节点参与数量变化，工作证明难度由此决定：基于平均每小时产生的区块数量的一个移动平均值。如果区块生成得过快，那么难度将会增加。\n5. 网络 (Network) The steps to run the network are as follows:\nNew transactions are broadcast to all nodes. Each node collects new transactions into a block. Each node works on finding a difficult proof-of-work for its block. When a node finds a proof-of-work, it broadcasts the block to all nodes. Nodes accept the block only if all transactions in it are valid and not already spent. Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash. 运行网络的步骤如下：\n所有新的交易向所有节点广播； 每个节点将新交易打包到一个区块； 每个节点开始为此区块找一个具备难度的工作证明； 当某个区块找到其工作证明，它就要将此区块广播给所有节点； 众多其他节点当且只当以下条件满足才会接受这个区块：其中所有的交易都是有效的，且未被双重支付； 众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。 Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one.\n节点始终认为最长链是正确的那个，且会不断向其添加新数据。若是有两个节点同时向网络广播了两个不同版本的“下一个区块”，有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个。这种情况下，节点将在它们先接收到的那个区块上继续工作，但也会把另外一个分支保存下来，以防后者成为最长链。当下一个工作证明被找到，而其中的一个分支成为更长的链之后，这个暂时的分歧会被打消，在另外一个分支上工作的节点们会切换到更长的链上。\nNew transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one.\n新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。\n6. 奖励 (Incentive) By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended.\n按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 CPU 工作时间和它们所用的电力。\nThe incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.\n奖励还可以来自交易费用。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀。\nThe incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth.\n奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。\n7. 回收硬盘空间 (Reclaiming Disk Space) Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block\u0026rsquo;s hash, transactions are hashed in a Merkle Tree257, with only the root included in the block\u0026rsquo;s hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored.\n如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树257之中，而只有树根被纳入该区块的哈希之中。通过砍掉树枝方法，老区块即可被压缩。内部的哈希并不需要被保存。\nA block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore\u0026rsquo;s Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.\n一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。\n8. 简化版支付确认 (Simplified Payment Verification) It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he\u0026rsquo;s convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it\u0026rsquo;s timestamped in. He can\u0026rsquo;t check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.\n即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。\nAs such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker\u0026rsquo;s fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user\u0026rsquo;s software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification.\n只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。\n9. 价值的组合与分割 (Combining and Splitting Value) Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender.\n尽管逐个地处理硬币是可能的，但为每分钱设置一个单独的记录是很笨拙的。为了允许价值的分割与合并，交易记录包含多个输入和输出。一般情况下，要么是一个单独的来自于一个相对大的之前的交易的输入，要么是很多个输入来自于更小金额的组合；与此同时，最多有两个输出：一个是支付（指向收款方），如果必要的话，另外一个是找零（指向发款方）。\nIt should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction\u0026rsquo;s history.\n值得注意的是，“扇出”在这里并不是问题 —— 所谓“扇出”，就是指一笔交易依赖于数笔交易，且这些交易又依赖于更多笔交易。从来就没有必要去提取任何一笔交易的完整独立的历史拷贝。\n10. 隐私 (Privacy) The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the \u0026ldquo;tape\u0026rdquo;, is made public, but without telling who the parties were.\n传统的银行模型通过限制他人获取交易者和可信第三方的信息而达成一定程度的隐私保护。出于对将所有交易记录公开的需求否决了这种方法。但是，维持隐私可通过于另一处的切断信息流来实现——公钥匿名。公众可以看到某某向某某转账了一定的金额，但是，没有任何信息指向某个确定的人。这种水平的信息发布有点像股市交易，只有时间和各个交易的金额被公布，但是，没有人知道交易双方都是谁。\nAs an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.\n还有另外一层防火墙。交易者应该针对每一笔交易启用一对新的公私钥，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。\n11. 计算 (Calculations) We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.\n假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不能对系统做任意的修改，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。\nThe race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker\u0026rsquo;s chain being extended by one block, reducing the gap by -1.\n诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了 $1$；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了 $1$。\nThe probability of an attacker catching up from a given deficit is analogous to a Gambler\u0026rsquo;s Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows8:\n攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率8，如下：\n$$ \\begin{eqnarray*} \\large p \u0026amp;=\u0026amp; \\text{ 诚实节点找到下一个区块的概率}\\\\ \\large q \u0026amp;=\u0026amp; \\text{ 攻击者找到下一个区块的概率}\\\\ \\large q_z \u0026amp;=\u0026amp; \\text{ 攻击者落后 $z$ 个区块却依然能够赶上的概率} \\end{eqnarray*} $$\n$$ \\large q_z = \\begin{Bmatrix} 1 \u0026amp; \\textit{if}; p \\leq q\\\\ (q/p)^z \u0026amp; \\textit{if}; p \u0026gt; q \\end{Bmatrix} $$\nGiven our assumption that $p \\gt q​$, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn\u0026rsquo;t make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.\n既然我们已经假定 $p \u0026gt; q$, 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地向前猛跨一步，那么他的胜率将在他进一步落后的同时消弭殆尽。\nWe now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can\u0026rsquo;t change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.\n现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。\nThe receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.\n收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。\nThe recipient waits until the transaction has been added to a block and $z$ blocks have been linked after it. He doesn\u0026rsquo;t know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker\u0026rsquo;s potential progress will be a Poisson distribution with expected value:\n收款人等到此笔交易被打包进区块，并已经有 $z$ 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为：\n$$ \\large \\lambda = z \\frac qp $$\nTo get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:\n为了算出攻击者依然可以赶上的概率，我们要把攻击者需要追赶的区块数目的帕松分布概率密度，乘以在落后该区块数目下能够追上来的概率：\n$$ \\large \\sum_{k=0}^{\\infty} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\cdot \\begin{Bmatrix} (q/p)^{(z-k)} \u0026amp; \\textit{if};k\\leq z\\\\ 1 \u0026amp; \\textit{if} ; k \u0026gt; z \\end{Bmatrix} $$\nRearranging to avoid summing the infinite tail of the distribution\u0026hellip;\n为了避免对密度分布的无穷级数求和重新整理…\n$$ \\large 1 - \\sum_{k=0}^{z} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\left ( 1-(q/p)^{(z-k)} \\right ) $$\nConverting to C code\u0026hellip;\n转换为 C 语言程序……\n#include \u0026lt;math.h\u0026gt; double AttackerSuccessProbability(double q, int z) { double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k \u0026lt;= z; k++) { double poisson = exp(-lambda); for (i = 1; i \u0026lt;= k; i++) poisson *= lambda / i; sum -= poisson * (1 - pow(q / p, z - k)); } return sum; } Running some results, we can see the probability drop off exponentially with $z$.\n获取部分结果，我们可以看到概率随着 $z$ 的增加指数级下降：\nq=0.1 z=0 P=1.0000000 z=1 P=0.2045873 z=2 P=0.0509779 z=3 P=0.0131722 z=4 P=0.0034552 z=5 P=0.0009137 z=6 P=0.0002428 z=7 P=0.0000647 z=8 P=0.0000173 z=9 P=0.0000046 z=10 P=0.0000012 q=0.3 z=0 P=1.0000000 z=5 P=0.1773523 z=10 P=0.0416605 z=15 P=0.0101008 z=20 P=0.0024804 z=25 P=0.0006132 z=30 P=0.0001522 z=35 P=0.0000379 z=40 P=0.0000095 z=45 P=0.0000024 z=50 P=0.0000006 Solving for P less than 0.1%\u0026hellip;\n若是 P 小于 0.1%……\nP \u0026lt; 0.001 q=0.10 z=5 q=0.15 z=8 q=0.20 z=11 q=0.25 z=15 q=0.30 z=24 q=0.35 z=41 q=0.40 z=89 q=0.45 z=340 12. 结论 (Conclusion) We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.\n我们提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。\n参考文献 (References) Repo https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation\nb-money Dai Wei (1998-11-01) http://www.weidai.com/bmoney.txt\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDesign of a secure timestamping service with minimal trust requirements Henri Massias, Xavier Serret-Avila, Jean-Jacques Quisquater 20th Symposium on Information Theory in the Benelux (1999-05) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHow to time-stamp a digital document Stuart Haber, W.Scott Stornetta Journal of Cryptology (1991) https://doi.org/cwwxd4 DOI: 10.1007/bf00196791\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nImproving the Efficiency and Reliability of Digital Time-Stamping Dave Bayer, Stuart Haber, W. Scott Stornetta Sequences II (1993) https://doi.org/bn4rpx DOI: 10.1007/978-1-4613-9323-8_24\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSecure names for bit-strings Stuart Haber, W. Scott Stornetta Proceedings of the 4th ACM conference on Computer and communications security - CCS ’97(1997) https://doi.org/dtnrf6 DOI: 10.1145/266420.266430\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHashcash - A Denial of Service Counter-Measure Adam Back (2002-08-01) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nProtocols for Public Key Cryptosystems Ralph C. Merkle 1980 IEEE Symposium on Security and Privacy (1980-04) https://doi.org/bmvbd6 DOI: 10.1109/sp.1980.10006\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAn Introduction to Probability Theory and its Applications William Feller John Wiley \u0026amp; Sons (1957) https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://vcvvvc.github.io/post/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6_zh/","tags":["Bitcoin","BlockChain"],"title":"比特币白皮书_zh"},{"categories":null,"contents":" 随: https://vcvvvc.github.io/vcvc/sui.html\n第一篇: https://vcvvvc.github.io/vcvc/index.html\n本博客采用GitHub page + Hugo搭建 | 主题: m10c\n","permalink":"https://vcvvvc.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","permalink":"https://vcvvvc.github.io/post/search/","tags":null,"title":"Search"}]