<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Vc</title>
    <link>https://vcvvvc.github.io/tags/linux/</link>
    <description>Recent content in Linux on Vc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 17 Apr 2024 16:42:04 +0800</lastBuildDate>
    <atom:link href="https://vcvvvc.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker use Tutorial</title>
      <link>https://vcvvvc.github.io/post/docker_tutorial/</link>
      <pubDate>Wed, 17 Apr 2024 16:42:04 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/docker_tutorial/</guid>
      <description>Install docker ubuntu # Add Docker&amp;#39;s official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: echo \ &amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \ $(. /etc/os-release &amp;amp;&amp;amp; echo &amp;#34;$VERSION_CODENAME&amp;#34;) stable&amp;#34; | \ sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin sudo docker run hello-world # 重启 service docker restart https://docs.</description>
    </item>
    <item>
      <title>TIME_WAIT与SO_LINGER</title>
      <link>https://vcvvvc.github.io/post/time_wait%E4%B8%8Eso_linger/</link>
      <pubDate>Mon, 29 May 2023 21:13:27 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/time_wait%E4%B8%8Eso_linger/</guid>
      <description>TIME_WAIT 主动关闭方在收到被动关闭方的FIN包后并返回ACK后，会进入TIME_WAIT状态，TIME_WAIT状态又称2MSL状态，每个TCP连接都必须有一个最大报文段生存时间MSL，在网络传输中超过这个时间的报文段将被丢弃。当TCP连接发起一个主动关闭，并发出最后一个ACK时，必须在TIME_WAIT状态停留两倍MSL时间，在2MSL等待期间，定义这个连接的插口(客户端IP地址和端口号，服务器IP地址和端口号的四元组)将不能再被使用。&#xA;主动发起关闭连接的一方，才会有 TIME-WAIT 状态。 需要TIME-WAIT状态，主要是两个原因：&#xA;防止历史连接中的数据，被后面相同四元组的连接错误的接收；&#xA;保证「被动关闭连接」的一方，能被正确的关闭；&#xA;序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0。&#xA;初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。&#xA;序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。&#xA;tcp协议头中有seq和ack_seq两个字段，分别代表序列号和确认号。tcp协议通过序列号标识发送的报文段。seq的类型是__u32，当超过__u32的最大值时，会回绕到0。&#xA;一个tcp流的初始序列号（ISN）并不是从0开始的，而是采用一定的随机算法产生的，因此ISN可能很大（比如(2^32-10)），因此同一个tcp流的seq号可能会回绕到0。而我们tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。&#xA;TCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。&#xA;是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。&#xA;TIME-WAIT状态过多危害 第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等； 第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过 net.ipv4.ip_local_port_range参数指定范围。 出现过多的原因 HTTP 没有使用长连接&#xA;HTTP 长连接超时&#xA;HTTP 长连接的请求数量达到上限&#xA;SO_LINGER SO_LINGER选项的作用是等待发送缓冲区中的数据发送完成，但是并不保证发送缓冲区中的数据一定被对端接收（对端宕机或线路问题），只是说会等待一段时间让这个过程完成。&#xA;struct linger { int l_onoff; //0=off, nonzero=on(开关) int l_linger; //linger time(延迟时间) } l_onoff l_linger closesocket 发送队列 底层行为 0 关闭 立即返回 保持直到发送完成 系统接管套接字并保证将数据发送至对端。（就是正常的close） 1 0 立即返回 立即放弃 直接发送RST包，自身立即复位，不用经过2MSL状态。对端收到复位错误号。 1 1 阻塞直到l_linger时间超时或数据发送完成。 在超时时间段内保持尝试发送，若超时则立即放弃。 设置超时时间，若超时未完成数据发送，则立即返回按linger = 0的行为关闭 Re: https://zhuanlan.</description>
    </item>
    <item>
      <title>SO_REUSEPORT与SO_REUSEADDR</title>
      <link>https://vcvvvc.github.io/post/so_reuseport%E4%B8%8Eso_reuseaddr/</link>
      <pubDate>Mon, 29 May 2023 20:54:49 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/so_reuseport%E4%B8%8Eso_reuseaddr/</guid>
      <description>SO_REUSEPORT端口重用 int opt_val = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;amp;opt_val, sizeof(opt_val)) SO_REUSEPORT是允许多个socket绑定到同一个ip+port上&#xA;每一个线程拥有自己的服务器套接字, 在服务器套接字上没有了锁的竞争&#xA;内核层面实现负载均衡&#xA;SO_REUSEPORT在以下场景下有用： 当服务器需要使用多个进程或线程来监听相同的端口，而不想遇到惊群现象或资源竞争时，可以设置SO_REUSEPORT选项，以便实现网络连接的负载均衡。&#xA;当服务器需要使用UDP协议来接收多播数据报时，可以设置SO_REUSEPORT选项，以便让每个进程或线程接收到不同的数据报，提高效率和性能。&#xA;EPOLL惊群问题&#xA;SO_REUSEADDR是地址重用 int opt_val = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;opt_val, sizeof(opt_val)) SO_REUSEADDR可以解决服务器主动关闭连接后，需要等待2MSL时间才能重新绑定相同的端口的问题。如果不设置这个选项，服务器在关闭连接后，会进入TIME_WAIT状态，此时再次启动服务器，就会绑定失败，报：Address already in use。如果设置了这个选项，服务器就可以立即重启并绑定相同的端口&#xA;SO_REUSEADDR可以解决服务器使用通配符IP地址（0.0.0.0）监听端口后，无法再绑定具体的IP地址到相同的端口的问题。如果不设置这个选项，当一个socket绑定到0.0.0.0:port后，其他socket就无法绑定到192.168.0.1:port等具体的IP地址上。如果设置了这个选项，就可以允许多个socket绑定到相同的端口，只要它们使用不同的本地IP地址&#xA;SO_REUSEADDR在以下场景下有用： 当服务器需要频繁地启动和关闭，而不想等待2MSL时间才能重新绑定相同的端口时，可以设置SO_REUSEADDR选项，以便快速重启。&#xA;当服务器需要使用通配符IP地址（0.0.0.0）监听端口，同时又想绑定其他具体的IP地址到相同的端口时，可以设置SO_REUSEADDR选项，以便支持多个IP地址的监听。&#xA;Epoll惊群 #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;sys/epoll.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;sys/wait.h&amp;gt; #define PROCESS_NUM 10 static int create_and_bind (char *port) { int fd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in serveraddr; serveraddr.</description>
    </item>
    <item>
      <title>并行、并发、异步、同步</title>
      <link>https://vcvvvc.github.io/post/async_thread/</link>
      <pubDate>Fri, 29 Jul 2022 00:12:53 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/async_thread/</guid>
      <description>并发和并行 并发&#xA;通过一种算法将 CPU 资源合理地分配给多个任务，当一个任务执行 I/O 操作时，CPU 可以转而执行其它的任务，等到 I/O 操作完成以后，或者新的任务遇到 I/O 操作时，CPU 再回到原来的任务继续执行。&#xA;并行&#xA;多核 CPU 的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。&#xA;并发+并行&#xA;每个核心并发执行两个任务，两个核心并行的话就能执行四个任务。当然也可以一个核心执行一个任务，另一个核心并发执行三个任务，这跟操作系统的分配方式，以及每个任务的工作状态有关系。&#xA;异步跟同步 图为同步/异步&#xA;同步等待上一步执行完成后才会执行下一步。&#xA;异步系统当中的解决方案是开启一个额外的线程进行处理。&#xA;第一个线程获取第一个文件，第二个线程获取第二个文件，第二个线程并不需要等待第一个线程执行完毕再执行。当两个线程都获得到对应的结果之后，再重新同步处理合并结果的操作。&#xA;同步执行&#xA;异步&#xA;setTimeout(function cbFn(){ console.log(&amp;#39;learnInPro&amp;#39;); }, 1000); console.log(&amp;#39;sync things&amp;#39;); setTimeout就是一个异步任务，当JS引擎顺序执行到setTimeout的时候发现他是个异步任务，则会把这个任务挂起，继续执行后面的代码。直到1000ms后，回调函数cbFn才会执行，这就是异步，在执行到setTimeout的时候，JS并不会傻呵呵的等着1000ms执行cbFn回调函数，而是继续执行了后面的代码。&#xA;异步不会造成阻塞&#xA;异步可以启用额外的线程去执行任务。&#xA;异步并不会缩短任务的时间&#xA;python异步 import asyncio # 定义异步函数 async def print_after(delay, message): # 异步等待 await asyncio.sleep(delay) # 打印消息 print(message) # 获取事件循环 loop = asyncio.get_event_loop() # 创建任务列表 tasks = [ loop.create_task(print_after(1, &amp;#39;Hello&amp;#39;)), loop.create_task(print_after(2, &amp;#39;World&amp;#39;)), ] # 在事件循环中执行任务 loop.</description>
    </item>
    <item>
      <title>Geth_私链创建并链接钱包</title>
      <link>https://vcvvvc.github.io/post/geth_use/</link>
      <pubDate>Sat, 09 Apr 2022 23:03:33 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/geth_use/</guid>
      <description>1. 下载安装geth https://geth.ethereum.org/&#xA;2. 创建私有链 创建创世块配置文件 genesis.json&#xA;{ &amp;#34;config&amp;#34;: { &amp;#34;chainId&amp;#34;: 15, &amp;#34;homesteadBlock&amp;#34;: 0, &amp;#34;eip155Block&amp;#34;: 0, &amp;#34;eip158Block&amp;#34;: 0, &amp;#34;eip150Block&amp;#34;: 0 }, &amp;#34;coinbase&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000&amp;#34;, &amp;#34;difficulty&amp;#34; : &amp;#34;0x40000&amp;#34;, &amp;#34;extraData&amp;#34; : &amp;#34;&amp;#34;, &amp;#34;gasLimit&amp;#34; : &amp;#34;0xffffffff&amp;#34;, &amp;#34;nonce&amp;#34; : &amp;#34;0x0000000000000042&amp;#34;, &amp;#34;mixhash&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;, &amp;#34;parentHash&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;, &amp;#34;timestamp&amp;#34; : &amp;#34;0x00&amp;#34;, &amp;#34;alloc&amp;#34;: { } } 3. 初始化 geth --datadir genesis-block init genesis.json 启动节点&#xA;#1 geth --datadir genesis-block --networkid 1108 console 注册账户 personal.newAccount(&amp;#39;Your Password&amp;#39;) #创建两个 余额查询&#xA;my=eth.accounts[0] eth.</description>
    </item>
    <item>
      <title>Ubuntu20_install_docker</title>
      <link>https://vcvvvc.github.io/post/ubuntu20_install_docker/</link>
      <pubDate>Fri, 01 Apr 2022 22:22:24 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/ubuntu20_install_docker/</guid>
      <description>https://zhuanlan.zhihu.com/p/143156163</description>
    </item>
    <item>
      <title>何为协程</title>
      <link>https://vcvvvc.github.io/post/%E4%BD%95%E4%B8%BA%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 30 Jan 2022 23:18:03 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/%E4%BD%95%E4%B8%BA%E5%8D%8F%E7%A8%8B/</guid>
      <description>什么是协程 进程-&amp;gt;线程-&amp;gt;协程&#xA;Re:&#xA;https://baike.baidu.com/item/协程/8652240&#xA;https://cloud.tencent.com/developer/article/1916705&#xA;https://zhuanlan.zhihu.com/p/172471249&#xA;https://www.zhihu.com/question/32218874/answers/updated&#xA;https://zhuanlan.zhihu.com/p/70256971&#xA;https://docs.python.org/zh-cn/3/library/asyncio-task.html&#xA;Unity: https://developer.unity.cn/projects/61c80ba3edbc2a244ffbcf25&#xA;https://www.nowcoder.com/discuss/821457&#xA;http://c.biancheng.net/view/5214.html&#xA;https://zhuanlan.zhihu.com/p/59178345&#xA;https://zhuanlan.zhihu.com/p/337946103</description>
    </item>
    <item>
      <title>C&#43;&#43;获取域名IP</title>
      <link>https://vcvvvc.github.io/post/get_domain_ip_cpp/</link>
      <pubDate>Fri, 14 Jan 2022 00:09:51 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/get_domain_ip_cpp/</guid>
      <description>#https://blog.csdn.net/dosthing/article/details/80383817 std::string ip = &amp;#34;www.baidu.com&amp;#34;; struct hostent stHostent; struct hostent *pstHostent = nullptr; char **pptr = nullptr; char buf[2048] = &amp;#34;\0&amp;#34;; sprintf(buf,&amp;#34;%s&amp;#34;, &amp;#34;ip&amp;#34;); int iError; if((pstHostent = gethostbyname(buf)) == NULL || pstHostent-&amp;gt;h_addr_list == NULL || pstHostent-&amp;gt;h_addr_list[0] == NULL) { std::cout &amp;lt;&amp;lt; &amp;#34;can&amp;#39;t parse the domain&amp;#34; &amp;lt;&amp;lt; std::endl; exit(0); } else { std::cout &amp;lt;&amp;lt; &amp;#34;official hostname: &amp;#34; &amp;lt;&amp;lt; pstHostent-&amp;gt;h_name &amp;lt;&amp;lt; std::endl; for(pptr = pstHostent-&amp;gt;h_aliases; *pptr != NULL; pptr++) std::cout &amp;lt;&amp;lt; &amp;#34;alias: &amp;#34; &amp;lt;&amp;lt; *pptr &amp;lt;&amp;lt; std::endl; switch(pstHostent-&amp;gt;h_addrtype) { case AF_INET: case AF_INET6: pptr = pstHostent-&amp;gt;h_addr_list; for(; *pptr!</description>
    </item>
    <item>
      <title>Ubuntu20.10 install vscode</title>
      <link>https://vcvvvc.github.io/post/ubuntu2010_install_vscode/</link>
      <pubDate>Thu, 02 Dec 2021 16:06:36 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/ubuntu2010_install_vscode/</guid>
      <description>20.10有点下问题，得简单配置下&#xA;添加到bashrc 或zshrc cd ~ mkdir vscode alias code=&amp;#39;code --user-data-dir $HOME/vscode&amp;#39; root运行 vim /usr/bin/code # 跟谷歌浏览器一样 添加 --no-sandbox </description>
    </item>
    <item>
      <title>Ubuntu20.4 install gcc11.2.0</title>
      <link>https://vcvvvc.github.io/post/ubuntu20_install_gcc11/</link>
      <pubDate>Thu, 02 Dec 2021 11:08:36 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/ubuntu20_install_gcc11/</guid>
      <description>编译安装 make时间比较长。&#xA;#直接存sh里 wget https://mirrors.ustc.edu.cn/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.gz tar -zxvf gcc-11.2.0.tar.gz cd gcc-11.2.0 ./contrib/download_prerequisites mkdir build cd build ../configure configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-11.2 --enable-checking=release --enable-languages=c,c++ --disable-multilib --program-suffix=-11.2 make -j4 make install 设置默认gcc ln -s /usr/local/gcc-11.2/bin/g++-11.2 /usr/bin/g++-11.2 ln -s /usr/local/gcc-11.2/bin/gcc-11.2 /usr/bin/gcc-11.2 update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11.2 100 update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11.2 100 #选择版本 就一个选项的不会提供选择 update-alternatives --config gcc update-alternatives --config g++ gcc -v g++ -v Re: https://blog.csdn.net/wbvalid/article/details/119945557&#xA;https://blog.csdn.net/EternallyAccompany/article/details/108865331</description>
    </item>
    <item>
      <title>readv_writev</title>
      <link>https://vcvvvc.github.io/post/readv_writev/</link>
      <pubDate>Fri, 26 Nov 2021 20:31:17 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/readv_writev/</guid>
      <description>readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）。&#xA;#include &amp;lt;sys/uio.h&amp;gt; ssize_t readv(int filedes, const struct iovec *iov, int iovcnt); #散布读 ssize_t writev(int filedes, const struct iovec *iov, int iovcnt); #聚集写 其中的iovec&#xA;#include &amp;lt;sys/uio.h&amp;gt; struct iovec { ptr_t iov_base; /* Starting address */ size_t iov_len; /* Length in bytes */ }; 代码：https://github.com/vcvvvc/CPP_Test/tree/master/test/writev&#xA;Re: https://www.cnblogs.com/nufangrensheng/p/3559304.html&#xA;https://www.cnblogs.com/youngerchina/p/5624567.html</description>
    </item>
    <item>
      <title>ip转换函数</title>
      <link>https://vcvvvc.github.io/post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 21 Nov 2021 22:08:01 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</guid>
      <description>主机字节序（大端） 和 网络字节序（小端)&#xA;大端: 0x12 | 0x32 | 0x56&#xA;小端: 0x56 | 0x34 | 0x12&#xA;Host to Network long/short&#xA;Network to Host long/short&#xA;uint32_t htonl(uint32_t hostlong); //将主机的无符号长整型数转换成网络字节序 uint16_t htons(uint16_t hostshort); //将主机的无符号短整形数转换成网络字节序 uint32_t ntohl(uint32_t netlong); //将一个无符号长整型数从网络字节序转换为主机字节序 uint16_t ntohs(uint16_t netshort); //将一个无符号短整形数从网络字节序转换为主机字节序 https://github.com/vcvvvc/CPP_Test/tree/master/test/hostto&#xA;#把ip地址转化为用于网络传输的二进制数值(32位) in_addr_t inet_addr(const char *cp); #少用了 int inet_aton(const char * cp, struct in_addr *inp); #将网络传输的二进制数值转化为成点分十进制的ip地址 char* inet_ntoa(struct in_addr in); #这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。 地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。 int inet_pton(int family, const char *strptr, void *addrptr); const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len); Re: https://www.</description>
    </item>
    <item>
      <title>I/O多路复用</title>
      <link>https://vcvvvc.github.io/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Sun, 10 Oct 2021 10:00:00 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>I/O模型 https://vcvvvc.github.io/post/server_actor/&#xA;I/O多路复用 Select、Poll、Epoll, 多路是指？多个业务方（句柄）并发下来的 IO 。 复用是指？复用这一个后台处理程序。&#xA;Select select()函数主要解决的是accept()函数阻塞问题，而没有解决recv()和send()函数阻塞问题&#xA;#include &amp;lt;sys/select.h&amp;gt; int select(int nfds, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout); nfds参数指定被监听的文件描述符的总数。&#xA;readfds, writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。&#xA;#include &amp;lt;sys/select.h&amp;gt; int FD_ZERO(int fd, fd_set *fdset); //一个 fd_set类型变量的所有位都设为 0 int FD_CLR(int fd, fd_set *fdset); //清除某个位时可以使用 int FD_SET(int fd, fd_set *fd_set); //设置变量的某个位置位 int FD_ISSET(int fd, fd_set *fdset); //测试某个位是否被置位 timeout参数用来设置select函数的超时时间 struct timeval{ long tv_sec; /*秒 */ long tv_usec; /*微秒 */ } select示例代码: select.cpp Poll #include &amp;lt;poll.</description>
    </item>
    <item>
      <title>总结mmap(零拷贝)</title>
      <link>https://vcvvvc.github.io/post/use_mmap/</link>
      <pubDate>Mon, 04 Oct 2021 21:10:09 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/use_mmap/</guid>
      <description>总结分析传统io, mmap, sendfile&#xA;传统IO 通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过write()写入到socket缓冲区，最后写入目标。&#xA;整个过程发生了4次用户态和内核态的上下文切换和4次拷贝&#xA;用户进程通过read()方法向操作系统发起调用，此时上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，read()返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将应用缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回 mmap #用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize); 调用 mmap() 系统调用对文件进行映射后，用户对映射后的内存进行读写实际上是对文件缓存的读写，所以减少了一次系统调用，从而加速了对文件读写的效率。&#xA;整个过程发生了4次用户态和内核态的上下文切换和3次拷贝，具体流程如下：&#xA;用户进程通过mmap()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 上下文从内核态转为用户态，mmap调用返回 用户进程通过write()方法发起调用，上下文从用户态转为内核态 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回 munmap int munmap(void *addr, size_t len); munmap()用来取消参数start 所指的映射内存起始地址，参数length 则是欲取消的内存大小。当进程结束或利用exec 相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。&#xA;Sendfile sendfile函数在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。&#xA;ssize_t senfile(int out_fd,int in_fd,off_t* offset,size_t count); 整个过程发生了2次用户态和内核态的上下文切换和3次拷贝&#xA;用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器把数据从硬盘中拷贝到读缓冲区 CPU将读缓冲区中数据拷贝到socket缓冲区 DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，sendfile调用返回 sendfile+DMA Scatter/Gather 它将读缓冲区中的数据描述信息&amp;ndash;内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程&#xA;整个过程发生了2次用户态和内核态的上下文切换和2次拷贝，其中更重要的是完全没有CPU拷贝&#xA;用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态 DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储 CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区 DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡 sendfile()调用返回，上下文从内核态切换回用户态 Re: https://zhuanlan.</description>
    </item>
    <item>
      <title>Ubuntu20开机自启脚本</title>
      <link>https://vcvvvc.github.io/post/ubuntu20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Sun, 03 Oct 2021 12:08:21 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/ubuntu20%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/</guid>
      <description>我测试了好几篇文章,终于有个成功了&#xA;local.service vim /etc/systemd/system/rc-local.service&#xA;输入以下内容:&#xA;[Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.local [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardOutput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target rc.local vim /etc/rc.local&#xA;#!/bin/sh -e ## rc.local sh /root/startup.sh exit 0 收尾 授权 chmod +x /etc/rc.local&#xA;自启动 systemctl enable rc-local&#xA;运行 systemctl start rc-local.service&#xA;查看状态 systemctl status rc-local.service&#xA;先别重启, ps -x配合grep搜索关键字看看进程启动没有&#xA;之后保存好文件重启进行测试 再次查看是否启动&#xA;举个例子:&#xA;startup.sh&#xA;#!/bin/bash -e cd /root/News-D/ nohup python3 main.py &amp;amp; cd /root/News-D/Finance/ nohup python3 -m http.server 20777 &amp;amp; rm nohup.</description>
    </item>
    <item>
      <title>Linux_ssh_nohup</title>
      <link>https://vcvvvc.github.io/post/linux_ssh_nohup/</link>
      <pubDate>Sun, 22 Aug 2021 22:03:04 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/linux_ssh_nohup/</guid>
      <description>Linux系统SSH客户端断开后保持进程继续运行配置方法&#xA;nohup python3 main.py &amp;amp; Re: https://help.aliyun.com/document_detail/42523.html</description>
    </item>
    <item>
      <title>Ubuntu20 Install Nvidia drivers</title>
      <link>https://vcvvvc.github.io/post/install_nvidia/</link>
      <pubDate>Thu, 06 May 2021 07:29:52 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/install_nvidia/</guid>
      <description>2021-05-06更新 完善一下&#xA;网上教程坑特别多 这个步骤是我自己装好总结的&#xA;电脑dell&#xA;显卡1650&#xA;1. 去残留 sudo apt-get remove --purge nvidia* 2. 添加规则 vim /etc/modprobe.d/blacklist.conf&#xA;blacklist nouveau options nouveau modeset=0 3. 验证是否成功 重启 重启之后输入命令&#xA;sudo update-initramfs -u lsmod | grep nouveau 如果没有返回信息代表成功&#xA;有信息的话 先检查下步骤2 再重启, 也可忽视 我这边见过一次有返回&#xA;4.选择合适的版本 1.输入命令: ubuntu-drivers devices&#xA;2.官网：Nvidia Official website&#xA;选择合适的版本来进行安装&#xA;sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update #选择自己的版本 例如我这边安装440 sudo apt-get install nvidia-driver-440 5.选择驱动应用 ubuntu配置点击 软件和更新 ==&amp;gt; 附件驱动 然后选择合适版本的驱动&#xA;Open warehouse =&amp;gt; additional drivers =&amp;gt; choose you drivers .</description>
    </item>
    <item>
      <title>Server sum</title>
      <link>https://vcvvvc.github.io/post/server_sum/</link>
      <pubDate>Sun, 04 Apr 2021 18:21:09 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/server_sum/</guid>
      <description>c++标准网络库对比 https://vcvvvc.github.io/post/c++标准网络库/ socket struct整理 https://vcvvvc.github.io/post/socket_struct/ socket编程需要的头文件整理 https://vcvvvc.github.io/post/socket_file/ socket function https://vcvvvc.github.io/post/socket/ I/O复用 https://vcvvvc.github.io/post//io多路复用 sem function https://vcvvvc.github.io/post/sem/ server io actor https://vcvvvc.github.io/post/server_actor/ timer function https://vcvvvc.github.io/post/timer_function/ Linux Pthread 线程创建与使用 https://vcvvvc.github.io/post/pthread/&#xA;C++11 thread https://vcvvvc.github.io/post/cppthread/&#xA;Unp note https://vcvvvc.github.io/post/unp_note/&#xA;TCP_IP | 计算机网络 https://vcvvvc.github.io/post/computer_network/&#xA;exception class 异常类 https://vcvvvc.github.io/post/cpp_exception/</description>
    </item>
    <item>
      <title>getopt_long</title>
      <link>https://vcvvvc.github.io/post/getopt_long/</link>
      <pubDate>Sun, 14 Mar 2021 14:26:33 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/getopt_long/</guid>
      <description>2021-5-31更新&#xA;#include &amp;lt;unistd.h&amp;gt; extern char *optarg; extern int optind, opterr, optopt; #include &amp;lt;getopt.h&amp;gt; int getopt(int argc, char * const argv[],const char *optstring); int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); 参数以及返回值介绍（以上三个函数都适用）：&#xA;1、argc和argv和main函数的两个参数一致。&#xA;2、optstring: 表示短选项字符串。&#xA;形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下：&#xA;只有一个字符，不带冒号——只表示选项， 如-c 一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100 一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格,形式应该如-b 3、longopts：表示长选项结构体。结构如下：&#xA;struct option { const char *name; int has_arg; int *flag; int val; }; static struct option longOpts[] = { { &amp;#34;daemon&amp;#34;, no_argument, NULL, &amp;#39;D&amp;#39; }, { &amp;#34;dir&amp;#34;, required_argument, NULL, &amp;#39;d&amp;#39; }, { &amp;#34;out&amp;#34;, required_argument, NULL, &amp;#39;o&amp;#39; }, { &amp;#34;log&amp;#34;, required_argument, NULL, &amp;#39;l&amp;#39; }, { &amp;#34;split&amp;#34;, required_argument, NULL, &amp;#39;s&amp;#39; }, { &amp;#34;http-proxy&amp;#34;, required_argument, &amp;amp;lopt, 1 }, { &amp;#34;http-user&amp;#34;, required_argument, &amp;amp;lopt, 2 }, { &amp;#34;http-passwd&amp;#34;, required_argument, &amp;amp;lopt, 3 }, { &amp;#34;http-proxy-user&amp;#34;, required_argument, &amp;amp;lopt, 4 }, { &amp;#34;http-proxy-passwd&amp;#34;, required_argument, &amp;amp;lopt, 5 }, { &amp;#34;http-auth-scheme&amp;#34;, required_argument, &amp;amp;lopt, 6 }, { &amp;#34;version&amp;#34;, no_argument, NULL, &amp;#39;v&amp;#39; }, { &amp;#34;help&amp;#34;, no_argument, NULL, &amp;#39;h&amp;#39; }, { 0, 0, 0, 0 } }; (1)name:表示选项的名称,比如daemon,dir,out等。</description>
    </item>
    <item>
      <title>Tcpdump</title>
      <link>https://vcvvvc.github.io/post/tcpdump/</link>
      <pubDate>Fri, 05 Mar 2021 22:03:34 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/tcpdump/</guid>
      <description>备忘 简洁明了的教程&#xA;https://www.jianshu.com/p/d9162722f189&#xA;https://www.jianshu.com/p/a57a5b0e58f0&#xA;https://zhuanlan.zhihu.com/p/74812069</description>
    </item>
    <item>
      <title>Clion_remote_debug</title>
      <link>https://vcvvvc.github.io/post/clion_remote_debug/</link>
      <pubDate>Mon, 22 Feb 2021 22:10:27 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/clion_remote_debug/</guid>
      <description>环境 Macos Clion2020.3.2 Server: ubuntu18 设置 1. 首先添加一个ssh&#xA;2. 部署服务器上传文件&#xA;选择SFTP协议&#xA;3. 设置本地与远程文件路径&#xA;4. 上传文件&#xA;5. 设置自动上传&#xA;环境配置 安装环境&#xA;Centos # cmake yum install cmake -y # gcc &amp;amp; gdb yum install gcc-c++ -y yum install gdb -y #gdbserver yum install gdb-gdbserver -y Ubuntu apt-get install cmake apt-get install gcc apt-get install g++ apt-get install gdb apt-get install gdbserver gdbserver配置&#xA;target remote中格式是: tcp:ip:port&#xA;远程调试 编译程序 -g 或者cmkae&#xA;cmake .. -DCMAKE_BUILD_TYPE=Debug make #注意这个10234是端口 跟上图中设置的对应 gdbserver :10234 .</description>
    </item>
    <item>
      <title>Use_gdb</title>
      <link>https://vcvvvc.github.io/post/use_gdb/</link>
      <pubDate>Wed, 17 Feb 2021 23:02:08 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/use_gdb/</guid>
      <description>GDB 教程 转载自：https://github.com/DAN-AND-DNA/learn-gdb-by-example-for-c.git&#xA;内容 原理 启动gdb 退出gdb 为gdb进行编译 调试程序 CoreDump简单概念 产生CoreDump文件 调试CoreDump文件 help命令 list命令 start命令 next命令 step命令 break命令 查看断点 删除断点 tbreak命令 continue命令 backtrace命令 查看当前所处的函数堆栈帧 选择函数堆栈帧 打印函数局部变量 run命令 修改变量值 查看变量类型 查看线程运行 启动图像界面 原理 断点功能一般是通过gdb捕获特定的内核信号来实现的，然后定位目标程序停止的地址来判断断点是否成功触发。大致的流程为， 首先gdb fork()出来一个子进程，该子进程启动目标程序(通过ptrace() 和 exec())， 父进程捕获该子进程的所有的信号(通过ptrace() 和 wait())，当子进程收到信号时，子进程就会被挂起，直到父进程通知其继续运行(通过ptrace())&#xA;启动gdb 1 常规启动，非常多的提示信息:&#xA;$ gdb GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt; This is free software: you are free to change and redistribute it.</description>
    </item>
    <item>
      <title>Timer function</title>
      <link>https://vcvvvc.github.io/post/timer_function/</link>
      <pubDate>Sun, 07 Feb 2021 21:45:11 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/timer_function/</guid>
      <description>非活跃，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。&#xA;定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。&#xA;定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。&#xA;定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。&#xA;Linux下提供了三种定时的方法:&#xA;socket选项SO_RECVTIMEO和SO_SNDTIMEO SIGALRM信号 I/O复用系统调用的超时参数 Socket选项 struct timeval timeout; timeout.tv_sec = time; timeout.tv_usec = 0; socklen_t time_len = sizeof(timeout); ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;amp;timeout, time_len); //发送数据超时 用返回值errno判断是否达到指定时间 (errno == SO_SNDTIMEO) SIGALRM信号 sigaction结构体&#xA;struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); } sa_handler是一个函数指针，指向信号处理函数 sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息 sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号 sa_flags用于指定信号处理的行为 SA_RESTART，使被信号打断的系统调用自动重新发起 SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号 SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程 SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号 SA_RESETHAND，信号处理之后重新设置为默认的处理方式 SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数 sa_restorer一般不使用</description>
    </item>
    <item>
      <title>Server actor</title>
      <link>https://vcvvvc.github.io/post/server_actor/</link>
      <pubDate>Sun, 31 Jan 2021 22:19:30 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/server_actor/</guid>
      <description>同步IO模型通常用于实现Reactor模式, 异步IO模型则用于实现Proactor模式。&#xA;Reactor Reactor模式要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。&#xA;Reactor工作流程∶&#xA;主线程往 epoll内核事件表中注册 socket 上的读就绪事件。 主线程调用epoll_wait 等待socket上有数据可读。 当socket上有数据可读时，epoll_wait 通知主线程。主线程则将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件。 主线程调用epoll_wait 等待socket可写。 当socket可写时，epoll_wait 通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。 Procactor 将多有I/O操作都交给主线程和内核来处理, 工作线程仅负责业务逻辑&#xA;Proactor工作流程∶&#xA;主线程调用aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的 man 手册）。 主线程继续处理其他逻辑。 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。 主线程继续处理其他逻辑。 当用户缓冲区的数据被写人 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。 模拟Proactor 使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程∶&#xA;主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket上有数据可读。 当 socket 上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket上的写就绪事件。 主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll wait 通知主线程。主线程往 socket 上写人服务器处理客户请求的结果。 半同步/半异步 在I/O模型中，&amp;ldquo;同步&amp;quot;和&amp;quot;异步&amp;quot;区分的是内核向应用程序通知的是何种 I/O 事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。在并发模式中，&amp;ldquo;同步&amp;quot;指的是程序完全按照代码序列的顺序执行∶&amp;ldquo;异步&amp;quot;指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</description>
    </item>
    <item>
      <title>Linux Sem</title>
      <link>https://vcvvvc.github.io/post/sem/</link>
      <pubDate>Sat, 23 Jan 2021 20:45:54 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/sem/</guid>
      <description>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：&#xA;P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行 V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一 int sem_init(sem_t *sem, int pshared, unsigned int value)&#xA;初始化m_sem value为指定信号量的初始值&#xA;pshared为0 信号量在进程的线程之间共享 pshared非0 信号量在进程之间共享 sem_init函数用于初始化一个未命名的信号量 sem_destory函数用于销毁信号量 sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞 sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程 调用seminit函数时，操作系统将创建信号量对象，此对象中记录着“信号量值”（semaphoreValue）整数。 该值在调用sem_post函数时增1，调用semwait函数时减1。 但信号量的值不能小于0，因此，在信号量为0的情况下调用sem一vait函数时，调用函数的线程将进人阻塞状态（因为函数未返回）。 当然，此时如果有其他线程调用sem一post函数，信号量的值将变为1，而原本阻塞的线程可以将该信号量重新减为0并跳出阻塞状态。 实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为1）。 **类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制&#xA;class sem{ public: //构造函数 sem() { //信号量初始化 if(sem_init(&amp;amp;m_sem,0,0)!=0){ throw std::exception(); } } //析构函数 ~sem() { //信号量销毁 sem_destroy(&amp;amp;m_sem); } private: sem_t m_sem; }; Reference:&#xA;https://blog.csdn.net/m0_45867846/article/details/109021863</description>
    </item>
    <item>
      <title>Unp_Note</title>
      <link>https://vcvvvc.github.io/post/unp_note/</link>
      <pubDate>Mon, 11 Jan 2021 22:40:43 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/unp_note/</guid>
      <description>基本流程图 示范代码: https://github.com/vcvvvc/CPP_Test/tree/master/server/socket/practice/8_socket&#xA;TCP UDP 客户角度 服务器角度 套接字选项 config_init connect_mysql init_socket setsockopt linger </description>
    </item>
    <item>
      <title>Socket write_send</title>
      <link>https://vcvvvc.github.io/post/socket_write_send/</link>
      <pubDate>Sat, 21 Nov 2020 14:59:41 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/socket_write_send/</guid>
      <description>ssize_t write(int fd, const void*buf,size_t nbytes);&#xA;write函数将buf中的nbytes字节内容写入文件描述符fd.&#xA;成功时返回写的字节数.失败时返回-1. 并设置errno变量. 在网络程序中,当我们向套接字文件描述符写时有两可能. 1)write的返回值大于0,表示写了部分或者是全部的数据. 这样我们用一个while循环来不停的写入，但是循环过程中的buf参数和nbyte参数得由我们来更新。也就是说，网络写函数是不负责将全部数据写完之后在返回的。 2)返回的值小于0,此时出现了错误.我们要根据错误类型来处理. 如果错误为EINTR表示在写的时候出现了中断错误. 如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接).&#xA;ssize_t read(int fd,void *buf,size_t nbyte)&#xA;read函数是负责从fd中读取内容.&#xA;当读成功 时,read返回实际所读的字节数,如果返回的值是0 表示已经读到文件的结束了,小于0表示出现了错误.如果错误为EINTR说明读是由中断引起 的, 如果是ECONNREST表示网络连接出了问题. 和上面一样,我们也写一个自己的读函数.&#xA;recv和send函数提供了和read和write差不多的功能.不过它们提供了第四个参数来控制读写操作.&#xA;int recv(int sockfd,void *buf,int len,int flags) int send(int sockfd,void *buf,int len,int flags) 前面的三个参数和read, write一样,第四个参数可以是0或者是以下的组合&#xA;标题 内容 MSG_DONTROUTE 不查找表 MSG_OOB 接受或者发送带外数据 MSG_PEEK 查看数据,并不从系统缓冲区移走数据 MSG_WAITALL 等待所有数据 MSG_DONTROUTE:是 send函数使用的标志.这个标志告诉IP.目的主机在本地网络上面,没有必要查找表.这个标志一般用网络诊断和路由程序里面. MSG_OOB:表示可以接收和发送带外的数据.关于带外数据我们以后会解释的.&#xA;MSG_PEEK:是recv函数的使用标志, 表示只是从系统缓冲区中读取内容,而不清除系统缓冲区的内容.这样下次读的时候,仍然是一样的内容.一般在有多个进程读写数据时可以使用这个标志.&#xA;MSG_WAITALL 是recv函数的使用标志,表示等到所有的信息到达时才返回.使用这个标志的时候recv回一直阻塞,直到指定的条件满足,或者是发生了错误. 1)当读到了指定的字节时,函数正常返回.返回值等于len 2)当读到了文件的结尾时,函数正常返回.返回值小于len 3)当操作发生错误时,返回-1,且设置错误为相应的错误号(errno)&#xA;Re:&#xA;https://blog.csdn.net/petershina/article/details/7946615</description>
    </item>
    <item>
      <title>Vim_config</title>
      <link>https://vcvvvc.github.io/post/vim_config/</link>
      <pubDate>Tue, 13 Oct 2020 18:12:48 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/vim_config/</guid>
      <description>编译安装 #https://www.cnblogs.com/JoiT/p/build_from_source_for_linux_vim.html apt install libncurses5-dev libgtk2.0-dev libatk1.0-dev \ libcairo2-dev libx11-dev libxpm-dev libxt-dev apt-get remove --purge vim-tiny vim vim-runtime gvim vim-common vim-gui-common vim-nox ./configure --with-features=huge \ --enable-multibyte \ --enable-gui=gtk3 \ --enable-cscope \ --prefix=/usr/local make make install 主题配置 首先要确认你的终端支持真彩，一般来说，主流的比如iTerm2, Putty, Powershell的最新版本都已经支持了。我们可以运行以下命令检测一下&#xA;(echo -e &#39;\e[48:2:1:2:3m\eP$qm\e\\&#39; ; xxd)&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34;=&amp;gt;全局配置&amp;lt;=&amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34; &amp;#34;关闭vi兼容模式&amp;#34; set nocompatible &amp;#34;设置历史记录步数&amp;#34; set history=1000 &amp;#34;开启相关插件&amp;#34; &amp;#34;侦测文件类型&amp;#34; filetype on &amp;#34;载入文件类型插件&amp;#34; filetype plugin on &amp;#34;为特定文件类型载入相关缩进文件&amp;#34; filetype indent on &amp;#34;当文件在外部被修改时，自动更新该文件&amp;#34; set autoread &amp;#34;激活鼠标的使用&amp;#34; set mouse=a set selection=exclusive set selectmode=mouse,key &amp;#34;保存全局变量&amp;#34; set viminfo+=!</description>
    </item>
    <item>
      <title>C/S_B/S 架构</title>
      <link>https://vcvvvc.github.io/post/cs_bs/</link>
      <pubDate>Mon, 05 Oct 2020 16:14:49 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/cs_bs/</guid>
      <description>什么是C/S和B/S架构？&#xA;C/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。&#xA;B/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。&#xA;第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。&#xA;第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。&#xA;优点/缺点 C/S架构的优点&#xA;a. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。&#xA;b. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。&#xA;c. 客户端直接操作界面。&#xA;C/S架构的缺点&#xA;a&amp;gt; C/S架构适用于局域网，对网速的要求比较高。&#xA;b&amp;gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。&#xA;c&amp;gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。&#xA;d&amp;gt; 系统的维护也比较麻烦。&#xA;B/S架构的优点 a&amp;gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。&#xA;b&amp;gt; 浏览器只处理一些简单的逻辑事务，负担小。&#xA;c&amp;gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。&#xA;d&amp;gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。&#xA;e&amp;gt; B/S建立在广域网上，所以需要的网速要求不高。&#xA;f&amp;gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。&#xA;g&amp;gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。&#xA;B/S架构的缺点 a&amp;gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。&#xA;b&amp;gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。&#xA;第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。 https://blog.csdn.net/qq_42828949/article/details/82822901&#xA;https://blog.csdn.net/zhengqijun_/article/details/53056624</description>
    </item>
    <item>
      <title>Linux Pthread</title>
      <link>https://vcvvvc.github.io/post/pthread/</link>
      <pubDate>Sun, 27 Sep 2020 17:53:48 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/pthread/</guid>
      <description>int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)&#xA;其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构 pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用， 默认值是PTHREAD_ PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。&#xA;注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_destroy（pthread_cond_t cond）。&#xA;也可以静态的初始化条件变量&#xA;pthread_cond_t my_condition = PTHREAD_COND_INITIALIZER; pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr); // 初始化锁变量mutex。 // attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t *mutex); // 加锁（阻塞操作） pthread_mutex_trylock(pthread_mutex_t *mutex); // 试图加锁（不阻塞操作） // 当互斥锁空闲时将占有该锁；否则立即返回 // 但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t *mutex); 销毁一个不再需要的互斥量，释放系统资源。 pthread_cond_wait() / pthread_cond_timedwait -----等待条件变量，挂起线程，区别是后者，会有timeout时间， 如果到了timeout,线程自动解除阻塞，这个时间和 time()系统调用相同意义的。以1970年时间算起。 pthread_cond_signal ----激活等待列表中的线程， pthread_cond_broadcast() -------激活所有等待线程列表中最先入队的线程 条件变量&#xA;条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：&#xA;1）一个线程等待&amp;quot;条件变量的条件成立&amp;quot;而挂起； 2）另一个线程使&amp;quot;条件成立&amp;quot;（给出条件成立信号）。 为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。&#xA;注意：&#xA;1）上面这几个函数都是原子操作，可以为理解为一条指令，不会被其他程序打断&#xA;2）上面这个几个函数，必须配合使用。&#xA;3）pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，继续执行pthread_cond_wait&#xA;返回值:&#xA;pthread_mutex_lock() 和 pthread_mutex_unlock() 返回0，否则返回一个错误的提示码&#xA;pthread_mutex_trylock() 在成功获得了一个mutex的锁后返回0，否则返回一个错误提示码错误</description>
    </item>
    <item>
      <title>CPP_Mysql_use</title>
      <link>https://vcvvvc.github.io/post/mysql_use/</link>
      <pubDate>Fri, 25 Sep 2020 16:40:02 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/mysql_use/</guid>
      <description>Mysql ex mysql_init() 获取或初始化MYSQL结构 mysql_real_connect() 连接到MySQL服务器。 mysql_query() 执行指定为“以Null终结的字符串”的SQL查询 mysql_use_result() 初始化逐行的结果集检索 mysql_field_count() 返回上次执行语句的结果集的列数 mysql_fetch_row() 从结果集中获取下一行 mysql_num_fields() 返回结果集中的字段数 class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; }; 基本步骤&#xA;使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接 Re:&#xA;https://blog.csdn.net/lisonglisonglisong/article/details/25071793</description>
    </item>
    <item>
      <title>Centos7 Install mongodb</title>
      <link>https://vcvvvc.github.io/post/install_mongodb/</link>
      <pubDate>Mon, 21 Sep 2020 13:44:35 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/install_mongodb/</guid>
      <description>Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo&#xA;[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc Install Mongodb sudo yum install -y mongodb-org Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use Re:&#xA;https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</description>
    </item>
    <item>
      <title>Centos7 Install_redis</title>
      <link>https://vcvvvc.github.io/post/install_redis/</link>
      <pubDate>Mon, 21 Sep 2020 13:32:22 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/install_redis/</guid>
      <description>升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo &amp;#34;source /opt/rh/devtoolset-9/enable&amp;#34; &amp;gt;&amp;gt; /etc/profile gcc -v 安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis 配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf&#xA;daemonize no 改为 daemonize yes 开机自启 vim /etc/systemd/system/redis.service&#xA;[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.service systemctl enable redis.</description>
    </item>
    <item>
      <title>Centos7 Install mysql</title>
      <link>https://vcvvvc.github.io/post/install_mysql/</link>
      <pubDate>Sun, 20 Sep 2020 22:36:44 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/install_mysql/</guid>
      <description>1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm&#xA;2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled&#xA;3.安装Mysql5.7 sudo yum -y install mysql-community-server&#xA;4.启动Mysql sudo systemctl start mysqld&#xA;5.设置系统启动时自动启动 sudo systemctl enable mysqld&#xA;6.查看启动状态 sudo systemctl status mysqld&#xA;7.root 密码 cat /var/log/mysqld.log | grep -i &#39;temporary password&#39;&#xA;8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等&#xA;mysql_secure_installation&#xA;9.设置数据库编码为utf8 sudo vim /etc/my.cnf&#xA;[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect=&amp;#39;SET NAMES utf8&amp;#39; character-set-server = utf8 reboot sudo systemctl restart mysqld</description>
    </item>
    <item>
      <title>Mysql_use</title>
      <link>https://vcvvvc.github.io/post/mysqluse/</link>
      <pubDate>Sat, 19 Sep 2020 12:08:34 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/mysqluse/</guid>
      <description>创建数据库 CREATE DATABASE IF NOT EXISTS vctest DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. CREATE DATABASE IF NOT EXISTS mytestdb;&#xA;删除数据库 drop database test1; 2. DROP DATABASE IF EXISTS mytestdb;&#xA;查看All DB show databases;&#xA;导入sql source test.sql&#xA;select&#xA;use vctest select city, phone, country from `offices`; SELECT语句由以下列表中所述的几个子句组成：&#xA;语句中的SELECT和FROM语句是必须的，其他部分是可选的。&#xA;SELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。 即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。&#xA;SELECT lastname, firstname, jobtitle FROM employees WHERE jobtitle = &amp;#39;Sales Rep&amp;#39;; INSERT 创建表</description>
    </item>
    <item>
      <title>Socket struct</title>
      <link>https://vcvvvc.github.io/post/socket_struct/</link>
      <pubDate>Sun, 13 Sep 2020 17:03:43 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/socket_struct/</guid>
      <description>struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。&#xA;但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：&#xA;struct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息&#xA;sin_family指代协议族，在socket编程中只能是AF_INET&#xA;sin_port存储端口号（使用网络字节顺序）&#xA;sin_addr存储IP地址，使用in_addr这个数据结构&#xA;struct in_addr { unsigned long s_addr; }; 这个数据结构是由于历史原因保留下来的，主要用作与以前的格式兼容。</description>
    </item>
    <item>
      <title>Socket file</title>
      <link>https://vcvvvc.github.io/post/socket_file/</link>
      <pubDate>Sun, 13 Sep 2020 16:43:04 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/socket_file/</guid>
      <description>socket编程中需要用到的头文件&#xA;sys/types.h：数据类型定义&#xA;sys/socket.h：提供socket函数及数据结构&#xA;netinet/in.h：定义数据结构sockaddr_in&#xA;arpa/inet.h：提供IP地址转换函数&#xA;netdb.h：提供设置及获取域名的函数&#xA;sys/ioctl.h：提供对I/O控制的函数&#xA;sys/poll.h：提供socket等待测试机制的函数&#xA;其他在网络程序中常见的头文件&#xA;unistd.h：提供通用的文件、目录、程序及进程操作的函数&#xA;errno.h：提供错误号errno的定义，用于错误处理&#xA;fcntl.h：提供对文件控制的函数&#xA;time.h：提供有关时间的函数&#xA;crypt.h：提供使用DES加密算法的加密函数&#xA;pwd.h：提供对/etc/passwd文件访问的函数&#xA;shadow.h：提供对/etc/shadow文件访问的函数&#xA;pthread.h：提供多线程操作的函数&#xA;signal.h：提供对信号操作的函数&#xA;sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数&#xA;建议：在编写网络程序时，可以直接使用下面这段头文件代码&#xA;#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;malloc.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;sys/ioctl.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; 涉及到用户权限及密码验证问题时加入如下语句：&#xA;#include &amp;lt;shadow.h&amp;gt; #include &amp;lt;crypt.h&amp;gt; #include &amp;lt;pwd.h&amp;gt; 需要注意的是，应该在编译时链接加密算法库，即增加编译选项：-lcrypt&#xA;涉及到文件及时间操作加入如下语句&#xA;#include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;utime.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;sys/file.</description>
    </item>
    <item>
      <title>Cpp exception class</title>
      <link>https://vcvvvc.github.io/post/cpp_exception/</link>
      <pubDate>Sun, 13 Sep 2020 15:13:08 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/cpp_exception/</guid>
      <description>class exception{ public: exception () throw(); //构造函数 exception (const exception&amp;amp;) throw(); //拷贝构造函数 exception&amp;amp; operator= (const exception&amp;amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。&#xA;exception 类的继承层次: exception 类 直接派生类&#xA;exceptopn explain login_error logic error runtime_error 运行时错误 bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常 bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常 bad_cast 使用 dynamic_cast 转换失败时抛出的异常 ios_base::failure io 过程中出现的异常 bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型 logic_error 的派生类</description>
    </item>
    <item>
      <title>Linux cpp put Backtrace</title>
      <link>https://vcvvvc.github.io/post/backtrace/</link>
      <pubDate>Wed, 02 Sep 2020 14:10:18 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/backtrace/</guid>
      <description>获取Backtrace #include &amp;lt;execinfo.h&amp;gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file.</description>
    </item>
    <item>
      <title>epoll use</title>
      <link>https://vcvvvc.github.io/post/epoll_use/</link>
      <pubDate>Thu, 27 Aug 2020 12:09:01 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/epoll_use/</guid>
      <description>简介 #include &amp;lt;sys/epoll.h&amp;gt;&#xA;epoll与select&#xA;Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。&#xA;触发模式 epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。&#xA;水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件 //LevelTriggered(LT) //缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。&#xA;边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。 //Edge Triggered(ET) //高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)&#xA;假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除， 则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。 总结: LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。 ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据, 也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样; 而LT模式是只要有数据没有处理就会一直通知下去的. 1. 创建一个epoll的句柄 int epoll_create(int size); 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。&#xA;这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。&#xA;2. 将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //op为注册事件 epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</description>
    </item>
    <item>
      <title>Socket function</title>
      <link>https://vcvvvc.github.io/post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/socket/</guid>
      <description>setsockopt&#xA;获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 SO_LINGER选项&#xA;struct linger { int l_onoff; int l_linger; }; l_onoff = 0, 数据保持发送完成后立即返回 l_onoff = 1, l_linger = 0, 立即放回 放弃发送, 发送rst 自身立即复位 l_onoff = 1, l_linger = 1, 阻塞到超时或数据发送完成, 保持尝试发送,超时后立即结束 SO_REUSEADDR选项&#xA;改变了通配绑定时处理源地址冲突的处理方式, 让端口释放后立即就可以被再次使用&#xA;允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。一般不用于tco服务器 允许完全重复的捆绑 Re:&#xA;https://www.cnblogs.com/my_life/articles/5174585.html&#xA;https://www.jianshu.com/p/141aa1c41f15&#xA;https://blog.csdn.net/u010144805/article/details/78579528&#xA;int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：</description>
    </item>
    <item>
      <title>Makefile template</title>
      <link>https://vcvvvc.github.io/post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/makefile_template/</guid>
      <description>V1 ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $&amp;lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET) Reference: Makefile 文件 -只有include和src文件夹</description>
    </item>
    <item>
      <title>Shell_command($!, $@...)</title>
      <link>https://vcvvvc.github.io/post/shell_commans/</link>
      <pubDate>Sat, 01 Aug 2020 21:31:50 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/shell_commans/</guid>
      <description>./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value $* 1 2 3 4 </description>
    </item>
    <item>
      <title>Arch Beautify desktop</title>
      <link>https://vcvvvc.github.io/post/arch_desktop/</link>
      <pubDate>Thu, 30 Jul 2020 18:04:47 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/arch_desktop/</guid>
      <description>1. install xorg systemctl enable dhcpcd pacman -S xorg-server xorg-xinit install tool pacman -S zsh alacritty fctix fcitx-im fcitx-configtool i3 git sh -c &amp;#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;#34; install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts add user 这一步随意&#xA;useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim login new user touch .</description>
    </item>
    <item>
      <title>Vmware install Archlinux </title>
      <link>https://vcvvvc.github.io/post/arch_install/</link>
      <pubDate>Thu, 30 Jul 2020 16:43:47 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/arch_install/</guid>
      <description>0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso 准备最新景象&#xA;选择UEFI引导&#xA;1. Start ls /sys/firmware/efi/efivars 这条命令检测是否在EFI模式下&#xA;禁用 reflector&#xA;systemctl stop reflector.service&#xA;检查网络, ping qq.com&#xA;Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.&#xA;Update systime&#xA;timedatectl set-ntp true 2. Partition the disks cfdisk /dev/sda #choose gpt Move to Write , enter, yes, last Quit . 3. Format the partitions 3.</description>
    </item>
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>https://vcvvvc.github.io/post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/linux_install_boost/</guid>
      <description>Boost C++ is Cpp programming language that provides support for tasks and structures&#xA;Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压) Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc Compile &amp;amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr Test programming #include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;#34;func1:&amp;#34; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;#34;\tfunc2:&amp;#34; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl; sleep(2); } } int main() { boost::thread thread1(&amp;amp;func1); boost::thread thread2(&amp;amp;func2); system(&amp;#34;read&amp;#34;); isRuning = false; thread2.</description>
    </item>
    <item>
      <title>Ubuntu20 install FFmpeg</title>
      <link>https://vcvvvc.github.io/post/ffmpeg_install/</link>
      <pubDate>Mon, 27 Jul 2020 17:41:31 +0800</pubDate>
      <guid>https://vcvvvc.github.io/post/ffmpeg_install/</guid>
      <description>Start Download FFmpeg Install tool 1. install yasm&#xA;sudo apt-get install yasm if not installed yasm, os will output &amp;ldquo;nasm/yasm not found or too old. Use &amp;ndash;disable-x86asm for a crippled build.&amp;rdquo;&#xA;2. install SDL2&#xA;SDL2-2.0.12(stable)&#xA;tar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg&#xA;cd ffmpeg/ ./configure sudo make -j4 sudo make install 3. Check ffmpeg -version ffplay -version </description>
    </item>
  </channel>
</rss>
