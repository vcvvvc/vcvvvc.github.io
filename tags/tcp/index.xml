<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TCP on Vc</title>
    <link>/tags/tcp/</link>
    <description>Recent content in TCP on Vc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 23 Feb 2022 17:47:16 +0800</lastBuildDate><atom:link href="/tags/tcp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TCP_三次握手与四次挥手</title>
      <link>/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Sun, 20 Jun 2021 18:12:03 +0800</pubDate>
      
      <guid>/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>三次握手 第一次握手:
(客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。)
Client端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。
第二次握手:
(服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。)
Server端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack=seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK=1、SYN=1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。
第三次握手:
(客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1)
Client收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。
四次挥手 第一次挥手
(主动方发送Fin+Ack报文,并置发送序号为x)
假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN=1，这个控制位代表客户端想要断开连接；序列号seq=u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。
第二次挥手
(被动方送ACK报文,并置发送序号为Z,在确认序号为x+1)
服务端收到客户端的报文后发出确认报文，控制位ACK=1；确认号ack=u+1；序列号seq=v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。
第三次挥手
(被动方发送Fin+Ack报文,并置发送序号为Y,在确认序号为x)
客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN=1，表示服务端向客户端发送断开连接请求；确认标志ACK=1；确认序号ack=u+1；序号seq=w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。
第四次挥手
(主动方发送ack报文,并置发送序号为x,在确认序号为Y)
客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK=1；确认号ack=w+1;序号seq=u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。
相关面试题
TCP三次握手？为什么不是两次？为什么不是四次？
第一次握手, 目的端确认源端的发送能力、目的端确认目的端的接受能力 第二次握手, 源端确认源端的发送能力、源端确认源端的接受能力、源端确认目的端的发送能力、源端确认目的端的接收能力 第三次握手, 目的端确认源端的接收能力、目的端确认目的端的发送能力 因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。
TCP四次挥手？为什么不是三次？为什么不是五次？
第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN=1）。
如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。
在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？
客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：
客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN=1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
Re: https://zhuanlan.zhihu.com/p/137942749
https://zhuanlan.zhihu.com/p/40013850
https://zhuanlan.zhihu.com/p/138272238</description>
    </item>
    
    <item>
      <title>Computer_network</title>
      <link>/post/computer_network/</link>
      <pubDate>Thu, 06 May 2021 10:09:44 +0800</pubDate>
      
      <guid>/post/computer_network/</guid>
      <description>计算机网络 应用层 HTTP HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。
Cookie
HTTP 是一种不保存状态，即无状态（stateless）协议。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。 请求方法
OPTIONS
请求一些选项信息，允许客户端查看服务器的性能 GET
请求指定的页面信息，并返回实体主体 HEAD
类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST
向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 PUT
从客户端向服务器传送的数据取代指定的文档的内容 DELETE
请求服务器删除指定的页面 TRACE
回显服务器收到的请求，主要用于测试或诊断 报文
报文
是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 实体
作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。 客户端(请求报文)
请求行
用于请求的方法，请求 URI 和 HTTP 版本 状态行
含表明响应结果的状态码，原因短语和 HTTP 版本 首部字段
表示请求和响应的各种条件和属性的各类首部 通用首部 请求首部 响应首部 实体首部 服务端(响应报文) 内容同上</description>
    </item>
    
    <item>
      <title>Tcp_ip</title>
      <link>/post/tcp_ip/</link>
      <pubDate>Thu, 25 Feb 2021 14:28:11 +0800</pubDate>
      
      <guid>/post/tcp_ip/</guid>
      <description>计算机体系结构 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 封装 链路层 链路层主要有三个目的：
为IP模块发送和接收IP数据报； 为ARP模块发送ARP请求和接收ARP应答； 为RARP发送RARP请求和接收RARP应答。 PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。
环回接口
re: mtu
网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输
不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。
无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。
IP 地址分类:
IP 地址 ::= {&amp;lt;网络号&amp;gt;,&amp;lt;主机号&amp;gt;} IP地址类别 网络号 网络范围 主机号 IP地址范围 A 类 8bit，第一位固定为0 0——127 24bit 1.</description>
    </item>
    
    <item>
      <title>C/S_B/S 架构</title>
      <link>/post/cs_bs/</link>
      <pubDate>Mon, 05 Oct 2020 16:14:49 +0800</pubDate>
      
      <guid>/post/cs_bs/</guid>
      <description>什么是C/S和B/S架构？
C/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。
B/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。
第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。
第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。
优点/缺点 C/S架构的优点
a. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。
b. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。
c. 客户端直接操作界面。
C/S架构的缺点
a&amp;gt; C/S架构适用于局域网，对网速的要求比较高。
b&amp;gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。
c&amp;gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。
d&amp;gt; 系统的维护也比较麻烦。
B/S架构的优点 a&amp;gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。
b&amp;gt; 浏览器只处理一些简单的逻辑事务，负担小。
c&amp;gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。
d&amp;gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。
e&amp;gt; B/S建立在广域网上，所以需要的网速要求不高。
f&amp;gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。
g&amp;gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。
B/S架构的缺点 a&amp;gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。
b&amp;gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。
第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。 https://blog.csdn.net/qq_42828949/article/details/82822901
https://blog.csdn.net/zhengqijun_/article/details/53056624</description>
    </item>
    
  </channel>
</rss>
