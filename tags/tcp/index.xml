<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TCP on Vcvc Blog</title>
    <link>https://6923403.github.io/tags/tcp/</link>
    <description>Recent content in TCP on Vcvc Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 15 Feb 2022 20:36:44 +0800</lastBuildDate><atom:link href="https://6923403.github.io/tags/tcp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ip首部</title>
      <link>https://6923403.github.io/post/ip%E9%A6%96%E9%83%A8/</link>
      <pubDate>Tue, 15 Feb 2022 20:36:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ip%E9%A6%96%E9%83%A8/</guid>
      <description>IPv4首部   版本：由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4，因此在这个字段上的值也为“4”。
  首部长度(（IHL：Internet Header Length）)：由4比特构成，表明IP首部的大小，单位为4字节（32比特）。对于没有可选项的IP包，首部长度则设置为“5”。也就是说，当没有可选项时，IP首部的长度为20字节（4*5=20）。
  区别服务（TOS：Type Of Service）: 由8比特构成，用来表明服务质量。每一个的具体含义如表所示。
   DSCP（Differential Services Codepoint，差分服务代码点）是TOS（Type Of Services）的一部分。现在统称为DiffSer，用来进行质量控制。  如果3-5位的值为0,0~2位则被称作类别选择代码点。这样就可以向TOS的优先度那样提供8中类型的质量控级别。对于每一种级别所采取的措施则由提供DiffServ的运营管理者制定。为了与TOS保持一致，值越大优先度也越高。如果第五位为1，表示实验或本地使用的意思。
 ECN(Ecplicit Congestion Notification，显示拥塞通告)用来报告网络拥塞情况，由两个比特构成。  第6位的ECT 用以通告上传TCP层协议是否处理ECN。当路由器在转发ECN为1的包的过程中，如果出现网络拥塞的情况，就将CE位设置为1。
  总长度（Total Length）： 表示IP首部与数据部分合起来的字节数。该字段长16比特。因此IP包的最大长度为65535=2^16字节。目前还不存在能够传输最大长度为65535字节的IP包的数据链路。不过，由于有IP分片处理，从IP的上一层的角度看，不论底层采用何种数据链路，都可以认为能够以IP的最大包长传输数据。
  标识（ID：Identification）：由16比特构成，用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。通常，每发送一个IP包，它的值也逐渐递增。此外，即使IP相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。
  标志：由3比特构成，标识包被分片的相关信息。每一个的具体含义如图：
    片位移（FO：Fragment Offset）：由13比特构成，用来标识被分片的每一个分段相当于原始数据的位置。第一个分片对应的值为0.由于FO域占13位，因此最多可以表示8192（=2^13）个相对位置。单位为8字节，因此最大可表示原始数据8*8192=65536字节的位置。
  生存时间（TTL：Time To Live）：由8比特构成，它最初的意思是以秒为单位记录当前包在网络上应该生存的期限。然而，在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减1，直到变成0则丢弃该包。
  协议（Protocol）：由8比特构成，表示IP首部的下一个首部隶属于哪个协议。目前使用的协议部分如图：
    首部校验和（Header Checksum）：由16比特（2个字节）构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。校验和的计算过程，首先要将校验和的所有位置设置为0，然后以16比特为单位划分IP首部，并用1补数计算所有16位字的和。最后将所得到这个和的1补数赋给首部校验和字段。
  源地址（Source Address）：由32比特构成，表示发送端IP地址。
  目标地址（Destination Address）：由32比特构成，表示接收端IP地址。</description>
    </item>
    
    <item>
      <title>TCP_三次握手与四次挥手</title>
      <link>https://6923403.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Sun, 20 Jun 2021 18:12:03 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcp_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>三次握手 
第一次握手:
(客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。)
Client端将SYN置为1，表示希望与Server端建立连接；序号seq初始化为J，并将该数据包发送给Server端，Client进入SYN_SENT状态，等待Server确认。服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。
第二次握手:
(服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。)
Server端检查报文发现SYN为1，知道了Client端想建立连接；Server端将SYN置为1，表示Server端也希望与Clinet端建立连接；Server端将ACK置为1，表示收到了Client端建立连接的请求；Server端将seq初始化为K；Server端将ack置为J+1，这里ack=seq + 1，还有疑问（如果控制位占1字节，为什么第三次握手时有ACK=1、SYN=1，ack为什么不是+2？如果+1只是告诉服务端收到了消息，那ACK控制位就已经达到目的了，为什么还要多次一举再加一个ack?）。第二次握手包括服务端确认客户端发来的报文和服务端向客户端发送报文两个过程。
第三次握手:
(客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1)
Client收到报文后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。第三次握手包括客户端确认服务端发来的报文，客户端向服务端发送报文和服务端确认客户端发来的报文三个过程。
 四次挥手 
第一次挥手
(主动方发送Fin+Ack报文,并置发送序号为x)
假设客户端主动发起断开请求，客户端向服务端发送报文，报文首部包括FIN=1，这个控制位代表客户端想要断开连接；序列号seq=u，这时客户端进入FIN-WAIT-1（终止等待1）状态，停止发送数据，并等待服务端的确认。
第二次挥手
(被动方送ACK报文,并置发送序号为Z,在确认序号为x+1)
服务端收到客户端的报文后发出确认报文，控制位ACK=1；确认号ack=u+1；序列号seq=v；然后服务端就进入CLOSE-WAIT（关闭等待）状态。TCP服务端会告知上层的应用进程来自客户端的连接即将关闭，让应用程序做好相应的准备。此时客户端已经没有数据向服务端发送了，但服务端向客户端发送数据，客户端依然能接收。
第三次挥手
(被动方发送Fin+Ack报文,并置发送序号为Y,在确认序号为x)
客户端收到服务器确认报文后，进入FIN-WAIT-2状态。此时服务器再次发送报文，报文首部控制位FIN=1，表示服务端向客户端发送断开连接请求；确认标志ACK=1；确认序号ack=u+1；序号seq=w，然后服务器进入LAST-ACK（最后确认态），等待客户端确认。
第四次挥手
(主动方发送ack报文,并置发送序号为x,在确认序号为Y)
客户端收到了服务端的断开连接的报文后，必须发出确认报文，标志位ACK=1；确认号ack=w+1;序号seq=u+1；之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时客户端的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态关闭连接。而服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接。当客户端和服务端都进入了CLOSED状态后，客户端和服务端之间的连接才完全断开。
 相关面试题
  TCP三次握手？为什么不是两次？为什么不是四次？
 第一次握手, 目的端确认源端的发送能力、目的端确认目的端的接受能力 第二次握手, 源端确认源端的发送能力、源端确认源端的接受能力、源端确认目的端的发送能力、源端确认目的端的接收能力 第三次握手, 目的端确认源端的接收能力、目的端确认目的端的发送能力  因为2次握手表格填充不完，源端和目的端无法确认双方的收发能力；为什么不是4次握手？3次握手表格就填充完毕了，不需要再多一次握手了。
  TCP四次挥手？为什么不是三次？为什么不是五次？
第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN=1）。
如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，会造成服务端发送了回执后立刻又发送断开请求，造成服务端有数据没有全部发送至客户端，因此必须将第二次挥手和第三次挥手分开；五次挥手则完全没必要，多此一举。
  在四次挥手中，为什么客户端进入TIME_WAIT状态等待2*MSL时间，而不是直接进入CLOSED状态？
客户端在发送完给服务端的回执报文后没有立刻进入CLOSED状态，而是进入TIME-WAIT状态，然后等待2*MSL（最长报文段寿命）的时间后才进入CLOSED状态，这是为什么？原因有以下两点：
  客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN=1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；
  等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
  注：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</description>
    </item>
    
    <item>
      <title>Computer_network</title>
      <link>https://6923403.github.io/post/computer_network/</link>
      <pubDate>Thu, 06 May 2021 10:09:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/computer_network/</guid>
      <description>计算机网络 应用层 HTTP   HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。
  Cookie
 HTTP 是一种不保存状态，即无状态（stateless）协议。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。    请求方法
  OPTIONS
 请求一些选项信息，允许客户端查看服务器的性能    GET
 请求指定的页面信息，并返回实体主体    HEAD
 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头    POST
 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改    PUT
 从客户端向服务器传送的数据取代指定的文档的内容    DELETE
 请求服务器删除指定的页面    TRACE
 回显服务器收到的请求，主要用于测试或诊断      报文</description>
    </item>
    
    <item>
      <title>Tcp_ip</title>
      <link>https://6923403.github.io/post/tcp_ip/</link>
      <pubDate>Thu, 25 Feb 2021 14:28:11 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/tcp_ip/</guid>
      <description>计算机体系结构 各层作用及协议    分层 作用 协议     物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器）   数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机）   网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）   运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX   会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC   表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII   应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS     封装  链路层 链路层主要有三个目的：
 为IP模块发送和接收IP数据报； 为ARP模块发送ARP请求和接收ARP应答； 为RARP发送RARP请求和接收RARP应答。  PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。
环回接口
re: mtu
 网络层  IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议）  IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</description>
    </item>
    
    <item>
      <title>Unp_Note</title>
      <link>https://6923403.github.io/post/unp_note/</link>
      <pubDate>Mon, 11 Jan 2021 22:40:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/unp_note/</guid>
      <description>基本流程图 示范代码: https://github.com/6923403/CPP_Test/tree/master/server/socket/practice/8_socket
 TCP UDP 客户角度 服务器角度  套接字选项   config_init connect_mysql init_socket setsockopt linger  </description>
    </item>
    
    <item>
      <title>C/S_B/S 架构</title>
      <link>https://6923403.github.io/post/cs_bs/</link>
      <pubDate>Mon, 05 Oct 2020 16:14:49 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cs_bs/</guid>
      <description>什么是C/S和B/S架构？
C/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。
B/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。
第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。
第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。
 优点/缺点 C/S架构的优点
a. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。
b. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。
c. 客户端直接操作界面。
C/S架构的缺点
a&amp;gt; C/S架构适用于局域网，对网速的要求比较高。
b&amp;gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。
c&amp;gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。
d&amp;gt; 系统的维护也比较麻烦。
 B/S架构的优点  a&amp;gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。
b&amp;gt; 浏览器只处理一些简单的逻辑事务，负担小。
c&amp;gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。
d&amp;gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。
e&amp;gt; B/S建立在广域网上，所以需要的网速要求不高。
f&amp;gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。
g&amp;gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。
B/S架构的缺点  a&amp;gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。
b&amp;gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。
  第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。   https://blog.csdn.net/qq_42828949/article/details/82822901
https://blog.csdn.net/zhengqijun_/article/details/53056624</description>
    </item>
    
  </channel>
</rss>
