<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CPP on VW Blog</title>
    <link>./tags/cpp/</link>
    <description>Recent content in CPP on VW Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 11 Apr 2023 18:07:17 +0800</lastBuildDate>
    <atom:link href="./tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>STL容器总结</title>
      <link>./post/stl%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 11 Apr 2023 18:07:17 +0800</pubDate>
      <guid>./post/stl%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;hr&gt;&#xA;&lt;h2 id=&#34;re&#34;&gt;Re:&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zjy4869/p/15501384.html&#34;&gt;https://www.cnblogs.com/zjy4869/p/15501384.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zjy4869/p/15501448.html&#34;&gt;https://www.cnblogs.com/zjy4869/p/15501448.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.51cto.com/u_15717393/5471961&#34;&gt;https://blog.51cto.com/u_15717393/5471961&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zinglix.xyz/2018/09/20/STL-container/&#34;&gt;https://zinglix.xyz/2018/09/20/STL-container/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;标准网络库/对比</title>
      <link>./post/c&#43;&#43;%E6%A0%87%E5%87%86%E7%BD%91%E7%BB%9C%E5%BA%93/</link>
      <pubDate>Thu, 15 Dec 2022 14:07:46 +0800</pubDate>
      <guid>./post/c&#43;&#43;%E6%A0%87%E5%87%86%E7%BD%91%E7%BB%9C%E5%BA%93/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/357075167&#34;&gt;https://zhuanlan.zhihu.com/p/357075167&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;各编程语言http请求对比&#34;&gt;各编程语言HTTP请求对比&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;c: libcurl&lt;/li&gt;&#xA;&lt;li&gt;c#: RestSharp&lt;/li&gt;&#xA;&lt;li&gt;go: net/http&lt;/li&gt;&#xA;&lt;li&gt;java: OKHttp&lt;/li&gt;&#xA;&lt;li&gt;php: HttpRequest&lt;/li&gt;&#xA;&lt;li&gt;python: requests&lt;/li&gt;&#xA;&lt;li&gt;ruby: net/http&lt;/li&gt;&#xA;&lt;li&gt;nodejs: http&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;cc网络库对比&#34;&gt;c/c++网络库对比&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;libevent&lt;/li&gt;&#xA;&lt;li&gt;libev&lt;/li&gt;&#xA;&lt;li&gt;libuv&lt;/li&gt;&#xA;&lt;li&gt;libhv&lt;/li&gt;&#xA;&lt;li&gt;asio&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Effective C&#43;&#43; 总结</title>
      <link>./post/effective_cpp/</link>
      <pubDate>Sat, 20 Aug 2022 17:01:22 +0800</pubDate>
      <guid>./post/effective_cpp/</guid>
      <description>&lt;p&gt;2021年整理， 2023年更新一下&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;条款01-将c视为一个语言联邦&#34;&gt;条款01: 将C++视为一个语言联邦&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;C++已经是个多重范型编程语言 (multiparadigm programming language）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;条款02尽量以-constenuminline替换define&#34;&gt;条款02：尽量以 const，enum，inline替换#define&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;也可以说是 宁可以编译器替换预处理器&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;#define&lt;/code&gt; 不被视为语言的一部分 当编译出错后你可能很难找到这个错误，从而浪费大量时间&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二、 值得注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Gameplayer&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; NumTurns &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//常量声明式&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; scores[NumTurns];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;第三、 万一你的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的&amp;quot;the enum hack&amp;quot;补偿做法。其理论基础是：“一个属于枚举类型（enumerated type）的数值可权充ints被使用”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;enum hack的行为某方面说比较像#define而不像const&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Gameplayer&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; {NumTurns &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; scores[NumTurns];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;本文要点&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;对于单纯常量,最好以const对象或enums替换#defines.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;对于形似函数的宏(macros) ,最好改用inline函数替换#defines.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;条款03-尽可能使用const&#34;&gt;条款03: 尽可能使用const&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;如果关键字const出现在星号左边,表示被指物是常量;如果出现在星号右边,表示指针自身是常量;如果出现在星号两边,表示被指物和指针两者都是常量。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;修饰变量，说明该变量不可以被改变；&lt;/li&gt;&#xA;&lt;li&gt;修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；&lt;/li&gt;&#xA;&lt;li&gt;修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；&lt;/li&gt;&#xA;&lt;li&gt;修饰成员函数，说明该成员函数内不能修改成员变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; greeting;                &lt;span style=&#34;color:#75715e&#34;&gt;// 指针变量，指向字符数组变量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; greeting;          &lt;span style=&#34;color:#75715e&#34;&gt;// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; p3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; greeting;          &lt;span style=&#34;color:#75715e&#34;&gt;// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; p4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; greeting;    &lt;span style=&#34;color:#75715e&#34;&gt;// 自身是常量的指针，指向字符数组常量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;function1&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Var);           &lt;span style=&#34;color:#75715e&#34;&gt;// 传递过来的参数在函数内不可变&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;function2&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; Var);         &lt;span style=&#34;color:#75715e&#34;&gt;// 参数指针所指内容为常量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;function3&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Var);         &lt;span style=&#34;color:#75715e&#34;&gt;// 参数指针为常量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;function4&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; Var);          &lt;span style=&#34;color:#75715e&#34;&gt;// 引用参数在函数内为常量&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 函数返回值&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;function5&lt;/span&gt;();      &lt;span style=&#34;color:#75715e&#34;&gt;// 返回一个常数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;function6&lt;/span&gt;();     &lt;span style=&#34;color:#75715e&#34;&gt;// 返回一个指向常量的指针变量，使用：const int *p = function6();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;function7&lt;/span&gt;();     &lt;span style=&#34;color:#75715e&#34;&gt;// 返回一个指向变量的常指针，使用：int* const p = function7();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;const成员函数承诺绝不改变其对象的逻辑状态 (logical state) , non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数,就是冒了这样的风险:&lt;code&gt;你曾经承诺不改动的那个对象被改动了。&lt;/code&gt;这就是为什么&amp;quot;const成员函数调用non-const成员函数”是一种错误行为:因为对象有可能因此被改动。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Effective C&#43;&#43; 下</title>
      <link>./post/effective_cpp_2/</link>
      <pubDate>Sat, 20 Aug 2022 17:00:36 +0800</pubDate>
      <guid>./post/effective_cpp_2/</guid>
      <description>&lt;h3 id=&#34;条款41了解隐式接口和编译期多态&#34;&gt;条款41:了解隐式接口和编译期多态&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; doProcessing (T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; w) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (w.size() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; w &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; someNastywidget) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T &lt;span style=&#34;color:#a6e22e&#34;&gt;temp&lt;/span&gt;(w);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        temp.normalize();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        temp.swap(w);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;w必须支持哪一种接口,系由template中执行于w身上的操作来决定。&lt;/li&gt;&#xA;&lt;li&gt;凡涉及w的任何函数调用,例如operator&amp;gt;和operator!,有可能造成template具现化(instantiated) ,使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function templates&amp;quot;会导致调用不同的函数,这 便是所谓的编译期多态(compile-time polymorphism) 。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;显式接口和隐式接口的差异&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;其public接口由一个构造函数、一个析构函数、函数及其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和copy assignment操作符(见条款5) 。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;隐式接口就完全不同了。它并不基于函数签名式,而是由有效表达式(valid expressions)组成。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; doProcessing( T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; w)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (w.size() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; w &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; someNastywidget) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;它必须提供一个名为size的成员函数,该函数返回一个整数值。&lt;/li&gt;&#xA;&lt;li&gt;它必须支持一个operator!=函数,用来比较两个T对象。这里我们假设 someNastyWidget的类型为T&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;本文要点&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;classes和templates都支持接口(interfaces)和多态(polymorphism) 。&lt;/li&gt;&#xA;&lt;li&gt;对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual函数发生于运行期。&lt;/li&gt;&#xA;&lt;li&gt;对template参数而言,接口是隐式的(implicit) ,奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;条款42-了解typename的双重意义&#34;&gt;条款42: 了解typename的双重意义&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;widget&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//使用&amp;#34;class&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Widget&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//使用&amp;#34;typename&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;C++并不总是把class和typename视为等价。有时候你一定得使用 typename。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; print2nd(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; container) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (container.size() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        C&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; iterator iter(container.begin());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;iter;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;iter;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; value;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;template内出现的名 称如果相依于某个template参数, 称之为从属名称(dependent names)。如果从属 名称在class内呈嵌套状,我们称它为嵌套从属名称(nested dependent name) 。int是一个不依赖任何template参数的名称，为非从属名称(non-dependent names)。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>何为协程</title>
      <link>./post/%E4%BD%95%E4%B8%BA%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 30 Jan 2022 23:18:03 +0800</pubDate>
      <guid>./post/%E4%BD%95%E4%B8%BA%E5%8D%8F%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;什么是协程&#34;&gt;什么是协程&lt;/h2&gt;&#xA;&lt;p&gt;进程-&amp;gt;线程-&amp;gt;协程&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Re:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/&#34;&gt;https://baike.baidu.com/item/&lt;/a&gt;协程/8652240&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1916705&#34;&gt;https://cloud.tencent.com/developer/article/1916705&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/172471249&#34;&gt;https://zhuanlan.zhihu.com/p/172471249&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/32218874/answers/updated&#34;&gt;https://www.zhihu.com/question/32218874/answers/updated&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/70256971&#34;&gt;https://zhuanlan.zhihu.com/p/70256971&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/zh-cn/3/library/asyncio-task.html&#34;&gt;https://docs.python.org/zh-cn/3/library/asyncio-task.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Unity: &lt;a href=&#34;https://developer.unity.cn/projects/61c80ba3edbc2a244ffbcf25&#34;&gt;https://developer.unity.cn/projects/61c80ba3edbc2a244ffbcf25&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/821457&#34;&gt;https://www.nowcoder.com/discuss/821457&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/view/5214.html&#34;&gt;http://c.biancheng.net/view/5214.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/59178345&#34;&gt;https://zhuanlan.zhihu.com/p/59178345&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/337946103&#34;&gt;https://zhuanlan.zhihu.com/p/337946103&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;获取域名IP</title>
      <link>./post/get_domain_ip_cpp/</link>
      <pubDate>Fri, 14 Jan 2022 00:09:51 +0800</pubDate>
      <guid>./post/get_domain_ip_cpp/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#https:&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//blog.csdn.net/dosthing/article/details/80383817&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string ip &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;www.baidu.com&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hostent&lt;/span&gt; stHostent;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hostent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pstHostent &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;pptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;2048&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sprintf(buf,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ip&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; iError;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;((pstHostent &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gethostbyname(buf)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr_list &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;can&amp;#39;t parse the domain&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;official hostname: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(pptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_aliases; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pptr &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL; pptr&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alias: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pptr &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt;(pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addrtype)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; AF_INET:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; AF_INET6:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr_list;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pptr&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;NULL; pptr&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;address:%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,inet_ntop(pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addrtype, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pptr, buf,&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;first address: %s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,inet_ntop(pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addrtype, pstHostent&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr,buf,&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unkown address type&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>通过typeid()获取类名</title>
      <link>./post/typeid_get_class_name/</link>
      <pubDate>Wed, 15 Dec 2021 19:39:23 +0800</pubDate>
      <guid>./post/typeid_get_class_name/</guid>
      <description>&lt;p&gt;时间一长，模版跟继承还多容易忘，这样比看代码更效率些。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;&#xA;    TC_LockT&amp;lt;T&amp;gt;::TC_LockT(const T &amp;amp;mutex) &#xA;    {&#xA;        std::cout &amp;lt;&amp;lt; &amp;#34;1class name = &amp;#34; &amp;lt;&amp;lt; typeid(mutex).name() &amp;lt;&amp;lt; std::endl;&#xA;        std::cout &amp;lt;&amp;lt; &amp;#34;2class name = &amp;#34; &amp;lt;&amp;lt; typeid(*this).name() &amp;lt;&amp;lt; std::endl;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>readv_writev</title>
      <link>./post/readv_writev/</link>
      <pubDate>Fri, 26 Nov 2021 20:31:17 +0800</pubDate>
      <guid>./post/readv_writev/</guid>
      <description>&lt;p&gt;&lt;strong&gt;readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;sys/uio.h&amp;gt;&#xA;ssize_t readv(int filedes, const struct iovec *iov, int iovcnt); #散布读&#xA;ssize_t writev(int filedes, const struct iovec *iov, int iovcnt); #聚集写&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中的&lt;code&gt;iovec&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;sys/uio.h&amp;gt;&#xA;struct iovec {&#xA;    ptr_t iov_base; /* Starting address */&#xA;    size_t iov_len; /* Length in bytes */&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码：&lt;a href=&#34;https://github.com/vcvvvc/CPP_Test/tree/master/test/writev&#34;&gt;https://github.com/vcvvvc/CPP_Test/tree/master/test/writev&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;re&#34;&gt;Re:&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/nufangrensheng/p/3559304.html&#34;&gt;https://www.cnblogs.com/nufangrensheng/p/3559304.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/youngerchina/p/5624567.html&#34;&gt;https://www.cnblogs.com/youngerchina/p/5624567.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>ip转换函数</title>
      <link>./post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 21 Nov 2021 22:08:01 +0800</pubDate>
      <guid>./post/ip%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;主机字节序（大端） 和 网络字节序（小端)&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;大端: 0x12 | 0x32 | 0x56&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;小端: 0x56 | 0x34 | 0x12&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;Host to Network long/short&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Network to Host long/short&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uint32_t htonl(uint32_t hostlong); //将主机的无符号长整型数转换成网络字节序&#xA;uint16_t htons(uint16_t hostshort); //将主机的无符号短整形数转换成网络字节序&#xA;uint32_t ntohl(uint32_t netlong); //将一个无符号长整型数从网络字节序转换为主机字节序&#xA;uint16_t ntohs(uint16_t netshort); //将一个无符号短整形数从网络字节序转换为主机字节序&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/vcvvvc/CPP_Test/tree/master/test/hostto&#34;&gt;https://github.com/vcvvvc/CPP_Test/tree/master/test/hostto&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#把ip地址转化为用于网络传输的二进制数值(32位)&#xA;in_addr_t inet_addr(const char *cp); #少用了&#xA;int inet_aton(const char * cp, struct in_addr *inp); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#将网络传输的二进制数值转化为成点分十进制的ip地址&#xA;char* inet_ntoa(struct in_addr in);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。&#xA;地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。&#xA;int inet_pton(int family, const char *strptr, void *addrptr);&#xA;const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./img/inet_to/1.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cpp内存管理</title>
      <link>./post/cpp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 31 Oct 2021 21:51:37 +0800</pubDate>
      <guid>./post/cpp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;re&#34;&gt;Re:&lt;/h2&gt;&#xA;&lt;p&gt;收集 总结的真不错&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/findumars/p/5929831.html&#34;&gt;https://www.cnblogs.com/findumars/p/5929831.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>总结mmap(零拷贝)</title>
      <link>./post/use_mmap/</link>
      <pubDate>Mon, 04 Oct 2021 21:10:09 +0800</pubDate>
      <guid>./post/use_mmap/</guid>
      <description>&lt;p&gt;&lt;strong&gt;总结分析传统io, mmap, sendfile&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;传统io&#34;&gt;传统IO&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过write()写入到socket缓冲区，最后写入目标。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/usemmap/v1.jpg&#34; alt=&#34;v1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;整个过程发生了4次用户态和内核态的上下文切换和4次拷贝&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户进程通过read()方法向操作系统发起调用，此时上下文从用户态转向内核态&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/li&gt;&#xA;&lt;li&gt;CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，read()返回&lt;/li&gt;&#xA;&lt;li&gt;用户进程通过write()方法发起调用，上下文从用户态转为内核态&lt;/li&gt;&#xA;&lt;li&gt;CPU将应用缓冲区中数据拷贝到socket缓冲区&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/usemmap/v2.jpg&#34; alt=&#34;v2&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;mmap&#34;&gt;mmap&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。&#xA;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;调用 mmap() 系统调用对文件进行映射后，用户对映射后的内存进行读写实际上是对文件缓存的读写，所以减少了一次系统调用，从而加速了对文件读写的效率。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/usemmap/v3.jpg&#34; alt=&#34;v3&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;整个过程发生了4次用户态和内核态的上下文切换和3次拷贝，具体流程如下：&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户进程通过mmap()方法向操作系统发起调用，上下文从用户态转向内核态&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/li&gt;&#xA;&lt;li&gt;上下文从内核态转为用户态，mmap调用返回&lt;/li&gt;&#xA;&lt;li&gt;用户进程通过write()方法发起调用，上下文从用户态转为内核态&lt;/li&gt;&#xA;&lt;li&gt;CPU将读缓冲区中数据拷贝到socket缓冲区&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/usemmap/v4.jpg&#34; alt=&#34;v4&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;munmap&#34;&gt;munmap&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int munmap(void *addr, size_t len); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;munmap()用来取消参数start 所指的映射内存起始地址，参数length 则是欲取消的内存大小。当进程结束或利用exec 相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;sendfile&#34;&gt;Sendfile&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;sendfile函数在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssize_t senfile(int out_fd,int in_fd,off_t* offset,size_t count);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;整个过程发生了2次用户态和内核态的上下文切换和3次拷贝&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/li&gt;&#xA;&lt;li&gt;CPU将读缓冲区中数据拷贝到socket缓冲区&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，sendfile调用返回&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/usemmap/v5.jpg&#34; alt=&#34;v5&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;sendfiledma-scattergather&#34;&gt;sendfile+DMA Scatter/Gather&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;它将读缓冲区中的数据描述信息&amp;ndash;内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;整个过程发生了2次用户态和内核态的上下文切换和2次拷贝，其中更重要的是完全没有CPU拷贝&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户进程通过sendfile()方法向操作系统发起调用，上下文从用户态转向内核态&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储&lt;/li&gt;&#xA;&lt;li&gt;CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区&lt;/li&gt;&#xA;&lt;li&gt;DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡&lt;/li&gt;&#xA;&lt;li&gt;sendfile()调用返回，上下文从内核态切换回用户态&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/usemmap/v6.jpg&#34; alt=&#34;v6&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>类静态成员初始化、赋值</title>
      <link>./post/%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 18 Aug 2021 19:29:15 +0800</pubDate>
      <guid>./post/%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>&lt;p&gt;&lt;strong&gt;类静态成员类外初始化与在另一个类成员函数赋值&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;为什么类的静态成员要在类外初始化&#34;&gt;为什么类的静态成员要在类外初始化&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;C++的静态成员是需要初始化的（实际上需要分配一个内存，不一定需要赋值），初始化是赋一个初始值，而定义是分配内存。静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义。&#xA;静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用于相同的情况下会导致重名的问题。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态常量成员可以在类内初始化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;类的静态成员变量在另一个类赋值&#34;&gt;类的静态成员变量在另一个类赋值&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//头文件代码 a.h&#xA;class SPostMsgToMain&#xA;{&#xA;public:&#xA;&#xA;//存储消息线程的指针&#xA;static CWinThread* m_pThread;&#xA;};&#xA;&#xA;&#xA;//a.cpp&#xA;SPostMsgToMain::m_pThread=NULL;   //此处为静态成员的定义。该定义要写在实现文件里面，不能写在头文件里面&#xA;&#xA;&#xA;//thread.cpp&#xA;QueryThread::QueryThread(void)&#xA;{&#xA;    SPostMsgToMain::m_pThread = this;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;Re:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/sevenjoin/article/details/81772792&#34;&gt;https://blog.csdn.net/sevenjoin/article/details/81772792&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lvquanye9483/article/details/81946116&#34;&gt;https://blog.csdn.net/lvquanye9483/article/details/81946116&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;下面是09年已经删除的帖子，这是bing保存的快照:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://cncc.bingj.com/cache.aspx?q=%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%B5%8B%E5%80%BC&amp;amp;d=5052518157061723&amp;amp;mkt=zh-CN&amp;amp;setlang=zh-CN&amp;amp;w=Cbsmd6ZwoUn5nv9mNe0Q81efIZrRFq5l&#34;&gt;http://cncc.bingj.com/cache.aspx?q=类的静态成员变量在另一个类赋值&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cpp_stl</title>
      <link>./post/cpp_stl/</link>
      <pubDate>Sat, 12 Jun 2021 14:26:45 +0800</pubDate>
      <guid>./post/cpp_stl/</guid>
      <description>&lt;h1 id=&#34;空间配置器&#34;&gt;空间配置器&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;容器类型&#34;&gt;容器类型&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标准STL序列容器: vector,string、 deque和list.&lt;/li&gt;&#xA;&lt;li&gt;标准STL关联容器: set, multiset. map和multimap.&lt;/li&gt;&#xA;&lt;li&gt;非标准序列容器slist和rope, slist是一个单向链表, rope本质上是一“重型&amp;quot; string&lt;/li&gt;&#xA;&lt;li&gt;非标准的关联容器hash-set, hash-multiset. hash-map和hash-multimap&lt;/li&gt;&#xA;&lt;li&gt;标准的非STL容器,包括数组、bitset. valarray、 stack, queue和priority_queue.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;vector&#34;&gt;Vector&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;template &amp;lt;class T, class Alloc=alloc&amp;gt;&#xA;class vector{&#xA;private:&#xA;    //vector的嵌套型别定义&#xA;    typedef T value_type;&#xA;    typedef value_type* pointer;&#xA;    typedef value_type* iterator;&#xA;    typedef value_type&amp;amp; reference;&#xA;    typedef size_t      size_type;&#xA;    typedef ptrdiff_t   difference_type;&#xA;protect:&#xA;    // simple_alloc是SGI STL默认的空间配置器&#xA;    typedef simple_alloc&amp;lt;value_type, Alloc&amp;gt; data_allocator;&#xA;    iterator start;&#x9;&#x9;&#x9;&#x9;// 表示目前使用空间的头&#xA;    iterator finish;&#x9;&#x9;&#x9;// 表示目前使用空间的尾&#xA;    iterator end_of_storage;&#x9;// 表示目前可用空间的尾&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;vector提供的接口：包括得到vector的属性接口、vector的操作接口以及构造函数：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构造函数：vector()、vector(size_type n、const T&amp;amp; value)、vector(size_type n)；&lt;/li&gt;&#xA;&lt;li&gt;属性函数：begin、end、size、capacity、empty、operator[]、front和back&lt;/li&gt;&#xA;&lt;li&gt;操作函数：push_back()、pop_back()、erase()、resize()、clear()。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Chrono_use</title>
      <link>./post/chrono_use/</link>
      <pubDate>Tue, 01 Jun 2021 15:57:31 +0800</pubDate>
      <guid>./post/chrono_use/</guid>
      <description>&lt;h1 id=&#34;时间戳获取&#34;&gt;时间戳获取&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using namespace std::chrono;&#xA;    auto millisec_since_epoch = duration_cast&amp;lt;milliseconds&amp;gt;(system_clock::now().time_since_epoch()).count();&#xA;    auto msec = duration_cast&amp;lt;microseconds&amp;gt;(system_clock::now().time_since_epoch()).count();&#xA;&#xA;    auto sec_since_epoch = duration_cast&amp;lt;seconds&amp;gt;(system_clock::now().time_since_epoch()).count();&#xA;&#xA;    std::cout &amp;lt;&amp;lt; &amp;#34;seconds since epoch: &amp;#34; &amp;lt;&amp;lt; sec_since_epoch &amp;lt;&amp;lt; std::endl;&#xA;    std::cout &amp;lt;&amp;lt; &amp;#34;milliseconds since epoch: &amp;#34; &amp;lt;&amp;lt; millisec_since_epoch &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;秒seconds since epoch: 1622534342&lt;/li&gt;&#xA;&lt;li&gt;微妙 milliseconds since epoch: 1622534342050&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;标准年月日时间获取&#34;&gt;标准年月日+时间获取&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());&#xA;char re_time[256] = {0};&#xA;std::strftime(re_time, sizeof(re_time), &amp;#34;%Y-%m-%d %X&amp;#34;, std::localtime(&amp;amp;now));&#xA;std::cout &amp;lt;&amp;lt; “注册时间 ” &amp;lt;&amp;lt; re_time &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注册时间: 2021-06-01 15:56:42&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Re:&lt;/p&gt;</description>
    </item>
    <item>
      <title>B_Tree</title>
      <link>./post/b_tree/</link>
      <pubDate>Wed, 19 May 2021 22:48:49 +0800</pubDate>
      <guid>./post/b_tree/</guid>
      <description>&lt;h3 id=&#34;主角得拿出来文字记录下&#34;&gt;主角得拿出来文字记录下。&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;一个m阶的B树具有如下属性:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个节点最多有m-1个关键字（可以存有的键值对）。&lt;/li&gt;&#xA;&lt;li&gt;根节点最少可以只有1个关键字。&lt;/li&gt;&#xA;&lt;li&gt;非根节点至少有m/2个关键字。&lt;/li&gt;&#xA;&lt;li&gt;每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。&lt;/li&gt;&#xA;&lt;li&gt;所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。&lt;/li&gt;&#xA;&lt;li&gt;每个节点都存有索引和数据，也就是对应的key和value。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在含有n个关键字的B树上查找时，从根结点到关键字结点的 路径上涉及的结点数不超过log |m/2| ((n+1)/2)+1。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;不错的讲解&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.yiibai.com/data_structure/b-tree.html&#34;&gt;https://www.yiibai.com/data_structure/b-tree.html&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://blog.nowcoder.net/n/ef07c1ad8f8346078eeab66518152bf0&#34;&gt;https://blog.nowcoder.net/n/ef07c1ad8f8346078eeab66518152bf0&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://blog.csdn.net/alzzw/article/details/97633941&#34;&gt;https://blog.csdn.net/alzzw/article/details/97633941&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;一棵m阶的B+树和m阶的B树的差异在于:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有n棵子树的结点中包含有n个关键字；&lt;/li&gt;&#xA;&lt;li&gt;所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录 的指针，叶子结点本身依关键字的大小自小而大顺序链接；&lt;/li&gt;&#xA;&lt;li&gt;所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或 最小）关键字。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://blog.csdn.net/liu1064782986/article/details/7982290&#34;&gt;https://blog.csdn.net/liu1064782986/article/details/7982290&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩（我们称它为2结点）或三个孩子（我们称它为3结点）。&lt;/p&gt;&#xA;&lt;p&gt;一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>cpp_class权限 继承</title>
      <link>./post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 23 Apr 2021 14:01:54 +0800</pubDate>
      <guid>./post/cpp_class_%E6%9D%83%E9%99%90_%E7%BB%A7%E6%89%BF/</guid>
      <description>&lt;p&gt;补充实例： &lt;strong&gt;cpp_class继承: &lt;a href=&#34;https://vcvvvc.github.io/post/cpp_inherit/&#34;&gt;https://vcvvvc.github.io/post/cpp_inherit&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;1. private, public, protected 访问标号的访问范围&lt;/p&gt;&#xA;&lt;p&gt;private：只能由1.该类中的函数、2.其友元函数访问。&#xA;不能被任何其他访问，该类的对象也不能访问。&lt;/p&gt;&#xA;&lt;p&gt;protected：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问。&#xA;但不能被该类的对象访问。&lt;/p&gt;&#xA;&lt;p&gt;public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。&lt;/p&gt;&#xA;&lt;p&gt;注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。&lt;/p&gt;&#xA;&lt;p&gt;2 类被继承后方法属性变化&lt;/p&gt;&#xA;&lt;p&gt;private 属性不能够被继承。&#xA;使用private继承， 父类的protected和public属性在子类中变为private；&#xA;使用protected继承，父类的protected和public属性在子类中变为protected；&#xA;使用public继承， 父类的protected和public属性不发生改变;&lt;/p&gt;&#xA;&lt;p&gt;3 private继承和public继承的适用情况&lt;/p&gt;&#xA;&lt;p&gt;C++将public继承视为is-a关系。private继承则并不意味着is-a关系，private继承意味着implemented-in-terms-of（根据某物实现出）。private继承意味着只有实现部分被继承，接口部分被略去。private继承在软件设计层面上没有意义，其意义只在于软件实现层面。&lt;/p&gt;&#xA;&lt;p&gt;private继承：&lt;/p&gt;&#xA;&lt;p&gt;1）编译器不会自动将一个子类对象转换为一个父类对象，而public继承会；&lt;/p&gt;&#xA;&lt;p&gt;2）子类中由父类继承而来的成员（protected和public）都变为private。&lt;/p&gt;&#xA;&lt;p&gt;implemented-in-terms-of也可以由复合实现。在应用域，复合意味着has-a；在实现域，复合意味着is-implemented-in-terms-of。尽可能使用复合实现这种关系，必要时（涉及protected成员或virtual函数时）才使用private继承。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ae01.alicdn.com/kf/Uc2e6c6947374494d8389171edb97e0a1u.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原文链接：https://blog.csdn.net/kingzone_2008/article/details/10066181&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;虚继承&#34;&gt;虚继承&lt;/h2&gt;&#xA;&lt;p&gt;C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。解决二义性。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; sum&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; sum&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; b&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Server sum</title>
      <link>./post/server_sum/</link>
      <pubDate>Sun, 04 Apr 2021 18:21:09 +0800</pubDate>
      <guid>./post/server_sum/</guid>
      <description>&lt;h2 id=&#34;c标准网络库对比&#34;&gt;c++标准网络库对比&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post/c++%E6%A0%87%E5%87%86%E7%BD%91%E7%BB%9C%E5%BA%93/&#34;&gt;https://vcvvvc.github.io/post/c++标准网络库/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;socket-struct整理&#34;&gt;socket struct整理&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post/socket_struct/&#34;&gt;https://vcvvvc.github.io/post/socket_struct/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;socket编程需要的头文件整理&#34;&gt;socket编程需要的头文件整理&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post/socket_file/&#34;&gt;https://vcvvvc.github.io/post/socket_file/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;socket-function&#34;&gt;socket function&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post/socket/&#34;&gt;https://vcvvvc.github.io/post/socket/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;io复用&#34;&gt;I/O复用&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post//io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&#34;&gt;https://vcvvvc.github.io/post//io多路复用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;sem-function&#34;&gt;sem function&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post/sem/&#34;&gt;https://vcvvvc.github.io/post/sem/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;server-io-actor&#34;&gt;server io actor&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post/server_actor/&#34;&gt;https://vcvvvc.github.io/post/server_actor/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;timer-function&#34;&gt;timer function&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../../post/timer_function/&#34;&gt;https://vcvvvc.github.io/post/timer_function/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;linux-pthread-线程创建与使用&#34;&gt;Linux Pthread 线程创建与使用&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;../../post/pthread/&#34;&gt;https://vcvvvc.github.io/post/pthread/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;c11-thread&#34;&gt;C++11 thread&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;../../post/cppthread/&#34;&gt;https://vcvvvc.github.io/post/cppthread/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;unp-note&#34;&gt;Unp note&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;../../post/unp_note/&#34;&gt;https://vcvvvc.github.io/post/unp_note/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;tcp_ip--计算机网络&#34;&gt;TCP_IP | 计算机网络&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;../../post/computer_network/&#34;&gt;https://vcvvvc.github.io/post/computer_network/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;exception-class-异常类&#34;&gt;exception class 异常类&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;../../post/cpp_exception/&#34;&gt;https://vcvvvc.github.io/post/cpp_exception/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>getopt_long</title>
      <link>./post/getopt_long/</link>
      <pubDate>Sun, 14 Mar 2021 14:26:33 +0800</pubDate>
      <guid>./post/getopt_long/</guid>
      <description>&lt;p&gt;&lt;strong&gt;2021-5-31更新&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;&#xA;extern char *optarg;&#xA;extern int optind, opterr, optopt;&#xA;#include &amp;lt;getopt.h&amp;gt;&#xA;int getopt(int argc, char * const argv[],const char *optstring);&#xA;int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);&#xA;int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数以及返回值介绍（以上三个函数都适用）：&lt;/p&gt;&#xA;&lt;p&gt;1、argc和argv和main函数的两个参数一致。&lt;/p&gt;&#xA;&lt;p&gt;2、optstring: 表示短选项字符串。&lt;/p&gt;&#xA;&lt;p&gt;形式如“a:b::cd:“，分别表示程序支持的命令行短选项有-a、-b、-c、-d，冒号含义如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只有一个字符，不带冒号——只表示选项， 如-c &lt;/li&gt;&#xA;&lt;li&gt;一个字符，后接一个冒号——表示选项后面带一个参数，如-a 100&lt;/li&gt;&#xA;&lt;li&gt;一个字符，后接两个冒号——表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数直接不能有空格,形式应该如-b&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;3、longopts：表示长选项结构体。结构如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct option&#xA;{&#xA;     const char *name;&#xA;     int         has_arg;&#xA;     int        *flag;&#xA;     int         val;&#xA;};&#xA;&#xA; static struct option longOpts[] = {&#xA;      { &amp;#34;daemon&amp;#34;, no_argument, NULL, &amp;#39;D&amp;#39; },&#xA;      { &amp;#34;dir&amp;#34;, required_argument, NULL, &amp;#39;d&amp;#39; },&#xA;      { &amp;#34;out&amp;#34;, required_argument, NULL, &amp;#39;o&amp;#39; },&#xA;      { &amp;#34;log&amp;#34;, required_argument, NULL, &amp;#39;l&amp;#39; },&#xA;      { &amp;#34;split&amp;#34;, required_argument, NULL, &amp;#39;s&amp;#39; },&#xA;      { &amp;#34;http-proxy&amp;#34;, required_argument, &amp;amp;lopt, 1 },&#xA;      { &amp;#34;http-user&amp;#34;, required_argument, &amp;amp;lopt, 2 },&#xA;      { &amp;#34;http-passwd&amp;#34;, required_argument, &amp;amp;lopt, 3 },&#xA;      { &amp;#34;http-proxy-user&amp;#34;, required_argument, &amp;amp;lopt, 4 },&#xA;      { &amp;#34;http-proxy-passwd&amp;#34;, required_argument, &amp;amp;lopt, 5 },&#xA;      { &amp;#34;http-auth-scheme&amp;#34;, required_argument, &amp;amp;lopt, 6 },&#xA;      { &amp;#34;version&amp;#34;, no_argument, NULL, &amp;#39;v&amp;#39; },&#xA;      { &amp;#34;help&amp;#34;, no_argument, NULL, &amp;#39;h&amp;#39; },&#xA;      { 0, 0, 0, 0 }&#xA;    };&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(1)name:表示选项的名称,比如daemon,dir,out等。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Use_gdb</title>
      <link>./post/use_gdb/</link>
      <pubDate>Wed, 17 Feb 2021 23:02:08 +0800</pubDate>
      <guid>./post/use_gdb/</guid>
      <description>&lt;h1 id=&#34;gdb-教程&#34;&gt;GDB 教程&lt;/h1&gt;&#xA;&lt;p&gt;转载自：https://github.com/DAN-AND-DNA/learn-gdb-by-example-for-c.git&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8gdb&#34;&gt;启动gdb&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E9%80%80%E5%87%BAgdb&#34;&gt;退出gdb&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B8%BAgdb%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91&#34;&gt;为gdb进行编译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F&#34;&gt;调试程序&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#CoreDump%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5&#34;&gt;CoreDump简单概念&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BA%A7%E7%94%9FCoreDump%E6%96%87%E4%BB%B6&#34;&gt;产生CoreDump文件&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%B0%83%E8%AF%95CoreDump%E6%96%87%E4%BB%B6&#34;&gt;调试CoreDump文件&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#help%E5%91%BD%E4%BB%A4&#34;&gt;help命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#list%E5%91%BD%E4%BB%A4&#34;&gt;list命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#start%E5%91%BD%E4%BB%A4&#34;&gt;start命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#next%E5%91%BD%E4%BB%A4&#34;&gt;next命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#step%E5%91%BD%E4%BB%A4&#34;&gt;step命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#break%E5%91%BD%E4%BB%A4&#34;&gt;break命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E6%96%AD%E7%82%B9&#34;&gt;查看断点&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%A0%E9%99%A4%E6%96%AD%E7%82%B9&#34;&gt;删除断点&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#tbreak%E5%91%BD%E4%BB%A4&#34;&gt;tbreak命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#continue%E5%91%BD%E4%BB%A4&#34;&gt;continue命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#backtrace%E5%91%BD%E4%BB%A4&#34;&gt;backtrace命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%89%80%E5%A4%84%E7%9A%84%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88%E5%B8%A7&#34;&gt;查看当前所处的函数堆栈帧&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88%E5%B8%A7&#34;&gt;选择函数堆栈帧&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&#34;&gt;打印函数局部变量&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#run%E5%91%BD%E4%BB%A4&#34;&gt;run命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E5%80%BC&#34;&gt;修改变量值&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B&#34;&gt;查看变量类型&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C&#34;&gt;查看线程运行&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%83%8F%E7%95%8C%E9%9D%A2&#34;&gt;启动图像界面&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;&#xA;&lt;p&gt;断点功能一般是通过gdb捕获特定的内核信号来实现的，然后定位目标程序停止的地址来判断断点是否成功触发。大致的流程为，&#xA;首先gdb fork()出来一个子进程，该子进程启动目标程序(通过ptrace() 和 exec())，&#xA;父进程捕获该子进程的所有的信号(通过ptrace() 和 wait())，当子进程收到信号时，子进程就会被挂起，直到父进程通知其继续运行(通过ptrace())&lt;/p&gt;&#xA;&lt;h2 id=&#34;启动gdb&#34;&gt;启动gdb&lt;/h2&gt;&#xA;&lt;p&gt;1 常规启动，非常多的提示信息:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ gdb&#xA;GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7&#xA;Copyright (C) 2013 Free Software Foundation, Inc.&#xA;License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;&#xA;This is free software: you are free to change and redistribute it.&#xA;There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;&#xA;and &amp;quot;show warranty&amp;quot; for details.&#xA;This GDB was configured as &amp;quot;x86_64-redhat-linux-gnu&amp;quot;.&#xA;For bug reporting instructions, please see:&#xA;&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.&#xA;(gdb)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;2 简约启动，关闭提示信息:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unp_Note</title>
      <link>./post/unp_note/</link>
      <pubDate>Mon, 11 Jan 2021 22:40:43 +0800</pubDate>
      <guid>./post/unp_note/</guid>
      <description>&lt;h1 id=&#34;基本流程图&#34;&gt;基本流程图&lt;/h1&gt;&#xA;&lt;p&gt;示范代码: &lt;a href=&#34;https://github.com/vcvvvc/CPP_Test/tree/master/server/socket/practice/8_socket&#34;&gt;https://github.com/vcvvvc/CPP_Test/tree/master/server/socket/practice/8_socket&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;tcp&#34;&gt;TCP&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/unp/server.png&#34; alt=&#34;server&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;udp&#34;&gt;UDP&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/unp/con_udp.jpg&#34; alt=&#34;udp&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;客户角度&#34;&gt;客户角度&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/unp/server2.png&#34; alt=&#34;server2&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务器角度&#34;&gt;服务器角度&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/unp/server3.png&#34; alt=&#34;server3&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;套接字选项&#34;&gt;套接字选项&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/unp/server4.png&#34; alt=&#34;server4&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/unp/server5.png&#34; alt=&#34;server5&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;config_init&lt;/li&gt;&#xA;&lt;li&gt;connect_mysql&lt;/li&gt;&#xA;&lt;li&gt;init_socket&lt;/li&gt;&#xA;&lt;li&gt;setsockopt linger&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Vim_config</title>
      <link>./post/vim_config/</link>
      <pubDate>Tue, 13 Oct 2020 18:12:48 +0800</pubDate>
      <guid>./post/vim_config/</guid>
      <description>&lt;h1 id=&#34;编译安装&#34;&gt;编译安装&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#https://www.cnblogs.com/JoiT/p/build_from_source_for_linux_vim.html&#xA;apt install libncurses5-dev libgtk2.0-dev libatk1.0-dev \&#xA;libcairo2-dev libx11-dev libxpm-dev libxt-dev&#xA;&#xA;apt-get remove --purge vim-tiny vim vim-runtime gvim vim-common vim-gui-common vim-nox&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./configure --with-features=huge \&#xA;    --enable-multibyte \&#xA;    --enable-gui=gtk3 \&#xA;    --enable-cscope \&#xA;    --prefix=/usr/local&#xA;&#xA;make &#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;主题配置&#34;&gt;主题配置&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;首先要确认你的终端支持真彩，一般来说，主流的比如iTerm2, Putty, Powershell的最新版本都已经支持了。我们可以运行以下命令检测一下&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;(echo -e &#39;\e[48:2:1:2:3m\eP$qm\e\\&#39; ; xxd)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&amp;#34;&amp;#34;&amp;#34;=&amp;gt;全局配置&amp;lt;=&amp;#34;&amp;#34;&amp;#34;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;关闭vi兼容模式&amp;#34;&#xA;&#xA;set nocompatible&#xA;&#xA;&amp;#34;设置历史记录步数&amp;#34;&#xA;&#xA;set history=1000&#xA;&#xA;&amp;#34;开启相关插件&amp;#34;   &#xA;&#xA;&amp;#34;侦测文件类型&amp;#34;&#xA;&#xA;filetype on&#xA;&#xA;&amp;#34;载入文件类型插件&amp;#34;&#xA;&#xA;filetype plugin on&#xA;&#xA;&amp;#34;为特定文件类型载入相关缩进文件&amp;#34;&#xA;&#xA;filetype indent on&#xA;&#xA;&amp;#34;当文件在外部被修改时，自动更新该文件&amp;#34;&#xA;&#xA;set autoread&#xA;&#xA;&amp;#34;激活鼠标的使用&amp;#34;&#xA;&#xA;set mouse=a&#xA;&#xA;set selection=exclusive&#xA;&#xA;set selectmode=mouse,key&#xA;&#xA;&amp;#34;保存全局变量&amp;#34;&#xA;&#xA;set viminfo+=!&#xA;&#xA;&amp;#34;带有如下符号的单词不要被换行分割&amp;#34;&#xA;&#xA;set iskeyword+=_,$,@,%,#,-&#xA;&#xA;&amp;#34;通过使用: commands命令，告诉我们文件的哪一行被改变过&amp;#34;&#xA;&#xA;set report=0&#xA;&#xA;&amp;#34;被分割的窗口间显示空白，便于阅读&amp;#34;&#xA;&#xA;set fillchars=vert:\ ,stl:\ ,stlnc:\&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;=&amp;gt;字体和颜色&amp;lt;=&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;自动开启语法高亮&amp;#34;&#xA;&#xA;syntax enable&#xA;&#xA;&amp;#34;设置字体&amp;#34;&#xA;&#xA;&amp;#34;set guifont=dejaVu\ Sans\ MONO\ 10&#xA;&#xA;set guifont=Courier_New:h10:cANSI&#xA;&#xA;&amp;#34;设置颜色&amp;#34;&#xA;&#xA;&amp;#34;colorscheme desert&#xA;&#xA;&amp;#34;#set t_Co=256 记着注释或者删除这一行&amp;#34;&#xA;&#xA;if has(&amp;#34;termguicolors&amp;#34;)&#xA;&#xA;    set termguicolors&#xA;&#xA;endif&#xA;&#xA;&amp;#34;高亮显示当前行&amp;#34;&#xA;&#xA;&amp;#34;set cursorline    白色条框 不喜欢可以关闭&amp;#34;&#xA;&#xA;set cursorline  &#xA;&#xA;&amp;#34;hi cursorline guibg=#00ff00&amp;#34;&#xA;&#xA;&amp;#34;hi CursorColumn guibg=#00ff00&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;=&amp;gt;代码折叠功能&amp;lt;=&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;激活折叠功能&amp;#34;&#xA;&#xA;set foldenable&#xA;&#xA;&amp;#34;set nofen（这个是关闭折叠功能）&amp;#34;&#xA;&#xA;&amp;#34;设置按照语法方式折叠（可简写set fdm=XX）&amp;#34;&#xA;&#xA;&amp;#34;有6种折叠方法：&#xA;&#xA;&amp;#34;manual  手工定义折叠&amp;#34;&#xA;&#xA;&amp;#34;indent  更多的缩进表示更高级别的折叠&amp;#34;&#xA;&#xA;&amp;#34;expr    用表达式来定义折叠&amp;#34;&#xA;&#xA;&amp;#34;syntax  用语法高亮来定义折叠&amp;#34;&#xA;&#xA;&amp;#34;diff    对没有更改的文本进行折叠&amp;#34;&#xA;&#xA;&amp;#34;marker  对文中的标志进行折叠&amp;#34;&#xA;&#xA;set foldmethod=manual&#xA;&#xA;&amp;#34;set fdl=0（这个是不选用任何折叠方法）&amp;#34;&#xA;&#xA;&amp;#34;设置折叠区域的宽度&amp;#34;&#xA;&#xA;&amp;#34;如果不为0，则在屏幕左侧显示一个折叠标识列&#xA;&#xA;&amp;#34;分别用“-”和“+”来表示打开和关闭的折叠&#xA;&#xA;set foldcolumn=0&#xA;&#xA;&amp;#34;设置折叠层数为3&amp;#34;&#xA;&#xA;setlocal foldlevel=3&#xA;&#xA;&amp;#34;设置为自动关闭折叠&amp;#34;&#xA;&#xA;set foldclose=all&#xA;&#xA;&amp;#34;用空格键来代替zo和zc快捷键实现开关折叠&amp;#34;&#xA;&#xA;&amp;#34;zo O-pen a fold (打开折叠)&#xA;&#xA;&amp;#34;zc C-lose a fold (关闭折叠)&#xA;&#xA;&amp;#34;zf F-old creation (创建折叠)&#xA;&#xA;&amp;#34;nnoremap &amp;lt;space&amp;gt; @=((foldclosed(line(&amp;#39;.&amp;#39;)) &amp;lt; 0) ? &amp;#39;zc&amp;#39; : &amp;#39;zo&amp;#39;)&amp;lt;CR&amp;gt;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;=&amp;gt;文字处理&amp;lt;=&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;使用空格来替换Tab&amp;#34;&#xA;&#xA;set expandtab&#xA;&#xA;&amp;#34;设置所有的Tab和缩进为4个空格&amp;#34;&#xA;&#xA;set tabstop=4&#xA;&#xA;&amp;#34;设定&amp;lt;&amp;lt;和&amp;gt;&amp;gt;命令移动时的宽度为4&amp;#34;&#xA;&#xA;set shiftwidth=4&#xA;&#xA;&amp;#34;使得按退格键时可以一次删除4个空格&amp;#34;&#xA;&#xA;set softtabstop=4&#xA;&#xA;set smarttab&#xA;&#xA;&amp;#34;缩进，自动缩进（继承前一行的缩进）&amp;#34;&#xA;&#xA;&amp;#34;set autoindent 命令打开自动缩进，是下面配置的缩写&#xA;&#xA;&amp;#34;可使用autoindent命令的简写，即“:set ai”和“:set noai”&#xA;&#xA;&amp;#34;还可以使用“:set ai sw=4”在一个命令中打开缩进并设置缩进级别&#xA;&#xA;set ai&#xA;&#xA;set cindent&#xA;&#xA;&amp;#34;智能缩进&amp;#34;&#xA;&#xA;set si&#xA;&#xA;&amp;#34;自动换行”&#xA;&#xA;set wrap&#xA;&#xA;&amp;#34;设置软宽度&amp;#34;&#xA;&#xA;set sw=4&#xA;&#xA;&amp;#34;行内替换&amp;#34;&#xA;&#xA;set gdefault&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;=&amp;gt;Vim 界面&amp;lt;=&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;增强模式中的命令行自动完成操作&amp;#34;&#xA;&#xA;set wildmenu&#xA;&#xA;&amp;#34;显示标尺&amp;#34;&#xA;&#xA;set ruler&#xA;&#xA;&amp;#34;设置命令行的高度&amp;#34;&#xA;&#xA;set cmdheight=1&#xA;&#xA;&amp;#34;显示行数&amp;#34;&#xA;&#xA;set nu&#xA;&#xA;&amp;#34;不要图形按钮&amp;#34;&#xA;&#xA;set go=&#xA;&#xA;&amp;#34;在执行宏命令时，不进行显示重绘；在宏命令执行完成后，一次性重绘，以便提高性能&amp;#34;&#xA;&#xA;set lz&#xA;&#xA;&amp;#34;使回格键（backspace）正常处理indent, eol, start等&amp;#34;&#xA;&#xA;set backspace=eol,start,indent&#xA;&#xA;&amp;#34;允许空格键和光标键跨越行边界&amp;#34;&#xA;&#xA;set whichwrap+=&amp;lt;,&amp;gt;,h,l&#xA;&#xA;&amp;#34;设置魔术&amp;#34;&#xA;&#xA;set magic&#xA;&#xA;&amp;#34;关闭遇到错误时的声音提示&amp;#34;&#xA;&#xA;&amp;#34;关闭错误信息响铃&amp;#34;&#xA;&#xA;set noerrorbells&#xA;&#xA;&amp;#34;关闭使用可视响铃代替呼叫&amp;#34;&#xA;&#xA;set novisualbell&#xA;&#xA;&amp;#34;高亮显示匹配的括号([{和}])&amp;#34;&#xA;&#xA;set showmatch&#xA;&#xA;&amp;#34;匹配括号高亮的时间（单位是十分之一秒）&amp;#34;&#xA;&#xA;set mat=2&#xA;&#xA;&amp;#34;光标移动到buffer的顶部和底部时保持3行距离&amp;#34;&#xA;&#xA;set scrolloff=3&#xA;&#xA;&amp;#34;搜索逐字符高亮&amp;#34;&#xA;&#xA;set hlsearch&#xA;&#xA;set incsearch&#xA;&#xA;&amp;#34;搜索时不区分大小写&amp;#34;&#xA;&#xA;&amp;#34;还可以使用简写（“:set ic”和“:set noic”）&amp;#34;&#xA;&#xA;set ignorecase&#xA;&#xA;&amp;#34;用浅色高亮显示当前行&amp;#34;&#xA;&#xA;autocmd InsertLeave * se nocul&#xA;&#xA;autocmd InsertEnter * se cul&#xA;&#xA;&amp;#34;输入的命令显示出来，看的清楚&amp;#34;&#xA;&#xA;set showcmd&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;=&amp;gt;编码设置&amp;lt;=&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;设置编码&amp;#34;&#xA;&#xA;set encoding=utf-8&#xA;&#xA;set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&#xA;&#xA;&amp;#34;设置文件编码&amp;#34;&#xA;&#xA;set fileencodings=utf-8,gbk,latin1&#xA;&#xA;&amp;#34;设置终端编码&amp;#34;&#xA;&#xA;set termencoding=utf-8&#xA;&#xA;&amp;#34;设置语言编码&amp;#34;&#xA;&#xA;set langmenu=zh_CN.UTF-8&#xA;&#xA;set helplang=cn&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;=&amp;gt;其他设置&amp;lt;=&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&#xA;&#xA;&amp;#34;开启新行时使用智能自动缩进&amp;#34;&#xA;&#xA;set smartindent&#xA;&#xA;set cin&#xA;&#xA;set showmatch&#xA;&#xA;&amp;#34;在处理未保存或只读文件的时候，弹出确认&amp;#34;&#xA;&#xA;set confirm&#xA;&#xA;&amp;#34;隐藏工具栏&amp;#34;&#xA;&#xA;set guioptions-=T&#xA;&#xA;&amp;#34;隐藏菜单栏&amp;#34;&#xA;&#xA;set guioptions-=m&#xA;&#xA;&amp;#34;置空错误铃声的终端代码&amp;#34;&#xA;&#xA;set vb t_vb=&#xA;&#xA;&amp;#34;显示状态栏（默认值为1，表示无法显示状态栏）&amp;#34;&#xA;&#xA;set laststatus=2&#xA;&#xA;&amp;#34;状态行显示的内容&amp;#34;&#xA;&#xA;set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&amp;#34;%d/%m/%y\ -\ %H:%M\&amp;#34;)}&#xA;&#xA;&amp;#34;粘贴不换行问题的解决方法&amp;#34;&#xA;&#xA;set pastetoggle=&amp;lt;F9&amp;gt;&#xA;&#xA;&amp;#34;设置背景颜色&amp;#34;&#xA;&#xA;set background=dark&#xA;&#xA;&amp;#34;文件类型自动检测，代码智能补全&amp;#34;&#xA;&#xA;set completeopt=longest,preview,menu&#xA;&#xA;&amp;#34;共享剪切板&amp;#34;&#xA;&#xA;set clipboard+=unnamed&#xA;&#xA;&amp;#34;从不备份&amp;#34;&#xA;&#xA;set nobackup&#xA;&#xA;set noswapfile&#xA;&#xA;&amp;#34;自动保存&amp;#34;&#xA;&#xA;set autowrite&#xA;&#xA;&amp;#34;显示中文帮助&amp;#34;&#xA;&#xA;if version &amp;gt;= 603&#xA;&#xA;        set helplang=cn&#xA;&#xA;            set encoding=utf-8&#xA;&#xA;endif&#xA;&#xA;&amp;#34;设置高亮相关项&amp;#34;&#xA;&#xA;highlight Search ctermbg=black ctermfg=white guifg=white guibg=black&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>CPP_Const</title>
      <link>./post/cppconst/</link>
      <pubDate>Tue, 06 Oct 2020 15:03:40 +0800</pubDate>
      <guid>./post/cppconst/</guid>
      <description>&lt;h1 id=&#34;const&#34;&gt;const&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;修饰变量，变量不可以被改变；&lt;/li&gt;&#xA;&lt;li&gt;修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；&lt;/li&gt;&#xA;&lt;li&gt;修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；&lt;/li&gt;&#xA;&lt;li&gt;修饰成员函数，说明该成员函数内不能修改成员变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 类&#xA;class A&#xA;{&#xA;private:&#xA;    const int a;                // 常对象成员，只能在初始化列表赋值&#xA;&#xA;public:&#xA;    // 构造函数&#xA;    A() : a(0) { };&#xA;    A(int x) : a(x) { };        // 初始化列表&#xA;&#xA;    // const可用于对重载函数的区分&#xA;    int getValue();             // 普通成员函数&#xA;    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值&#xA;};&#xA;&#xA;void function()&#xA;{&#xA;    // 对象&#xA;    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量&#xA;    const A a;                  // 常对象，只能调用常成员函数&#xA;    const A *p = &amp;amp;a;            // 指针变量，指向常对象&#xA;    const A &amp;amp;q = a;             // 指向常对象的引用&#xA;&#xA;    // 指针&#xA;    char greeting[] = &amp;#34;Hello&amp;#34;;&#xA;    char* p1 = greeting;                // 指针变量，指向字符数组变量&#xA;    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）&#xA;    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）&#xA;    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量&#xA;}&#xA;&#xA;// 函数&#xA;void function1(const int Var);           // 传递过来的参数在函数内不可变&#xA;void function2(const char* Var);         // 参数指针所指内容为常量&#xA;void function3(char* const Var);         // 参数指针为常量&#xA;void function4(const int&amp;amp; Var);          // 引用参数在函数内为常量&#xA;&#xA;// 函数返回值&#xA;const int function5();      // 返回一个常数&#xA;const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();&#xA;int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;const-的指针与引用&#34;&gt;const 的指针与引用&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向常量的指针（pointer to const）&lt;/li&gt;&#xA;&lt;li&gt;自身是常量的指针（常量指针，const pointer）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;引用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向常量的引用（reference to const）&lt;/li&gt;&#xA;&lt;li&gt;没有 const reference，因为引用本身就是 const pointer&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;用法小结&#34;&gt;用法小结&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;指针&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algorithm x^n</title>
      <link>./post/recursion/</link>
      <pubDate>Sun, 04 Oct 2020 16:09:26 +0800</pubDate>
      <guid>./post/recursion/</guid>
      <description>&lt;p&gt;&lt;strong&gt;O(1)常数阶 &amp;lt; O(logn)对数阶 &amp;lt; O(n)线性阶 &amp;lt; O(n^2)平方阶 &amp;lt; O(n^3)(立方阶) &amp;lt; O(2^n) (指数阶)&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;for-on&#34;&gt;For O(n)&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int function1(int x, int n) {&#xA;    int result = 1;  // 注意 任何数的0次方等于1&#xA;    for (int i = 0; i &amp;lt; n; i++) {&#xA;        result = result * x;&#xA;    }&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;recursion-on&#34;&gt;Recursion O(n)&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int function2(int x, int n) {&#xA;    if (n == 0) {&#xA;        return 1; // return 1 同样是因为0次方是等于1的&#xA;    }&#xA;    return function2(x, n - 1) * x;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;recursion2-on&#34;&gt;Recursion2 O(n)&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int function3(int x, int n) {&#xA;    if (n == 0) {&#xA;        return 1;&#xA;    }&#xA;    if (n % 2 == 1) {&#xA;        return function3(x, n/2) * function3(x, n/2)*x;&#xA;    }&#xA;    return function3(x, n/2) * function3(x, n/2);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;recursion3-ologn&#34;&gt;Recursion3 O(logn)&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int function4(int x, int n) {&#xA;    if (n == 0) {&#xA;        return 1;&#xA;    }&#xA;    int t = function4(x, n/2);// 这里相对于function3，是把这个递归操作抽取出来&#xA;    if (n % 2 == 1) {&#xA;        return t*t*x;&#xA;    }&#xA;    return t*t;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Linux Pthread</title>
      <link>./post/pthread/</link>
      <pubDate>Sun, 27 Sep 2020 17:53:48 +0800</pubDate>
      <guid>./post/pthread/</guid>
      <description>&lt;p&gt;&lt;code&gt;int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构 pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用，&lt;/strong&gt;&#xA;&lt;strong&gt;默认值是&lt;/strong&gt;&lt;code&gt;PTHREAD_ PROCESS_PRIVATE&lt;/code&gt;，&lt;strong&gt;即此条件变量被同一进程内的各个线程使用。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_destroy（pthread_cond_t cond）。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;也可以静态的初始化条件变量&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pthread_cond_t my_condition = PTHREAD_COND_INITIALIZER;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr);&#xA;// 初始化锁变量mutex。&#xA;// attr为锁属性，NULL值为默认属性。&#xA;&#xA;pthread_mutex_lock(pthread_mutex_t *mutex);&#xA;// 加锁（阻塞操作）&#xA;&#xA;pthread_mutex_trylock(pthread_mutex_t *mutex);&#xA;// 试图加锁（不阻塞操作）&#xA;// 当互斥锁空闲时将占有该锁；否则立即返回&#xA;// 但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。&#xA;&#xA;pthread_mutex_unlock(pthread_mutex_t *mutex);&#xA;释放锁&#xA;&#xA;pthread_mutex_destroy(pthread_mutex_t *mutex);&#xA;销毁一个不再需要的互斥量，释放系统资源。&#xA;&#xA;pthread_cond_wait() / pthread_cond_timedwait -----等待条件变量，挂起线程，区别是后者，会有timeout时间，&#xA;如果到了timeout,线程自动解除阻塞，这个时间和 time()系统调用相同意义的。以1970年时间算起。&#xA;&#xA;pthread_cond_signal ----激活等待列表中的线程，&#xA;&#xA;pthread_cond_broadcast() -------激活所有等待线程列表中最先入队的线程&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;条件变量&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1）一个线程等待&amp;quot;条件变量的条件成立&amp;quot;而挂起；&lt;/li&gt;&#xA;&lt;li&gt;2）另一个线程使&amp;quot;条件成立&amp;quot;（给出条件成立信号）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;注意：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;1）上面这几个函数都是原子操作，可以为理解为一条指令，不会被其他程序打断&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2）上面这个几个函数，必须配合使用。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;3）pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，继续执行pthread_cond_wait&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;返回值:&lt;/p&gt;&#xA;&lt;p&gt;pthread_mutex_lock() 和 pthread_mutex_unlock() 返回0，否则返回一个错误的提示码&lt;/p&gt;&#xA;&lt;p&gt;pthread_mutex_trylock() 在成功获得了一个mutex的锁后返回0，否则返回一个错误提示码错误&lt;/p&gt;&#xA;&lt;p&gt;pthread_mutex_lock() 和 pthread_mutex_unlock()失败的时候 [EINVAL] mutex在生成的时候，它的protocol属性的值是 PTHREAD_PRIO_PROTECT，同时调用线程的优先级(priority)比该mutex的当前prority上限高&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cpp_inherit</title>
      <link>./post/cpp_inherit/</link>
      <pubDate>Fri, 25 Sep 2020 17:44:01 +0800</pubDate>
      <guid>./post/cpp_inherit/</guid>
      <description>&lt;p&gt;&lt;code&gt;class derived-class: access-specifier base-class&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Shape&#xA;{&#xA;   public:&#xA;      void setWidth(int w)&#xA;      {&#xA;         width = w;&#xA;      }&#xA;      void setHeight(int h)&#xA;      {&#xA;         height = h;&#xA;      }&#xA;   protected:&#xA;      int width;&#xA;      int height;&#xA;};&#xA;// 派生类&#xA;class Rectangle: public Shape&#xA;{&#xA;   public:&#xA;      int getArea()&#xA;      {&#xA;         return (width * height);&#xA;      }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Rectangle rect;&#xA;rect.setWidth(3);&#xA;rect.setHeight(5);&#xA;&#xA;#rect result = 15&#xA;cout &amp;lt;&amp;lt; rect.getArea() &amp;lt;&amp;lt; endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;访问控制和继承&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;访问&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;public&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;protected&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;private&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;同一个类&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;yes&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;yes&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;yes&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;派生类&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;yes&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;yes&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;no&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;外部的类&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;yes&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;no&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;no&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。&lt;/li&gt;&#xA;&lt;li&gt;保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。&lt;/li&gt;&#xA;&lt;li&gt;私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>CPP_Mysql_use</title>
      <link>./post/mysql_use/</link>
      <pubDate>Fri, 25 Sep 2020 16:40:02 +0800</pubDate>
      <guid>./post/mysql_use/</guid>
      <description>&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Mysql&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;ex&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;mysql_init()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;获取或初始化MYSQL结构&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;mysql_real_connect()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;连接到MySQL服务器。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;mysql_query()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;执行指定为“以Null终结的字符串”的SQL查询&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;mysql_use_result()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;初始化逐行的结果集检索&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;mysql_field_count()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;返回上次执行语句的结果集的列数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;mysql_fetch_row()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;从结果集中获取下一行&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;mysql_num_fields()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;返回结果集中的字段数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class MyDB&#xA;{&#xA;public:&#xA;&#x9;MyDB();&#xA;&#x9;~MyDB();&#xA;&#x9;bool initDB(string host, string user, string pwd, string db_name);&#xA;&#x9;bool exeSQL(string sql);&#xA;private:&#xA;&#x9;MYSQL *connection;&#xA;&#x9;MYSQL_RES *result;&#xA;&#x9;MYSQL_ROW row;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;基本步骤&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;使用mysql_init()初始化连接&#xA;使用mysql_real_connect()建立一个到mysql数据库的连接&#xA;使用mysql_query()执行查询语句&#xA;result = mysql_use_result(conn)获取结果集&#xA;mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数&#xA;通过mysql_fetch_row(result)不断获取下一行，然后循环输出&#xA;释放结果集所占内存mysql_free_result(result)&#xA;mysql_close(conn)关闭连接&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;Re:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lisonglisonglisong/article/details/25071793&#34;&gt;https://blog.csdn.net/lisonglisonglisong/article/details/25071793&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Left_Right</title>
      <link>./post/leftright/</link>
      <pubDate>Thu, 17 Sep 2020 21:49:43 +0800</pubDate>
      <guid>./post/leftright/</guid>
      <description>&lt;p&gt;&lt;strong&gt;形参（形式参数）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;实参（实际参数）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Re: &lt;a href=&#34;http://c.biancheng.net/view/1853.html&#34;&gt;http://c.biancheng.net/view/1853.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;左值和右值&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/view/1510.html&#34;&gt;http://c.biancheng.net/view/1510.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;常量和变量&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/cprogramming/c-variables.html&#34;&gt;https://www.runoob.com/cprogramming/c-variables.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/cprogramming/c-constants.html&#34;&gt;https://www.runoob.com/cprogramming/c-constants.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/cpp/html/19.html&#34;&gt;http://c.biancheng.net/cpp/html/19.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>About function: Volatile</title>
      <link>./post/volatile/</link>
      <pubDate>Sun, 13 Sep 2020 18:12:48 +0800</pubDate>
      <guid>./post/volatile/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/33074506&#34;&gt;https://zhuanlan.zhihu.com/p/33074506&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/w3cnote/c-volatile-keyword.html&#34;&gt;https://www.runoob.com/w3cnote/c-volatile-keyword.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Socket struct</title>
      <link>./post/socket_struct/</link>
      <pubDate>Sun, 13 Sep 2020 17:03:43 +0800</pubDate>
      <guid>./post/socket_struct/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct sockaddr {&#xA;    unsigned short sa_family; /* address family, AF_xxx */&#xA;    char sa_data[14]; /* 14 bytes of protocol address */&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct sockaddr_in {&#xA;    short int sin_family; /* Address family */&#xA;    unsigned short int sin_port; /* Port number */&#xA;    struct in_addr sin_addr; /* Internet address */&#xA;    unsigned char sin_zero[8]; /* Same size as struct sockaddr */&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sin_family指代协议族，在socket编程中只能是AF_INET&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sin_port存储端口号（使用网络字节顺序）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sin_addr存储IP地址，使用in_addr这个数据结构&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct in_addr {&#xA;    unsigned long s_addr;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;这个数据结构是由于历史原因保留下来的，主要用作与以前的格式兼容。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;s_addr按照网络字节顺序存储IP地址&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Socket file</title>
      <link>./post/socket_file/</link>
      <pubDate>Sun, 13 Sep 2020 16:43:04 +0800</pubDate>
      <guid>./post/socket_file/</guid>
      <description>&lt;p&gt;&lt;strong&gt;socket编程中需要用到的头文件&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sys/types.h：数据类型定义&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sys/socket.h：提供socket函数及数据结构&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;netinet/in.h：定义数据结构sockaddr_in&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;arpa/inet.h：提供IP地址转换函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;netdb.h：提供设置及获取域名的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sys/ioctl.h：提供对I/O控制的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sys/poll.h：提供socket等待测试机制的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;其他在网络程序中常见的头文件&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;unistd.h：提供通用的文件、目录、程序及进程操作的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;errno.h：提供错误号errno的定义，用于错误处理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;fcntl.h：提供对文件控制的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;time.h：提供有关时间的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;crypt.h：提供使用DES加密算法的加密函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;pwd.h：提供对/etc/passwd文件访问的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;shadow.h：提供对/etc/shadow文件访问的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;pthread.h：提供多线程操作的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;signal.h：提供对信号操作的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;建议：在编写网络程序时，可以直接使用下面这段头文件代码&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &amp;lt;sys/types.h&amp;gt;&#xA;#include &amp;lt;sys/socket.h&amp;gt;&#xA;#include &amp;lt;netdb.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;ctype.h&amp;gt;&#xA;#include &amp;lt;errno.h&amp;gt;&#xA;#include &amp;lt;malloc.h&amp;gt;&#xA;#include &amp;lt;netinet/in.h&amp;gt;&#xA;#include &amp;lt;arpa/inet.h&amp;gt;&#xA;#include &amp;lt;sys/ioctl.h&amp;gt;&#xA;#include &amp;lt;stdarg.h&amp;gt;&#xA;#include &amp;lt;fcntl.h&amp;gt;&#xA;#include &amp;lt;fcntl.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;涉及到用户权限及密码验证问题时加入如下语句：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;shadow.h&amp;gt;&#xA;#include &amp;lt;crypt.h&amp;gt;&#xA;#include &amp;lt;pwd.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;需要注意的是，应该在编译时链接加密算法库，即增加编译选项：-lcrypt&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;涉及到文件及时间操作加入如下语句&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;sys/time.h&amp;gt;&#xA;#include &amp;lt;utime.h&amp;gt;&#xA;#include &amp;lt;time.h&amp;gt;&#xA;#include &amp;lt;sys/stat.h&amp;gt;&#xA;#include &amp;lt;sys/file.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;涉及到多进程操作时加入如下语句&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cpp exception class</title>
      <link>./post/cpp_exception/</link>
      <pubDate>Sun, 13 Sep 2020 15:13:08 +0800</pubDate>
      <guid>./post/cpp_exception/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class exception{&#xA;public:&#xA;    exception () throw();  //构造函数&#xA;    exception (const exception&amp;amp;) throw();  //拷贝构造函数&#xA;    exception&amp;amp; operator= (const exception&amp;amp;) throw();  //运算符重载&#xA;    virtual ~exception() throw();  //虚析构函数&#xA;    virtual const char* what() const throw();  //虚函数&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;exception-类的继承层次&#34;&gt;exception 类的继承层次:&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/cpp_exception/exception1.jpg&#34; alt=&#34;exception&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;exception-类&#34;&gt;exception 类&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;直接派生类&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;exceptopn&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;explain&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;login_error&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;logic error&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;runtime_error&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;运行时错误&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;bad_alloc&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;使用 new 或 new[] 分配内存失败时抛出的异常&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;bad_typeid&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;bad_cast&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;使用 dynamic_cast 转换失败时抛出的异常&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;ios_base::failure&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;io 过程中出现的异常&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;bad_exception&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;logic_error 的派生类&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux cpp put Backtrace</title>
      <link>./post/backtrace/</link>
      <pubDate>Wed, 02 Sep 2020 14:10:18 +0800</pubDate>
      <guid>./post/backtrace/</guid>
      <description>&lt;h1 id=&#34;获取backtrace&#34;&gt;获取Backtrace&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;execinfo.h&amp;gt;&#xA;&#xA;/* Store up to SIZE return address of the current program state in&#xA;   ARRAY and return the exact number of values stored.  */&#xA;int backtrace(void **array, int size);&#xA;&#xA;/* Return names of functions from the backtrace list in ARRAY in a newly&#xA;   malloc()ed memory block.  */&#xA;char **backtrace_symbols(void *const *array, int size);&#xA;&#xA;/* This function is similar to backtrace_symbols() but it writes the result&#xA;   immediately to a file.  */&#xA;void backtrace_symbols_fd(void *const *array, int size, int fd);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;int backtrace(void **buffer,int size)&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cpp11 move</title>
      <link>./post/move/</link>
      <pubDate>Sun, 30 Aug 2020 19:57:05 +0800</pubDate>
      <guid>./post/move/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;utility&amp;gt;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;int main()&#xA;{&#xA;    std::string str = &amp;#34;Hello&amp;#34;;&#xA;    std::vector&amp;lt;std::string&amp;gt; v;&#xA;    //调用常规的拷贝构造函数，新建字符数组，拷贝数据&#xA;    v.push_back(str);&#xA;    std::cout &amp;lt;&amp;lt; &amp;#34;After copy, str is \&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34;\n&amp;#34;;&#xA;    //调用移动构造函数，掏空str，掏空后，最好不要使用str&#xA;    v.push_back(std::move(str));&#xA;    std::cout &amp;lt;&amp;lt; &amp;#34;After move, str is \&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34;\n&amp;#34;;&#xA;    std::cout &amp;lt;&amp;lt; &amp;#34;The contents of the vector are \&amp;#34;&amp;#34; &amp;lt;&amp;lt; v[0]&#xA;                                         &amp;lt;&amp;lt; &amp;#34;\&amp;#34;, \&amp;#34;&amp;#34; &amp;lt;&amp;lt; v[1] &amp;lt;&amp;lt; &amp;#34;\&amp;#34;\n&amp;#34;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cout:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;After copy, str is &amp;#34;Hello&amp;#34;&#xA;After move, str is &amp;#34;&amp;#34;&#xA;The contents of the vector are &amp;#34;Hello&amp;#34;, &amp;#34;Hello&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;函数原型&#34;&gt;函数原型&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;&#xA;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; t)&#xA;{&#xA;&#x9;return static_cast&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;原型定义中的原理实现&#34;&gt;原型定义中的原理实现:&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;公式一）X&amp;amp; &amp;amp;、X&amp;amp;&amp;amp; &amp;amp;、X&amp;amp; &amp;amp;&amp;amp;都折叠成X&amp;amp;，用于处理左值&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>CPP11_thread</title>
      <link>./post/cppthread/</link>
      <pubDate>Sat, 29 Aug 2020 11:44:31 +0800</pubDate>
      <guid>./post/cppthread/</guid>
      <description>&lt;h1 id=&#34;create_thread-ex&#34;&gt;create_thread Ex&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;1.导入#include&lt;!-- raw HTML omitted --&gt;&amp;mdash;用于创建线程&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2.导入#include&lt;!-- raw HTML omitted --&gt;&amp;ndash;用于时间延时 获取时间之类的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;定义一个线程对象t1，这就自动创建了一个线程，参数就是你要线程去执行的函数，t1是变量名字 随便取&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;std::thread t1(func);&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;下面这里返回一个毫秒级别的时间间隔参数值，间隔10毫秒&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;std::chrono::milliseconds(10)&#xA;this_thread::sleep_for（）就是让此线程休眠，可以传入休眠的时间&#xA;this_thread::sleep_for(std::chrono::milliseconds(10));让本线程休眠10毫秒&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;thread4&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;join()就是阻塞线程&#xA;阻塞的目的就是让Main主线程等待一下创建的线程，免得我函数还在跑，程序就直接结束了。&lt;/li&gt;&#xA;&lt;li&gt;detach()将线程与线程对象分离&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;thread5&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;c++11还提供了一个&lt;code&gt;lock_guard&lt;/code&gt;类，它利用了RAII机制可以保证安全释放mutex。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;lock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;thread6&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;c++11还提供了&lt;code&gt;std::unique_lock&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。&#xA;unique_lock比lock_guard使用更加灵活，功能更加强大。&#xA;使用unique_lock需要付出更多的时间、性能成本。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;thread7&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;互斥量很像的条件变量的知识&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;条件变量&lt;code&gt;std::condition_variable&lt;/code&gt;的使用&lt;/strong&gt;&#xA;&lt;code&gt;std::condition_variable&lt;/code&gt; 是为了解决死锁而生的。 当互斥操作不够用而引入的。&lt;/p&gt;&#xA;&lt;p&gt;比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::condition_variable&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;notify_one()用于唤醒一个线程；&lt;/li&gt;&#xA;&lt;li&gt;notify_all() 则是通知所有线程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;thread8&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;原子变量的使用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在新标准C++11，引入了原子操作的概念，原子操作更接近内核，并通过这个新的头文件提供了多种原子操作数据类型.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;thread9&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;future与promise的使用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在c++11中增加的线程库很方便的让我们去使用线程，但是因为做出了一些改变，我们并不能像往常一样直接使用thread.join()获取线程函数的返回值了，而我们有时候又确实要利用线程函数的返回值。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;thread库提供了future用来访问异步操作的结果，因为一个异步操作的结果往往不能立即获取，只能在未来的某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future .&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;future和promise的作用是在不同线程之间传递数据。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;假设线程1需要线程2的数据，那么组合使用方式如下:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;线程1初始化一个promise对象和一个future对象，promise传递给线程2，相当于线程2对线程1的一个承诺；future相当于一个接受一个承诺，用来获取未来线程2传递的值&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;线程2获取到promise后，需要对这个promise传递有关的数据，之后线程1的future就可以获取数据了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果线程1想要获取数据，而线程2未给出数据，则线程1阻塞，直到线程2的数据到达&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/cppthread/thread9.png&#34; alt=&#34;thread9&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;thread10&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;future与package_task的使用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::packaged_task&lt;/code&gt;包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;std::packaged_task&lt;/code&gt;将其包装的可调用对象的执行结果传递给一个std::future对象，与std::promise某种程度上是很像的，promise保存一个共享状态的值，而package_task保存的是一个函数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Socket function</title>
      <link>./post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      <guid>./post/socket/</guid>
      <description>&lt;p&gt;&lt;strong&gt;setsockopt&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时，&#xA;&#xA;选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选&#xA;&#xA;项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./img/socket/1.png&#34; alt=&#34;option&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;SO_LINGER选项&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct linger&#xA;{&#xA;    int l_onoff;&#xA;    int l_linger;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;l_onoff = 0, 数据保持发送完成后立即返回&lt;/li&gt;&#xA;&lt;li&gt;l_onoff = 1, l_linger = 0, 立即放回 放弃发送, 发送rst 自身立即复位&lt;/li&gt;&#xA;&lt;li&gt;l_onoff = 1, l_linger = 1, 阻塞到超时或数据发送完成, 保持尝试发送,超时后立即结束&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;SO_REUSEADDR选项&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;改变了通配绑定时处理源地址冲突的处理方式, 让端口释放后立即就可以被再次使用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在&lt;/li&gt;&#xA;&lt;li&gt;允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可&lt;/li&gt;&#xA;&lt;li&gt;允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。一般不用于tco服务器&lt;/li&gt;&#xA;&lt;li&gt;允许完全重复的捆绑&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Re:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/my_life/articles/5174585.html&#34;&gt;https://www.cnblogs.com/my_life/articles/5174585.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/141aa1c41f15&#34;&gt;https://www.jianshu.com/p/141aa1c41f15&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u010144805/article/details/78579528&#34;&gt;https://blog.csdn.net/u010144805/article/details/78579528&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int fcntl(int fd, int cmd);&#xA;int fcntl(int fd, int cmd, long arg);&#xA;int fcntl(int fd, int cmd, struct flock *lock);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;fcntl函数有5种功能：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.复制一个现有的描述符（cmd=F_DUPFD）.&lt;/li&gt;&#xA;&lt;li&gt;2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).&lt;/li&gt;&#xA;&lt;li&gt;3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).&lt;/li&gt;&#xA;&lt;li&gt;4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).&lt;/li&gt;&#xA;&lt;li&gt;5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Re: &lt;a href=&#34;https://www.cnblogs.com/xuyh/p/3273082.html&#34;&gt;https://www.cnblogs.com/xuyh/p/3273082.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Makefile template</title>
      <link>./post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      <guid>./post/makefile_template/</guid>
      <description>&lt;h1 id=&#34;v1&#34;&gt;V1&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xA;############ 交叉编译&#xA;CROSS_COMPILE=aarch64-himix100-linux-&#xA;CC=$(CROSS_COMPILE)g++&#xA;&#xA;# 当前路径&#xA;PWD := $(shell pwd)&#xA;&#xA;#库&#xA;LIB += -lpthread -lsqlite3&#xA;&#xA;#参数&#xA;CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g&#xA;&#xA;#.cpp源文件&#xA;SRCS=$(wildcard ./src/*.cpp)&#xA;&#xA;#头文件&#xA;INC=-I$(PWD)/include&#xA;&#xA;#中间文件&#xA;OBJS=$(SRCS:.cpp=.o)&#xA;&#xA;#二进制文件&#xA;BIN=maincpp&#xA;&#xA;#start，表示开始执行&#xA;start:$(OBJS)&#xA;&#x9;$(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB)&#xA;&#xA;.cpp.o:&#xA;&#x9;$(CC) $(INC)  -o $@ -c $&amp;lt; $(CFLAB) $(LIB)&#xA;&#xA;.PHONY : clean&#xA;clean:&#xA;&#x9;rm -f ${BIN} ./src/*.o&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;v2&#34;&gt;V2&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Makefile&#xA;cc=gcc&#xA;&#xA;LDFLAGS=-lncurses&#xA;&#xA;SRCS := $(wildcard *.c)&#xA;TARGET := $(SRCS:%.c=%)&#xA;&#xA;$(TARGET):$(SRCS)&#xA;&#x9;$(cc) $(LDFLAGS) $(SRCS) -o $(TARGET)&#xA;&#xA;clean:&#xA;&#x9;rm $(TARGET)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;reference&#34;&gt;Reference:&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_38184741/article/details/84450937&#34;&gt;Makefile 文件 -只有include和src文件夹&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Binary Tree</title>
      <link>./post/binary_tree/</link>
      <pubDate>Tue, 18 Aug 2020 14:40:25 +0800</pubDate>
      <guid>./post/binary_tree/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数&#xA;为n 2 ,则n 0 =n 2 +1。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x&#xA;的最大整数)。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序&#xA;编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;1.如果i=1,则结点i是二叉树的根,无双亲;如果i&amp;gt;1,则其双亲是结&#xA;点。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2.如果2i&amp;gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是&#xA;结点2i。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;3.如果2i+1&amp;gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;树转换为二叉树&#34;&gt;树转换为二叉树&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;将树转换为二叉树的步骤如下&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;1.加线。在所有兄弟结点之间加一条连&#xA;线。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删&#xA;除它与其他孩子结点之间的连线。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;3.层次调整。以树的根结点为轴心,&#xA;将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子&#xA;是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/binarytree/tree1.png&#34; alt=&#34;tree1&#34;&gt;&#xA;&lt;img src=&#34;./img/binarytree/tree2.png&#34; alt=&#34;tree2&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;森林转换为二叉树&#34;&gt;森林转换为二叉树&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.把每个树转换为二叉树。&lt;/li&gt;&#xA;&lt;li&gt;2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵&#xA;二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。&#xA;当所有的二叉树连接起来后就得到了由森林转换来的二叉树。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/binarytree/tree3.png&#34; alt=&#34;tree3&#34;&gt;&#xA;&lt;img src=&#34;./img/binarytree/tree4.png&#34; alt=&#34;tree4&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;二叉树转换为树&#34;&gt;二叉树转换为树&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.加线。若某结点的左孩子结点存在,则将&#xA;这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右&#xA;孩子结点&amp;hellip;&amp;hellip;哈,反正就是左孩子的n个右孩子结点都作为此结点的孩&#xA;子。将该结点与这些右孩子结点用线连接起来。&lt;/li&gt;&#xA;&lt;li&gt;2.去线。删除原二叉树中所有结点与其右孩子结点的连线。&lt;/li&gt;&#xA;&lt;li&gt;3.层次调整。使之结构层次分明。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/binarytree/tree5.png&#34; alt=&#34;tree5&#34;&gt;&#xA;&lt;img src=&#34;./img/binarytree/tree6.png&#34; alt=&#34;tree6&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;二叉树转换为森林&#34;&gt;二叉树转换为森林&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;判断一棵二叉树能够转换成一棵树还是森林,标准很简单,那就是只要&#xA;看这棵二叉树的根结点有没有右孩子,有就是森林,没有就是一棵树。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.从根结点开始,若右孩子存在,则把与右孩子结点的连线删除,再查看分离后的二叉树,若右孩子存在,则连线删除&amp;hellip;&amp;hellip;,直到所有右孩子连线都删除为止,得到分离的二&#xA;叉树。&lt;/li&gt;&#xA;&lt;li&gt;2.再将每棵分离后的二叉树转换为树即可。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./img/binarytree/tree7.png&#34; alt=&#34;tree7&#34;&gt;&#xA;&lt;img src=&#34;./img/binarytree/tree8.png&#34; alt=&#34;tree8&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;树与森林的遍历&#34;&gt;树与森林的遍历&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;树的遍历分为两种方式。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.一种是先根遍历树,即先访问树的根结点,&#xA;然后依次先根遍历根的每棵子树。&lt;/li&gt;&#xA;&lt;li&gt;2.另一种是后根遍历,即先依次后根&#xA;遍历每棵子树,然后再访问根结点。比如图tree6/7中右下方的树,它的&#xA;先根遍历序列为ABEFCDG,后根遍历序列为EFBCGDA。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;森林的遍历也分为两种方式:&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; auto ponit</title>
      <link>./post/cpp_auto_ponit/</link>
      <pubDate>Mon, 17 Aug 2020 15:10:13 +0800</pubDate>
      <guid>./post/cpp_auto_ponit/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。&lt;/li&gt;&#xA;&lt;li&gt;Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;1shared_ptr&#34;&gt;1.shared_ptr&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;shared_ptr&amp;lt;T&amp;gt; sp&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;3-make_shared&#34;&gt;3. make_shared&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;make_shared&amp;lt;T&amp;gt;(args)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shared_ptr&amp;lt;int&amp;gt; p = make_shared&amp;lt;int&amp;gt;(42);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;3weak_ptr&#34;&gt;3.weak_ptr&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;4unique_ptr&#34;&gt;4.unique_ptr&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;unique_ptr&amp;lt;T&amp;gt; up&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Constexpr</title>
      <link>./post/constexpr/</link>
      <pubDate>Fri, 14 Aug 2020 16:16:33 +0800</pubDate>
      <guid>./post/constexpr/</guid>
      <description>&lt;h1 id=&#34;0array&#34;&gt;0.Array&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int url[10]; //true&#xA;int url[6 + 4] //true&#xA;&#xA;int len = 10;&#xA;int url[len] //flase&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;1constexpr&#34;&gt;1.Constexpr&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int main()&#xA;{&#xA;    /*&#xA;     * If have not constexpr, CPP throw error&#xA;     */&#xA;    constexpr int num = 1 + 2 + 3; &#xA;    int url[num] = {1,2,3,4,5,6};&#xA;    couts&amp;lt;&amp;lt; url[1] &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;2only-have-one-return&#34;&gt;2.Only have one &amp;lsquo;return&amp;rsquo;&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Error&#xA;constexpr int display(int x) {&#xA;    int ret = 1 + 2 + x;&#xA;    return ret;&#xA;}&#xA;&#xA;# True&#xA;constexpr int display(int x) {&#xA;    return 1 + 2 + x;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;3must-have-return&#34;&gt;3.Must have &amp;lsquo;return&amp;rsquo;&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Error&#xA;constexpr void display() {&#xA;    ... &#xA;}&#xA;&#xA;# True &#xA;constexpr int display() {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;4must-have-funciion-declaration&#34;&gt;4.Must have funciion declaration&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;int noconst_dis(int x);&#xA;&#xA;// constexpr&#xA;constexpr int display(int x);&#xA;&#xA;constexpr int display(int x){&#xA;    return 1 + 2 + x;&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    int a[display(3)] = { 1,2,3,4 };&#xA;    cout &amp;lt;&amp;lt; a[2] &amp;lt;&amp;lt; endl;&#xA;    cout &amp;lt;&amp;lt; noconst_dis(3) &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&#xA;int noconst_dis(int x) {&#xA;    return 1 + 2 + x;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;5return-must-constant-expession&#34;&gt;5.&amp;lsquo;Return&amp;rsquo; must constant expession&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int num = 3;&#xA;constexpr int display(int x){&#xA;    return num + x;&#xA;}&#xA;int main()&#xA;{&#xA;    //display(3) not is constant &#xA;    int a[display(3)] = { 1,2,3,4 };&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;6constexpr-struct&#34;&gt;6.Constexpr struct&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Error&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;constexpr struct myType {&#xA;    const char* name;&#xA;    int age;&#xA;};&#xA;int main()&#xA;{&#xA;    constexpr struct myType mt { &amp;#34;zhangsan&amp;#34;, 10 };&#xA;    cout &amp;lt;&amp;lt; mt.name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; mt.age &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&#xA;# True&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;struct myType {&#xA;    constexpr myType(char *name,int age):name(name),age(age){};&#xA;    const char* name;&#xA;    int age;&#xA;};&#xA;&#xA;int main()&#xA;{&#xA;    constexpr struct myType mt { &amp;#34;zhangsan&amp;#34;, 10 };&#xA;    cout &amp;lt;&amp;lt; mt.name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; mt.age &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;7-class&#34;&gt;7. CLass&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;//自定义类型的定义&#xA;class myType {&#xA;public:&#xA;    constexpr myType(const char *name,int age):name(name),age(age){};&#xA;    constexpr const char * getname(){&#xA;        return name;&#xA;    }&#xA;&#xA;    /*&#xA;     * unsupport virtual function&#xA;     */&#xA;    constexpr int getage(){&#xA;        return age;&#xA;    }&#xA;private:&#xA;    const char* name;&#xA;    int age;&#xA;    //其它结构体成员&#xA;};&#xA;int main()&#xA;{&#xA;    constexpr struct myType mt { &amp;#34;zhangsan&amp;#34;, 10 };&#xA;    constexpr const char * name = mt.getname();&#xA;    constexpr int age = mt.getage();&#xA;    cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;8template&#34;&gt;8.Template&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;struct myType {&#xA;    const char* name;&#xA;    int age;&#xA;};&#xA;&#xA;template&amp;lt;typename T&amp;gt;&#xA;constexpr T dispaly(T t){&#xA;    return t;&#xA;}&#xA;int main()&#xA;{&#xA;    struct myType stu{&amp;#34;zhangsan&amp;#34;,10};&#xA;&#xA;    struct myType ret = dispaly(stu);&#xA;    cout &amp;lt;&amp;lt; ret.name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; ret.age &amp;lt;&amp;lt; endl;&#xA;&#xA;    constexpr int ret1 = dispaly(10);&#xA;    cout &amp;lt;&amp;lt; ret1 &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Variable function(fun(char *, ...)) and vsnprintf()</title>
      <link>./post/variable_function/</link>
      <pubDate>Tue, 28 Jul 2020 14:44:30 +0800</pubDate>
      <guid>./post/variable_function/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;void fun(char * fmt, &amp;hellip;); &lt;br&gt;&#xA;int vsprintf(char *str, const char *format, va_list arg);&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;test-programming&#34;&gt;Test programming&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdarg.h&amp;gt;&#xA;&#xA;/*&#xA; * Re: https://github.com/antirez/kilo/kilo.c&#xA; * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html&#xA; */&#xA;&#xA;char buffer[80];&#xA;&#xA;int editorSetstatus(const char * fmt, ...)&#xA;{&#xA;    va_list ap;&#xA;    va_start(ap, fmt);&#xA;    int ret;&#xA;    ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap);&#xA;&#xA;    va_end(ap);&#xA;&#xA;    return (ret);&#xA;}&#xA;&#xA;int main(int argc, char **argv)&#xA;{&#xA;    int len = 20;&#xA;    editorSetstatus(&amp;#34;%d&amp;#34;, len);&#xA;&#xA;    printf(&amp;#34;%s \n&amp;#34;, buffer);&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;gcc -Wall -g fun.c -o fun&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>./post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      <guid>./post/linux_install_boost/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Boost C++ is Cpp programming language that provides support for tasks and structures&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;download-source&#34;&gt;Download Source&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz&#xA;tar zxvf boost(解压)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;set-use-gcc&#34;&gt;Set use GCC&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cd boost&#xA;./bootstrap.sh --with-libraries=all --with-toolset=gcc&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;compile--install-boost&#34;&gt;Compile &amp;amp; Install boost&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./b2 toolset=gcc&#xA;./b2 install --prefix=/usr&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;test-programming&#34;&gt;Test programming&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;using namespace std;&#xA;&#xA;volatile bool isRuning = true;&#xA;&#xA;void func1()&#xA;{&#xA;    static int cnt1 = 0;&#xA;    while(isRuning)&#xA;    {&#xA;        cout &amp;lt;&amp;lt; &amp;#34;func1:&amp;#34; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl;&#xA;        sleep(1);&#xA;    }&#xA;}&#xA;&#xA;void func2()&#xA;{&#xA;    static int cnt2 = 0;&#xA;    while(isRuning)&#xA;    {&#xA;        cout &amp;lt;&amp;lt; &amp;#34;\tfunc2:&amp;#34; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl;&#xA;        sleep(2);&#xA;    }&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    boost::thread thread1(&amp;amp;func1);&#xA;    boost::thread thread2(&amp;amp;func2);&#xA;&#xA;    system(&amp;#34;read&amp;#34;);&#xA;    isRuning = false;&#xA;&#xA;    thread2.join();&#xA;    thread1.join();&#xA;    cout &amp;lt;&amp;lt; &amp;#34;exit&amp;#34; &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;g++ main.cpp -g -o main -lboost_thread -lpthread&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
