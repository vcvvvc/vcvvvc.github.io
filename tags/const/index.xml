<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Const on VW Blog</title>
    <link>./tags/const/</link>
    <description>Recent content in Const on VW Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 06 Oct 2020 15:03:40 +0800</lastBuildDate>
    <atom:link href="./tags/const/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPP_Const</title>
      <link>./post/cppconst/</link>
      <pubDate>Tue, 06 Oct 2020 15:03:40 +0800</pubDate>
      <guid>./post/cppconst/</guid>
      <description>&lt;h1 id=&#34;const&#34;&gt;const&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;修饰变量，变量不可以被改变；&lt;/li&gt;&#xA;&lt;li&gt;修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；&lt;/li&gt;&#xA;&lt;li&gt;修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；&lt;/li&gt;&#xA;&lt;li&gt;修饰成员函数，说明该成员函数内不能修改成员变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 类&#xA;class A&#xA;{&#xA;private:&#xA;    const int a;                // 常对象成员，只能在初始化列表赋值&#xA;&#xA;public:&#xA;    // 构造函数&#xA;    A() : a(0) { };&#xA;    A(int x) : a(x) { };        // 初始化列表&#xA;&#xA;    // const可用于对重载函数的区分&#xA;    int getValue();             // 普通成员函数&#xA;    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值&#xA;};&#xA;&#xA;void function()&#xA;{&#xA;    // 对象&#xA;    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量&#xA;    const A a;                  // 常对象，只能调用常成员函数&#xA;    const A *p = &amp;amp;a;            // 指针变量，指向常对象&#xA;    const A &amp;amp;q = a;             // 指向常对象的引用&#xA;&#xA;    // 指针&#xA;    char greeting[] = &amp;#34;Hello&amp;#34;;&#xA;    char* p1 = greeting;                // 指针变量，指向字符数组变量&#xA;    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）&#xA;    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）&#xA;    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量&#xA;}&#xA;&#xA;// 函数&#xA;void function1(const int Var);           // 传递过来的参数在函数内不可变&#xA;void function2(const char* Var);         // 参数指针所指内容为常量&#xA;void function3(char* const Var);         // 参数指针为常量&#xA;void function4(const int&amp;amp; Var);          // 引用参数在函数内为常量&#xA;&#xA;// 函数返回值&#xA;const int function5();      // 返回一个常数&#xA;const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();&#xA;int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;const-的指针与引用&#34;&gt;const 的指针与引用&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向常量的指针（pointer to const）&lt;/li&gt;&#xA;&lt;li&gt;自身是常量的指针（常量指针，const pointer）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;引用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向常量的引用（reference to const）&lt;/li&gt;&#xA;&lt;li&gt;没有 const reference，因为引用本身就是 const pointer&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;用法小结&#34;&gt;用法小结&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;指针&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Constexpr</title>
      <link>./post/constexpr/</link>
      <pubDate>Fri, 14 Aug 2020 16:16:33 +0800</pubDate>
      <guid>./post/constexpr/</guid>
      <description>&lt;h1 id=&#34;0array&#34;&gt;0.Array&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int url[10]; //true&#xA;int url[6 + 4] //true&#xA;&#xA;int len = 10;&#xA;int url[len] //flase&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;1constexpr&#34;&gt;1.Constexpr&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int main()&#xA;{&#xA;    /*&#xA;     * If have not constexpr, CPP throw error&#xA;     */&#xA;    constexpr int num = 1 + 2 + 3; &#xA;    int url[num] = {1,2,3,4,5,6};&#xA;    couts&amp;lt;&amp;lt; url[1] &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;2only-have-one-return&#34;&gt;2.Only have one &amp;lsquo;return&amp;rsquo;&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Error&#xA;constexpr int display(int x) {&#xA;    int ret = 1 + 2 + x;&#xA;    return ret;&#xA;}&#xA;&#xA;# True&#xA;constexpr int display(int x) {&#xA;    return 1 + 2 + x;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;3must-have-return&#34;&gt;3.Must have &amp;lsquo;return&amp;rsquo;&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Error&#xA;constexpr void display() {&#xA;    ... &#xA;}&#xA;&#xA;# True &#xA;constexpr int display() {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;4must-have-funciion-declaration&#34;&gt;4.Must have funciion declaration&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;int noconst_dis(int x);&#xA;&#xA;// constexpr&#xA;constexpr int display(int x);&#xA;&#xA;constexpr int display(int x){&#xA;    return 1 + 2 + x;&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    int a[display(3)] = { 1,2,3,4 };&#xA;    cout &amp;lt;&amp;lt; a[2] &amp;lt;&amp;lt; endl;&#xA;    cout &amp;lt;&amp;lt; noconst_dis(3) &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&#xA;int noconst_dis(int x) {&#xA;    return 1 + 2 + x;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;5return-must-constant-expession&#34;&gt;5.&amp;lsquo;Return&amp;rsquo; must constant expession&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int num = 3;&#xA;constexpr int display(int x){&#xA;    return num + x;&#xA;}&#xA;int main()&#xA;{&#xA;    //display(3) not is constant &#xA;    int a[display(3)] = { 1,2,3,4 };&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;6constexpr-struct&#34;&gt;6.Constexpr struct&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Error&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;constexpr struct myType {&#xA;    const char* name;&#xA;    int age;&#xA;};&#xA;int main()&#xA;{&#xA;    constexpr struct myType mt { &amp;#34;zhangsan&amp;#34;, 10 };&#xA;    cout &amp;lt;&amp;lt; mt.name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; mt.age &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&#xA;# True&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;struct myType {&#xA;    constexpr myType(char *name,int age):name(name),age(age){};&#xA;    const char* name;&#xA;    int age;&#xA;};&#xA;&#xA;int main()&#xA;{&#xA;    constexpr struct myType mt { &amp;#34;zhangsan&amp;#34;, 10 };&#xA;    cout &amp;lt;&amp;lt; mt.name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; mt.age &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;7-class&#34;&gt;7. CLass&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;//自定义类型的定义&#xA;class myType {&#xA;public:&#xA;    constexpr myType(const char *name,int age):name(name),age(age){};&#xA;    constexpr const char * getname(){&#xA;        return name;&#xA;    }&#xA;&#xA;    /*&#xA;     * unsupport virtual function&#xA;     */&#xA;    constexpr int getage(){&#xA;        return age;&#xA;    }&#xA;private:&#xA;    const char* name;&#xA;    int age;&#xA;    //其它结构体成员&#xA;};&#xA;int main()&#xA;{&#xA;    constexpr struct myType mt { &amp;#34;zhangsan&amp;#34;, 10 };&#xA;    constexpr const char * name = mt.getname();&#xA;    constexpr int age = mt.getage();&#xA;    cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;8template&#34;&gt;8.Template&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;struct myType {&#xA;    const char* name;&#xA;    int age;&#xA;};&#xA;&#xA;template&amp;lt;typename T&amp;gt;&#xA;constexpr T dispaly(T t){&#xA;    return t;&#xA;}&#xA;int main()&#xA;{&#xA;    struct myType stu{&amp;#34;zhangsan&amp;#34;,10};&#xA;&#xA;    struct myType ret = dispaly(stu);&#xA;    cout &amp;lt;&amp;lt; ret.name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; ret.age &amp;lt;&amp;lt; endl;&#xA;&#xA;    constexpr int ret1 = dispaly(10);&#xA;    cout &amp;lt;&amp;lt; ret1 &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
