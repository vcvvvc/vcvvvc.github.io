<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pointer on VW Blog</title>
    <link>./tags/pointer/</link>
    <description>Recent content in Pointer on VW Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 06 Oct 2020 15:03:40 +0800</lastBuildDate>
    <atom:link href="./tags/pointer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPP_Const</title>
      <link>./post/cppconst/</link>
      <pubDate>Tue, 06 Oct 2020 15:03:40 +0800</pubDate>
      <guid>./post/cppconst/</guid>
      <description>&lt;h1 id=&#34;const&#34;&gt;const&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;修饰变量，变量不可以被改变；&lt;/li&gt;&#xA;&lt;li&gt;修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；&lt;/li&gt;&#xA;&lt;li&gt;修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；&lt;/li&gt;&#xA;&lt;li&gt;修饰成员函数，说明该成员函数内不能修改成员变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 类&#xA;class A&#xA;{&#xA;private:&#xA;    const int a;                // 常对象成员，只能在初始化列表赋值&#xA;&#xA;public:&#xA;    // 构造函数&#xA;    A() : a(0) { };&#xA;    A(int x) : a(x) { };        // 初始化列表&#xA;&#xA;    // const可用于对重载函数的区分&#xA;    int getValue();             // 普通成员函数&#xA;    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值&#xA;};&#xA;&#xA;void function()&#xA;{&#xA;    // 对象&#xA;    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量&#xA;    const A a;                  // 常对象，只能调用常成员函数&#xA;    const A *p = &amp;amp;a;            // 指针变量，指向常对象&#xA;    const A &amp;amp;q = a;             // 指向常对象的引用&#xA;&#xA;    // 指针&#xA;    char greeting[] = &amp;#34;Hello&amp;#34;;&#xA;    char* p1 = greeting;                // 指针变量，指向字符数组变量&#xA;    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）&#xA;    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）&#xA;    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量&#xA;}&#xA;&#xA;// 函数&#xA;void function1(const int Var);           // 传递过来的参数在函数内不可变&#xA;void function2(const char* Var);         // 参数指针所指内容为常量&#xA;void function3(char* const Var);         // 参数指针为常量&#xA;void function4(const int&amp;amp; Var);          // 引用参数在函数内为常量&#xA;&#xA;// 函数返回值&#xA;const int function5();      // 返回一个常数&#xA;const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();&#xA;int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h1 id=&#34;const-的指针与引用&#34;&gt;const 的指针与引用&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向常量的指针（pointer to const）&lt;/li&gt;&#xA;&lt;li&gt;自身是常量的指针（常量指针，const pointer）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;引用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向常量的引用（reference to const）&lt;/li&gt;&#xA;&lt;li&gt;没有 const reference，因为引用本身就是 const pointer&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;用法小结&#34;&gt;用法小结&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;指针&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
